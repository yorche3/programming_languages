module Words

from "result" include Result
from "regex" include Regex
from "char" include Char
from "string" include String
from "array" include Array

provide let reverseString = (str: String) => {
  let len = String.length(str)
  let mut i = len - 1
  let mut reversed = ""
  while (i >= 0) {
    reversed = reversed ++ Char.toString(String.charAt(i, str))
    i -= 1
  }
  reversed
}

provide let isPalindrome = (str: String) => {
  let cleannedStr = Regex.replaceAll(Result.unwrap(Regex.make("\s")), str, "")
  let mut i = 0
  let mut j = String.length(cleannedStr) - 1
  while (i < j) {
    if (String.charAt(i, cleannedStr) != String.charAt(j, cleannedStr)) {
      return false
    }
    i += 1
    j -= 1
  }
  return true
}

let computeLPSArray = (patt: String) => {
  let lenPatt = String.length(patt)
  let mut lps = Array.make(lenPatt, 0)
  let mut i = 1
  let mut len = 0
  while (i < lenPatt) {
    if (String.charAt(i, patt) == String.charAt(len, patt)) {
      len += 1
      lps[i] = len
      i += 1
    } else {
      if (len != 0) {
        len = lps[len - 1]
      } else {
        lps[i] = 0
        i += 1
      }
    }
  }
  lps
}

provide let kmpSearch = (sub: String, str: String) => {
  let lenSub = String.length(sub)
  let lenStr = String.length(str)
  if (lenSub == 0) {
    return true
  }
  if (lenSub > lenStr) {
    return false
  }
  let lps = computeLPSArray(sub)
  let mut i = 0
  let mut j = 0
  let mut result = false
  while (i < lenStr) {
    if (String.charAt(i, str) == String.charAt(j, sub)) {
      i += 1
      j += 1
      if (j == lenSub) {
        return true
      } 
    } else {
      if (j != 0) {
        j = lps[j - 1]
      } else {
        i += 1
      }
    }
  }
  return false
}

let max = (a: int, b: int) => {
  if (a > b) {
    a
  } else {
    b
  }
}

provide let lcs = (str1: String, str2: String) => {
  let lenStr1 = String.length(str1)
  let lenStr2 = String.length(str2)
  let mut dp = Array.make(lenStr1 + 1, Array.make(lenStr2 + 1, 0))
  for (let mut i = 1; i <= lenStr1; i += 1) {
    for (let mut j = 1; j <= lenStr2; j += 1) {
      if (String.charAt(i - 1, str1) == String.charAt(j - 1, str2)) {
        dp[i][j] = dp[i - 1][j - 1] + 1
      } else {
        dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
      }
    }
  }
  dp[lenStr1][lenStr2]
}
