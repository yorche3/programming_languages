func reverse_string(str) {
  chars = strchar(str)
  len = strlen(str)
	if(len <= 1) {
		return str
	}
	for(i = 1; i <= (len / 2); i++) {
		aux = chars(i)
		chars(i) = chars(len - i + 1)
		chars(len - i + 1) = aux
	}
  return strchar(chars)
}

func is_palindrome(str) {
	len_str = strlen(str)
	if(len_str <= 1){
		return 1
	}
	buffer = strchar(str)
	len = 0
	for(i = 1; i <= len_str; i++) {
		ch = buffer(i)
		if(ch != ' ' && ch != '\t' && ch != '\n' && ch != '\r') {
			buffer(++len) = ch
		}
	}
	for(i = 1; i <= (len / 2); i++) {
		if(buffer(i) != buffer(len - i + 1)) {
			return 0
		}
	}
  return 1
}

func compute_lps_array(patt) {
	buffer = strchar(patt)
	len_patt = strlen(patt)
	lps = lps = array(0, len_sub)
	i = 2
	len = 0
	while(i <= len_patt) {
		if(buffer(i) == buffer(len + 1)) {
			lps(i) = ++len
			i++
		} else {
			if(len != 0) {
				len = lps(len)
			} else {
				lps(i) = 0
				i++
			}
		}
	}
	return lps
}

func kmp_search(sub, str) {
	len_sub = strlen(sub)
	len_str = strlen(str)
	if(len_sub == 0) {
		return 1
	} else if(len_sub > len_str) {
		return 0
	}
	lps = compute_lps_array(sub)
	i = 0
	j = 0
	str_buffer = strchar(str)
	sub_buffer = strchar(sub)
	while(i < len_str) {
		if(str_buffer(i + 1) == sub_buffer(j + 1)) {
			i++
			j++
			if(j == len_sub) {
				return 1
			}
		} else {
			if(j != 0) {
				j = lps(j)
			} else {
				i++
			}
		}
	}
  return 0
}

func lcs(str1, str2) {
	len1 = strlen(str1)
	len2 = strlen(str2)
	str1_buffer = strchar(str1)
	str2_buffer = strchar(str2)
	dp = array(array(0, len2 + 1), len1 + 1)
	for(i = 1; i <= len1; i++) {
		for(j = 1; j <= len2; j++) {
			if(str1_buffer(i) == str2_buffer(j)) {
				dp(i * (len2 + 1) + j) = dp((i - 1) * (len2 + 1) + (j - 1)) + 1
			} else {
				dp(i * (len2 + 1) + j) = max(dp((i - 1) * (len2 + 1) + j), dp(i * (len2 + 1) + (j - 1)))
			}
		}
	}
  return dp((len1) * (len2 + 1) + len2)
}