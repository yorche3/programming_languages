{
  "version": 3,
  "sources": ["../src/index-js.ts", "../std/portable/index.js", "../lib/binaryen.js", "../src/glue/binaryen.js", "../node_modules/as-float/build/math.js", "../node_modules/as-float/index.js", "../src/glue/js/float.js", "../src/glue/js/i64.js", "../src/glue/js/collections.js", "../std/assembly/shared/feature.ts", "../std/assembly/shared/target.ts", "../std/assembly/shared/runtime.ts", "../std/assembly/shared/typeinfo.ts", "../src/common.ts", "../src/diagnosticMessages.generated", "../src/util.ts", "../src/util/binary.ts", "../src/util/collections.ts", "../src/util/math.ts", "../src/util/text.ts", "../src/util/path.ts", "../src/util/terminal.ts", "../src/util/vector.ts", "../src/diagnostics.ts", "../src/ast.ts", "../src/tokenizer.ts", "../src/module.ts", "../src/flow.ts", "../src/resolver.ts", "../src/parser.ts", "../src/program.ts", "../src/types.ts", "../src/builtins.ts", "../src/passes/pass.ts", "../src/passes/rtrace.ts", "../src/passes/shadowstack.ts", "../src/bindings/util.ts", "../src/bindings/js.ts", "../src/compiler.ts", "../src/bindings/tsd.ts", "../src/index-wasm.ts", "../src/extra/ast.ts", "../src/index.ts"],
  "sourcesContent": ["import \"./glue/js/index\";\nexport * from \"./index-wasm\";\n\n// Full API\nexport * from \"./ast\";\nexport * from \"./common\";\nexport * from \"./compiler\";\nexport * from \"./bindings\";\nexport * from \"./diagnostics\";\nexport * from \"./flow\";\nexport * from \"./module\";\nexport * from \"./parser\";\nexport * from \"./program\";\nexport * from \"./resolver\";\nexport * from \"./tokenizer\";\nexport * from \"./types\";\nexport * from \"./extra/ast\";\nimport * as util from \"./util\";\nexport { util };\n", "/** @module std/portable *//***/\n\nlet globalScope = typeof window !== \"undefined\" && window || typeof global !== \"undefined\" && global || self;\nif (typeof globalScope.ASC_TARGET === \"undefined\") {\n\n  globalScope.ASC_TARGET = 0; // Target.JS\n  globalScope.ASC_RUNTIME = 0; // Runtime.Stub\n  globalScope.ASC_NO_ASSERT = false;\n  globalScope.ASC_MEMORY_BASE = 0;\n  globalScope.ASC_OPTIMIZE_LEVEL = 3;\n  globalScope.ASC_SHRINK_LEVEL = 0;\n  globalScope.ASC_FEATURE_MUTABLE_GLOBAL = false;\n  globalScope.ASC_FEATURE_SIGN_EXTENSION = false;\n  globalScope.ASC_FEATURE_BULK_MEMORY = false;\n  globalScope.ASC_FEATURE_SIMD = false;\n  globalScope.ASC_FEATURE_THREADS = false;\n\n  let F64 = new Float64Array(1);\n  let U64 = new Uint32Array(F64.buffer);\n\n  Object.defineProperties(\n    globalScope[\"i8\"] = function i8(value) { return value << 24 >> 24; },\n    {\n      \"MIN_VALUE\": { value: -128 },\n      \"MAX_VALUE\": { value:  127 },\n\n      parse(str, radix) { return parseInt(str, radix) << 24 >> 24; }\n    }\n  );\n\n  Object.defineProperties(\n    globalScope[\"i16\"] = function i16(value) { return value << 16 >> 16; },\n    {\n      \"MIN_VALUE\": { value: -32768 },\n      \"MAX_VALUE\": { value:  32767 },\n\n      parse(str, radix) { return parseInt(str, radix) << 16 >> 16; }\n    }\n  );\n\n  Object.defineProperties(\n    globalScope[\"i32\"] = globalScope[\"isize\"] = function i32(value) { return value | 0; },\n    {\n      \"MIN_VALUE\": { value: -2147483648 },\n      \"MAX_VALUE\": { value:  2147483647 },\n\n      parse(str, radix) { return parseInt(str, radix) | 0; }\n    }\n  );\n\n  Object.defineProperties(\n    globalScope[\"u8\"] = function u8(value) { return value & 0xff; },\n    {\n      \"MIN_VALUE\": { value:   0 },\n      \"MAX_VALUE\": { value: 255 },\n\n      parse(str, radix) { return parseInt(str, radix) & 0xff; }\n    }\n  );\n\n  Object.defineProperties(\n    globalScope[\"u16\"] = function u16(value) { return value & 0xffff; },\n    {\n      \"MIN_VALUE\": { value:     0 },\n      \"MAX_VALUE\": { value: 65535 },\n\n      parse(str, radix) { return parseInt(str, radix) & 0xffff; }\n    }\n  );\n\n  Object.defineProperties(\n    globalScope[\"u32\"] = globalScope[\"usize\"] = function u32(value) { return value >>> 0; },\n    {\n      \"MIN_VALUE\": { value:          0 },\n      \"MAX_VALUE\": { value: 4294967295 },\n\n      parse(str, radix) { return parseInt(str, radix) >>> 0; }\n    }\n  );\n\n  Object.defineProperties(\n    globalScope[\"bool\"] = function bool(value) { return !!value; },\n    {\n      \"MIN_VALUE\": { value: false },\n      \"MAX_VALUE\": { value: true },\n\n      parse(str) { return str.trim() === \"true\"; }\n    }\n  );\n\n  Object.defineProperties(\n    globalScope[\"f32\"] = function f32(value) { return Math.fround(value); },\n    {\n      \"EPSILON\":   { value: 1.1920928955078125e-07 },\n      \"MIN_VALUE\": { value: 1.401298464324817e-45 },\n      \"MAX_VALUE\": { value: 3.4028234663852886e+38 },\n      \"MIN_NORMAL_VALUE\":  { value:  1.1754943508222875e-38 },\n      \"MIN_SAFE_INTEGER\":  { value: -16777215 },\n      \"MAX_SAFE_INTEGER\":  { value:  16777215 },\n      \"POSITIVE_INFINITY\": { value:  Infinity },\n      \"NEGATIVE_INFINITY\": { value: -Infinity },\n      \"NaN\": { value: NaN },\n\n      parse(str) { return Math.fround(parseFloat(str)); }\n    }\n  );\n\n  Object.defineProperties(\n    globalScope[\"f64\"] = function f64(value) { return +value; },\n    {\n      \"EPSILON\":   { value: 2.2204460492503131e-016 },\n      \"MIN_VALUE\": { value:                  5e-324 },\n      \"MAX_VALUE\": { value: 1.7976931348623157e+308 },\n      \"MIN_NORMAL_VALUE\":  { value:  2.2250738585072014e-308 },\n      \"MIN_SAFE_INTEGER\":  { value: -9007199254740991 },\n      \"MAX_SAFE_INTEGER\":  { value:  9007199254740991 },\n      \"POSITIVE_INFINITY\": { value:  Infinity },\n      \"NEGATIVE_INFINITY\": { value: -Infinity },\n      \"NaN\": { value: NaN },\n\n      parse(str) { return parseFloat(str); }\n    }\n  );\n\n  globalScope[\"clz\"] = Math.clz32;\n\n  globalScope[\"ctz\"] = function ctz(value) {\n    return 32 - Math.clz32(~value & (value - 1));\n  };\n\n  globalScope[\"popcnt\"] = function popcnt(value) {\n    value -= value >>> 1 & 0x55555555;\n    value = (value & 0x33333333) + (value >>> 2 & 0x33333333);\n    return (((value + (value >>> 4)) & 0x0F0F0F0F) * 0x01010101) >>> 24;\n  };\n\n  globalScope[\"rotl\"] = function rotl(value, shift) {\n    shift &= 31;\n    return (value << shift) | (value >>> (32 - shift));\n  };\n\n  globalScope[\"rotr\"] = function rotr(value, shift) {\n    shift &= 31;\n    return (value >>> shift) | (value << (32 - shift));\n  };\n\n  globalScope[\"abs\"] = Math.abs;\n\n  globalScope[\"max\"] = Math.max;\n\n  globalScope[\"min\"] = Math.min;\n\n  globalScope[\"ceil\"] = Math.ceil;\n\n  globalScope[\"floor\"] = Math.floor;\n\n  globalScope[\"nearest\"] = function nearest(value) {\n    const INV_EPS64 = 4503599627370496.0;\n    const y = Math.abs(value);\n    return y < INV_EPS64\n      ? (y + INV_EPS64 - INV_EPS64) * Math.sign(value)\n      : value;\n  };\n\n  globalScope[\"select\"] = function select(ifTrue, ifFalse, condition) {\n    return condition ? ifTrue : ifFalse;\n  };\n\n  globalScope[\"sqrt\"] = Math.sqrt;\n\n  globalScope[\"trunc\"] = Math.trunc;\n\n  globalScope[\"copysign\"] = function copysign(x, y) {\n    return y\n      ? Math.abs(x) * Math.sign(y)\n      : (F64[0] = y, U64[1] >>> 31 ? -1 : 1); // +0, -0, -NaN, +NaN\n  };\n\n  globalScope[\"bswap\"] = function bswap(value) {\n    let a = value >> 8 & 0x00FF00FF;\n    let b = (value & 0x00FF00FF) << 8;\n    value = a | b;\n    a = value >> 16 & 0x0000FFFF;\n    b = (value & 0x0000FFFF) << 16;\n    return a | b;\n  };\n\n  function UnreachableError() {\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, UnreachableError);\n    } else {\n      this.stack = this.name + \": \" + this.message + \"\\n\" + new Error().stack;\n    }\n  }\n  UnreachableError.prototype = Object.create(Error.prototype);\n  UnreachableError.prototype.name = \"UnreachableError\";\n  UnreachableError.prototype.message = \"unreachable\";\n\n  globalScope[\"unreachable\"] = function unreachable() {\n    throw new UnreachableError();\n  };\n\n  function AssertionError(message) {\n    this.message = message || \"assertion failed\";\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AssertionError);\n    } else {\n      this.stack = this.name + \": \" + this.message + \"\\n\" + new Error().stack;\n    }\n  }\n  AssertionError.prototype = Object.create(Error.prototype);\n  AssertionError.prototype.name = \"AssertionError\";\n\n  globalScope[\"assert\"] = function assert(isTrueish, message) {\n    if (isTrueish) return isTrueish;\n    throw new AssertionError(message);\n  };\n\n  globalScope[\"changetype\"] = function changetype(value) {\n    return value;\n  };\n\n  String[\"fromCharCodes\"] = function fromCharCodes(arr) {\n    const CHUNKSIZE = 1 << 13;\n    const len = arr.length;\n    if (len <= CHUNKSIZE) {\n      return String.fromCharCode.apply(String, arr);\n    }\n    let index = 0;\n    let parts = '';\n    while (index < len) {\n      parts += String.fromCharCode.apply(\n        String,\n        arr.slice(index, Math.min(index + CHUNKSIZE, len))\n      );\n      index += CHUNKSIZE;\n    }\n    return parts;\n  };\n\n  String[\"fromCodePoints\"] = function fromCodePoints(arr) {\n    const CHUNKSIZE = 1 << 13;\n    const len = arr.length;\n    if (len <= CHUNKSIZE) {\n      return String.fromCodePoint.apply(String, arr);\n    }\n    let index = 0;\n    let parts = '';\n    while (index < len) {\n      parts += String.fromCodePoint.apply(\n        String,\n        arr.slice(index, Math.min(index + CHUNKSIZE, len))\n      );\n      index += CHUNKSIZE;\n    }\n    return parts;\n  };\n\n  if (!String.prototype.at) {\n    Object.defineProperty(String.prototype, \"at\", {\n      value: function at(index) {\n        return this.charAt(index >= 0 ? index : index + this.length);\n      },\n      configurable: true\n    });\n  }\n\n  if (!String.prototype.replaceAll) {\n    Object.defineProperty(String.prototype, \"replaceAll\", {\n      value: function replaceAll(search, replacment) {\n        let res = this.split(search).join(replacment);\n        if (!search.length) res = replacment + res + replacment;\n        return res;\n      },\n      configurable: true\n    });\n  }\n\n  function defaultComparator(a, b) {\n    if (a == b) {\n      if (a != 0) return 0;\n      a = 1 / a, b = 1 / b;\n    } else {\n      let nanA = a != a, nanB = b != b;\n      if (nanA | nanB) return nanA - nanB;\n      if (a == null) a = String(a);\n      if (b == null) b = String(b);\n    }\n    return a > b ? 1 : -1;\n  }\n\n  const arraySort = Array.prototype.sort;\n  Array.prototype.sort = function sort(comparator) {\n    return arraySort.call(this, comparator || defaultComparator);\n  };\n\n  [ Array,\n    Uint8ClampedArray,\n    Uint8Array, Int8Array,\n    Uint16Array, Int16Array,\n    Uint32Array, Int32Array,\n    Float32Array, Float64Array\n  ].forEach(Ctr => {\n    if (!Ctr.prototype.at) {\n      Object.defineProperty(Ctr.prototype, \"at\", {\n        value: function at(index) {\n          return this[index >= 0 ? index : index + this.length];\n        },\n        configurable: true\n      });\n    }\n\n    if (!Ctr.prototype.findLastIndex) {\n      Object.defineProperty(Ctr.prototype, \"findLastIndex\", {\n        value: function findLastIndex(fn) {\n          for (let i = this.length - 1; i >= 0; --i) {\n            if (fn(this[i], i, this)) return i;\n          }\n          return -1;\n        },\n        configurable: true\n      });\n    }\n\n    if (Ctr != Array) {\n      Object.defineProperty(Ctr, \"wrap\", {\n        value: function wrap(buffer, byteOffset, length) {\n          return new Ctr(buffer, byteOffset, length);\n        },\n        configurable: true\n      });\n    }\n  });\n\n  globalScope[\"isInteger\"] = Number.isInteger;\n\n  globalScope[\"isFloat\"] = function isFloat(arg) {\n    return typeof arg === \"number\";\n  };\n\n  globalScope[\"isNullable\"] = function isNullable(arg) {\n    return true;\n  };\n\n  globalScope[\"isReference\"] = function isReference(arg) {\n    return typeof arg === \"object\" || typeof arg === \"string\";\n  };\n\n  globalScope[\"isFunction\"] = function isFunction(arg) {\n    return typeof arg === \"function\";\n  };\n\n  globalScope[\"isString\"] = function isString(arg) {\n    return typeof arg === \"string\" || arg instanceof String;\n  };\n\n  globalScope[\"isArray\"] = Array.isArray;\n  globalScope[\"isArrayLike\"] = function isArrayLike(expr) {\n    return expr\n      && typeof expr === 'object'\n      && typeof expr.length === 'number'\n      && expr.length >= 0\n      && Math.trunc(expr.length) === expr.length;\n  };\n\n  globalScope[\"isDefined\"] = function isDefined(expr) {\n    return typeof expr !== \"undefined\";\n  };\n\n  globalScope[\"isConstant\"] = function isConstant(expr) {\n    return false;\n  };\n\n  globalScope[\"unchecked\"] = function unchecked(expr) {\n    return expr;\n  };\n\n  globalScope[\"fmod\"] = function fmod(x, y) {\n    return x % y;\n  };\n\n  globalScope[\"fmodf\"] = function fmodf(x, y) {\n    return Math.fround(x % y);\n  };\n\n  globalScope[\"JSMath\"] = Math;\n\n  Object.defineProperties(globalScope[\"JSMath\"], {\n    sincos_sin: { value: 0.0, writable: true },\n    sincos_cos: { value: 0.0, writable: true },\n    signbit: {\n      value: function signbit(x) {\n        F64[0] = x; return Boolean(U64[1] >>> 31);\n      }\n    },\n    sincos: {\n      value: function sincos(x) {\n        this.sincos_sin = Math.sin(x);\n        this.sincos_cos = Math.cos(x);\n      }\n    },\n    exp2: {\n      value: function exp2(x) {\n        return Math.pow(2, x);\n      }\n    }\n  });\n\n  globalScope[\"unmanaged\"] = function() { /* nop */ };\n\n  globalScope[\"trace\"] = function(message, n) {\n    if (n) message += Array.prototype.slice.call(arguments, 2, 2 + n);\n    console.error(\"trace: \" + message);\n  };\n}", "export * from \"binaryen\";\nexport { default } from \"binaryen\";\n", "/**\n * @fileoverview Binaryen glue code for JavaScript.\n * @license Apache-2.0\n */\n\nimport binaryen from \"../../lib/binaryen.js\";\n\nexport const {\n  _BinaryenTypeCreate,\n  _BinaryenTypeArity,\n  _BinaryenTypeExpand,\n  _BinaryenTypeGetHeapType,\n  _BinaryenTypeFromHeapType,\n  _BinaryenTypeIsNullable,\n\n  _BinaryenTypeFuncref,\n  _BinaryenTypeExternref,\n  _BinaryenTypeAnyref,\n  _BinaryenTypeEqref,\n  _BinaryenTypeI31ref,\n  _BinaryenTypeStructref,\n  _BinaryenTypeArrayref,\n  _BinaryenTypeStringref,\n  _BinaryenTypeNullref,\n  _BinaryenTypeNullExternref,\n  _BinaryenTypeNullFuncref,\n\n  _BinaryenHeapTypeFunc,\n  _BinaryenHeapTypeExt,\n  _BinaryenHeapTypeAny,\n  _BinaryenHeapTypeEq,\n  _BinaryenHeapTypeI31,\n  _BinaryenHeapTypeStruct,\n  _BinaryenHeapTypeArray,\n  // _BinaryenHeapTypeExn,\n  _BinaryenHeapTypeString,\n  _BinaryenHeapTypeNone,\n  _BinaryenHeapTypeNoext,\n  _BinaryenHeapTypeNofunc,\n\n  _BinaryenHeapTypeIsBasic,\n  _BinaryenHeapTypeIsSignature,\n  _BinaryenHeapTypeIsStruct,\n  _BinaryenHeapTypeIsArray,\n  _BinaryenHeapTypeIsBottom,\n  _BinaryenHeapTypeGetBottom,\n  _BinaryenHeapTypeIsSubType,\n  _BinaryenStructTypeGetNumFields,\n  _BinaryenStructTypeGetFieldType,\n  _BinaryenStructTypeGetFieldPackedType,\n  _BinaryenStructTypeIsFieldMutable,\n  _BinaryenArrayTypeGetElementType,\n  _BinaryenArrayTypeGetElementPackedType,\n  _BinaryenArrayTypeIsElementMutable,\n  _BinaryenSignatureTypeGetParams,\n  _BinaryenSignatureTypeGetResults,\n\n  _BinaryenModuleCreate,\n  _BinaryenModuleDispose,\n\n  _BinaryenSizeofLiteral,\n  _BinaryenLiteralInt32,\n  _BinaryenLiteralInt64,\n  _BinaryenLiteralFloat32,\n  _BinaryenLiteralFloat64,\n  _BinaryenLiteralVec128,\n  _BinaryenLiteralFloat32Bits,\n  _BinaryenLiteralFloat64Bits,\n\n  _BinaryenExpressionGetId,\n  _BinaryenExpressionGetType,\n  _BinaryenExpressionSetType,\n  _BinaryenExpressionPrint,\n  _BinaryenExpressionCopy,\n  _BinaryenExpressionFinalize,\n\n  _BinaryenBlock,\n  _BinaryenBlockGetName,\n  _BinaryenBlockSetName,\n  _BinaryenBlockGetNumChildren,\n  _BinaryenBlockGetChildAt,\n  _BinaryenBlockSetChildAt,\n  _BinaryenBlockAppendChild,\n  _BinaryenBlockInsertChildAt,\n  _BinaryenBlockRemoveChildAt,\n\n  _BinaryenIf,\n  _BinaryenIfGetCondition,\n  _BinaryenIfSetCondition,\n  _BinaryenIfGetIfTrue,\n  _BinaryenIfSetIfTrue,\n  _BinaryenIfGetIfFalse,\n  _BinaryenIfSetIfFalse,\n\n  _BinaryenLoop,\n  _BinaryenLoopGetName,\n  _BinaryenLoopSetName,\n  _BinaryenLoopGetBody,\n  _BinaryenLoopSetBody,\n\n  _BinaryenBreak,\n  _BinaryenBreakGetName,\n  _BinaryenBreakSetName,\n  _BinaryenBreakGetCondition,\n  _BinaryenBreakSetCondition,\n  _BinaryenBreakGetValue,\n  _BinaryenBreakSetValue,\n\n  _BinaryenSwitch,\n  _BinaryenSwitchGetNumNames,\n  _BinaryenSwitchGetNameAt,\n  _BinaryenSwitchSetNameAt,\n  _BinaryenSwitchAppendName,\n  _BinaryenSwitchInsertNameAt,\n  _BinaryenSwitchRemoveNameAt,\n  _BinaryenSwitchGetDefaultName,\n  _BinaryenSwitchSetDefaultName,\n  _BinaryenSwitchGetCondition,\n  _BinaryenSwitchSetCondition,\n  _BinaryenSwitchGetValue,\n  _BinaryenSwitchSetValue,\n\n  _BinaryenCall,\n  _BinaryenCallGetTarget,\n  _BinaryenCallSetTarget,\n  _BinaryenCallGetNumOperands,\n  _BinaryenCallGetOperandAt,\n  _BinaryenCallSetOperandAt,\n  _BinaryenCallAppendOperand,\n  _BinaryenCallInsertOperandAt,\n  _BinaryenCallRemoveOperandAt,\n  _BinaryenCallIsReturn,\n  _BinaryenCallSetReturn,\n  _BinaryenReturnCall,\n\n  _BinaryenCallIndirect,\n  _BinaryenCallIndirectGetTable,\n  _BinaryenCallIndirectSetTable,\n  _BinaryenCallIndirectGetTarget,\n  _BinaryenCallIndirectSetTarget,\n  _BinaryenCallIndirectGetNumOperands,\n  _BinaryenCallIndirectGetOperandAt,\n  _BinaryenCallIndirectSetOperandAt,\n  _BinaryenCallIndirectAppendOperand,\n  _BinaryenCallIndirectInsertOperandAt,\n  _BinaryenCallIndirectRemoveOperandAt,\n  _BinaryenCallIndirectIsReturn,\n  _BinaryenCallIndirectSetReturn,\n  _BinaryenReturnCallIndirect,\n\n  _BinaryenLocalGet,\n  _BinaryenLocalGetGetIndex,\n  _BinaryenLocalGetSetIndex,\n\n  _BinaryenLocalSet,\n  _BinaryenLocalSetIsTee,\n  _BinaryenLocalSetGetIndex,\n  _BinaryenLocalSetSetIndex,\n  _BinaryenLocalSetGetValue,\n  _BinaryenLocalSetSetValue,\n  _BinaryenLocalTee,\n\n  _BinaryenGlobalGet,\n  _BinaryenGlobalGetGetName,\n  _BinaryenGlobalGetSetName,\n\n  _BinaryenGlobalSet,\n  _BinaryenGlobalSetGetName,\n  _BinaryenGlobalSetSetName,\n  _BinaryenGlobalSetGetValue,\n  _BinaryenGlobalSetSetValue,\n\n  _BinaryenMemorySize,\n\n  _BinaryenMemoryGrow,\n  _BinaryenMemoryGrowGetDelta,\n  _BinaryenMemoryGrowSetDelta,\n\n  _BinaryenLoad,\n  _BinaryenLoadIsAtomic,\n  _BinaryenLoadSetAtomic,\n  _BinaryenLoadIsSigned,\n  _BinaryenLoadSetSigned,\n  _BinaryenLoadGetOffset,\n  _BinaryenLoadSetOffset,\n  _BinaryenLoadGetBytes,\n  _BinaryenLoadSetBytes,\n  _BinaryenLoadGetAlign,\n  _BinaryenLoadSetAlign,\n  _BinaryenLoadGetPtr,\n  _BinaryenLoadSetPtr,\n  _BinaryenAtomicLoad,\n\n  _BinaryenStore,\n  _BinaryenStoreIsAtomic,\n  _BinaryenStoreSetAtomic,\n  _BinaryenStoreGetBytes,\n  _BinaryenStoreSetBytes,\n  _BinaryenStoreGetOffset,\n  _BinaryenStoreSetOffset,\n  _BinaryenStoreGetAlign,\n  _BinaryenStoreSetAlign,\n  _BinaryenStoreGetPtr,\n  _BinaryenStoreSetPtr,\n  _BinaryenStoreGetValue,\n  _BinaryenStoreSetValue,\n  _BinaryenStoreGetValueType,\n  _BinaryenStoreSetValueType,\n  _BinaryenAtomicStore,\n\n  _BinaryenConst,\n  _BinaryenConstGetValueI32,\n  _BinaryenConstSetValueI32,\n  _BinaryenConstGetValueI64Low,\n  _BinaryenConstSetValueI64Low,\n  _BinaryenConstGetValueI64High,\n  _BinaryenConstSetValueI64High,\n  _BinaryenConstGetValueF32,\n  _BinaryenConstSetValueF32,\n  _BinaryenConstGetValueF64,\n  _BinaryenConstSetValueF64,\n  _BinaryenConstGetValueV128,\n  _BinaryenConstSetValueV128,\n\n  _BinaryenUnary,\n  _BinaryenUnaryGetOp,\n  _BinaryenUnarySetOp,\n  _BinaryenUnaryGetValue,\n  _BinaryenUnarySetValue,\n\n  _BinaryenBinary,\n  _BinaryenBinaryGetOp,\n  _BinaryenBinarySetOp,\n  _BinaryenBinaryGetLeft,\n  _BinaryenBinarySetLeft,\n  _BinaryenBinaryGetRight,\n  _BinaryenBinarySetRight,\n\n  _BinaryenSelect,\n  _BinaryenSelectGetIfTrue,\n  _BinaryenSelectSetIfTrue,\n  _BinaryenSelectGetIfFalse,\n  _BinaryenSelectSetIfFalse,\n  _BinaryenSelectGetCondition,\n  _BinaryenSelectSetCondition,\n\n  _BinaryenDrop,\n  _BinaryenDropGetValue,\n  _BinaryenDropSetValue,\n\n  _BinaryenReturn,\n  _BinaryenReturnGetValue,\n  _BinaryenReturnSetValue,\n\n  _BinaryenNop,\n\n  _BinaryenUnreachable,\n\n  _BinaryenAtomicRMW,\n  _BinaryenAtomicRMWGetOp,\n  _BinaryenAtomicRMWSetOp,\n  _BinaryenAtomicRMWGetBytes,\n  _BinaryenAtomicRMWSetBytes,\n  _BinaryenAtomicRMWGetOffset,\n  _BinaryenAtomicRMWSetOffset,\n  _BinaryenAtomicRMWGetPtr,\n  _BinaryenAtomicRMWSetPtr,\n  _BinaryenAtomicRMWGetValue,\n  _BinaryenAtomicRMWSetValue,\n\n  _BinaryenAtomicCmpxchg,\n  _BinaryenAtomicCmpxchgGetBytes,\n  _BinaryenAtomicCmpxchgSetBytes,\n  _BinaryenAtomicCmpxchgGetOffset,\n  _BinaryenAtomicCmpxchgSetOffset,\n  _BinaryenAtomicCmpxchgGetPtr,\n  _BinaryenAtomicCmpxchgSetPtr,\n  _BinaryenAtomicCmpxchgGetExpected,\n  _BinaryenAtomicCmpxchgSetExpected,\n  _BinaryenAtomicCmpxchgGetReplacement,\n  _BinaryenAtomicCmpxchgSetReplacement,\n\n  _BinaryenAtomicWait,\n  _BinaryenAtomicWaitGetPtr,\n  _BinaryenAtomicWaitSetPtr,\n  _BinaryenAtomicWaitGetExpected,\n  _BinaryenAtomicWaitSetExpected,\n  _BinaryenAtomicWaitGetTimeout,\n  _BinaryenAtomicWaitSetTimeout,\n  _BinaryenAtomicWaitGetExpectedType,\n  _BinaryenAtomicWaitSetExpectedType,\n\n  _BinaryenAtomicNotify,\n  _BinaryenAtomicNotifyGetPtr,\n  _BinaryenAtomicNotifySetPtr,\n  _BinaryenAtomicNotifyGetNotifyCount,\n  _BinaryenAtomicNotifySetNotifyCount,\n\n  _BinaryenAtomicFence,\n  _BinaryenAtomicFenceGetOrder,\n  _BinaryenAtomicFenceSetOrder,\n\n  _BinaryenSIMDExtract,\n  _BinaryenSIMDExtractGetOp,\n  _BinaryenSIMDExtractSetOp,\n  _BinaryenSIMDExtractGetVec,\n  _BinaryenSIMDExtractSetVec,\n  _BinaryenSIMDExtractGetIndex,\n  _BinaryenSIMDExtractSetIndex,\n\n  _BinaryenSIMDReplace,\n  _BinaryenSIMDReplaceGetOp,\n  _BinaryenSIMDReplaceSetOp,\n  _BinaryenSIMDReplaceGetVec,\n  _BinaryenSIMDReplaceSetVec,\n  _BinaryenSIMDReplaceGetIndex,\n  _BinaryenSIMDReplaceSetIndex,\n  _BinaryenSIMDReplaceGetValue,\n  _BinaryenSIMDReplaceSetValue,\n\n  _BinaryenSIMDShuffle,\n  _BinaryenSIMDShuffleGetLeft,\n  _BinaryenSIMDShuffleSetLeft,\n  _BinaryenSIMDShuffleGetRight,\n  _BinaryenSIMDShuffleSetRight,\n  _BinaryenSIMDShuffleGetMask,\n  _BinaryenSIMDShuffleSetMask,\n\n  _BinaryenSIMDTernary,\n  _BinaryenSIMDTernaryGetOp,\n  _BinaryenSIMDTernarySetOp,\n  _BinaryenSIMDTernaryGetA,\n  _BinaryenSIMDTernarySetA,\n  _BinaryenSIMDTernaryGetB,\n  _BinaryenSIMDTernarySetB,\n  _BinaryenSIMDTernaryGetC,\n  _BinaryenSIMDTernarySetC,\n\n  _BinaryenSIMDShift,\n  _BinaryenSIMDShiftGetOp,\n  _BinaryenSIMDShiftSetOp,\n  _BinaryenSIMDShiftGetVec,\n  _BinaryenSIMDShiftSetVec,\n  _BinaryenSIMDShiftGetShift,\n  _BinaryenSIMDShiftSetShift,\n\n  _BinaryenSIMDLoad,\n  _BinaryenSIMDLoadGetOp,\n  _BinaryenSIMDLoadSetOp,\n  _BinaryenSIMDLoadGetOffset,\n  _BinaryenSIMDLoadSetOffset,\n  _BinaryenSIMDLoadGetAlign,\n  _BinaryenSIMDLoadSetAlign,\n  _BinaryenSIMDLoadGetPtr,\n  _BinaryenSIMDLoadSetPtr,\n\n  _BinaryenSIMDLoadStoreLane,\n  _BinaryenSIMDLoadStoreLaneGetOp,\n  _BinaryenSIMDLoadStoreLaneSetOp,\n  _BinaryenSIMDLoadStoreLaneGetOffset,\n  _BinaryenSIMDLoadStoreLaneSetOffset,\n  _BinaryenSIMDLoadStoreLaneGetAlign,\n  _BinaryenSIMDLoadStoreLaneSetAlign,\n  _BinaryenSIMDLoadStoreLaneGetIndex,\n  _BinaryenSIMDLoadStoreLaneSetIndex,\n  _BinaryenSIMDLoadStoreLaneGetPtr,\n  _BinaryenSIMDLoadStoreLaneSetPtr,\n  _BinaryenSIMDLoadStoreLaneGetVec,\n  _BinaryenSIMDLoadStoreLaneSetVec,\n  _BinaryenSIMDLoadStoreLaneIsStore,\n\n  _BinaryenMemoryInit,\n  _BinaryenMemoryInitGetSegment,\n  _BinaryenMemoryInitSetSegment,\n  _BinaryenMemoryInitGetDest,\n  _BinaryenMemoryInitSetDest,\n  _BinaryenMemoryInitGetOffset,\n  _BinaryenMemoryInitSetOffset,\n  _BinaryenMemoryInitGetSize,\n  _BinaryenMemoryInitSetSize,\n\n  _BinaryenDataDrop,\n  _BinaryenDataDropGetSegment,\n  _BinaryenDataDropSetSegment,\n\n  _BinaryenMemoryCopy,\n  _BinaryenMemoryCopyGetDest,\n  _BinaryenMemoryCopySetDest,\n  _BinaryenMemoryCopyGetSource,\n  _BinaryenMemoryCopySetSource,\n  _BinaryenMemoryCopyGetSize,\n  _BinaryenMemoryCopySetSize,\n\n  _BinaryenMemoryFill,\n  _BinaryenMemoryFillGetDest,\n  _BinaryenMemoryFillSetDest,\n  _BinaryenMemoryFillGetValue,\n  _BinaryenMemoryFillSetValue,\n  _BinaryenMemoryFillGetSize,\n  _BinaryenMemoryFillSetSize,\n\n  _BinaryenRefNull,\n\n  _BinaryenRefIsNull,\n  _BinaryenRefIsNullGetValue,\n  _BinaryenRefIsNullSetValue,\n\n  _BinaryenRefAs,\n  _BinaryenRefAsGetOp,\n  _BinaryenRefAsSetOp,\n  _BinaryenRefAsGetValue,\n  _BinaryenRefAsSetValue,\n\n  _BinaryenRefFunc,\n  _BinaryenRefFuncGetFunc,\n  _BinaryenRefFuncSetFunc,\n\n  _BinaryenRefEq,\n  _BinaryenRefEqGetLeft,\n  _BinaryenRefEqSetLeft,\n  _BinaryenRefEqGetRight,\n  _BinaryenRefEqSetRight,\n\n  _BinaryenTableGet,\n  _BinaryenTableGetGetTable,\n  _BinaryenTableGetSetTable,\n  _BinaryenTableGetGetIndex,\n  _BinaryenTableGetSetIndex,\n\n  _BinaryenTableSet,\n  _BinaryenTableSetGetTable,\n  _BinaryenTableSetSetTable,\n  _BinaryenTableSetGetIndex,\n  _BinaryenTableSetSetIndex,\n  _BinaryenTableSetGetValue,\n  _BinaryenTableSetSetValue,\n\n  _BinaryenTableSize,\n  _BinaryenTableSizeGetTable,\n  _BinaryenTableSizeSetTable,\n\n  _BinaryenTableGrow,\n  _BinaryenTableGrowGetTable,\n  _BinaryenTableGrowSetTable,\n  _BinaryenTableGrowGetValue,\n  _BinaryenTableGrowSetValue,\n  _BinaryenTableGrowGetDelta,\n  _BinaryenTableGrowSetDelta,\n\n  _BinaryenTry,\n  _BinaryenTryGetName,\n  _BinaryenTrySetName,\n  _BinaryenTryGetBody,\n  _BinaryenTrySetBody,\n  _BinaryenTryGetNumCatchTags,\n  _BinaryenTryGetNumCatchBodies,\n  _BinaryenTryGetCatchTagAt,\n  _BinaryenTrySetCatchTagAt,\n  _BinaryenTryAppendCatchTag,\n  _BinaryenTryInsertCatchTagAt,\n  _BinaryenTryRemoveCatchTagAt,\n  _BinaryenTryGetCatchBodyAt,\n  _BinaryenTrySetCatchBodyAt,\n  _BinaryenTryAppendCatchBody,\n  _BinaryenTryInsertCatchBodyAt,\n  _BinaryenTryRemoveCatchBodyAt,\n  _BinaryenTryHasCatchAll,\n  _BinaryenTryGetDelegateTarget,\n  _BinaryenTrySetDelegateTarget,\n  _BinaryenTryIsDelegate,\n\n  _BinaryenThrow,\n  _BinaryenThrowGetTag,\n  _BinaryenThrowSetTag,\n  _BinaryenThrowGetNumOperands,\n  _BinaryenThrowGetOperandAt,\n  _BinaryenThrowSetOperandAt,\n  _BinaryenThrowAppendOperand,\n  _BinaryenThrowInsertOperandAt,\n  _BinaryenThrowRemoveOperandAt,\n\n  _BinaryenRethrow,\n  _BinaryenRethrowGetTarget,\n  _BinaryenRethrowSetDepth,\n\n  _BinaryenTupleMake,\n  _BinaryenTupleMakeGetNumOperands,\n  _BinaryenTupleMakeGetOperandAt,\n  _BinaryenTupleMakeSetOperandAt,\n  _BinaryenTupleMakeAppendOperand,\n  _BinaryenTupleMakeInsertOperandAt,\n  _BinaryenTupleMakeRemoveOperandAt,\n\n  _BinaryenTupleExtract,\n  _BinaryenTupleExtractGetTuple,\n  _BinaryenTupleExtractSetTuple,\n  _BinaryenTupleExtractGetIndex,\n  _BinaryenTupleExtractSetIndex,\n\n  _BinaryenPop,\n\n  _BinaryenRefI31,\n  _BinaryenRefI31GetValue,\n  _BinaryenRefI31SetValue,\n\n  _BinaryenI31Get,\n  _BinaryenI31GetGetI31,\n  _BinaryenI31GetSetI31,\n  _BinaryenI31GetIsSigned,\n  _BinaryenI31GetSetSigned,\n\n  _BinaryenCallRef,\n  _BinaryenCallRefGetNumOperands,\n  _BinaryenCallRefGetOperandAt,\n  _BinaryenCallRefSetOperandAt,\n  _BinaryenCallRefAppendOperand,\n  _BinaryenCallRefInsertOperandAt,\n  _BinaryenCallRefRemoveOperandAt,\n  _BinaryenCallRefGetTarget,\n  _BinaryenCallRefSetTarget,\n  _BinaryenCallRefIsReturn,\n  _BinaryenCallRefSetReturn,\n\n  _BinaryenRefTest,\n  _BinaryenRefTestGetRef,\n  _BinaryenRefTestSetRef,\n  _BinaryenRefTestGetCastType,\n  _BinaryenRefTestSetCastType,\n\n  _BinaryenRefCast,\n  _BinaryenRefCastGetRef,\n  _BinaryenRefCastSetRef,\n\n  _BinaryenBrOn,\n  _BinaryenBrOnGetOp,\n  _BinaryenBrOnSetOp,\n  _BinaryenBrOnGetName,\n  _BinaryenBrOnSetName,\n  _BinaryenBrOnGetRef,\n  _BinaryenBrOnSetRef,\n  _BinaryenBrOnGetCastType,\n  _BinaryenBrOnSetCastType,\n\n  _BinaryenStructNew,\n  _BinaryenStructNewGetNumOperands,\n  _BinaryenStructNewGetOperandAt,\n  _BinaryenStructNewSetOperandAt,\n  _BinaryenStructNewAppendOperand,\n  _BinaryenStructNewInsertOperandAt,\n  _BinaryenStructNewRemoveOperandAt,\n\n  _BinaryenStructGet,\n  _BinaryenStructGetGetIndex,\n  _BinaryenStructGetSetIndex,\n  _BinaryenStructGetGetRef,\n  _BinaryenStructGetSetRef,\n  _BinaryenStructGetIsSigned,\n  _BinaryenStructGetSetSigned,\n\n  _BinaryenStructSet,\n  _BinaryenStructSetGetIndex,\n  _BinaryenStructSetSetIndex,\n  _BinaryenStructSetGetRef,\n  _BinaryenStructSetSetRef,\n  _BinaryenStructSetGetValue,\n  _BinaryenStructSetSetValue,\n\n  _BinaryenArrayNew,\n  _BinaryenArrayNewGetInit,\n  _BinaryenArrayNewSetInit,\n  _BinaryenArrayNewGetSize,\n  _BinaryenArrayNewSetSize,\n\n  _BinaryenArrayNewFixed,\n  _BinaryenArrayNewFixedGetNumValues,\n  _BinaryenArrayNewFixedGetValueAt,\n  _BinaryenArrayNewFixedSetValueAt,\n  _BinaryenArrayNewFixedAppendValue,\n  _BinaryenArrayNewFixedInsertValueAt,\n  _BinaryenArrayNewFixedRemoveValueAt,\n\n  _BinaryenArrayNewData,\n  _BinaryenArrayNewDataGetSegment,\n  _BinaryenArrayNewDataSetSegment,\n  _BinaryenArrayNewDataGetOffset,\n  _BinaryenArrayNewDataSetOffset,\n  _BinaryenArrayNewDataGetSize,\n  _BinaryenArrayNewDataSetSize,\n\n  _BinaryenArrayNewElem,\n  _BinaryenArrayNewElemGetSegment,\n  _BinaryenArrayNewElemSetSegment,\n  _BinaryenArrayNewElemGetOffset,\n  _BinaryenArrayNewElemSetOffset,\n  _BinaryenArrayNewElemGetSize,\n  _BinaryenArrayNewElemSetSize,\n\n  _BinaryenArrayGet,\n  _BinaryenArrayGetGetRef,\n  _BinaryenArrayGetSetRef,\n  _BinaryenArrayGetGetIndex,\n  _BinaryenArrayGetSetIndex,\n  _BinaryenArrayGetIsSigned,\n  _BinaryenArrayGetSetSigned,\n\n  _BinaryenArraySet,\n  _BinaryenArraySetGetRef,\n  _BinaryenArraySetSetRef,\n  _BinaryenArraySetGetIndex,\n  _BinaryenArraySetSetIndex,\n  _BinaryenArraySetGetValue,\n  _BinaryenArraySetSetValue,\n\n  _BinaryenArrayLen,\n  _BinaryenArrayLenGetRef,\n  _BinaryenArrayLenSetRef,\n\n  _BinaryenArrayFill,\n  _BinaryenArrayFillGetRef,\n  _BinaryenArrayFillSetRef,\n  _BinaryenArrayFillGetIndex,\n  _BinaryenArrayFillSetIndex,\n  _BinaryenArrayFillGetValue,\n  _BinaryenArrayFillSetValue,\n  _BinaryenArrayFillGetSize,\n  _BinaryenArrayFillSetSize,\n\n  _BinaryenArrayCopy,\n  _BinaryenArrayCopyGetDestRef,\n  _BinaryenArrayCopySetDestRef,\n  _BinaryenArrayCopyGetDestIndex,\n  _BinaryenArrayCopySetDestIndex,\n  _BinaryenArrayCopyGetSrcRef,\n  _BinaryenArrayCopySetSrcRef,\n  _BinaryenArrayCopyGetSrcIndex,\n  _BinaryenArrayCopySetSrcIndex,\n  _BinaryenArrayCopyGetLength,\n  _BinaryenArrayCopySetLength,\n\n  _BinaryenArrayInitData,\n  _BinaryenArrayInitDataGetSegment,\n  _BinaryenArrayInitDataSetSegment,\n  _BinaryenArrayInitDataGetRef,\n  _BinaryenArrayInitDataSetRef,\n  _BinaryenArrayInitDataGetIndex,\n  _BinaryenArrayInitDataSetIndex,\n  _BinaryenArrayInitDataGetOffset,\n  _BinaryenArrayInitDataSetOffset,\n  _BinaryenArrayInitDataGetSize,\n  _BinaryenArrayInitDataSetSize,\n\n  _BinaryenArrayInitElem,\n  _BinaryenArrayInitElemGetSegment,\n  _BinaryenArrayInitElemSetSegment,\n  _BinaryenArrayInitElemGetRef,\n  _BinaryenArrayInitElemSetRef,\n  _BinaryenArrayInitElemGetIndex,\n  _BinaryenArrayInitElemSetIndex,\n  _BinaryenArrayInitElemGetOffset,\n  _BinaryenArrayInitElemSetOffset,\n  _BinaryenArrayInitElemGetSize,\n  _BinaryenArrayInitElemSetSize,\n\n  _BinaryenStringNew,\n  _BinaryenStringNewGetOp,\n  _BinaryenStringNewSetOp,\n  _BinaryenStringNewGetRef,\n  _BinaryenStringNewSetRef,\n  _BinaryenStringNewGetStart,\n  _BinaryenStringNewSetStart,\n  _BinaryenStringNewGetEnd,\n  _BinaryenStringNewSetEnd,\n\n  _BinaryenStringConst,\n  _BinaryenStringConstGetString,\n  _BinaryenStringConstSetString,\n\n  _BinaryenStringMeasure,\n  _BinaryenStringMeasureGetOp,\n  _BinaryenStringMeasureSetOp,\n  _BinaryenStringMeasureGetRef,\n  _BinaryenStringMeasureSetRef,\n\n  _BinaryenStringEncode,\n  _BinaryenStringEncodeGetOp,\n  _BinaryenStringEncodeSetOp,\n  _BinaryenStringEncodeGetStr,\n  _BinaryenStringEncodeSetStr,\n  _BinaryenStringEncodeGetArray,\n  _BinaryenStringEncodeSetArray,\n  _BinaryenStringEncodeGetStart,\n  _BinaryenStringEncodeSetStart,\n\n  _BinaryenStringConcat,\n  _BinaryenStringConcatGetLeft,\n  _BinaryenStringConcatSetLeft,\n  _BinaryenStringConcatGetRight,\n  _BinaryenStringConcatSetRight,\n\n  _BinaryenStringEq,\n  _BinaryenStringEqGetOp,\n  _BinaryenStringEqSetOp,\n  _BinaryenStringEqGetLeft,\n  _BinaryenStringEqSetLeft,\n  _BinaryenStringEqGetRight,\n  _BinaryenStringEqSetRight,\n\n  _BinaryenStringWTF16Get,\n  _BinaryenStringWTF16GetGetRef,\n  _BinaryenStringWTF16GetSetRef,\n  _BinaryenStringWTF16GetGetPos,\n  _BinaryenStringWTF16GetSetPos,\n\n  _BinaryenStringSliceWTF,\n  _BinaryenStringSliceWTFGetRef,\n  _BinaryenStringSliceWTFSetRef,\n  _BinaryenStringSliceWTFGetStart,\n  _BinaryenStringSliceWTFSetStart,\n  _BinaryenStringSliceWTFGetEnd,\n  _BinaryenStringSliceWTFSetEnd,\n\n  _BinaryenAddFunction,\n  _BinaryenGetFunction,\n  _BinaryenRemoveFunction,\n  _BinaryenGetNumFunctions,\n  _BinaryenGetFunctionByIndex,\n\n  _BinaryenFunctionGetName,\n  _BinaryenFunctionGetParams,\n  _BinaryenFunctionGetResults,\n  _BinaryenFunctionGetNumVars,\n  _BinaryenFunctionGetVar,\n  _BinaryenFunctionAddVar,\n  _BinaryenFunctionGetNumLocals,\n  _BinaryenFunctionHasLocalName,\n  _BinaryenFunctionGetLocalName,\n  _BinaryenFunctionSetLocalName,\n  _BinaryenFunctionGetBody,\n  _BinaryenFunctionSetBody,\n  _BinaryenFunctionGetType,\n  _BinaryenFunctionSetType,\n  _BinaryenFunctionOptimize,\n  _BinaryenFunctionRunPasses,\n  _BinaryenFunctionSetDebugLocation,\n\n  _BinaryenAddFunctionImport,\n  _BinaryenAddTableImport,\n  _BinaryenAddMemoryImport,\n  _BinaryenAddGlobalImport,\n  _BinaryenAddTagImport,\n\n  _BinaryenAddFunctionExport,\n  _BinaryenAddTableExport,\n  _BinaryenAddMemoryExport,\n  _BinaryenAddGlobalExport,\n  _BinaryenAddTagExport,\n  _BinaryenGetExport,\n  _BinaryenRemoveExport,\n  _BinaryenGetNumExports,\n  _BinaryenGetExportByIndex,\n  _BinaryenExportGetKind,\n  _BinaryenExportGetName,\n  _BinaryenExportGetValue,\n\n  _BinaryenAddGlobal,\n  _BinaryenGetGlobal,\n  _BinaryenRemoveGlobal,\n  _BinaryenGetNumGlobals,\n  _BinaryenGetGlobalByIndex,\n\n  _BinaryenGlobalGetName,\n  _BinaryenGlobalGetType,\n  _BinaryenGlobalIsMutable,\n  _BinaryenGlobalGetInitExpr,\n\n  _BinaryenAddTag,\n  _BinaryenGetTag,\n  _BinaryenRemoveTag,\n\n  _BinaryenTagGetName,\n  _BinaryenTagGetParams,\n  _BinaryenTagGetResults,\n\n  _BinaryenAddTable,\n  _BinaryenRemoveTable,\n  _BinaryenGetNumTables,\n  _BinaryenGetTable,\n  _BinaryenGetTableByIndex,\n\n  _BinaryenTableGetName,\n  _BinaryenTableSetName,\n  _BinaryenTableGetInitial,\n  _BinaryenTableSetInitial,\n  _BinaryenTableHasMax,\n  _BinaryenTableGetMax,\n  _BinaryenTableSetMax,\n  _BinaryenTableGetType,\n  _BinaryenTableSetType,\n\n  _BinaryenAddActiveElementSegment,\n  _BinaryenAddPassiveElementSegment,\n  _BinaryenRemoveElementSegment,\n  _BinaryenGetNumElementSegments,\n  _BinaryenGetElementSegment,\n  _BinaryenGetElementSegmentByIndex,\n\n  _BinaryenSetMemory,\n  _BinaryenGetNumMemorySegments,\n  _BinaryenGetMemorySegmentByteOffset,\n  _BinaryenGetMemorySegmentByteLength,\n  _BinaryenCopyMemorySegmentData,\n  _BinaryenAddDataSegment,\n\n  _BinaryenSetStart,\n  _BinaryenGetStart,\n\n  _BinaryenModuleParse,\n  _BinaryenModulePrint,\n  _BinaryenModulePrintAsmjs,\n  _BinaryenModuleValidate,\n  _BinaryenModuleOptimize,\n  _BinaryenModuleRunPasses,\n  _BinaryenSizeofAllocateAndWriteResult,\n  _BinaryenModuleAllocateAndWrite,\n  _BinaryenModuleAllocateAndWriteText,\n  _BinaryenModuleAllocateAndWriteStackIR,\n  _BinaryenModuleRead,\n  _BinaryenModuleReadWithFeatures,\n  _BinaryenModuleInterpret,\n  _BinaryenModuleAddDebugInfoFileName,\n  _BinaryenModuleGetDebugInfoFileName,\n  _BinaryenModuleGetFeatures,\n  _BinaryenModuleSetFeatures,\n\n  _BinaryenAddCustomSection,\n\n  _BinaryenExpressionGetSideEffects,\n\n  _RelooperCreate,\n  _RelooperAddBlock,\n  _RelooperAddBranch,\n  _RelooperAddBlockWithSwitch,\n  _RelooperAddBranchForSwitch,\n  _RelooperRenderAndDispose,\n\n  _ExpressionRunnerCreate,\n  _ExpressionRunnerSetLocalValue,\n  _ExpressionRunnerSetGlobalValue,\n  _ExpressionRunnerRunAndDispose,\n\n  _TypeBuilderCreate,\n  _TypeBuilderGrow,\n  _TypeBuilderGetSize,\n  _TypeBuilderSetSignatureType,\n  _TypeBuilderSetStructType,\n  _TypeBuilderSetArrayType,\n  _TypeBuilderGetTempHeapType,\n  _TypeBuilderGetTempTupleType,\n  _TypeBuilderGetTempRefType,\n  _TypeBuilderSetSubType,\n  _TypeBuilderSetOpen,\n  _TypeBuilderCreateRecGroup,\n  _TypeBuilderBuildAndDispose,\n  _BinaryenModuleSetTypeName,\n  _BinaryenModuleSetFieldName,\n\n  _BinaryenGetOptimizeLevel,\n  _BinaryenSetOptimizeLevel,\n  _BinaryenGetShrinkLevel,\n  _BinaryenSetShrinkLevel,\n  _BinaryenGetDebugInfo,\n  _BinaryenSetDebugInfo,\n  _BinaryenGetTrapsNeverHappen,\n  _BinaryenSetTrapsNeverHappen,\n  _BinaryenGetClosedWorld,\n  _BinaryenSetClosedWorld,\n  _BinaryenGetLowMemoryUnused,\n  _BinaryenSetLowMemoryUnused,\n  _BinaryenGetZeroFilledMemory,\n  _BinaryenSetZeroFilledMemory,\n  _BinaryenGetFastMath,\n  _BinaryenSetFastMath,\n  _BinaryenGetGenerateStackIR,\n  _BinaryenSetGenerateStackIR,\n  _BinaryenGetOptimizeStackIR,\n  _BinaryenSetOptimizeStackIR,\n  _BinaryenGetPassArgument,\n  _BinaryenSetPassArgument,\n  _BinaryenClearPassArguments,\n  _BinaryenHasPassToSkip,\n  _BinaryenAddPassToSkip,\n  _BinaryenClearPassesToSkip,\n  _BinaryenGetAlwaysInlineMaxSize,\n  _BinaryenSetAlwaysInlineMaxSize,\n  _BinaryenGetFlexibleInlineMaxSize,\n  _BinaryenSetFlexibleInlineMaxSize,\n  _BinaryenGetOneCallerInlineMaxSize,\n  _BinaryenSetOneCallerInlineMaxSize,\n  _BinaryenGetAllowInliningFunctionsWithLoops,\n  _BinaryenSetAllowInliningFunctionsWithLoops,\n\n  // Helpers\n\n  _malloc,\n  _free,\n  __i32_store8,\n  __i32_store16,\n  __i32_store,\n  __f32_store,\n  __f64_store,\n  __i32_load8_s,\n  __i32_load8_u,\n  __i32_load16_s,\n  __i32_load16_u,\n  __i32_load,\n  __f32_load,\n  __f64_load\n\n} = binaryen;\n\nexport default binaryen;\n", "export const MathWasmBase64 = \"data:application/wasm;base64,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\";", "import { MathWasmBase64 } from \"./build/math.js\";\n\nexport const {f64_pow} = (await WebAssembly.instantiateStreaming(fetch(MathWasmBase64))).instance.exports;\n", "/**\n * @fileoverview Floating point glue code for JavaScript.\n * @license Apache-2.0\n */\n\nimport { f64_pow } from \"as-float\";\n\n/* eslint-disable no-undef */\n\nconst F64 = new Float64Array(1);\nconst F32 = new Float32Array(F64.buffer);\nconst I32 = new Int32Array(F64.buffer);\n\nglobalThis.f32_as_i32 = function f32_as_i32(value) {\n  F32[0] = value;\n  return I32[0];\n};\n\nglobalThis.i32_as_f32 = function i32_as_f32(value) {\n  I32[0] = value;\n  return F32[0];\n};\n\nglobalThis.f64_as_i64 = function f64_as_i64(value) {\n  F64[0] = value;\n  return i64_new(I32[0], I32[1]);\n};\n\nglobalThis.i64_as_f64 = function i64_as_f64(value) {\n  I32[0] = i64_low(value);\n  I32[1] = i64_high(value);\n  return F64[0];\n};\n\nglobalThis.f64_pow = f64_pow;\n", "/**\n * @fileoverview 64-bit integer glue code for JavaScript.\n * @license Apache-2.0\n */\n\n/* eslint-disable no-undef */\n\nimport Long from \"long\";\n\nglobalThis.i64_zero    = Long.ZERO;\nglobalThis.i64_one     = Long.ONE;\nglobalThis.i64_neg_one = Long.fromInt(-1);\nglobalThis.i64_minimum = Long.MIN_VALUE;\nglobalThis.i64_maximum = Long.MAX_VALUE;\n\nglobalThis.i64_is = function i64_is(value) {\n  return Long.isLong(value);\n};\n\nglobalThis.i64_new = function i64_new(lo, hi) {\n  return Long.fromBits(lo, hi);\n};\n\nglobalThis.i64_low = function i64_low(value) {\n  return value.low;\n};\n\nglobalThis.i64_high = function i64_high(value) {\n  return value.high;\n};\n\nglobalThis.i64_not = function i64_not(value) {\n  return value.not();\n};\n\nglobalThis.i64_neg = function i64_neg(value) {\n  return value.neg();\n};\n\nglobalThis.i64_clz = function i64_clz(value) {\n  return value.clz();\n};\n\nglobalThis.i64_ctz = function i64_ctz(value) {\n  return value.ctz();\n};\n\nglobalThis.i64_add = function i64_add(left, right) {\n  return left.add(right);\n};\n\nglobalThis.i64_sub = function i64_sub(left, right) {\n  return left.sub(right);\n};\n\nglobalThis.i64_mul = function i64_mul(left, right) {\n  return left.mul(right);\n};\n\nglobalThis.i64_pow = function i64_pow(left, right) {\n  let rightLo = right.low;\n  let rightHi = right.high;\n  if (rightHi <= 0) {\n    if (rightHi < 0) {\n      if (left.eq(globalThis.i64_neg_one)) {\n        return rightLo & 1 ? left : Long.ONE;\n      }\n      return left.eq(Long.ONE) ? left : Long.ZERO;\n    }\n    if (rightLo == 0) return Long.ONE;\n    if (rightLo == 1) return left;\n    if (rightLo == 2) return left.mul(left);\n  }\n  let result = Long.ONE;\n  while (rightLo | rightHi) {\n    if (rightLo & 1) result = result.mul(left);\n    right = right.shru(1);\n    left  = left.mul(left);\n    rightLo = right.low;\n    rightHi = right.high;\n  }\n  return result;\n};\n\nglobalThis.i64_div = function i64_div(left, right) {\n  return left.div(right);\n};\n\nglobalThis.i64_div_u = function i64_div_u(left, right) {\n  return left.toUnsigned().div(right.toUnsigned()).toSigned();\n};\n\nglobalThis.i64_rem = function i64_rem(left, right) {\n  return left.mod(right);\n};\n\nglobalThis.i64_rem_u = function i64_rem_u(left, right) {\n  return left.toUnsigned().mod(right.toUnsigned()).toSigned();\n};\n\nglobalThis.i64_and = function i64_and(left, right) {\n  return left.and(right);\n};\n\nglobalThis.i64_or = function i64_or(left, right) {\n  return left.or(right);\n};\n\nglobalThis.i64_xor = function i64_xor(left, right) {\n  return left.xor(right);\n};\n\nglobalThis.i64_shl = function i64_shl(left, right) {\n  return left.shl(right);\n};\n\nglobalThis.i64_shr = function i64_shr(left, right) {\n  return left.shr(right);\n};\n\nglobalThis.i64_shr_u = function i64_shr_u(left, right) {\n  return left.shru(right);\n};\n\nglobalThis.i64_eq = function i64_eq(left, right) {\n  return left.eq(right);\n};\n\nglobalThis.i64_ne = function i64_ne(left, right) {\n  return left.ne(right);\n};\n\nglobalThis.i64_ge = function i64_ge(left, right) {\n  return left.ge(right);\n};\n\nglobalThis.i64_ge_u = function i64_ge_u(left, right) {\n  return left.toUnsigned().ge(right.toUnsigned());\n};\n\nglobalThis.i64_gt = function i64_gt(left, right) {\n  return left.gt(right);\n};\n\nglobalThis.i64_gt_u = function i64_gt_u(left, right) {\n  return left.toUnsigned().gt(right.toUnsigned());\n};\n\nglobalThis.i64_le = function i64_le(left, right) {\n  return left.le(right);\n};\n\nglobalThis.i64_le_u = function i64_le_u(left, right) {\n  return left.toUnsigned().le(right.toUnsigned());\n};\n\nglobalThis.i64_lt = function i64_lt(left, right) {\n  return left.lt(right);\n};\n\nglobalThis.i64_lt_u = function i64_lt_u(left, right) {\n  return left.toUnsigned().lt(right.toUnsigned());\n};\n\nglobalThis.i64_align = function i64_align(value, alignment) {\n  assert(alignment && (alignment & (alignment - 1)) == 0);\n  let mask = Long.fromInt(alignment - 1);\n  return value.add(mask).and(mask.not());\n};\n\nglobalThis.i64_signbit = function i64_signbit(value) {\n  return Boolean(value.high >>> 31);\n};\n\nglobalThis.i64_is_i8 = function i64_is_i8(value) {\n  return value.high === 0 && (value.low >= 0 && value.low <= i8.MAX_VALUE)\n      || value.high === -1 && (value.low >= i8.MIN_VALUE && value.low < 0);\n};\n\nglobalThis.i64_is_i16 = function i64_is_i16(value) {\n  return value.high === 0 && (value.low >= 0 && value.low <= i16.MAX_VALUE)\n      || value.high === -1 && (value.low >= i16.MIN_VALUE && value.low < 0);\n};\n\nglobalThis.i64_is_i32 = function i64_is_i32(value) {\n  return (value.high === 0 && value.low >= 0)\n      || (value.high === -1 && value.low < 0);\n};\n\nglobalThis.i64_is_u8 = function i64_is_u8(value) {\n  return value.high === 0 && (value.low >>> 0) <= u8.MAX_VALUE;\n};\n\nglobalThis.i64_is_u16 = function i64_is_u16(value) {\n  return value.high === 0 && (value.low >>> 0) <= u16.MAX_VALUE;\n};\n\nglobalThis.i64_is_u32 = function i64_is_u32(value) {\n  return value.high === 0;\n};\n\nglobalThis.i64_is_bool = function i64_is_bool(value) {\n  return (value.high | (value.low & ~1)) === 0;\n};\n\nconst minSafeF32 = Long.fromNumber(f32.MIN_SAFE_INTEGER);\nconst maxSafeF32 = Long.fromNumber(f32.MAX_SAFE_INTEGER);\n\nglobalThis.i64_is_f32 = function i64_is_f32(value) {\n  return value.gte(minSafeF32) && value.lte(maxSafeF32);\n};\n\nconst minSafeF64 = Long.fromNumber(f64.MIN_SAFE_INTEGER);\nconst maxSafeF64 = Long.fromNumber(f64.MAX_SAFE_INTEGER);\n\nglobalThis.i64_is_f64 = function i64_is_f64(value) {\n  return value.gte(minSafeF64) && value.lte(maxSafeF64);\n};\n\nglobalThis.i64_to_f32 = function i64_to_f32(value) {\n  return globalThis.Math.fround(value.toNumber());\n};\n\nglobalThis.i64_to_f64 = function i64_to_f64(value) {\n  return value.toNumber();\n};\n\nglobalThis.i64_to_string = function i64_to_string(value, unsigned) {\n  return unsigned ? value.toUnsigned().toString() : value.toString();\n};\n\nglobalThis.i64_clone = function i64_clone(value) {\n  return Long.fromBits(value.low, value.high, value.unsigned);\n};\n", "/**\n * @fileoverview Collections glue code for JavaScript.\n * @license Apache-2.0\n */\n\nglobalThis.Map_keys = function Map_keys(map) {\n  return Array.from(map.keys());\n};\n\nglobalThis.Map_values = function Map_values(map) {\n  return Array.from(map.values());\n};\n\nglobalThis.Set_values = function Set_values(set) {\n  return Array.from(set.values());\n};\n", "// This file is shared with the compiler and must remain portable\n\n/** Indicates specific features to activate. */\nexport const enum Feature {\n  /** No additional features. */\n  None = 0,\n  /** Sign extension operations. */\n  SignExtension = 1 << 0, // see: https://github.com/WebAssembly/sign-extension-ops\n  /** Mutable global imports and exports. */\n  MutableGlobals = 1 << 1, // see: https://github.com/WebAssembly/mutable-global\n  /** Non-trapping float to integer operations. */\n  NontrappingF2I = 1 << 2, // see: https://github.com/WebAssembly/nontrapping-float-to-int-conversions\n  /** Bulk memory operations. */\n  BulkMemory = 1 << 3, // see: https://github.com/WebAssembly/bulk-memory-operations\n  /** SIMD types and operations. */\n  Simd = 1 << 4, // see: https://github.com/WebAssembly/simd\n  /** Threading and atomic operations. */\n  Threads = 1 << 5, // see: https://github.com/WebAssembly/threads\n  /** Exception handling operations. */\n  ExceptionHandling = 1 << 6, // see: https://github.com/WebAssembly/exception-handling\n  /** Tail call operations. */\n  TailCalls = 1 << 7, // see: https://github.com/WebAssembly/tail-call\n  /** Reference types. */\n  ReferenceTypes = 1 << 8, // see: https://github.com/WebAssembly/reference-types\n  /** Multi value types. */\n  MultiValue = 1 << 9, // see: https://github.com/WebAssembly/multi-value\n  /** Garbage collection. */\n  GC = 1 << 10, // see: https://github.com/WebAssembly/gc\n  /** Memory64. */\n  Memory64 = 1 << 11, // see: https://github.com/WebAssembly/memory64\n  /** Relaxed SIMD. */\n  RelaxedSimd = 1 << 12, // see: https://github.com/WebAssembly/relaxed-simd\n  /** Extended const expressions. */\n  ExtendedConst = 1 << 13, // see: https://github.com/WebAssembly/extended-const\n  /** Reference typed strings. */\n  Stringref = 1 << 14, // see: https://github.com/WebAssembly/stringref\n  /** All features. */\n  All = (1 << 15) - 1\n}\n\n/** Gets the name of the specified feature one would specify on the command line. */\nexport function featureToString(feature: Feature): string {\n  switch (feature) {\n    case Feature.SignExtension: return \"sign-extension\";\n    case Feature.MutableGlobals: return \"mutable-globals\";\n    case Feature.NontrappingF2I: return \"nontrapping-f2i\";\n    case Feature.BulkMemory: return \"bulk-memory\";\n    case Feature.Simd: return \"simd\";\n    case Feature.Threads: return \"threads\";\n    case Feature.ExceptionHandling: return \"exception-handling\";\n    case Feature.TailCalls: return \"tail-calls\";\n    case Feature.ReferenceTypes: return \"reference-types\";\n    case Feature.MultiValue: return \"multi-value\";\n    case Feature.GC: return \"gc\";\n    case Feature.Memory64: return \"memory64\";\n    case Feature.RelaxedSimd: return \"relaxed-simd\";\n    case Feature.ExtendedConst: return \"extended-const\";\n    case Feature.Stringref: return \"stringref\";\n  }\n  assert(false);\n  return \"\";\n}\n", "// This file is shared with the compiler and must remain portable\n\n/** Compilation target. */\nexport enum Target {\n  /** Portable. */\n  Js = 0,\n  /** WebAssembly with 32-bit pointers. */\n  Wasm32 = 1,\n  /** WebAssembly with 64-bit pointers. Experimental and not supported by any runtime yet. */\n  Wasm64 = 2,\n}\n", "// This file is shared with the compiler and must remain portable\n\n/** Runtime types. */\nexport enum Runtime {\n  /** Simple bump allocator without GC. */\n  Stub = 0,\n  /** Stop the world semi-automatic GC. */\n  Minimal = 1,\n  /** incremental GC. */\n  Incremental = 2,\n}\n", "// This file is shared with the compiler and must remain portable\n\n// \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Typeinfo interpretation \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// \u251C\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2524 \u25C4\u2500 __rtti_base\n// \u2502                             count                             \u2502\n// \u255E\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2510\n// \u2502                      Typeinfo#flags [id=0]                    \u2502 id < count\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n// \u2502                              ...                              \u2502\n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `StaticArray`. */\n  STATICARRAY = 1 << 2,\n  /** Type is a `Set`. */\n  SET = 1 << 3,\n  /** Type is a `Map`. */\n  MAP = 1 << 4,\n  /** Type has no outgoing pointers. */\n  POINTERFREE = 1 << 5,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 6,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 7,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 8,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 9,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 10,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 11,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 12,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 13,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 14,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 15,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 16,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 17,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 18,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 19,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 20,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 21,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 22,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 23\n}\n", "/**\n * @fileoverview Common constants used by various parts of the compiler.\n * @license Apache-2.0\n */\n\n/** Indicates traits of a {@link Node} or {@link Element}. */\nexport const enum CommonFlags {\n  /** No flags set. */\n  None = 0,\n\n  // Basic modifiers\n\n  /** Has an `import` modifier. */\n  Import = 1 << 0,\n  /** Has an `export` modifier. */\n  Export = 1 << 1,\n  /** Has a `declare` modifier. */\n  Declare = 1 << 2,\n  /** Has a `const` modifier. */\n  Const = 1 << 3,\n  /** Has a `let` modifier. */\n  Let = 1 << 4,\n  /** Has a `static` modifier. */\n  Static = 1 << 5,\n  /** Has a `readonly` modifier. */\n  Readonly = 1 << 6,\n  /** Has an `abstract` modifier. */\n  Abstract = 1 << 7,\n  /** Has a `public` modifier. */\n  Public = 1 << 8,\n  /** Has a `private` modifier. */\n  Private = 1 << 9,\n  /** Has a `protected` modifier. */\n  Protected = 1 << 10,\n  /** Has a `get` modifier. */\n  Get = 1 << 11,\n  /** Has a `set` modifier. */\n  Set = 1 << 12,\n  /** Has a `override` modifier.  */\n  Override = 1 << 13,\n\n  /** Has a definite assignment assertion `!` as in `x!: i32;`. */\n  DefinitelyAssigned = 1 << 14,\n\n  // Extended modifiers usually derived from basic modifiers\n\n  /** Is ambient, that is either declared or nested in a declared element. */\n  Ambient = 1 << 15,\n  /** Is generic. */\n  Generic = 1 << 16,\n  /** Is part of a generic context. */\n  GenericContext = 1 << 17,\n  /** Is an instance member. */\n  Instance = 1 << 18,\n  /** Is a constructor. */\n  Constructor = 1 << 19,\n  /** Is a module export. */\n  ModuleExport = 1 << 20,\n  /** Is a module import. */\n  ModuleImport = 1 << 21,\n\n  // Compilation states\n\n  /** Is resolved. */\n  Resolved = 1 << 22,\n  /** Is compiled. */\n  Compiled = 1 << 23,\n  /** Did error. */\n  Errored = 1 << 24,\n  /** Has a constant value and is therefore inlined. */\n  Inlined = 1 << 25,\n  /** Is scoped. */\n  Scoped = 1 << 26,\n  /** Is a stub. */\n  Stub = 1 << 27,\n  /** Is an overridden method. */\n  Overridden = 1 << 28,\n  /** Is (part of) a closure. */\n  Closure = 1 << 29,\n\n  // Other\n\n  /** Is quoted. */\n  Quoted = 1 << 30,\n  /** Is internally nullable. */\n  InternallyNullable = 1 << 31\n}\n\n/** Path delimiter inserted between file system levels. */\nexport const PATH_DELIMITER = \"/\";\n/** Substitution used to indicate the parent directory. */\nexport const PARENT_SUBST = \"..\";\n/** Function name prefix used for getters. */\nexport const GETTER_PREFIX = \"get:\";\n/** Function name prefix used for setters. */\nexport const SETTER_PREFIX = \"set:\";\n/** Delimiter used between class names and instance members. */\nexport const INSTANCE_DELIMITER = \"#\";\n/** Delimiter used between class and namespace names and static members. */\nexport const STATIC_DELIMITER = \".\";\n/** Delimiter used between a function and its inner elements. */\nexport const INNER_DELIMITER = \"~\";\n/** Substitution used to indicate a library directory. */\nexport const LIBRARY_SUBST = \"~lib\";\n/** Library directory prefix. */\nexport const LIBRARY_PREFIX = LIBRARY_SUBST + PATH_DELIMITER;\n/** Path index suffix. */\nexport const INDEX_SUFFIX = PATH_DELIMITER + \"index\";\n/** Stub function delimiter. */\nexport const STUB_DELIMITER = \"@\";\n\n/** Common names. */\nexport namespace CommonNames {\n  // special\n  export const Empty = \"\";\n  // types\n  export const i8 = \"i8\";\n  export const i16 = \"i16\";\n  export const i32 = \"i32\";\n  export const i64 = \"i64\";\n  export const isize = \"isize\";\n  export const u8 = \"u8\";\n  export const u16 = \"u16\";\n  export const u32 = \"u32\";\n  export const u64 = \"u64\";\n  export const usize = \"usize\";\n  export const bool = \"bool\";\n  export const f32 = \"f32\";\n  export const f64 = \"f64\";\n  export const v128 = \"v128\";\n  export const ref_func = \"ref_func\";\n  export const ref_extern = \"ref_extern\";\n  export const ref_any = \"ref_any\";\n  export const ref_eq = \"ref_eq\";\n  export const ref_struct = \"ref_struct\";\n  export const ref_array = \"ref_array\";\n  export const ref_i31 = \"ref_i31\";\n  export const ref_string = \"ref_string\";\n  export const ref_stringview_wtf8 = \"ref_stringview_wtf8\";\n  export const ref_stringview_wtf16 = \"ref_stringview_wtf16\";\n  export const ref_stringview_iter = \"ref_stringview_iter\";\n  export const i8x16 = \"i8x16\";\n  export const u8x16 = \"u8x16\";\n  export const i16x8 = \"i16x8\";\n  export const u16x8 = \"u16x8\";\n  export const i32x4 = \"i32x4\";\n  export const u32x4 = \"u32x4\";\n  export const i64x2 = \"i64x2\";\n  export const u64x2 = \"u64x2\";\n  export const f32x4 = \"f32x4\";\n  export const f64x2 = \"f64x2\";\n  export const void_ = \"void\";\n  export const number = \"number\";\n  export const boolean = \"boolean\";\n  export const string = \"string\";\n  export const native = \"native\";\n  export const indexof = \"indexof\";\n  export const valueof = \"valueof\";\n  export const returnof = \"returnof\";\n  export const nonnull = \"nonnull\";\n  // aliases\n  export const null_ = \"null\";\n  export const true_ = \"true\";\n  export const false_ = \"false\";\n  // objects\n  export const this_ = \"this\";\n  export const super_ = \"super\";\n  export const constructor = \"constructor\";\n  // constants\n  export const ASC_TARGET = \"ASC_TARGET\";\n  export const ASC_RUNTIME = \"ASC_RUNTIME\";\n  export const ASC_NO_ASSERT = \"ASC_NO_ASSERT\";\n  export const ASC_MEMORY_BASE = \"ASC_MEMORY_BASE\";\n  export const ASC_TABLE_BASE = \"ASC_TABLE_BASE\";\n  export const ASC_OPTIMIZE_LEVEL = \"ASC_OPTIMIZE_LEVEL\";\n  export const ASC_SHRINK_LEVEL = \"ASC_SHRINK_LEVEL\";\n  export const ASC_LOW_MEMORY_LIMIT = \"ASC_LOW_MEMORY_LIMIT\";\n  export const ASC_EXPORT_RUNTIME = \"ASC_EXPORT_RUNTIME\";\n  export const ASC_FEATURE_SIGN_EXTENSION = \"ASC_FEATURE_SIGN_EXTENSION\";\n  export const ASC_FEATURE_MUTABLE_GLOBALS = \"ASC_FEATURE_MUTABLE_GLOBALS\";\n  export const ASC_FEATURE_NONTRAPPING_F2I = \"ASC_FEATURE_NONTRAPPING_F2I\";\n  export const ASC_FEATURE_BULK_MEMORY = \"ASC_FEATURE_BULK_MEMORY\";\n  export const ASC_FEATURE_SIMD = \"ASC_FEATURE_SIMD\";\n  export const ASC_FEATURE_THREADS = \"ASC_FEATURE_THREADS\";\n  export const ASC_FEATURE_EXCEPTION_HANDLING = \"ASC_FEATURE_EXCEPTION_HANDLING\";\n  export const ASC_FEATURE_TAIL_CALLS = \"ASC_FEATURE_TAIL_CALLS\";\n  export const ASC_FEATURE_REFERENCE_TYPES = \"ASC_FEATURE_REFERENCE_TYPES\";\n  export const ASC_FEATURE_MULTI_VALUE = \"ASC_FEATURE_MULTI_VALUE\";\n  export const ASC_FEATURE_GC = \"ASC_FEATURE_GC\";\n  export const ASC_FEATURE_MEMORY64 = \"ASC_FEATURE_MEMORY64\";\n  export const ASC_FEATURE_RELAXED_SIMD = \"ASC_FEATURE_RELAXED_SIMD\";\n  export const ASC_FEATURE_EXTENDED_CONST = \"ASC_FEATURE_EXTENDED_CONST\";\n  export const ASC_FEATURE_STRINGREF = \"ASC_FEATURE_STRINGREF\";\n  export const ASC_VERSION_MAJOR = \"ASC_VERSION_MAJOR\";\n  export const ASC_VERSION_MINOR = \"ASC_VERSION_MINOR\";\n  export const ASC_VERSION_PATCH = \"ASC_VERSION_PATCH\";\n  // classes\n  export const I8 = \"I8\";\n  export const I16 = \"I16\";\n  export const I32 = \"I32\";\n  export const I64 = \"I64\";\n  export const Isize = \"Isize\";\n  export const U8 = \"U8\";\n  export const U16 = \"U16\";\n  export const U32 = \"U32\";\n  export const U64 = \"U64\";\n  export const Usize = \"Usize\";\n  export const Bool = \"Bool\";\n  export const F32 = \"F32\";\n  export const F64 = \"F64\";\n  export const V128 = \"V128\";\n  export const RefFunc = \"RefFunc\";\n  export const RefExtern = \"RefExtern\";\n  export const RefAny = \"RefAny\";\n  export const RefEq = \"RefEq\";\n  export const RefStruct = \"RefStruct\";\n  export const RefArray = \"RefArray\";\n  export const RefI31 = \"RefI31\";\n  export const RefString = \"RefString\";\n  export const String = \"String\";\n  export const RegExp = \"RegExp\";\n  export const Object = \"Object\";\n  export const Array = \"Array\";\n  export const StaticArray = \"StaticArray\";\n  export const Set = \"Set\";\n  export const Map = \"Map\";\n  export const Function = \"Function\";\n  export const ArrayBufferView = \"ArrayBufferView\";\n  export const ArrayBuffer = \"ArrayBuffer\";\n  export const Math = \"Math\";\n  export const Mathf = \"Mathf\";\n  export const NativeMath = \"NativeMath\";\n  export const NativeMathf = \"NativeMathf\";\n  export const Int8Array = \"Int8Array\";\n  export const Int16Array = \"Int16Array\";\n  export const Int32Array = \"Int32Array\";\n  export const Int64Array = \"Int64Array\";\n  export const Uint8Array = \"Uint8Array\";\n  export const Uint8ClampedArray = \"Uint8ClampedArray\";\n  export const Uint16Array = \"Uint16Array\";\n  export const Uint32Array = \"Uint32Array\";\n  export const Uint64Array = \"Uint64Array\";\n  export const Float32Array = \"Float32Array\";\n  export const Float64Array = \"Float64Array\";\n  export const TemplateStringsArray = \"TemplateStringsArray\";\n  export const Error = \"Error\";\n  // runtime\n  export const abort = \"abort\";\n  export const trace = \"trace\";\n  export const seed = \"seed\";\n  export const pow = \"pow\";\n  export const ipow32 = \"ipow32\";\n  export const ipow64 = \"ipow64\";\n  export const mod = \"mod\";\n  export const alloc = \"__alloc\";\n  export const realloc = \"__realloc\";\n  export const free = \"__free\";\n  export const new_ = \"__new\";\n  export const renew = \"__renew\";\n  export const link = \"__link\";\n  export const collect = \"__collect\";\n  export const visit = \"__visit\";\n  export const newBuffer = \"__newBuffer\";\n  export const newArray = \"__newArray\";\n  export const BLOCK = \"~lib/rt/common/BLOCK\";\n  export const OBJECT = \"~lib/rt/common/OBJECT\";\n  // memory & table\n  export const DefaultMemory = \"0\";\n  export const DefaultTable = \"0\";\n}\n\n// shared\nexport { Feature, featureToString } from \"../std/assembly/shared/feature\";\nexport { Target } from \"../std/assembly/shared/target\";\nexport { Runtime } from \"../std/assembly/shared/runtime\";\nexport { Typeinfo, TypeinfoFlags } from \"../std/assembly/shared/typeinfo\";\n", "// GENERATED FILE. DO NOT EDIT.\n\n/** Enum of available diagnostic codes. */\nexport enum DiagnosticCode {\n  Not_implemented_0 = 100,\n  Operation_is_unsafe = 101,\n  User_defined_0 = 102,\n  Feature_0_is_not_enabled = 103,\n  Low_memory_limit_exceeded_by_static_data_0_1 = 104,\n  Module_requires_at_least_0_pages_of_initial_memory = 105,\n  Module_requires_at_least_0_pages_of_maximum_memory = 106,\n  Shared_memory_requires_maximum_memory_to_be_defined = 107,\n  Shared_memory_requires_feature_threads_to_be_enabled = 108,\n  Transform_0_1 = 109,\n  Start_function_name_0_is_invalid_or_conflicts_with_another_export = 110,\n  Element_0_not_found = 111,\n  Exchange_of_0_values_is_not_supported_by_all_embeddings = 112,\n  Conversion_from_type_0_to_1_requires_an_explicit_cast = 200,\n  Conversion_from_type_0_to_1_will_require_an_explicit_cast_when_switching_between_32_64_bit = 201,\n  Type_0_cannot_be_changed_to_type_1 = 202,\n  Operation_0_cannot_be_applied_to_type_1 = 203,\n  Type_0_cannot_be_nullable = 204,\n  Mutable_value_cannot_be_inlined = 206,\n  Unmanaged_classes_cannot_extend_managed_classes_and_vice_versa = 207,\n  Unmanaged_classes_cannot_implement_interfaces = 208,\n  Invalid_regular_expression_flags = 209,\n  Expression_is_never_null = 210,\n  Class_0_is_final_and_cannot_be_extended = 211,\n  Decorator_0_is_not_valid_here = 212,\n  Duplicate_decorator = 213,\n  Type_0_is_illegal_in_this_context = 214,\n  Optional_parameter_must_have_an_initializer = 215,\n  Class_0_cannot_declare_a_constructor_when_instantiated_from_an_object_literal = 216,\n  Function_0_cannot_be_inlined_into_itself = 217,\n  Cannot_access_method_0_without_calling_it_as_it_requires_this_to_be_set = 218,\n  Optional_properties_are_not_supported = 219,\n  Expression_must_be_a_compile_time_constant = 220,\n  Type_0_is_not_a_function_index_or_function_reference = 221,\n  _0_must_be_a_value_between_1_and_2_inclusive = 222,\n  _0_must_be_a_power_of_two = 223,\n  _0_is_not_a_valid_operator = 224,\n  Expression_cannot_be_represented_by_a_type = 225,\n  Expression_resolves_to_unusual_type_0 = 226,\n  Array_literal_expected = 227,\n  Function_0_is_virtual_and_will_not_be_inlined = 228,\n  Property_0_only_has_a_setter_and_is_missing_a_getter = 229,\n  _0_keyword_cannot_be_used_here = 230,\n  A_class_with_a_constructor_explicitly_returning_something_else_than_this_must_be_final = 231,\n  Property_0_is_always_assigned_before_being_used = 233,\n  Expression_does_not_compile_to_a_value_at_runtime = 234,\n  Only_variables_functions_and_enums_become_WebAssembly_module_exports = 235,\n  Literal_0_does_not_fit_into_i64_or_u64_types = 236,\n  Index_signature_accessors_in_type_0_differ_in_types = 237,\n  Initializer_definitive_assignment_or_nullable_type_expected = 238,\n  Definitive_assignment_has_no_effect_on_local_variables = 239,\n  Ambiguous_operator_overload_0_conflicting_overloads_1_and_2 = 240,\n  Importing_the_table_disables_some_indirect_call_optimizations = 901,\n  Exporting_the_table_disables_some_indirect_call_optimizations = 902,\n  Expression_compiles_to_a_dynamic_check_at_runtime = 903,\n  Indexed_access_may_involve_bounds_checking = 904,\n  Explicitly_returning_constructor_drops_this_allocation = 905,\n  Unnecessary_definite_assignment = 906,\n  _NaN_does_not_compare_equal_to_any_other_value_including_itself_Use_isNaN_x_instead = 907,\n  Comparison_with_0_0_is_sign_insensitive_Use_Object_is_x_0_0_if_the_sign_matters = 908,\n  Unterminated_string_literal = 1002,\n  Identifier_expected = 1003,\n  _0_expected = 1005,\n  A_file_cannot_have_a_reference_to_itself = 1006,\n  Trailing_comma_not_allowed = 1009,\n  Unexpected_token = 1012,\n  A_rest_parameter_must_be_last_in_a_parameter_list = 1014,\n  Parameter_cannot_have_question_mark_and_initializer = 1015,\n  A_required_parameter_cannot_follow_an_optional_parameter = 1016,\n  _0_modifier_cannot_appear_on_class_elements_of_this_kind = 1031,\n  Statements_are_not_allowed_in_ambient_contexts = 1036,\n  Initializers_are_not_allowed_in_ambient_contexts = 1039,\n  _0_modifier_cannot_be_used_here = 1042,\n  A_rest_parameter_cannot_be_optional = 1047,\n  A_rest_parameter_cannot_have_an_initializer = 1048,\n  A_set_accessor_must_have_exactly_one_parameter = 1049,\n  A_set_accessor_parameter_cannot_have_an_initializer = 1052,\n  A_get_accessor_cannot_have_parameters = 1054,\n  Enum_member_must_have_initializer = 1061,\n  Type_parameters_cannot_appear_on_a_constructor_declaration = 1092,\n  Type_annotation_cannot_appear_on_a_constructor_declaration = 1093,\n  An_accessor_cannot_have_type_parameters = 1094,\n  A_set_accessor_cannot_have_a_return_type_annotation = 1095,\n  Type_parameter_list_cannot_be_empty = 1098,\n  Type_argument_list_cannot_be_empty = 1099,\n  A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement = 1104,\n  A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement = 1105,\n  A_return_statement_can_only_be_used_within_a_function_body = 1108,\n  Expression_expected = 1109,\n  Type_expected = 1110,\n  A_default_clause_cannot_appear_more_than_once_in_a_switch_statement = 1113,\n  Duplicate_label_0 = 1114,\n  An_export_assignment_cannot_have_modifiers = 1120,\n  Octal_literals_are_not_allowed_in_strict_mode = 1121,\n  Digit_expected = 1124,\n  Hexadecimal_digit_expected = 1125,\n  Unexpected_end_of_text = 1126,\n  Invalid_character = 1127,\n  _case_or_default_expected = 1130,\n  _super_must_be_followed_by_an_argument_list_or_member_access = 1034,\n  A_declare_modifier_cannot_be_used_in_an_already_ambient_context = 1038,\n  Type_argument_expected = 1140,\n  String_literal_expected = 1141,\n  Line_break_not_permitted_here = 1142,\n  Declaration_expected = 1146,\n  _const_declarations_must_be_initialized = 1155,\n  Unterminated_regular_expression_literal = 1161,\n  Declarations_with_initializers_cannot_also_have_definite_assignment_assertions = 1263,\n  Interface_declaration_cannot_have_implements_clause = 1176,\n  Binary_digit_expected = 1177,\n  Octal_digit_expected = 1178,\n  An_implementation_cannot_be_declared_in_ambient_contexts = 1183,\n  The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer = 1190,\n  An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive = 1198,\n  Unterminated_Unicode_escape_sequence = 1199,\n  Decorators_are_not_valid_here = 1206,\n  _abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration = 1242,\n  Method_0_cannot_have_an_implementation_because_it_is_marked_abstract = 1245,\n  An_interface_property_cannot_have_an_initializer = 1246,\n  A_definite_assignment_assertion_is_not_permitted_in_this_context = 1255,\n  A_class_may_only_extend_another_class = 1311,\n  A_parameter_property_cannot_be_declared_using_a_rest_parameter = 1317,\n  A_default_export_can_only_be_used_in_a_module = 1319,\n  An_expression_of_type_0_cannot_be_tested_for_truthiness = 1345,\n  An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal = 1351,\n  Duplicate_identifier_0 = 2300,\n  Cannot_find_name_0 = 2304,\n  Module_0_has_no_exported_member_1 = 2305,\n  An_interface_can_only_extend_an_interface = 2312,\n  Generic_type_0_requires_1_type_argument_s = 2314,\n  Type_0_is_not_generic = 2315,\n  Type_0_is_not_assignable_to_type_1 = 2322,\n  Property_0_is_private_in_type_1_but_not_in_type_2 = 2325,\n  Index_signature_is_missing_in_type_0 = 2329,\n  _this_cannot_be_referenced_in_current_location = 2332,\n  _this_cannot_be_referenced_in_constructor_arguments = 2333,\n  _super_can_only_be_referenced_in_a_derived_class = 2335,\n  _super_cannot_be_referenced_in_constructor_arguments = 2336,\n  Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors = 2337,\n  Property_0_does_not_exist_on_type_1 = 2339,\n  Property_0_is_private_and_only_accessible_within_class_1 = 2341,\n  Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures = 2349,\n  This_expression_is_not_constructable = 2351,\n  A_function_whose_declared_type_is_not_void_must_return_a_value = 2355,\n  The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access = 2357,\n  The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access = 2364,\n  Operator_0_cannot_be_applied_to_types_1_and_2 = 2365,\n  A_super_call_must_be_the_first_statement_in_the_constructor = 2376,\n  Constructors_for_derived_classes_must_contain_a_super_call = 2377,\n  _get_and_set_accessor_must_have_the_same_type = 2380,\n  Overload_signatures_must_all_be_public_private_or_protected = 2385,\n  Constructor_implementation_is_missing = 2390,\n  Function_implementation_is_missing_or_not_immediately_following_the_declaration = 2391,\n  Multiple_constructor_implementations_are_not_allowed = 2392,\n  Duplicate_function_implementation = 2393,\n  This_overload_signature_is_not_compatible_with_its_implementation_signature = 2394,\n  Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local = 2395,\n  Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2 = 2416,\n  A_class_can_only_implement_an_interface = 2422,\n  A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged = 2434,\n  Types_have_separate_declarations_of_a_private_property_0 = 2442,\n  Property_0_is_protected_in_type_1_but_public_in_type_2 = 2444,\n  Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses = 2445,\n  Variable_0_used_before_its_declaration = 2448,\n  Cannot_redeclare_block_scoped_variable_0 = 2451,\n  The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly = 2453,\n  Variable_0_is_used_before_being_assigned = 2454,\n  Type_alias_0_circularly_references_itself = 2456,\n  Type_0_has_no_property_1 = 2460,\n  The_0_operator_cannot_be_applied_to_type_1 = 2469,\n  In_const_enum_declarations_member_initializer_must_be_constant_expression = 2474,\n  Export_declaration_conflicts_with_exported_declaration_of_0 = 2484,\n  _0_is_referenced_directly_or_indirectly_in_its_own_base_expression = 2506,\n  Cannot_create_an_instance_of_an_abstract_class = 2511,\n  Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_2 = 2515,\n  Object_is_possibly_null = 2531,\n  Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property = 2540,\n  The_target_of_an_assignment_must_be_a_variable_or_a_property_access = 2541,\n  Index_signature_in_type_0_only_permits_reading = 2542,\n  Expected_0_arguments_but_got_1 = 2554,\n  Expected_at_least_0_arguments_but_got_1 = 2555,\n  Expected_0_type_arguments_but_got_1 = 2558,\n  Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned = 2564,\n  Property_0_is_used_before_being_assigned = 2565,\n  _0_is_defined_as_an_accessor_in_class_1_but_is_overridden_here_in_2_as_an_instance_property = 2610,\n  _0_is_defined_as_a_property_in_class_1_but_is_overridden_here_in_2_as_an_accessor = 2611,\n  A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums = 2651,\n  Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration = 2673,\n  Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration = 2674,\n  Cannot_extend_a_class_0_Class_constructor_is_marked_as_private = 2675,\n  The_this_types_of_each_signature_are_incompatible = 2685,\n  Namespace_0_has_no_exported_member_1 = 2694,\n  Namespace_can_only_have_declarations = 2695,\n  Required_type_parameters_may_not_follow_optional_type_parameters = 2706,\n  Duplicate_property_0 = 2718,\n  Property_0_is_missing_in_type_1_but_required_in_type_2 = 2741,\n  Type_0_has_no_call_signatures = 2757,\n  Get_accessor_0_must_be_at_least_as_accessible_as_the_setter = 2808,\n  This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0 = 4117,\n  File_0_not_found = 6054,\n  Numeric_separators_are_not_allowed_here = 6188,\n  Multiple_consecutive_numeric_separators_are_not_permitted = 6189,\n  This_expression_is_not_callable_because_it_is_a_get_accessor_Did_you_mean_to_use_it_without = 6234,\n  _super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class = 17009,\n  _super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class = 17011\n}\n\n/** Translates a diagnostic code to its respective string. */\nexport function diagnosticCodeToString(code: DiagnosticCode): string {\n  switch (code) {\n    case 100: return \"Not implemented: {0}\";\n    case 101: return \"Operation is unsafe.\";\n    case 102: return \"User-defined: {0}\";\n    case 103: return \"Feature '{0}' is not enabled.\";\n    case 104: return \"Low memory limit exceeded by static data: {0} > {1}\";\n    case 105: return \"Module requires at least '{0}' pages of initial memory.\";\n    case 106: return \"Module requires at least '{0}' pages of maximum memory.\";\n    case 107: return \"Shared memory requires maximum memory to be defined.\";\n    case 108: return \"Shared memory requires feature 'threads' to be enabled.\";\n    case 109: return \"Transform '{0}': {1}\";\n    case 110: return \"Start function name '{0}' is invalid or conflicts with another export.\";\n    case 111: return \"Element '{0}' not found.\";\n    case 112: return \"Exchange of '{0}' values is not supported by all embeddings\";\n    case 200: return \"Conversion from type '{0}' to '{1}' requires an explicit cast.\";\n    case 201: return \"Conversion from type '{0}' to '{1}' will require an explicit cast when switching between 32/64-bit.\";\n    case 202: return \"Type '{0}' cannot be changed to type '{1}'.\";\n    case 203: return \"Operation '{0}' cannot be applied to type '{1}'.\";\n    case 204: return \"Type '{0}' cannot be nullable.\";\n    case 206: return \"Mutable value cannot be inlined.\";\n    case 207: return \"Unmanaged classes cannot extend managed classes and vice-versa.\";\n    case 208: return \"Unmanaged classes cannot implement interfaces.\";\n    case 209: return \"Invalid regular expression flags.\";\n    case 210: return \"Expression is never 'null'.\";\n    case 211: return \"Class '{0}' is final and cannot be extended.\";\n    case 212: return \"Decorator '{0}' is not valid here.\";\n    case 213: return \"Duplicate decorator.\";\n    case 214: return \"Type '{0}' is illegal in this context.\";\n    case 215: return \"Optional parameter must have an initializer.\";\n    case 216: return \"Class '{0}' cannot declare a constructor when instantiated from an object literal.\";\n    case 217: return \"Function '{0}' cannot be inlined into itself.\";\n    case 218: return \"Cannot access method '{0}' without calling it as it requires 'this' to be set.\";\n    case 219: return \"Optional properties are not supported.\";\n    case 220: return \"Expression must be a compile-time constant.\";\n    case 221: return \"Type '{0}' is not a function index or function reference.\";\n    case 222: return \"'{0}' must be a value between '{1}' and '{2}' inclusive.\";\n    case 223: return \"'{0}' must be a power of two.\";\n    case 224: return \"'{0}' is not a valid operator.\";\n    case 225: return \"Expression cannot be represented by a type.\";\n    case 226: return \"Expression resolves to unusual type '{0}'.\";\n    case 227: return \"Array literal expected.\";\n    case 228: return \"Function '{0}' is virtual and will not be inlined.\";\n    case 229: return \"Property '{0}' only has a setter and is missing a getter.\";\n    case 230: return \"'{0}' keyword cannot be used here.\";\n    case 231: return \"A class with a constructor explicitly returning something else than 'this' must be '@final'.\";\n    case 233: return \"Property '{0}' is always assigned before being used.\";\n    case 234: return \"Expression does not compile to a value at runtime.\";\n    case 235: return \"Only variables, functions and enums become WebAssembly module exports.\";\n    case 236: return \"Literal '{0}' does not fit into 'i64' or 'u64' types.\";\n    case 237: return \"Index signature accessors in type '{0}' differ in types.\";\n    case 238: return \"Initializer, definitive assignment or nullable type expected.\";\n    case 239: return \"Definitive assignment has no effect on local variables.\";\n    case 240: return \"Ambiguous operator overload '{0}' (conflicting overloads '{1}' and '{2}').\";\n    case 901: return \"Importing the table disables some indirect call optimizations.\";\n    case 902: return \"Exporting the table disables some indirect call optimizations.\";\n    case 903: return \"Expression compiles to a dynamic check at runtime.\";\n    case 904: return \"Indexed access may involve bounds checking.\";\n    case 905: return \"Explicitly returning constructor drops 'this' allocation.\";\n    case 906: return \"Unnecessary definite assignment.\";\n    case 907: return \"'NaN' does not compare equal to any other value including itself. Use isNaN(x) instead.\";\n    case 908: return \"Comparison with -0.0 is sign insensitive. Use Object.is(x, -0.0) if the sign matters.\";\n    case 1002: return \"Unterminated string literal.\";\n    case 1003: return \"Identifier expected.\";\n    case 1005: return \"'{0}' expected.\";\n    case 1006: return \"A file cannot have a reference to itself.\";\n    case 1009: return \"Trailing comma not allowed.\";\n    case 1012: return \"Unexpected token.\";\n    case 1014: return \"A rest parameter must be last in a parameter list.\";\n    case 1015: return \"Parameter cannot have question mark and initializer.\";\n    case 1016: return \"A required parameter cannot follow an optional parameter.\";\n    case 1031: return \"'{0}' modifier cannot appear on class elements of this kind.\";\n    case 1036: return \"Statements are not allowed in ambient contexts.\";\n    case 1039: return \"Initializers are not allowed in ambient contexts.\";\n    case 1042: return \"'{0}' modifier cannot be used here.\";\n    case 1047: return \"A rest parameter cannot be optional.\";\n    case 1048: return \"A rest parameter cannot have an initializer.\";\n    case 1049: return \"A 'set' accessor must have exactly one parameter.\";\n    case 1052: return \"A 'set' accessor parameter cannot have an initializer.\";\n    case 1054: return \"A 'get' accessor cannot have parameters.\";\n    case 1061: return \"Enum member must have initializer.\";\n    case 1092: return \"Type parameters cannot appear on a constructor declaration.\";\n    case 1093: return \"Type annotation cannot appear on a constructor declaration.\";\n    case 1094: return \"An accessor cannot have type parameters.\";\n    case 1095: return \"A 'set' accessor cannot have a return type annotation.\";\n    case 1098: return \"Type parameter list cannot be empty.\";\n    case 1099: return \"Type argument list cannot be empty.\";\n    case 1104: return \"A 'continue' statement can only be used within an enclosing iteration statement.\";\n    case 1105: return \"A 'break' statement can only be used within an enclosing iteration or switch statement.\";\n    case 1108: return \"A 'return' statement can only be used within a function body.\";\n    case 1109: return \"Expression expected.\";\n    case 1110: return \"Type expected.\";\n    case 1113: return \"A 'default' clause cannot appear more than once in a 'switch' statement.\";\n    case 1114: return \"Duplicate label '{0}'.\";\n    case 1120: return \"An export assignment cannot have modifiers.\";\n    case 1121: return \"Octal literals are not allowed in strict mode.\";\n    case 1124: return \"Digit expected.\";\n    case 1125: return \"Hexadecimal digit expected.\";\n    case 1126: return \"Unexpected end of text.\";\n    case 1127: return \"Invalid character.\";\n    case 1130: return \"'case' or 'default' expected.\";\n    case 1034: return \"'super' must be followed by an argument list or member access.\";\n    case 1038: return \"A 'declare' modifier cannot be used in an already ambient context.\";\n    case 1140: return \"Type argument expected.\";\n    case 1141: return \"String literal expected.\";\n    case 1142: return \"Line break not permitted here.\";\n    case 1146: return \"Declaration expected.\";\n    case 1155: return \"'const' declarations must be initialized.\";\n    case 1161: return \"Unterminated regular expression literal.\";\n    case 1263: return \"Declarations with initializers cannot also have definite assignment assertions.\";\n    case 1176: return \"Interface declaration cannot have 'implements' clause.\";\n    case 1177: return \"Binary digit expected.\";\n    case 1178: return \"Octal digit expected.\";\n    case 1183: return \"An implementation cannot be declared in ambient contexts.\";\n    case 1190: return \"The variable declaration of a 'for...of' statement cannot have an initializer.\";\n    case 1198: return \"An extended Unicode escape value must be between 0x0 and 0x10FFFF inclusive.\";\n    case 1199: return \"Unterminated Unicode escape sequence.\";\n    case 1206: return \"Decorators are not valid here.\";\n    case 1242: return \"'abstract' modifier can only appear on a class, method, or property declaration.\";\n    case 1245: return \"Method '{0}' cannot have an implementation because it is marked abstract.\";\n    case 1246: return \"An interface property cannot have an initializer.\";\n    case 1255: return \"A definite assignment assertion '!' is not permitted in this context.\";\n    case 1311: return \"A class may only extend another class.\";\n    case 1317: return \"A parameter property cannot be declared using a rest parameter.\";\n    case 1319: return \"A default export can only be used in a module.\";\n    case 1345: return \"An expression of type '{0}' cannot be tested for truthiness.\";\n    case 1351: return \"An identifier or keyword cannot immediately follow a numeric literal.\";\n    case 2300: return \"Duplicate identifier '{0}'.\";\n    case 2304: return \"Cannot find name '{0}'.\";\n    case 2305: return \"Module '{0}' has no exported member '{1}'.\";\n    case 2312: return \"An interface can only extend an interface.\";\n    case 2314: return \"Generic type '{0}' requires {1} type argument(s).\";\n    case 2315: return \"Type '{0}' is not generic.\";\n    case 2322: return \"Type '{0}' is not assignable to type '{1}'.\";\n    case 2325: return \"Property '{0}' is private in type '{1}' but not in type '{2}'.\";\n    case 2329: return \"Index signature is missing in type '{0}'.\";\n    case 2332: return \"'this' cannot be referenced in current location.\";\n    case 2333: return \"'this' cannot be referenced in constructor arguments.\";\n    case 2335: return \"'super' can only be referenced in a derived class.\";\n    case 2336: return \"'super' cannot be referenced in constructor arguments.\";\n    case 2337: return \"Super calls are not permitted outside constructors or in nested functions inside constructors.\";\n    case 2339: return \"Property '{0}' does not exist on type '{1}'.\";\n    case 2341: return \"Property '{0}' is private and only accessible within class '{1}'.\";\n    case 2349: return \"Cannot invoke an expression whose type lacks a call signature. Type '{0}' has no compatible call signatures.\";\n    case 2351: return \"This expression is not constructable.\";\n    case 2355: return \"A function whose declared type is not 'void' must return a value.\";\n    case 2357: return \"The operand of an increment or decrement operator must be a variable or a property access.\";\n    case 2364: return \"The left-hand side of an assignment expression must be a variable or a property access.\";\n    case 2365: return \"Operator '{0}' cannot be applied to types '{1}' and '{2}'.\";\n    case 2376: return \"A 'super' call must be the first statement in the constructor.\";\n    case 2377: return \"Constructors for derived classes must contain a 'super' call.\";\n    case 2380: return \"'get' and 'set' accessor must have the same type.\";\n    case 2385: return \"Overload signatures must all be public, private or protected.\";\n    case 2390: return \"Constructor implementation is missing.\";\n    case 2391: return \"Function implementation is missing or not immediately following the declaration.\";\n    case 2392: return \"Multiple constructor implementations are not allowed.\";\n    case 2393: return \"Duplicate function implementation.\";\n    case 2394: return \"This overload signature is not compatible with its implementation signature.\";\n    case 2395: return \"Individual declarations in merged declaration '{0}' must be all exported or all local.\";\n    case 2416: return \"Property '{0}' in type '{1}' is not assignable to the same property in base type '{2}'.\";\n    case 2422: return \"A class can only implement an interface.\";\n    case 2434: return \"A namespace declaration cannot be located prior to a class or function with which it is merged.\";\n    case 2442: return \"Types have separate declarations of a private property '{0}'.\";\n    case 2444: return \"Property '{0}' is protected in type '{1}' but public in type '{2}'.\";\n    case 2445: return \"Property '{0}' is protected and only accessible within class '{1}' and its subclasses.\";\n    case 2448: return \"Variable '{0}' used before its declaration.\";\n    case 2451: return \"Cannot redeclare block-scoped variable '{0}'\";\n    case 2453: return \"The type argument for type parameter '{0}' cannot be inferred from the usage. Consider specifying the type arguments explicitly.\";\n    case 2454: return \"Variable '{0}' is used before being assigned.\";\n    case 2456: return \"Type alias '{0}' circularly references itself.\";\n    case 2460: return \"Type '{0}' has no property '{1}'.\";\n    case 2469: return \"The '{0}' operator cannot be applied to type '{1}'.\";\n    case 2474: return \"In 'const' enum declarations member initializer must be constant expression.\";\n    case 2484: return \"Export declaration conflicts with exported declaration of '{0}'.\";\n    case 2506: return \"'{0}' is referenced directly or indirectly in its own base expression.\";\n    case 2511: return \"Cannot create an instance of an abstract class.\";\n    case 2515: return \"Non-abstract class '{0}' does not implement inherited abstract member '{1}' from '{2}'.\";\n    case 2531: return \"Object is possibly 'null'.\";\n    case 2540: return \"Cannot assign to '{0}' because it is a constant or a read-only property.\";\n    case 2541: return \"The target of an assignment must be a variable or a property access.\";\n    case 2542: return \"Index signature in type '{0}' only permits reading.\";\n    case 2554: return \"Expected {0} arguments, but got {1}.\";\n    case 2555: return \"Expected at least {0} arguments, but got {1}.\";\n    case 2558: return \"Expected {0} type arguments, but got {1}.\";\n    case 2564: return \"Property '{0}' has no initializer and is not assigned in the constructor before 'this' is used or returned.\";\n    case 2565: return \"Property '{0}' is used before being assigned.\";\n    case 2610: return \"'{0}' is defined as an accessor in class '{1}', but is overridden here in '{2}' as an instance property.\";\n    case 2611: return \"'{0}' is defined as a property in class '{1}', but is overridden here in '{2}' as an accessor.\";\n    case 2651: return \"A member initializer in a enum declaration cannot reference members declared after it, including members defined in other enums.\";\n    case 2673: return \"Constructor of class '{0}' is private and only accessible within the class declaration.\";\n    case 2674: return \"Constructor of class '{0}' is protected and only accessible within the class declaration.\";\n    case 2675: return \"Cannot extend a class '{0}'. Class constructor is marked as private.\";\n    case 2685: return \"The 'this' types of each signature are incompatible.\";\n    case 2694: return \"Namespace '{0}' has no exported member '{1}'.\";\n    case 2695: return \"Namespace can only have declarations.\";\n    case 2706: return \"Required type parameters may not follow optional type parameters.\";\n    case 2718: return \"Duplicate property '{0}'.\";\n    case 2741: return \"Property '{0}' is missing in type '{1}' but required in type '{2}'.\";\n    case 2757: return \"Type '{0}' has no call signatures.\";\n    case 2808: return \"Get accessor '{0}' must be at least as accessible as the setter.\";\n    case 4117: return \"This member cannot have an 'override' modifier because it is not declared in the base class '{0}'.\";\n    case 6054: return \"File '{0}' not found.\";\n    case 6188: return \"Numeric separators are not allowed here.\";\n    case 6189: return \"Multiple consecutive numeric separators are not permitted.\";\n    case 6234: return \"This expression is not callable because it is a 'get' accessor. Did you mean to use it without '()'?\";\n    case 17009: return \"'super' must be called before accessing 'this' in the constructor of a derived class.\";\n    case 17011: return \"'super' must be called before accessing a property of 'super' in the constructor of a derived class.\";\n    default: return \"\";\n  }\n}\n", "/**\n * @fileoverview Various utility.\n * @license Apache-2.0\n */\n\nexport * from \"./util/binary\";\nexport * from \"./util/collections\";\nexport * from \"./util/math\";\nexport * from \"./util/path\";\nexport * from \"./util/terminal\";\nexport * from \"./util/text\";\nexport * from \"./util/vector\";\n", "/**\n * @fileoverview Various binary reading and writing utility.\n * @license Apache-2.0\n */\n\n/** Reads an 8-bit integer from the specified buffer. */\nexport function readI8(buffer: Uint8Array, offset: i32): i32 {\n  return buffer[offset];\n}\n\n/** Writes an 8-bit integer to the specified buffer. */\nexport function writeI8(value: i32, buffer: Uint8Array, offset: i32): void {\n  buffer[offset] = value;\n}\n\n/** Reads a 16-bit integer from the specified buffer. */\nexport function readI16(buffer: Uint8Array, offset: i32): i32 {\n  return i32(buffer[offset    ])\n       | i32(buffer[offset + 1]) << 8;\n}\n\n/** Writes a 16-bit integer to the specified buffer. */\nexport function writeI16(value: i32, buffer: Uint8Array, offset: i32): void {\n  buffer[offset    ] = value;\n  buffer[offset + 1] = value >>> 8;\n}\n\n/** Reads a 32-bit integer from the specified buffer. */\nexport function readI32(buffer: Uint8Array, offset: i32): i32 {\n  return i32(buffer[offset    ])\n       | i32(buffer[offset + 1]) << 8\n       | i32(buffer[offset + 2]) << 16\n       | i32(buffer[offset + 3]) << 24;\n}\n\n/** Writes a 32-bit integer to the specified buffer. */\nexport function writeI32(value: i32, buffer: Uint8Array, offset: i32): void {\n  buffer[offset    ] = value;\n  buffer[offset + 1] = value >>> 8;\n  buffer[offset + 2] = value >>> 16;\n  buffer[offset + 3] = value >>> 24;\n}\n\n/** Writes a 32-bit integer as a 64-bit integer to the specified buffer. */\nexport function writeI32AsI64(value: i32, buffer: Uint8Array, offset: i32, unsigned: bool = false): void {\n  writeI32(value, buffer, offset);\n  writeI32(unsigned || value >= 0 ? 0 : -1, buffer, offset + 4);\n}\n\n/** Reads a 64-bit integer from the specified buffer. */\nexport function readI64(buffer: Uint8Array, offset: i32): i64 {\n  let lo = readI32(buffer, offset);\n  let hi = readI32(buffer, offset + 4);\n  return i64_new(lo, hi);\n}\n\n/** Writes a 64-bit integer to the specified buffer. */\nexport function writeI64(value: i64, buffer: Uint8Array, offset: i32): void {\n  writeI32(i64_low(value), buffer, offset);\n  writeI32(i64_high(value), buffer, offset + 4);\n}\n\n/** Writes a 64-bit integer as a 32-bit integer to the specified buffer. */\nexport function writeI64AsI32(value: i64, buffer: Uint8Array, offset: i32, unsigned: bool = false): void {\n  assert(unsigned ? i64_is_u32(value) : i64_is_i32(value));\n  writeI32(i64_low(value), buffer, offset);\n}\n\n/** Reads a 32-bit float from the specified buffer. */\nexport function readF32(buffer: Uint8Array, offset: i32): f32 {\n  return i32_as_f32(readI32(buffer, offset));\n}\n\n/** Writes a 32-bit float to the specified buffer. */\nexport function writeF32(value: f32, buffer: Uint8Array, offset: i32): void {\n  writeI32(f32_as_i32(value), buffer, offset);\n}\n\n/** Reads a 64-bit float from the specified buffer. */\nexport function readF64(buffer: Uint8Array, offset: i32): f64 {\n  return i64_as_f64(readI64(buffer, offset));\n}\n\n/** Writes a 64-bit float to the specified buffer. */\nexport function writeF64(value: f64, buffer: Uint8Array, offset: i32): void {\n  let valueI64 = f64_as_i64(value);\n  writeI32(i64_low(valueI64), buffer, offset);\n  writeI32(i64_high(valueI64), buffer, offset + 4);\n}\n\n/** Reads a 128-bit vector from the specified buffer. */\nexport function readV128(buffer: Uint8Array, offset: i32): Uint8Array {\n  return buffer.slice(offset, offset + 16);\n}\n\n/** Writes a 128-bit vector to the specified buffer. */\nexport function writeV128(value: Uint8Array, buffer: Uint8Array, offset: i32): void {\n  assert(value.length == 16);\n  buffer.set(value, offset);\n}\n", "/**\n * @fileoverview Various collections utility.\n * @license Apache-2.0\n */\n\n/** Clone map. Typically used to track contextual type arguments. */\nexport function cloneMap<K,V>(map: Map<K,V> | null): Map<K,V> {\n  if (!ASC_TARGET) { // JS\n    // fast path for js target\n    return new Map<K,V>(map);\n  } else {\n    let out = new Map<K,V>();\n    if (map) {\n      // TODO: for (let [k, v] of map) {\n      for (let _keys = Map_keys(map), i = 0, k = _keys.length; i < k; ++i) {\n        let k = unchecked(_keys[i]);\n        let v = assert(map.get(k));\n        out.set(k, v);\n      }\n    }\n    return out;\n  }\n}\n\n/** Merge two maps in into new one. */\nexport function mergeMaps<K,V>(map1: Map<K,V>, map2: Map<K,V>): Map<K,V> {\n  if (!ASC_TARGET) { // JS\n    let out = new Map<K,V>(map1);\n    map2.forEach((v, k) => out.set(k, v));\n    return out;\n  } else {\n    let out = new Map<K,V>();\n    // TODO: for (let [k, v] of map1) {\n    for (let _keys = Map_keys(map1), i = 0, k = _keys.length; i < k; ++i) {\n      let k = unchecked(_keys[i]);\n      let v = assert(map1.get(k));\n      out.set(k, v);\n    }\n    // TODO: for (let [k, v] of map2) {\n    for (let _keys = Map_keys(map2), i = 0, k = _keys.length; i < k; ++i) {\n      let k = unchecked(_keys[i]);\n      let v = assert(map2.get(k));\n      out.set(k, v);\n    }\n    return out;\n  }\n}\n\n/** BitSet represent growable sequence of N bits. It's faster alternative of Set<i32> when elements\n * are not too much sparsed. Also it's more memory and cache efficient than Array<bool>.\n * The best way to use it for short bit sequences (less than 32*(2**16)).\n */\nexport class BitSet {\n  words!: Uint32Array;\n\n  constructor() {\n    this.clear();\n  }\n\n  get size(): i32 {\n    let count = 0;\n    let words = this.words;\n    for (let i = 0, len = words.length; i < len; i++) {\n      let word = unchecked(words[i]);\n      if (word) count += popcnt(word);\n    }\n    return count;\n  }\n\n  add(index: i32): this {\n    let idx = index >>> 5;\n    let words = this.words;\n    if (idx >= words.length) { // resize\n      this.words = new Uint32Array(idx + 16);\n      this.words.set(words);\n      words = this.words;\n    }\n    unchecked(words[idx] |= 1 << index);\n    return this;\n  }\n\n  delete(index: i32): void {\n    let idx = index >>> 5;\n    let words = this.words;\n    if (idx >= words.length) return;\n    unchecked(words[idx] &= ~(1 << index));\n  }\n\n  has(index: i32): bool {\n    let idx = index >>> 5;\n    let words = this.words;\n    if (idx >= words.length) return false;\n    return (unchecked(words[index >>> 5]) & (1 << index)) !== 0;\n  }\n\n  clear(): void {\n    this.words = new Uint32Array(16);\n  }\n\n  toArray(): i32[] {\n    let res = new Array<i32>(this.size);\n    for (let i = 0, p = 0, len = this.words.length; i < len; ++i) {\n      let word = unchecked(this.words[i]);\n      while (word) {\n        let mask = word & -word;\n        unchecked(res[p++] = (i << 5) + popcnt(mask - 1));\n        word ^= mask;\n      }\n    }\n    return res;\n  }\n\n  toString(): string {\n    return `BitSet { ${this.toArray()} }`;\n  }\n}\n", "/**\n * @fileoverview Various math utility.\n * @license Apache-2.0\n */\n\n/** Tests if `x` is a power of two. */\nexport function isPowerOf2(x: i32): bool {\n  return x != 0 && (x & (x - 1)) == 0;\n}\n\nexport function accuratePow64(x: f64, y: f64): f64 {\n  if (!ASC_TARGET) { // ASC_TARGET == JS\n    // Engines like V8, WebKit and SpiderMonkey uses powi fast path if exponent is integer\n    // This speculative optimization leads to loose precisions like 10 ** -5 != 1e-5 anymore\n    // and introduces inconsistencies between different engines and versions\n    // For avoid this behavior we using bootstrap f64_pow function.\n    return f64_pow(x, y);\n  }\n  return Math.pow(x, y);\n}\n", "/**\n * @fileoverview Various character and text utility.\n * @license Apache-2.0\n */\n\n/** An enum of named character codes. */\nexport const enum CharCode {\n\n  Null = 0,\n  LineFeed = 0x0A,\n  CarriageReturn = 0x0D,\n  LineSeparator = 0x2028,\n  ParagraphSeparator = 0x2029,\n  NextLine = 0x0085,\n\n  Space = 0x20,\n  NonBreakingSpace = 0xA0,\n  EnQuad = 0x2000,\n  EmQuad = 0x2001,\n  EnSpace = 0x2002,\n  EmSpace = 0x2003,\n  ThreePerEmSpace = 0x2004,\n  FourPerEmSpace = 0x2005,\n  SixPerEmSpace = 0x2006,\n  FigureSpace = 0x2007,\n  PunctuationSpace = 0x2008,\n  ThinSpace = 0x2009,\n  HairSpace = 0x200A,\n  ZeroWidthSpace = 0x200B,\n  NarrowNoBreakSpace = 0x202F,\n  IdeographicSpace = 0x3000,\n  MathematicalSpace = 0x205F,\n  Ogham = 0x1680,\n\n  _ = 0x5F,\n\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n\n  a = 0x61,\n  b = 0x62,\n  c = 0x63,\n  d = 0x64,\n  e = 0x65,\n  f = 0x66,\n  g = 0x67,\n  h = 0x68,\n  i = 0x69,\n  j = 0x6A,\n  k = 0x6B,\n  l = 0x6C,\n  m = 0x6D,\n  n = 0x6E,\n  o = 0x6F,\n  p = 0x70,\n  q = 0x71,\n  r = 0x72,\n  s = 0x73,\n  t = 0x74,\n  u = 0x75,\n  v = 0x76,\n  w = 0x77,\n  x = 0x78,\n  y = 0x79,\n  z = 0x7A,\n\n  A = 0x41,\n  B = 0x42,\n  C = 0x43,\n  D = 0x44,\n  E = 0x45,\n  F = 0x46,\n  G = 0x47,\n  H = 0x48,\n  I = 0x49,\n  J = 0x4A,\n  K = 0x4B,\n  L = 0x4C,\n  M = 0x4D,\n  N = 0x4E,\n  O = 0x4F,\n  P = 0x50,\n  Q = 0x51,\n  R = 0x52,\n  S = 0x53,\n  T = 0x54,\n  U = 0x55,\n  V = 0x56,\n  W = 0x57,\n  X = 0x58,\n  Y = 0x59,\n  Z = 0x5a,\n\n  Ampersand = 0x26,\n  Asterisk = 0x2A,\n  At = 0x40,\n  Backslash = 0x5C,\n  Backtick = 0x60,\n  Bar = 0x7C,\n  Caret = 0x5E,\n  CloseBrace = 0x7D,\n  CloseBracket = 0x5D,\n  CloseParen = 0x29,\n  Colon = 0x3A,\n  Comma = 0x2C,\n  Dollar = 0x24,\n  Dot = 0x2E,\n  DoubleQuote = 0x22,\n  Equals = 0x3D,\n  Exclamation = 0x21,\n  GreaterThan = 0x3E,\n  Hash = 0x23,\n  LessThan = 0x3C,\n  Minus = 0x2D,\n  OpenBrace = 0x7B,\n  OpenBracket = 0x5B,\n  OpenParen = 0x28,\n  Percent = 0x25,\n  Plus = 0x2B,\n  Question = 0x3F,\n  Semicolon = 0x3B,\n  SingleQuote = 0x27,\n  Slash = 0x2F,\n  Tilde = 0x7E,\n\n  Backspace = 0x08,\n  FormFeed = 0x0C,\n  ByteOrderMark = 0xFEFF,\n  Tab = 0x09,\n  VerticalTab = 0x0B\n}\n\n/** Tests if the specified character code is some sort of line break. */\nexport function isLineBreak(c: i32): bool {\n  switch (c) {\n    case CharCode.LineFeed:\n    case CharCode.CarriageReturn:\n    case CharCode.LineSeparator:\n    case CharCode.ParagraphSeparator: {\n      return true;\n    }\n    default: {\n      return false;\n    }\n  }\n}\n\n/** Tests if the specified character code is some sort of white space. */\nexport function isWhiteSpace(c: i32): bool {\n  // NOTE: Calling code assumes that there are no supplementary whitespaces.\n  // If Unicode ever adds one, uses of this function must be updated to\n  // conditionally advance by two code units, i.e. using `numCodeUnits`.\n  switch (c) {\n    case CharCode.Space:\n    case CharCode.Tab:\n    case CharCode.VerticalTab:\n    case CharCode.FormFeed:\n    case CharCode.NonBreakingSpace:\n    case CharCode.NextLine:\n    case CharCode.Ogham:\n    case CharCode.NarrowNoBreakSpace:\n    case CharCode.MathematicalSpace:\n    case CharCode.IdeographicSpace:\n    case CharCode.ByteOrderMark: {\n      return true;\n    }\n    default: {\n      return c >= CharCode.EnQuad && c <= CharCode.ZeroWidthSpace;\n    }\n  }\n}\n\n/** First high (lead) surrogate. */\nexport const SURROGATE_HIGH = 0xD800;\n\n/** First low (trail) surrogate. */\nexport const SURROGATE_LOW = 0xDC00;\n\n/** Tests if a code unit or code point is a surrogate. */\nexport function isSurrogate(c: i32): bool {\n  // F800: 11111 0 0000000000 Mask\n  // D800: 11011 X XXXXXXXXXX Any surrogate\n  return (c & 0xF800) == SURROGATE_HIGH;\n}\n\n/** Tests if a surrogate is a high (lead) surrogate. */\nexport function isSurrogateHigh(c: i32): bool {\n  // D800-DBFF\n  return c < SURROGATE_LOW;\n}\n\n/** Tests if a surrogate is a low (trail) surrogate. */\nexport function isSurrogateLow(c: i32): bool {\n  // DC00-DFFF\n  return c >= SURROGATE_LOW;\n}\n\n/** Tests if a code unit or code point is a high (lead) surrogate. */\nexport function isHighSurrogate(c: i32): bool {\n  // FC00: 11111 1 0000000000 Mask\n  // D800: 11011 0 XXXXXXXXXX High/Lead surrogate\n  return (c & 0xFC00) == SURROGATE_HIGH;\n}\n\n/** Tests if a code unit or code point is a low (trail) surrogate. */\nexport function isLowSurrogate(c: i32): bool {\n  // FC00: 11111 1 0000000000 Mask\n  // DC00: 11011 1 XXXXXXXXXX Low/Trail surrogate\n  return (c & 0xFC00) == SURROGATE_LOW;\n}\n\n/** Converts a surrogate pair to its respective code point. */\nexport function combineSurrogates(hi: i32, lo: i32): i32 {\n  return 0x10000 + ((hi & 0x3FF) << 10) | (lo & 0x3FF);\n}\n\n/** Gets the number of UTF-16 code units of the specified code point. */\nexport function numCodeUnits(cp: i32): i32 {\n  return 1 + i32(cp > 0xffff);\n}\n\nexport function isAlpha(c: i32): bool {\n  let c0 = c | 32; // unify uppercases and lowercases a|A - z|Z\n  return c0 >= CharCode.a && c0 <= CharCode.z;\n}\n\n/** Tests if the specified character code is a valid decimal digit. */\nexport function isDecimal(c: i32): bool {\n  return c >= CharCode._0 && c <= CharCode._9;\n}\n\n/** Tests if the specified character code is a valid octal digit. */\nexport function isOctal(c: i32): bool {\n  return c >= CharCode._0 && c <= CharCode._7;\n}\n\n/** Tests if the specified character code is a valid hexadecimal symbol [a-f]. */\nexport function isHexBase(c: i32): bool {\n  let c0 = c | 32; // unify uppercases and lowercases a|A - f|F\n  return c0 >= CharCode.a && c0 <= CharCode.f;\n}\n\n/** Tests if the specified character code is a valid hexadecimal digit. */\nexport function isHexOrDecimal(c: i32): bool {\n  return isDecimal(c) || isHexBase(c);\n}\n\n/** Tests if the specified character code is trivially alphanumeric. */\nexport function isAlphaOrDecimal(c: i32): bool {\n  return isAlpha(c) || isDecimal(c);\n}\n\n/** Tests if the specified code point is a valid start of an identifier. */\nexport function isIdentifierStart(cp: i32): bool {\n  return isAlpha(cp)\n      || cp == CharCode._\n      || cp == CharCode.Dollar\n      || cp >= unicodeIdentifierStartMin && cp <= unicodeIdentifierStartMax\n         && lookupInUnicodeMap(cp, unicodeIdentifierStart);\n}\n\n/** Tests if the specified code point is a valid part of an identifier. */\nexport function isIdentifierPart(cp: i32): bool {\n  return isAlphaOrDecimal(cp)\n      || cp == CharCode._\n      || cp == CharCode.Dollar\n      || cp >= unicodeIdentifierPartMin && cp <= unicodeIdentifierPartMax\n         && lookupInUnicodeMap(cp, unicodeIdentifierPart);\n}\n\n/** Tests if the specified string is a valid identifer. */\nexport function isIdentifier(str: string): bool {\n  let len = str.length;\n  if (!len) return false;\n  let cp = <i32>str.codePointAt(0);\n  if (!isIdentifierStart(cp)) return false;\n  let i = numCodeUnits(cp);\n  while (i < len) {\n    cp = <i32>str.codePointAt(i);\n    if (!isIdentifierPart(cp)) return false;\n    i += numCodeUnits(cp);\n  }\n  return true;\n}\n\n/** Unicode 14.0 ID_Start/Other_ID_Start ranges */\nconst unicodeIdentifierStart: i32[] = [/*\n| from  ...  to | from  ...  to | from  ...  to | from  ...  to |*/\n  170   , 170   , 181   , 181   , 186   , 186   , 192   , 214   ,\n  216   , 246   , 248   , 705   , 710   , 721   , 736   , 740   ,\n  748   , 748   , 750   , 750   , 880   , 884   , 886   , 887   ,\n  890   , 893   , 895   , 895   , 902   , 902   , 904   , 906   ,\n  908   , 908   , 910   , 929   , 931   , 1013  , 1015  , 1153  ,\n  1162  , 1327  , 1329  , 1366  , 1369  , 1369  , 1376  , 1416  ,\n  1488  , 1514  , 1519  , 1522  , 1568  , 1610  , 1646  , 1647  ,\n  1649  , 1747  , 1749  , 1749  , 1765  , 1766  , 1774  , 1775  ,\n  1786  , 1788  , 1791  , 1791  , 1808  , 1808  , 1810  , 1839  ,\n  1869  , 1957  , 1969  , 1969  , 1994  , 2026  , 2036  , 2037  ,\n  2042  , 2042  , 2048  , 2069  , 2074  , 2074  , 2084  , 2084  ,\n  2088  , 2088  , 2112  , 2136  , 2144  , 2154  , 2160  , 2183  ,\n  2185  , 2190  , 2208  , 2249  , 2308  , 2361  , 2365  , 2365  ,\n  2384  , 2384  , 2392  , 2401  , 2417  , 2432  , 2437  , 2444  ,\n  2447  , 2448  , 2451  , 2472  , 2474  , 2480  , 2482  , 2482  ,\n  2486  , 2489  , 2493  , 2493  , 2510  , 2510  , 2524  , 2525  ,\n  2527  , 2529  , 2544  , 2545  , 2556  , 2556  , 2565  , 2570  ,\n  2575  , 2576  , 2579  , 2600  , 2602  , 2608  , 2610  , 2611  ,\n  2613  , 2614  , 2616  , 2617  , 2649  , 2652  , 2654  , 2654  ,\n  2674  , 2676  , 2693  , 2701  , 2703  , 2705  , 2707  , 2728  ,\n  2730  , 2736  , 2738  , 2739  , 2741  , 2745  , 2749  , 2749  ,\n  2768  , 2768  , 2784  , 2785  , 2809  , 2809  , 2821  , 2828  ,\n  2831  , 2832  , 2835  , 2856  , 2858  , 2864  , 2866  , 2867  ,\n  2869  , 2873  , 2877  , 2877  , 2908  , 2909  , 2911  , 2913  ,\n  2929  , 2929  , 2947  , 2947  , 2949  , 2954  , 2958  , 2960  ,\n  2962  , 2965  , 2969  , 2970  , 2972  , 2972  , 2974  , 2975  ,\n  2979  , 2980  , 2984  , 2986  , 2990  , 3001  , 3024  , 3024  ,\n  3077  , 3084  , 3086  , 3088  , 3090  , 3112  , 3114  , 3129  ,\n  3133  , 3133  , 3160  , 3162  , 3165  , 3165  , 3168  , 3169  ,\n  3200  , 3200  , 3205  , 3212  , 3214  , 3216  , 3218  , 3240  ,\n  3242  , 3251  , 3253  , 3257  , 3261  , 3261  , 3293  , 3294  ,\n  3296  , 3297  , 3313  , 3314  , 3332  , 3340  , 3342  , 3344  ,\n  3346  , 3386  , 3389  , 3389  , 3406  , 3406  , 3412  , 3414  ,\n  3423  , 3425  , 3450  , 3455  , 3461  , 3478  , 3482  , 3505  ,\n  3507  , 3515  , 3517  , 3517  , 3520  , 3526  , 3585  , 3632  ,\n  3634  , 3635  , 3648  , 3654  , 3713  , 3714  , 3716  , 3716  ,\n  3718  , 3722  , 3724  , 3747  , 3749  , 3749  , 3751  , 3760  ,\n  3762  , 3763  , 3773  , 3773  , 3776  , 3780  , 3782  , 3782  ,\n  3804  , 3807  , 3840  , 3840  , 3904  , 3911  , 3913  , 3948  ,\n  3976  , 3980  , 4096  , 4138  , 4159  , 4159  , 4176  , 4181  ,\n  4186  , 4189  , 4193  , 4193  , 4197  , 4198  , 4206  , 4208  ,\n  4213  , 4225  , 4238  , 4238  , 4256  , 4293  , 4295  , 4295  ,\n  4301  , 4301  , 4304  , 4346  , 4348  , 4680  , 4682  , 4685  ,\n  4688  , 4694  , 4696  , 4696  , 4698  , 4701  , 4704  , 4744  ,\n  4746  , 4749  , 4752  , 4784  , 4786  , 4789  , 4792  , 4798  ,\n  4800  , 4800  , 4802  , 4805  , 4808  , 4822  , 4824  , 4880  ,\n  4882  , 4885  , 4888  , 4954  , 4992  , 5007  , 5024  , 5109  ,\n  5112  , 5117  , 5121  , 5740  , 5743  , 5759  , 5761  , 5786  ,\n  5792  , 5866  , 5870  , 5880  , 5888  , 5905  , 5919  , 5937  ,\n  5952  , 5969  , 5984  , 5996  , 5998  , 6000  , 6016  , 6067  ,\n  6103  , 6103  , 6108  , 6108  , 6176  , 6264  , 6272  , 6312  ,\n  6314  , 6314  , 6320  , 6389  , 6400  , 6430  , 6480  , 6509  ,\n  6512  , 6516  , 6528  , 6571  , 6576  , 6601  , 6656  , 6678  ,\n  6688  , 6740  , 6823  , 6823  , 6917  , 6963  , 6981  , 6988  ,\n  7043  , 7072  , 7086  , 7087  , 7098  , 7141  , 7168  , 7203  ,\n  7245  , 7247  , 7258  , 7293  , 7296  , 7304  , 7312  , 7354  ,\n  7357  , 7359  , 7401  , 7404  , 7406  , 7411  , 7413  , 7414  ,\n  7418  , 7418  , 7424  , 7615  , 7680  , 7957  , 7960  , 7965  ,\n  7968  , 8005  , 8008  , 8013  , 8016  , 8023  , 8025  , 8025  ,\n  8027  , 8027  , 8029  , 8029  , 8031  , 8061  , 8064  , 8116  ,\n  8118  , 8124  , 8126  , 8126  , 8130  , 8132  , 8134  , 8140  ,\n  8144  , 8147  , 8150  , 8155  , 8160  , 8172  , 8178  , 8180  ,\n  8182  , 8188  , 8305  , 8305  , 8319  , 8319  , 8336  , 8348  ,\n  8450  , 8450  , 8455  , 8455  , 8458  , 8467  , 8469  , 8469  ,\n  8472  , 8477  , 8484  , 8484  , 8486  , 8486  , 8488  , 8488  ,\n  8490  , 8505  , 8508  , 8511  , 8517  , 8521  , 8526  , 8526  ,\n  8544  , 8584  , 11264 , 11492 , 11499 , 11502 , 11506 , 11507 ,\n  11520 , 11557 , 11559 , 11559 , 11565 , 11565 , 11568 , 11623 ,\n  11631 , 11631 , 11648 , 11670 , 11680 , 11686 , 11688 , 11694 ,\n  11696 , 11702 , 11704 , 11710 , 11712 , 11718 , 11720 , 11726 ,\n  11728 , 11734 , 11736 , 11742 , 12293 , 12295 , 12321 , 12329 ,\n  12337 , 12341 , 12344 , 12348 , 12353 , 12438 , 12443 , 12447 ,\n  12449 , 12538 , 12540 , 12543 , 12549 , 12591 , 12593 , 12686 ,\n  12704 , 12735 , 12784 , 12799 , 13312 , 19903 , 19968 , 42124 ,\n  42192 , 42237 , 42240 , 42508 , 42512 , 42527 , 42538 , 42539 ,\n  42560 , 42606 , 42623 , 42653 , 42656 , 42735 , 42775 , 42783 ,\n  42786 , 42888 , 42891 , 42954 , 42960 , 42961 , 42963 , 42963 ,\n  42965 , 42969 , 42994 , 43009 , 43011 , 43013 , 43015 , 43018 ,\n  43020 , 43042 , 43072 , 43123 , 43138 , 43187 , 43250 , 43255 ,\n  43259 , 43259 , 43261 , 43262 , 43274 , 43301 , 43312 , 43334 ,\n  43360 , 43388 , 43396 , 43442 , 43471 , 43471 , 43488 , 43492 ,\n  43494 , 43503 , 43514 , 43518 , 43520 , 43560 , 43584 , 43586 ,\n  43588 , 43595 , 43616 , 43638 , 43642 , 43642 , 43646 , 43695 ,\n  43697 , 43697 , 43701 , 43702 , 43705 , 43709 , 43712 , 43712 ,\n  43714 , 43714 , 43739 , 43741 , 43744 , 43754 , 43762 , 43764 ,\n  43777 , 43782 , 43785 , 43790 , 43793 , 43798 , 43808 , 43814 ,\n  43816 , 43822 , 43824 , 43866 , 43868 , 43881 , 43888 , 44002 ,\n  44032 , 55203 , 55216 , 55238 , 55243 , 55291 , 63744 , 64109 ,\n  64112 , 64217 , 64256 , 64262 , 64275 , 64279 , 64285 , 64285 ,\n  64287 , 64296 , 64298 , 64310 , 64312 , 64316 , 64318 , 64318 ,\n  64320 , 64321 , 64323 , 64324 , 64326 , 64433 , 64467 , 64829 ,\n  64848 , 64911 , 64914 , 64967 , 65008 , 65019 , 65136 , 65140 ,\n  65142 , 65276 , 65313 , 65338 , 65345 , 65370 , 65382 , 65470 ,\n  65474 , 65479 , 65482 , 65487 , 65490 , 65495 , 65498 , 65500 ,\n  65536 , 65547 , 65549 , 65574 , 65576 , 65594 , 65596 , 65597 ,\n  65599 , 65613 , 65616 , 65629 , 65664 , 65786 , 65856 , 65908 ,\n  66176 , 66204 , 66208 , 66256 , 66304 , 66335 , 66349 , 66378 ,\n  66384 , 66421 , 66432 , 66461 , 66464 , 66499 , 66504 , 66511 ,\n  66513 , 66517 , 66560 , 66717 , 66736 , 66771 , 66776 , 66811 ,\n  66816 , 66855 , 66864 , 66915 , 66928 , 66938 , 66940 , 66954 ,\n  66956 , 66962 , 66964 , 66965 , 66967 , 66977 , 66979 , 66993 ,\n  66995 , 67001 , 67003 , 67004 , 67072 , 67382 , 67392 , 67413 ,\n  67424 , 67431 , 67456 , 67461 , 67463 , 67504 , 67506 , 67514 ,\n  67584 , 67589 , 67592 , 67592 , 67594 , 67637 , 67639 , 67640 ,\n  67644 , 67644 , 67647 , 67669 , 67680 , 67702 , 67712 , 67742 ,\n  67808 , 67826 , 67828 , 67829 , 67840 , 67861 , 67872 , 67897 ,\n  67968 , 68023 , 68030 , 68031 , 68096 , 68096 , 68112 , 68115 ,\n  68117 , 68119 , 68121 , 68149 , 68192 , 68220 , 68224 , 68252 ,\n  68288 , 68295 , 68297 , 68324 , 68352 , 68405 , 68416 , 68437 ,\n  68448 , 68466 , 68480 , 68497 , 68608 , 68680 , 68736 , 68786 ,\n  68800 , 68850 , 68864 , 68899 , 69248 , 69289 , 69296 , 69297 ,\n  69376 , 69404 , 69415 , 69415 , 69424 , 69445 , 69488 , 69505 ,\n  69552 , 69572 , 69600 , 69622 , 69635 , 69687 , 69745 , 69746 ,\n  69749 , 69749 , 69763 , 69807 , 69840 , 69864 , 69891 , 69926 ,\n  69956 , 69956 , 69959 , 69959 , 69968 , 70002 , 70006 , 70006 ,\n  70019 , 70066 , 70081 , 70084 , 70106 , 70106 , 70108 , 70108 ,\n  70144 , 70161 , 70163 , 70187 , 70272 , 70278 , 70280 , 70280 ,\n  70282 , 70285 , 70287 , 70301 , 70303 , 70312 , 70320 , 70366 ,\n  70405 , 70412 , 70415 , 70416 , 70419 , 70440 , 70442 , 70448 ,\n  70450 , 70451 , 70453 , 70457 , 70461 , 70461 , 70480 , 70480 ,\n  70493 , 70497 , 70656 , 70708 , 70727 , 70730 , 70751 , 70753 ,\n  70784 , 70831 , 70852 , 70853 , 70855 , 70855 , 71040 , 71086 ,\n  71128 , 71131 , 71168 , 71215 , 71236 , 71236 , 71296 , 71338 ,\n  71352 , 71352 , 71424 , 71450 , 71488 , 71494 , 71680 , 71723 ,\n  71840 , 71903 , 71935 , 71942 , 71945 , 71945 , 71948 , 71955 ,\n  71957 , 71958 , 71960 , 71983 , 71999 , 71999 , 72001 , 72001 ,\n  72096 , 72103 , 72106 , 72144 , 72161 , 72161 , 72163 , 72163 ,\n  72192 , 72192 , 72203 , 72242 , 72250 , 72250 , 72272 , 72272 ,\n  72284 , 72329 , 72349 , 72349 , 72368 , 72440 , 72704 , 72712 ,\n  72714 , 72750 , 72768 , 72768 , 72818 , 72847 , 72960 , 72966 ,\n  72968 , 72969 , 72971 , 73008 , 73030 , 73030 , 73056 , 73061 ,\n  73063 , 73064 , 73066 , 73097 , 73112 , 73112 , 73440 , 73458 ,\n  73648 , 73648 , 73728 , 74649 , 74752 , 74862 , 74880 , 75075 ,\n  77712 , 77808 , 77824 , 78894 , 82944 , 83526 , 92160 , 92728 ,\n  92736 , 92766 , 92784 , 92862 , 92880 , 92909 , 92928 , 92975 ,\n  92992 , 92995 , 93027 , 93047 , 93053 , 93071 , 93760 , 93823 ,\n  93952 , 94026 , 94032 , 94032 , 94099 , 94111 , 94176 , 94177 ,\n  94179 , 94179 , 94208 , 100343, 100352, 101589, 101632, 101640,\n  110576, 110579, 110581, 110587, 110589, 110590, 110592, 110882,\n  110928, 110930, 110948, 110951, 110960, 111355, 113664, 113770,\n  113776, 113788, 113792, 113800, 113808, 113817, 119808, 119892,\n  119894, 119964, 119966, 119967, 119970, 119970, 119973, 119974,\n  119977, 119980, 119982, 119993, 119995, 119995, 119997, 120003,\n  120005, 120069, 120071, 120074, 120077, 120084, 120086, 120092,\n  120094, 120121, 120123, 120126, 120128, 120132, 120134, 120134,\n  120138, 120144, 120146, 120485, 120488, 120512, 120514, 120538,\n  120540, 120570, 120572, 120596, 120598, 120628, 120630, 120654,\n  120656, 120686, 120688, 120712, 120714, 120744, 120746, 120770,\n  120772, 120779, 122624, 122654, 123136, 123180, 123191, 123197,\n  123214, 123214, 123536, 123565, 123584, 123627, 124896, 124902,\n  124904, 124907, 124909, 124910, 124912, 124926, 124928, 125124,\n  125184, 125251, 125259, 125259, 126464, 126467, 126469, 126495,\n  126497, 126498, 126500, 126500, 126503, 126503, 126505, 126514,\n  126516, 126519, 126521, 126521, 126523, 126523, 126530, 126530,\n  126535, 126535, 126537, 126537, 126539, 126539, 126541, 126543,\n  126545, 126546, 126548, 126548, 126551, 126551, 126553, 126553,\n  126555, 126555, 126557, 126557, 126559, 126559, 126561, 126562,\n  126564, 126564, 126567, 126570, 126572, 126578, 126580, 126583,\n  126585, 126588, 126590, 126590, 126592, 126601, 126603, 126619,\n  126625, 126627, 126629, 126633, 126635, 126651, 131072, 173791,\n  173824, 177976, 177984, 178205, 178208, 183969, 183984, 191456,\n  194560, 195101, 196608, 201546,\n];\nconst unicodeIdentifierStartMin = 170;\nconst unicodeIdentifierStartMax = 201546;\n\n/** Unicode 14.0 ID_Continue/Other_ID_Continue + ID_Start/Other_ID_Start ranges*/\nconst unicodeIdentifierPart: i32[] = [/*\n| from  ...  to | from  ...  to | from  ...  to | from  ...  to |*/\n  170   , 170   , 181   , 181   , 183   , 183   , 186   , 186   ,\n  192   , 214   , 216   , 246   , 248   , 705   , 710   , 721   ,\n  736   , 740   , 748   , 748   , 750   , 750   , 768   , 884   ,\n  886   , 887   , 890   , 893   , 895   , 895   , 902   , 906   ,\n  908   , 908   , 910   , 929   , 931   , 1013  , 1015  , 1153  ,\n  1155  , 1159  , 1162  , 1327  , 1329  , 1366  , 1369  , 1369  ,\n  1376  , 1416  , 1425  , 1469  , 1471  , 1471  , 1473  , 1474  ,\n  1476  , 1477  , 1479  , 1479  , 1488  , 1514  , 1519  , 1522  ,\n  1552  , 1562  , 1568  , 1641  , 1646  , 1747  , 1749  , 1756  ,\n  1759  , 1768  , 1770  , 1788  , 1791  , 1791  , 1808  , 1866  ,\n  1869  , 1969  , 1984  , 2037  , 2042  , 2042  , 2045  , 2045  ,\n  2048  , 2093  , 2112  , 2139  , 2144  , 2154  , 2160  , 2183  ,\n  2185  , 2190  , 2200  , 2273  , 2275  , 2403  , 2406  , 2415  ,\n  2417  , 2435  , 2437  , 2444  , 2447  , 2448  , 2451  , 2472  ,\n  2474  , 2480  , 2482  , 2482  , 2486  , 2489  , 2492  , 2500  ,\n  2503  , 2504  , 2507  , 2510  , 2519  , 2519  , 2524  , 2525  ,\n  2527  , 2531  , 2534  , 2545  , 2556  , 2556  , 2558  , 2558  ,\n  2561  , 2563  , 2565  , 2570  , 2575  , 2576  , 2579  , 2600  ,\n  2602  , 2608  , 2610  , 2611  , 2613  , 2614  , 2616  , 2617  ,\n  2620  , 2620  , 2622  , 2626  , 2631  , 2632  , 2635  , 2637  ,\n  2641  , 2641  , 2649  , 2652  , 2654  , 2654  , 2662  , 2677  ,\n  2689  , 2691  , 2693  , 2701  , 2703  , 2705  , 2707  , 2728  ,\n  2730  , 2736  , 2738  , 2739  , 2741  , 2745  , 2748  , 2757  ,\n  2759  , 2761  , 2763  , 2765  , 2768  , 2768  , 2784  , 2787  ,\n  2790  , 2799  , 2809  , 2815  , 2817  , 2819  , 2821  , 2828  ,\n  2831  , 2832  , 2835  , 2856  , 2858  , 2864  , 2866  , 2867  ,\n  2869  , 2873  , 2876  , 2884  , 2887  , 2888  , 2891  , 2893  ,\n  2901  , 2903  , 2908  , 2909  , 2911  , 2915  , 2918  , 2927  ,\n  2929  , 2929  , 2946  , 2947  , 2949  , 2954  , 2958  , 2960  ,\n  2962  , 2965  , 2969  , 2970  , 2972  , 2972  , 2974  , 2975  ,\n  2979  , 2980  , 2984  , 2986  , 2990  , 3001  , 3006  , 3010  ,\n  3014  , 3016  , 3018  , 3021  , 3024  , 3024  , 3031  , 3031  ,\n  3046  , 3055  , 3072  , 3084  , 3086  , 3088  , 3090  , 3112  ,\n  3114  , 3129  , 3132  , 3140  , 3142  , 3144  , 3146  , 3149  ,\n  3157  , 3158  , 3160  , 3162  , 3165  , 3165  , 3168  , 3171  ,\n  3174  , 3183  , 3200  , 3203  , 3205  , 3212  , 3214  , 3216  ,\n  3218  , 3240  , 3242  , 3251  , 3253  , 3257  , 3260  , 3268  ,\n  3270  , 3272  , 3274  , 3277  , 3285  , 3286  , 3293  , 3294  ,\n  3296  , 3299  , 3302  , 3311  , 3313  , 3314  , 3328  , 3340  ,\n  3342  , 3344  , 3346  , 3396  , 3398  , 3400  , 3402  , 3406  ,\n  3412  , 3415  , 3423  , 3427  , 3430  , 3439  , 3450  , 3455  ,\n  3457  , 3459  , 3461  , 3478  , 3482  , 3505  , 3507  , 3515  ,\n  3517  , 3517  , 3520  , 3526  , 3530  , 3530  , 3535  , 3540  ,\n  3542  , 3542  , 3544  , 3551  , 3558  , 3567  , 3570  , 3571  ,\n  3585  , 3642  , 3648  , 3662  , 3664  , 3673  , 3713  , 3714  ,\n  3716  , 3716  , 3718  , 3722  , 3724  , 3747  , 3749  , 3749  ,\n  3751  , 3773  , 3776  , 3780  , 3782  , 3782  , 3784  , 3789  ,\n  3792  , 3801  , 3804  , 3807  , 3840  , 3840  , 3864  , 3865  ,\n  3872  , 3881  , 3893  , 3893  , 3895  , 3895  , 3897  , 3897  ,\n  3902  , 3911  , 3913  , 3948  , 3953  , 3972  , 3974  , 3991  ,\n  3993  , 4028  , 4038  , 4038  , 4096  , 4169  , 4176  , 4253  ,\n  4256  , 4293  , 4295  , 4295  , 4301  , 4301  , 4304  , 4346  ,\n  4348  , 4680  , 4682  , 4685  , 4688  , 4694  , 4696  , 4696  ,\n  4698  , 4701  , 4704  , 4744  , 4746  , 4749  , 4752  , 4784  ,\n  4786  , 4789  , 4792  , 4798  , 4800  , 4800  , 4802  , 4805  ,\n  4808  , 4822  , 4824  , 4880  , 4882  , 4885  , 4888  , 4954  ,\n  4957  , 4959  , 4969  , 4977  , 4992  , 5007  , 5024  , 5109  ,\n  5112  , 5117  , 5121  , 5740  , 5743  , 5759  , 5761  , 5786  ,\n  5792  , 5866  , 5870  , 5880  , 5888  , 5909  , 5919  , 5940  ,\n  5952  , 5971  , 5984  , 5996  , 5998  , 6000  , 6002  , 6003  ,\n  6016  , 6099  , 6103  , 6103  , 6108  , 6109  , 6112  , 6121  ,\n  6155  , 6157  , 6159  , 6169  , 6176  , 6264  , 6272  , 6314  ,\n  6320  , 6389  , 6400  , 6430  , 6432  , 6443  , 6448  , 6459  ,\n  6470  , 6509  , 6512  , 6516  , 6528  , 6571  , 6576  , 6601  ,\n  6608  , 6618  , 6656  , 6683  , 6688  , 6750  , 6752  , 6780  ,\n  6783  , 6793  , 6800  , 6809  , 6823  , 6823  , 6832  , 6845  ,\n  6847  , 6862  , 6912  , 6988  , 6992  , 7001  , 7019  , 7027  ,\n  7040  , 7155  , 7168  , 7223  , 7232  , 7241  , 7245  , 7293  ,\n  7296  , 7304  , 7312  , 7354  , 7357  , 7359  , 7376  , 7378  ,\n  7380  , 7418  , 7424  , 7957  , 7960  , 7965  , 7968  , 8005  ,\n  8008  , 8013  , 8016  , 8023  , 8025  , 8025  , 8027  , 8027  ,\n  8029  , 8029  , 8031  , 8061  , 8064  , 8116  , 8118  , 8124  ,\n  8126  , 8126  , 8130  , 8132  , 8134  , 8140  , 8144  , 8147  ,\n  8150  , 8155  , 8160  , 8172  , 8178  , 8180  , 8182  , 8188  ,\n  8255  , 8256  , 8276  , 8276  , 8305  , 8305  , 8319  , 8319  ,\n  8336  , 8348  , 8400  , 8412  , 8417  , 8417  , 8421  , 8432  ,\n  8450  , 8450  , 8455  , 8455  , 8458  , 8467  , 8469  , 8469  ,\n  8472  , 8477  , 8484  , 8484  , 8486  , 8486  , 8488  , 8488  ,\n  8490  , 8505  , 8508  , 8511  , 8517  , 8521  , 8526  , 8526  ,\n  8544  , 8584  , 11264 , 11492 , 11499 , 11507 , 11520 , 11557 ,\n  11559 , 11559 , 11565 , 11565 , 11568 , 11623 , 11631 , 11631 ,\n  11647 , 11670 , 11680 , 11686 , 11688 , 11694 , 11696 , 11702 ,\n  11704 , 11710 , 11712 , 11718 , 11720 , 11726 , 11728 , 11734 ,\n  11736 , 11742 , 11744 , 11775 , 12293 , 12295 , 12321 , 12335 ,\n  12337 , 12341 , 12344 , 12348 , 12353 , 12438 , 12441 , 12447 ,\n  12449 , 12538 , 12540 , 12543 , 12549 , 12591 , 12593 , 12686 ,\n  12704 , 12735 , 12784 , 12799 , 13312 , 19903 , 19968 , 42124 ,\n  42192 , 42237 , 42240 , 42508 , 42512 , 42539 , 42560 , 42607 ,\n  42612 , 42621 , 42623 , 42737 , 42775 , 42783 , 42786 , 42888 ,\n  42891 , 42954 , 42960 , 42961 , 42963 , 42963 , 42965 , 42969 ,\n  42994 , 43047 , 43052 , 43052 , 43072 , 43123 , 43136 , 43205 ,\n  43216 , 43225 , 43232 , 43255 , 43259 , 43259 , 43261 , 43309 ,\n  43312 , 43347 , 43360 , 43388 , 43392 , 43456 , 43471 , 43481 ,\n  43488 , 43518 , 43520 , 43574 , 43584 , 43597 , 43600 , 43609 ,\n  43616 , 43638 , 43642 , 43714 , 43739 , 43741 , 43744 , 43759 ,\n  43762 , 43766 , 43777 , 43782 , 43785 , 43790 , 43793 , 43798 ,\n  43808 , 43814 , 43816 , 43822 , 43824 , 43866 , 43868 , 43881 ,\n  43888 , 44010 , 44012 , 44013 , 44016 , 44025 , 44032 , 55203 ,\n  55216 , 55238 , 55243 , 55291 , 63744 , 64109 , 64112 , 64217 ,\n  64256 , 64262 , 64275 , 64279 , 64285 , 64296 , 64298 , 64310 ,\n  64312 , 64316 , 64318 , 64318 , 64320 , 64321 , 64323 , 64324 ,\n  64326 , 64433 , 64467 , 64829 , 64848 , 64911 , 64914 , 64967 ,\n  65008 , 65019 , 65024 , 65039 , 65056 , 65071 , 65075 , 65076 ,\n  65101 , 65103 , 65136 , 65140 , 65142 , 65276 , 65296 , 65305 ,\n  65313 , 65338 , 65343 , 65343 , 65345 , 65370 , 65382 , 65470 ,\n  65474 , 65479 , 65482 , 65487 , 65490 , 65495 , 65498 , 65500 ,\n  65536 , 65547 , 65549 , 65574 , 65576 , 65594 , 65596 , 65597 ,\n  65599 , 65613 , 65616 , 65629 , 65664 , 65786 , 65856 , 65908 ,\n  66045 , 66045 , 66176 , 66204 , 66208 , 66256 , 66272 , 66272 ,\n  66304 , 66335 , 66349 , 66378 , 66384 , 66426 , 66432 , 66461 ,\n  66464 , 66499 , 66504 , 66511 , 66513 , 66517 , 66560 , 66717 ,\n  66720 , 66729 , 66736 , 66771 , 66776 , 66811 , 66816 , 66855 ,\n  66864 , 66915 , 66928 , 66938 , 66940 , 66954 , 66956 , 66962 ,\n  66964 , 66965 , 66967 , 66977 , 66979 , 66993 , 66995 , 67001 ,\n  67003 , 67004 , 67072 , 67382 , 67392 , 67413 , 67424 , 67431 ,\n  67456 , 67461 , 67463 , 67504 , 67506 , 67514 , 67584 , 67589 ,\n  67592 , 67592 , 67594 , 67637 , 67639 , 67640 , 67644 , 67644 ,\n  67647 , 67669 , 67680 , 67702 , 67712 , 67742 , 67808 , 67826 ,\n  67828 , 67829 , 67840 , 67861 , 67872 , 67897 , 67968 , 68023 ,\n  68030 , 68031 , 68096 , 68099 , 68101 , 68102 , 68108 , 68115 ,\n  68117 , 68119 , 68121 , 68149 , 68152 , 68154 , 68159 , 68159 ,\n  68192 , 68220 , 68224 , 68252 , 68288 , 68295 , 68297 , 68326 ,\n  68352 , 68405 , 68416 , 68437 , 68448 , 68466 , 68480 , 68497 ,\n  68608 , 68680 , 68736 , 68786 , 68800 , 68850 , 68864 , 68903 ,\n  68912 , 68921 , 69248 , 69289 , 69291 , 69292 , 69296 , 69297 ,\n  69376 , 69404 , 69415 , 69415 , 69424 , 69456 , 69488 , 69509 ,\n  69552 , 69572 , 69600 , 69622 , 69632 , 69702 , 69734 , 69749 ,\n  69759 , 69818 , 69826 , 69826 , 69840 , 69864 , 69872 , 69881 ,\n  69888 , 69940 , 69942 , 69951 , 69956 , 69959 , 69968 , 70003 ,\n  70006 , 70006 , 70016 , 70084 , 70089 , 70092 , 70094 , 70106 ,\n  70108 , 70108 , 70144 , 70161 , 70163 , 70199 , 70206 , 70206 ,\n  70272 , 70278 , 70280 , 70280 , 70282 , 70285 , 70287 , 70301 ,\n  70303 , 70312 , 70320 , 70378 , 70384 , 70393 , 70400 , 70403 ,\n  70405 , 70412 , 70415 , 70416 , 70419 , 70440 , 70442 , 70448 ,\n  70450 , 70451 , 70453 , 70457 , 70459 , 70468 , 70471 , 70472 ,\n  70475 , 70477 , 70480 , 70480 , 70487 , 70487 , 70493 , 70499 ,\n  70502 , 70508 , 70512 , 70516 , 70656 , 70730 , 70736 , 70745 ,\n  70750 , 70753 , 70784 , 70853 , 70855 , 70855 , 70864 , 70873 ,\n  71040 , 71093 , 71096 , 71104 , 71128 , 71133 , 71168 , 71232 ,\n  71236 , 71236 , 71248 , 71257 , 71296 , 71352 , 71360 , 71369 ,\n  71424 , 71450 , 71453 , 71467 , 71472 , 71481 , 71488 , 71494 ,\n  71680 , 71738 , 71840 , 71913 , 71935 , 71942 , 71945 , 71945 ,\n  71948 , 71955 , 71957 , 71958 , 71960 , 71989 , 71991 , 71992 ,\n  71995 , 72003 , 72016 , 72025 , 72096 , 72103 , 72106 , 72151 ,\n  72154 , 72161 , 72163 , 72164 , 72192 , 72254 , 72263 , 72263 ,\n  72272 , 72345 , 72349 , 72349 , 72368 , 72440 , 72704 , 72712 ,\n  72714 , 72758 , 72760 , 72768 , 72784 , 72793 , 72818 , 72847 ,\n  72850 , 72871 , 72873 , 72886 , 72960 , 72966 , 72968 , 72969 ,\n  72971 , 73014 , 73018 , 73018 , 73020 , 73021 , 73023 , 73031 ,\n  73040 , 73049 , 73056 , 73061 , 73063 , 73064 , 73066 , 73102 ,\n  73104 , 73105 , 73107 , 73112 , 73120 , 73129 , 73440 , 73462 ,\n  73648 , 73648 , 73728 , 74649 , 74752 , 74862 , 74880 , 75075 ,\n  77712 , 77808 , 77824 , 78894 , 82944 , 83526 , 92160 , 92728 ,\n  92736 , 92766 , 92768 , 92777 , 92784 , 92862 , 92864 , 92873 ,\n  92880 , 92909 , 92912 , 92916 , 92928 , 92982 , 92992 , 92995 ,\n  93008 , 93017 , 93027 , 93047 , 93053 , 93071 , 93760 , 93823 ,\n  93952 , 94026 , 94031 , 94087 , 94095 , 94111 , 94176 , 94177 ,\n  94179 , 94180 , 94192 , 94193 , 94208 , 100343, 100352, 101589,\n  101632, 101640, 110576, 110579, 110581, 110587, 110589, 110590,\n  110592, 110882, 110928, 110930, 110948, 110951, 110960, 111355,\n  113664, 113770, 113776, 113788, 113792, 113800, 113808, 113817,\n  113821, 113822, 118528, 118573, 118576, 118598, 119141, 119145,\n  119149, 119154, 119163, 119170, 119173, 119179, 119210, 119213,\n  119362, 119364, 119808, 119892, 119894, 119964, 119966, 119967,\n  119970, 119970, 119973, 119974, 119977, 119980, 119982, 119993,\n  119995, 119995, 119997, 120003, 120005, 120069, 120071, 120074,\n  120077, 120084, 120086, 120092, 120094, 120121, 120123, 120126,\n  120128, 120132, 120134, 120134, 120138, 120144, 120146, 120485,\n  120488, 120512, 120514, 120538, 120540, 120570, 120572, 120596,\n  120598, 120628, 120630, 120654, 120656, 120686, 120688, 120712,\n  120714, 120744, 120746, 120770, 120772, 120779, 120782, 120831,\n  121344, 121398, 121403, 121452, 121461, 121461, 121476, 121476,\n  121499, 121503, 121505, 121519, 122624, 122654, 122880, 122886,\n  122888, 122904, 122907, 122913, 122915, 122916, 122918, 122922,\n  123136, 123180, 123184, 123197, 123200, 123209, 123214, 123214,\n  123536, 123566, 123584, 123641, 124896, 124902, 124904, 124907,\n  124909, 124910, 124912, 124926, 124928, 125124, 125136, 125142,\n  125184, 125259, 125264, 125273, 126464, 126467, 126469, 126495,\n  126497, 126498, 126500, 126500, 126503, 126503, 126505, 126514,\n  126516, 126519, 126521, 126521, 126523, 126523, 126530, 126530,\n  126535, 126535, 126537, 126537, 126539, 126539, 126541, 126543,\n  126545, 126546, 126548, 126548, 126551, 126551, 126553, 126553,\n  126555, 126555, 126557, 126557, 126559, 126559, 126561, 126562,\n  126564, 126564, 126567, 126570, 126572, 126578, 126580, 126583,\n  126585, 126588, 126590, 126590, 126592, 126601, 126603, 126619,\n  126625, 126627, 126629, 126633, 126635, 126651, 130032, 130041,\n  131072, 173791, 173824, 177976, 177984, 178205, 178208, 183969,\n  183984, 191456, 194560, 195101, 196608, 201546, 917760, 917999,\n];\nconst unicodeIdentifierPartMin = 170;\nconst unicodeIdentifierPartMax = 917999;\n\nfunction lookupInUnicodeMap(code: i32, map: i32[]): bool {\n  let lo = 0;\n  let hi = map.length;\n  while (lo + 1 < hi) {\n    let mid = lo + ((hi - lo) >>> 1);\n    mid -= (mid & 1);\n    let midVal = map[mid];\n    if (midVal <= code && code <= map[mid + 1]) {\n      return true;\n    }\n    if (code < midVal) {\n      hi = mid;\n    } else {\n      lo = mid + 2;\n    }\n  }\n  return false;\n}\n\n/** Creates an indentation matching the number of specified levels. */\nconst indentX1 = \"  \";\nconst indentX2 = \"    \";\nconst indentX3 = \"      \";\nconst indentX4 = \"        \";\nconst indentCache = new Map<i32,string>();\n\nexport function indent(sb: string[], level: i32): void {\n  if (level <= 4) {\n    switch (level) {\n      case 1: sb.push(indentX1); break;\n      case 2: sb.push(indentX2); break;\n      case 3: sb.push(indentX3); break;\n      case 4: sb.push(indentX4); break;\n    }\n  } else {\n    let indents: string;\n    // Limit number of indent entries to 1024 for avoiding unnecessary\n    // memory consumetion\n    if (indentCache.size <= 1024) {\n      if (indentCache.has(level)) {\n        indents = assert(indentCache.get(level));\n      } else {\n        indentCache.set(level, (indents = indentX1.repeat(level)));\n      }\n    } else {\n      indents = indentX1.repeat(level);\n    }\n    sb.push(indents);\n  }\n}\n\n/** Escapes a string using the specified kind of quote. */\nexport function escapeString(str: string, quote: CharCode): string {\n  let sb = new Array<string>();\n  let off = 0;\n  let i = 0;\n  for (let k = str.length; i < k;) {\n    switch (str.charCodeAt(i)) {\n      case CharCode.Null: {\n        if (i > off) sb.push(str.substring(off, off = i + 1));\n        sb.push(\"\\\\0\");\n        off = ++i;\n        break;\n      }\n      case CharCode.Backspace: {\n        if (i > off) sb.push(str.substring(off, i));\n        off = ++i;\n        sb.push(\"\\\\b\");\n        break;\n      }\n      case CharCode.Tab: {\n        if (i > off) sb.push(str.substring(off, i));\n        off = ++i;\n        sb.push(\"\\\\t\");\n        break;\n      }\n      case CharCode.LineFeed: {\n        if (i > off) sb.push(str.substring(off, i));\n        off = ++i;\n        sb.push(\"\\\\n\");\n        break;\n      }\n      case CharCode.VerticalTab: {\n        if (i > off) sb.push(str.substring(off, i));\n        off = ++i;\n        sb.push(\"\\\\v\");\n        break;\n      }\n      case CharCode.FormFeed: {\n        if (i > off) sb.push(str.substring(off, i));\n        off = ++i;\n        sb.push(\"\\\\f\");\n        break;\n      }\n      case CharCode.CarriageReturn: {\n        if (i > off) sb.push(str.substring(off, i));\n        sb.push(\"\\\\r\");\n        off = ++i;\n        break;\n      }\n      case CharCode.DoubleQuote: {\n        if (quote == CharCode.DoubleQuote) {\n          if (i > off) sb.push(str.substring(off, i));\n          sb.push(\"\\\\\\\"\");\n          off = ++i;\n        } else {\n          ++i;\n        }\n        break;\n      }\n      case CharCode.SingleQuote: {\n        if (quote == CharCode.SingleQuote) {\n          if (i > off) sb.push(str.substring(off, i));\n          sb.push(\"\\\\'\");\n          off = ++i;\n        } else {\n          ++i;\n        }\n        break;\n      }\n      case CharCode.Backslash: {\n        if (i > off) sb.push(str.substring(off, i));\n        sb.push(\"\\\\\\\\\");\n        off = ++i;\n        break;\n      }\n      case CharCode.Backtick: {\n        if (quote == CharCode.Backtick) {\n          if (i > off) sb.push(str.substring(off, i));\n          sb.push(\"\\\\`\");\n          off = ++i;\n        } else {\n          ++i;\n        }\n        break;\n      }\n      default: {\n        ++i;\n        break;\n      }\n    }\n  }\n  if (i > off) sb.push(str.substring(off, i));\n  return sb.join(\"\");\n}\n", "/**\n * @fileoverview Various file path utility.\n * @license Apache-2.0\n */\n\nimport {\n  CharCode\n} from \"./text\";\n\nimport {\n  PATH_DELIMITER\n} from \"../common\";\n\nconst separator = CharCode.Slash;\n\n/**\n * Normalizes the specified path, removing interior placeholders.\n * Expects a posix-compatible relative path (not Windows compatible).\n */\nexport function normalizePath(path: string): string {\n  let pos = 0;\n  let len = path.length;\n\n  // trim leading './'\n  while (pos + 1 < len &&\n    path.charCodeAt(pos) == CharCode.Dot &&\n    path.charCodeAt(pos + 1) == separator\n  ) {\n    pos += 2;\n  }\n\n  if (pos > 0 || len < path.length) {\n    path = path.substring(pos, len);\n    len -= pos;\n    pos = 0;\n  }\n\n  let atEnd: bool;\n  while (pos + 1 < len) {\n    atEnd = false;\n\n    // we are only interested in '/.' sequences ...\n    if (\n      path.charCodeAt(pos) == separator &&\n      path.charCodeAt(pos + 1) == CharCode.Dot\n    ) {\n      // '/.' ( '/' | $ )\n      atEnd = pos + 2 == len;\n      if (atEnd ||\n        pos + 2 < len &&\n        path.charCodeAt(pos + 2) == separator\n      ) {\n        path = atEnd\n          ? path.substring(0, pos)\n          : path.substring(0, pos) + path.substring(pos + 2);\n        len -= 2;\n        continue;\n      }\n\n      // '/.' ( './' | '.' $ )\n      atEnd = pos + 3 == len;\n      if (atEnd && path.charCodeAt(pos + 2) == CharCode.Dot ||\n        pos + 3 < len &&\n        path.charCodeAt(pos + 2) == CharCode.Dot &&\n        path.charCodeAt(pos + 3) == separator\n      ) {\n        // find preceeding '/'\n        let ipos = pos;\n        while (--ipos >= 0) {\n          if (path.charCodeAt(ipos) == separator) {\n            if (pos - ipos != 3 ||\n              path.charCodeAt(ipos + 1) != CharCode.Dot ||\n              path.charCodeAt(ipos + 2) != CharCode.Dot\n            ) { // exclude '..' itself\n              path = atEnd\n                ? path.substring(0, ipos)\n                : path.substring(0, ipos) + path.substring(pos + 3);\n              len -= pos + 3 - ipos;\n              pos = ipos - 1; // incremented again at end of loop\n            }\n            break;\n          }\n        }\n\n        // if there's no preceeding '/', trim start if non-empty\n        if (ipos < 0 && pos > 0) {\n          if (pos != 2 ||\n            path.charCodeAt(0) != CharCode.Dot ||\n            path.charCodeAt(1) != CharCode.Dot\n          ) { // exclude '..' itself\n            path = path.substring(pos + 4);\n            len = path.length;\n            continue;\n          }\n        }\n      }\n    }\n    pos++;\n  }\n  return len > 0 ? path : \".\";\n}\n\n/** Resolves the specified path relative to the specified origin. */\nexport function resolvePath(normalizedPath: string, origin: string): string {\n  if (normalizedPath.startsWith(\"std/\")) {\n    return normalizedPath;\n  }\n  return normalizePath(\n    dirname(origin) + PATH_DELIMITER + normalizedPath\n  );\n}\n\n/** Obtains the directory portion of a normalized path. */\nexport function dirname(normalizedPath: string): string {\n  let pos = normalizedPath.length;\n  if (pos <= 1) {\n    if (pos == 0) return \".\";\n    if (normalizedPath.charCodeAt(0) == separator) {\n      return normalizedPath;\n    }\n  }\n  while (--pos > 0) {\n    if (normalizedPath.charCodeAt(pos) == separator) {\n      return normalizedPath.substring(0, pos);\n    }\n  }\n  return \".\";\n}\n", "/**\n * @fileoverview Terminal utility.\n * @license Apache-2.0\n */\n\n/** Gray terminal color code. */\nexport const COLOR_GRAY = \"\\u001b[90m\";\n/** Red terminal color code. */\nexport const COLOR_RED = \"\\u001b[91m\";\n/** Green terminal color code. */\nexport const COLOR_GREEN = \"\\u001b[92m\";\n/** Yellow terminal color code. */\nexport const COLOR_YELLOW = \"\\u001b[93m\";\n/** Blue terminal color code. */\nexport const COLOR_BLUE = \"\\u001b[94m\";\n/** Magenta terminal color code. */\nexport const COLOR_MAGENTA = \"\\u001b[95m\";\n/** Cyan terminal color code. */\nexport const COLOR_CYAN = \"\\u001b[96m\";\n/** White terminal color code. */\nexport const COLOR_WHITE = \"\\u001b[97m\";\n/** Terminal color reset code. */\nexport const COLOR_RESET = \"\\u001b[0m\";\n\n/** Whether terminal colors are enabled or not. */\nlet colorsEnabled = true;\n\n/** Checks whether terminal colors are enabled or not. */\nexport function isColorsEnabled(): bool {\n  return colorsEnabled;\n}\n\n/** Sets whether terminal colors are enabled or not. */\nexport function setColorsEnabled(isEnabled: bool): bool {\n  let wasEnabled = isEnabled;\n  colorsEnabled = isEnabled;\n  return wasEnabled;\n}\n\n/** Wraps the specified text in the specified terminal color code. */\nexport function colorize(text: string, color: string): string {\n  return colorsEnabled ? color + text + COLOR_RESET : text;\n}\n", "/**\n * @fileoverview Various vector utility.\n * @license Apache-2.0\n */\n\n/** v128 zero constant. */\nexport const v128_zero = new Uint8Array(16);\n/** v128 all ones constant. */\nexport const v128_ones = new Uint8Array(16).fill(0xFF);\n", "/**\n * @fileoverview Shared diagnostic handling.\n * @license Apache-2.0\n */\n\nimport {\n  Source\n} from \"./ast\";\n\nimport {\n  DiagnosticCode,\n  diagnosticCodeToString\n} from \"./diagnosticMessages.generated\";\n\nimport {\n  isLineBreak,\n  isWhiteSpace,\n  COLOR_CYAN,\n  COLOR_YELLOW,\n  COLOR_RED,\n  COLOR_MAGENTA,\n  COLOR_RESET,\n  isColorsEnabled,\n  setColorsEnabled,\n  CharCode\n} from \"./util\";\n\nexport {\n  DiagnosticCode,\n  diagnosticCodeToString\n} from \"./diagnosticMessages.generated\";\n\n/** Indicates the category of a {@link DiagnosticMessage}. */\nexport const enum DiagnosticCategory {\n  /** Overly pedantic message. */\n  Pedantic,\n  /** Informatory message. */\n  Info,\n  /** Warning message. */\n  Warning,\n  /** Error message. */\n  Error\n}\n\nexport class Range {\n\n  source!: Source;\n\n  constructor(public start: i32, public end: i32) {}\n\n  static join(a: Range, b: Range): Range {\n    if (a.source != b.source) throw new Error(\"source mismatch\");\n    let range = new Range(\n      a.start < b.start ? a.start : b.start,\n      a.end > b.end ? a.end : b.end\n    );\n    range.source = a.source;\n    return range;\n  }\n\n  equals(other: Range): bool {\n    return (\n      this.source == other.source &&\n      this.start == other.start &&\n      this.end == other.end\n    );\n  }\n\n  get atStart(): Range {\n    let range = new Range(this.start, this.start);\n    range.source = this.source;\n    return range;\n  }\n\n  get atEnd(): Range {\n    let range = new Range(this.end, this.end);\n    range.source = this.source;\n    return range;\n  }\n\n  toString(): string {\n    return this.source.text.substring(this.start, this.end);\n  }\n}\n\n/** Returns the string representation of the specified diagnostic category. */\nexport function diagnosticCategoryToString(category: DiagnosticCategory): string {\n  switch (category) {\n    case DiagnosticCategory.Pedantic: return \"PEDANTIC\";\n    case DiagnosticCategory.Info: return \"INFO\";\n    case DiagnosticCategory.Warning: return \"WARNING\";\n    case DiagnosticCategory.Error: return \"ERROR\";\n    default: {\n      assert(false);\n      return \"\";\n    }\n  }\n}\n\n/** Returns the ANSI escape sequence for the specified category. */\nexport function diagnosticCategoryToColor(category: DiagnosticCategory): string {\n  switch (category) {\n    case DiagnosticCategory.Pedantic: return COLOR_MAGENTA;\n    case DiagnosticCategory.Info: return COLOR_CYAN;\n    case DiagnosticCategory.Warning: return COLOR_YELLOW;\n    case DiagnosticCategory.Error: return COLOR_RED;\n    default: {\n      assert(false);\n      return \"\";\n    }\n  }\n}\n\n/** Represents a diagnostic message. */\nexport class DiagnosticMessage {\n\n  /** Message code. */\n  code: i32;\n  /** Message category. */\n  category: DiagnosticCategory;\n  /** Message text. */\n  message: string;\n  /** Respective source range, if any. */\n  range: Range | null = null;\n  /** Related range, if any. */\n  relatedRange: Range | null = null; // TODO: Make this a related message for chains?\n\n  /** Constructs a new diagnostic message. */\n  private constructor(code: i32, category: DiagnosticCategory, message: string) {\n    this.code = code;\n    this.category = category;\n    this.message = message;\n  }\n\n  /** Creates a new diagnostic message of the specified category. */\n  static create(\n    code: DiagnosticCode,\n    category: DiagnosticCategory,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): DiagnosticMessage {\n    let message = diagnosticCodeToString(code);\n    if (arg0 != null) message = message.replace(\"{0}\", arg0);\n    if (arg1 != null) message = message.replace(\"{1}\", arg1);\n    if (arg2 != null) message = message.replace(\"{2}\", arg2);\n    return new DiagnosticMessage(code, category, message);\n  }\n\n  /** Tests if this message equals the specified. */\n  equals(other: DiagnosticMessage): bool {\n    if (this.code != other.code) return false;\n    let thisRange = this.range;\n    let otherRange = other.range;\n    if (thisRange) {\n      if (!otherRange || !thisRange.equals(otherRange)) return false;\n    } else if (otherRange) {\n      return false;\n    }\n    let thisRelatedRange = this.relatedRange;\n    let otherRelatedRange = other.relatedRange;\n    if (thisRelatedRange) {\n      if (!otherRelatedRange || !thisRelatedRange.equals(otherRelatedRange)) return false;\n    } else if (otherRelatedRange) {\n      return false;\n    }\n    return this.message == other.message;\n  }\n\n  /** Adds a source range to this message. */\n  withRange(range: Range): this {\n    this.range = range;\n    return this;\n  }\n\n  /** Adds a related source range to this message. */\n  withRelatedRange(range: Range): this {\n    this.relatedRange = range;\n    return this;\n  }\n\n  /** Converts this message to a string. */\n  toString(): string {\n    let category = diagnosticCategoryToString(this.category);\n    let range = this.range;\n    let code = this.code;\n    let message = this.message;\n    if (range) {\n      let source = range.source;\n      let path = source.normalizedPath;\n      let line = source.lineAt(range.start);\n      let column = source.columnAt();\n      let len = range.end - range.start;\n      return `${category} ${code}: \"${message}\" in ${path}(${line},${column}+${len})`;\n    }\n    return `${category} ${code}: ${message}`;\n  }\n}\n\n/** Formats a diagnostic message, optionally with terminal colors and source context. */\nexport function formatDiagnosticMessage(\n  message: DiagnosticMessage,\n  useColors: bool = false,\n  showContext: bool = false\n): string {\n  let wasColorsEnabled = setColorsEnabled(useColors);\n\n  // general information\n  let sb: string[] = [];\n  if (isColorsEnabled()) sb.push(diagnosticCategoryToColor(message.category));\n  sb.push(diagnosticCategoryToString(message.category));\n  if (isColorsEnabled()) sb.push(COLOR_RESET);\n  sb.push(message.code < 1000 ? \" AS\" : \" TS\");\n  sb.push(message.code.toString());\n  sb.push(\": \");\n  sb.push(message.message);\n\n  // include range information if available\n  let range = message.range;\n  if (range) {\n    let source = range.source;\n    let relatedRange = message.relatedRange;\n    let minLine = 0;\n    if (relatedRange) {\n      // Justify context indentation when multiple ranges are present\n      minLine = max(source.lineAt(range.start), relatedRange.source.lineAt(relatedRange.start));\n    }\n\n    // include context information if requested\n    if (showContext) {\n      sb.push(\"\\n\");\n      sb.push(formatDiagnosticContext(range, minLine));\n    } else {\n      sb.push(\"\\n in \");\n      sb.push(source.normalizedPath);\n    }\n    sb.push(\"(\");\n    sb.push(source.lineAt(range.start).toString());\n    sb.push(\",\");\n    sb.push(source.columnAt().toString());\n    sb.push(\")\");\n\n    if (relatedRange) {\n      let relatedSource = relatedRange.source;\n      if (showContext) {\n        sb.push(\"\\n\");\n        sb.push(formatDiagnosticContext(relatedRange, minLine));\n      } else {\n        sb.push(\"\\n in \");\n        sb.push(relatedSource.normalizedPath);\n      }\n      sb.push(\"(\");\n      sb.push(relatedSource.lineAt(relatedRange.start).toString());\n      sb.push(\",\");\n      sb.push(relatedSource.columnAt().toString());\n      sb.push(\")\");\n    }\n  }\n  setColorsEnabled(wasColorsEnabled);\n  return sb.join(\"\");\n}\n\n/** Formats the diagnostic context for the specified range, optionally with terminal colors. */\nfunction formatDiagnosticContext(range: Range, minLine: i32 = 0): string {\n  let source = range.source;\n  let text = source.text;\n  let len = text.length;\n  let start = range.start;\n  let end = start;\n  let lineNumber = source.lineAt(start).toString();\n  let lineNumberLength = minLine\n    ? max(minLine.toString().length, lineNumber.length)\n    : lineNumber.length;\n  let lineSpace = \" \".repeat(lineNumberLength);\n  // Find preceeding line break\n  while (start > 0 && !isLineBreak(text.charCodeAt(start - 1))) start--;\n  // Skip leading whitespace (assume no supplementary whitespaces)\n  while (start < len && isWhiteSpace(text.charCodeAt(start))) start++;\n  // Find next line break\n  while (end < len && !isLineBreak(text.charCodeAt(end))) end++;\n  let sb: string[] = [\n    lineSpace,\n    \"  :\\n \",\n    \" \".repeat(lineNumberLength - lineNumber.length),\n    lineNumber,\n    \" \u2502 \",\n    text.substring(start, end).replaceAll(\"\\t\", \"  \"),\n    \"\\n \",\n    lineSpace,\n    \" \u2502 \"\n  ];\n  while (start < range.start) {\n    if (text.charCodeAt(start) == CharCode.Tab) {\n      sb.push(\"  \");\n      start += 2;\n    } else {\n      sb.push(\" \");\n      start++;\n    }\n  }\n  if (isColorsEnabled()) sb.push(COLOR_RED);\n  if (range.start == range.end) {\n    sb.push(\"^\");\n  } else {\n    while (start++ < range.end) {\n      let cc = text.charCodeAt(start);\n      if (cc == CharCode.Tab) {\n        sb.push(\"~~\");\n      } else if (isLineBreak(cc)) {\n        sb.push(start == range.start + 1 ? \"^\" : \"~\");\n        break;\n      } else {\n        sb.push(\"~\");\n      }\n    }\n  }\n  if (isColorsEnabled()) sb.push(COLOR_RESET);\n  sb.push(\"\\n \");\n  sb.push(lineSpace);\n  sb.push(\" \u2514\u2500 in \");\n  sb.push(source.normalizedPath);\n  return sb.join(\"\");\n}\n\n/** Base class of all diagnostic emitters. */\nexport abstract class DiagnosticEmitter {\n\n  /** Diagnostic messages emitted so far. */\n  diagnostics: DiagnosticMessage[];\n  /** Diagnostic messages already seen, by range. */\n  private seen: Map<Source,Map<i32,DiagnosticMessage[]>> = new Map();\n\n  /** Initializes this diagnostic emitter. */\n  protected constructor(diagnostics: DiagnosticMessage[] | null = null) {\n    if (!diagnostics) diagnostics = [];\n    this.diagnostics = diagnostics;\n  }\n\n  /** Emits a diagnostic message of the specified category. */\n  emitDiagnostic(\n    code: DiagnosticCode,\n    category: DiagnosticCategory,\n    range: Range | null,\n    relatedRange: Range | null,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    let message = DiagnosticMessage.create(code, category, arg0, arg1, arg2);\n    if (range) message = message.withRange(range);\n    if (relatedRange) message.relatedRange = relatedRange;\n    // It is possible that the same diagnostic is emitted twice, for example\n    // when compiling generics with different types or when recompiling a loop\n    // because our initial assumptions didn't hold. It is even possible to get\n    // multiple instances of the same range during parsing. Deduplicate these.\n    if (range) {\n      let seen = this.seen;\n      if (seen.has(range.source)) {\n        let seenInSource = assert(seen.get(range.source));\n        if (seenInSource.has(range.start)) {\n          let seenMessagesAtPos = assert(seenInSource.get(range.start));\n          for (let i = 0, k = seenMessagesAtPos.length; i < k; ++i) {\n            if (seenMessagesAtPos[i].equals(message)) return;\n          }\n          seenMessagesAtPos.push(message);\n        } else {\n          seenInSource.set(range.start, [ message ]);\n        }\n      } else {\n        let seenInSource = new Map<i32,DiagnosticMessage[]>();\n        seenInSource.set(range.start, [ message ]);\n        seen.set(range.source, seenInSource);\n      }\n    }\n    this.diagnostics.push(message);\n    // console.log(formatDiagnosticMessage(message, true, true) + \"\\n\"); // temporary\n    // console.log(<string>new Error(\"stack\").stack);\n  }\n\n  /** Emits an overly pedantic diagnostic message. */\n  pedantic(\n    code: DiagnosticCode,\n    range: Range | null,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.Pedantic, range, null, arg0, arg1, arg2);\n  }\n\n  /** Emits an overly pedantic diagnostic message with a related range. */\n  pedanticRelated(\n    code: DiagnosticCode,\n    range: Range,\n    relatedRange: Range,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.Pedantic, range, relatedRange, arg0, arg1, arg2);\n  }\n\n  /** Emits an informatory diagnostic message. */\n  info(\n    code: DiagnosticCode,\n    range: Range | null,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.Info, range, null, arg0, arg1, arg2);\n  }\n\n  /** Emits an informatory diagnostic message with a related range. */\n  infoRelated(\n    code: DiagnosticCode,\n    range: Range,\n    relatedRange: Range,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.Info, range, relatedRange, arg0, arg1, arg2);\n  }\n\n  /** Emits a warning diagnostic message. */\n  warning(\n    code: DiagnosticCode,\n    range: Range | null,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.Warning, range, null, arg0, arg1, arg2);\n  }\n\n  /** Emits a warning diagnostic message with a related range. */\n  warningRelated(\n    code: DiagnosticCode,\n    range: Range,\n    relatedRange: Range,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.Warning, range, relatedRange, arg0, arg1, arg2);\n  }\n\n  /** Emits an error diagnostic message. */\n  error(\n    code: DiagnosticCode,\n    range: Range | null,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.Error, range, null, arg0, arg1, arg2);\n  }\n\n  /** Emits an error diagnostic message with a related range. */\n  errorRelated(\n    code: DiagnosticCode,\n    range: Range,\n    relatedRange: Range,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.Error, range, relatedRange, arg0, arg1, arg2);\n  }\n}\n", "/**\n * @fileoverview Abstract syntax tree representing a source file once parsed.\n *\n * Each node in the AST is represented by an instance of a subclass of `Node`,\n * with its `Node#kind` represented by one of the `NodeKind` constants, which\n * dependent code typically switches over. The intended way to create a node\n * is to use the respective `Node.createX` method instead of its constructor.\n *\n * Note that the AST does not contain any type information except type names.\n *\n * @license Apache-2.0\n */\n\n// TODO: Make the AST more easily serializable by refactoring `Node#range` so\n// it doesn't reference the non-serializable `Source` object.\n\nimport {\n  CommonFlags,\n  PATH_DELIMITER,\n  LIBRARY_PREFIX,\n  LIBRARY_SUBST\n} from \"./common\";\n\nimport {\n  Range\n} from \"./diagnostics\";\n\nimport {\n  Token\n} from \"./tokenizer\";\n\nimport {\n  normalizePath,\n  resolvePath,\n  CharCode\n} from \"./util\";\n\nimport {\n  ExpressionRef\n} from \"./module\";\n\nimport {\n  Type\n} from \"./types\";\n\n/** Indicates the kind of a node. */\nexport const enum NodeKind {\n\n  Source,\n\n  // types\n  NamedType,\n  FunctionType,\n  TypeName,\n  TypeParameter,\n  Parameter,\n\n  // expressions\n  Identifier,\n  Assertion,\n  Binary,\n  Call,\n  Class,\n  Comma,\n  ElementAccess,\n  False,\n  Function,\n  InstanceOf,\n  Literal,\n  New,\n  Null,\n  Omitted,\n  Parenthesized,\n  PropertyAccess,\n  Ternary,\n  Super,\n  This,\n  True,\n  Constructor,\n  UnaryPostfix,\n  UnaryPrefix,\n  Compiled,\n\n  // statements\n  Block,\n  Break,\n  Continue,\n  Do,\n  Empty,\n  Export,\n  ExportDefault,\n  ExportImport,\n  Expression,\n  For,\n  ForOf,\n  If,\n  Import,\n  Return,\n  Switch,\n  Throw,\n  Try,\n  Variable,\n  Void,\n  While,\n  Module,\n\n  // declaration statements\n  ClassDeclaration,\n  EnumDeclaration,\n  EnumValueDeclaration,\n  FieldDeclaration,\n  FunctionDeclaration,\n  ImportDeclaration,\n  InterfaceDeclaration,\n  MethodDeclaration,\n  NamespaceDeclaration,\n  TypeDeclaration,\n  VariableDeclaration,\n\n  // special\n  Decorator,\n  ExportMember,\n  SwitchCase,\n  IndexSignature,\n  Comment\n}\n\n/** Base class of all nodes. */\nexport abstract class Node {\n  constructor(\n    /** Kind of this node. */\n    public kind: NodeKind,\n    /** Source range. */\n    public range: Range\n  ) {}\n\n  // types\n\n  static createSimpleTypeName(\n    name: string,\n    range: Range\n  ): TypeName {\n    return new TypeName(Node.createIdentifierExpression(name, range), null, range);\n  }\n\n  static createNamedType(\n    name: TypeName,\n    typeArguments: TypeNode[] | null,\n    isNullable: bool,\n    range: Range\n  ): NamedTypeNode {\n    return new NamedTypeNode(name, typeArguments, isNullable, range);\n  }\n\n  static createFunctionType(\n    parameters: ParameterNode[],\n    returnType: TypeNode,\n    explicitThisType: NamedTypeNode | null,\n    isNullable: bool,\n    range: Range\n  ): FunctionTypeNode {\n    return new FunctionTypeNode(parameters, returnType, explicitThisType, isNullable, range);\n  }\n\n  static createOmittedType(\n    range: Range\n  ): NamedTypeNode {\n    return new NamedTypeNode(Node.createSimpleTypeName(\"\", range), null, false, range);\n  }\n\n  static createTypeParameter(\n    name: IdentifierExpression,\n    extendsType: NamedTypeNode | null,\n    defaultType: NamedTypeNode | null,\n    range: Range\n  ): TypeParameterNode {\n    return new TypeParameterNode(name, extendsType, defaultType, range);\n  }\n\n  static createParameter(\n    parameterKind: ParameterKind,\n    name: IdentifierExpression,\n    type: TypeNode,\n    initializer: Expression | null,\n    range: Range\n  ): ParameterNode {\n    return new ParameterNode(parameterKind, name, type, initializer, range);\n  }\n\n  // special\n\n  static createDecorator(\n    name: Expression,\n    args: Expression[] | null,\n    range: Range\n  ): DecoratorNode {\n    return new DecoratorNode(DecoratorKind.fromNode(name), name, args, range);\n  }\n\n  static createComment(\n    commentKind: CommentKind,\n    text: string,\n    range: Range\n  ): CommentNode {\n    return new CommentNode(commentKind, text, range);\n  }\n\n  // expressions\n\n  static createIdentifierExpression(\n    text: string,\n    range: Range,\n    isQuoted: bool = false\n  ): IdentifierExpression {\n    return new IdentifierExpression(text, isQuoted, range);\n  }\n\n  static createEmptyIdentifierExpression(\n    range: Range\n  ): IdentifierExpression {\n    return new IdentifierExpression(\"\", false, range);\n  }\n\n  static createArrayLiteralExpression(\n    elementExpressions: Expression[],\n    range: Range\n  ): ArrayLiteralExpression {\n    return new ArrayLiteralExpression(elementExpressions, range);\n  }\n\n  static createAssertionExpression(\n    assertionKind: AssertionKind,\n    expression: Expression,\n    toType: TypeNode | null,\n    range: Range\n  ): AssertionExpression {\n    return new AssertionExpression(assertionKind, expression, toType, range);\n  }\n\n  static createBinaryExpression(\n    operator: Token,\n    left: Expression,\n    right: Expression,\n    range: Range\n  ): BinaryExpression {\n    return new BinaryExpression(operator, left, right, range);\n  }\n\n  static createCallExpression(\n    expression: Expression,\n    typeArguments: TypeNode[] | null,\n    args: Expression[],\n    range: Range\n  ): CallExpression {\n    return new CallExpression(expression, typeArguments, args, range);\n  }\n\n  static createClassExpression(\n    declaration: ClassDeclaration\n  ): ClassExpression {\n    return new ClassExpression(declaration);\n  }\n\n  static createCommaExpression(\n    expressions: Expression[],\n    range: Range\n  ): CommaExpression {\n    return new CommaExpression(expressions, range);\n  }\n\n  static createConstructorExpression(\n    range: Range\n  ): ConstructorExpression {\n    return new ConstructorExpression(range);\n  }\n\n  static createElementAccessExpression(\n    expression: Expression,\n    elementExpression: Expression,\n    range: Range\n  ): ElementAccessExpression {\n    return new ElementAccessExpression(expression, elementExpression, range);\n  }\n\n  static createFalseExpression(\n    range: Range\n  ): FalseExpression {\n    return new FalseExpression(range);\n  }\n\n  static createFloatLiteralExpression(\n    value: f64,\n    range: Range\n  ): FloatLiteralExpression {\n    return new FloatLiteralExpression(value, range);\n  }\n\n  static createFunctionExpression(\n    declaration: FunctionDeclaration\n  ): FunctionExpression {\n    return new FunctionExpression(declaration);\n  }\n\n  static createInstanceOfExpression(\n    expression: Expression,\n    isType: TypeNode,\n    range: Range\n  ): InstanceOfExpression {\n    return new InstanceOfExpression(expression, isType, range);\n  }\n\n  static createIntegerLiteralExpression(\n    value: i64,\n    range: Range\n  ): IntegerLiteralExpression {\n    return new IntegerLiteralExpression(value, range);\n  }\n\n  static createNewExpression(\n    typeName: TypeName,\n    typeArguments: TypeNode[] | null,\n    args: Expression[],\n    range: Range\n  ): NewExpression {\n    return new NewExpression(typeName, typeArguments, args, range);\n  }\n\n  static createNullExpression(\n    range: Range\n  ): NullExpression {\n    return new NullExpression(range);\n  }\n\n  static createObjectLiteralExpression(\n    names: IdentifierExpression[],\n    values: Expression[],\n    range: Range\n  ): ObjectLiteralExpression {\n    return new ObjectLiteralExpression(names, values, range);\n  }\n\n  static createOmittedExpression(\n    range: Range\n  ): OmittedExpression {\n    return new OmittedExpression(range);\n  }\n\n  static createParenthesizedExpression(\n    expression: Expression,\n    range: Range\n  ): ParenthesizedExpression {\n    return new ParenthesizedExpression(expression, range);\n  }\n\n  static createPropertyAccessExpression(\n    expression: Expression,\n    property: IdentifierExpression,\n    range: Range\n  ): PropertyAccessExpression {\n    return new PropertyAccessExpression(expression, property, range);\n  }\n\n  static createRegexpLiteralExpression(\n    pattern: string,\n    patternFlags: string,\n    range: Range\n  ): RegexpLiteralExpression {\n    return new RegexpLiteralExpression(pattern, patternFlags, range);\n  }\n\n  static createTernaryExpression(\n    condition: Expression,\n    ifThen: Expression,\n    ifElse: Expression,\n    range: Range\n  ): TernaryExpression {\n    return new TernaryExpression(condition, ifThen, ifElse, range);\n  }\n\n  static createStringLiteralExpression(\n    value: string,\n    range: Range\n  ): StringLiteralExpression {\n    return new StringLiteralExpression(value, range);\n  }\n\n  static createSuperExpression(\n    range: Range\n  ): SuperExpression {\n    return new SuperExpression(range);\n  }\n\n  static createTemplateLiteralExpression(\n    tag: Expression | null,\n    parts: string[],\n    rawParts: string[],\n    expressions: Expression[],\n    range: Range\n  ): TemplateLiteralExpression {\n    return new TemplateLiteralExpression(tag, parts, rawParts, expressions, range);\n  }\n\n  static createThisExpression(\n    range: Range\n  ): ThisExpression {\n    return new ThisExpression(range);\n  }\n\n  static createTrueExpression(\n    range: Range\n  ): TrueExpression {\n    return new TrueExpression(range);\n  }\n\n  static createUnaryPostfixExpression(\n    operator: Token,\n    operand: Expression,\n    range: Range\n  ): UnaryPostfixExpression {\n    return new UnaryPostfixExpression(operator, operand, range);\n  }\n\n  static createUnaryPrefixExpression(\n    operator: Token,\n    operand: Expression,\n    range: Range\n  ): UnaryPrefixExpression {\n    return new UnaryPrefixExpression(operator, operand, range);\n  }\n\n  static createCompiledExpression(\n    expr: ExpressionRef,\n    type: Type,\n    range: Range\n  ): Expression {\n    return new CompiledExpression(expr, type, range);\n  }\n\n  // statements\n\n  static createBlockStatement(\n    statements: Statement[],\n    range: Range\n  ): BlockStatement {\n    return new BlockStatement(statements, range);\n  }\n\n  static createBreakStatement(\n    label: IdentifierExpression | null,\n    range: Range\n  ): BreakStatement {\n    return new BreakStatement(label, range);\n  }\n\n  static createClassDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    typeParameters: TypeParameterNode[] | null,\n    extendsType: NamedTypeNode | null,\n    implementsTypes: NamedTypeNode[] | null,\n    members: DeclarationStatement[],\n    range: Range\n  ): ClassDeclaration {\n    return new ClassDeclaration(name, decorators, flags, typeParameters, extendsType, implementsTypes, members, range);\n  }\n\n  static createContinueStatement(\n    label: IdentifierExpression | null,\n    range: Range\n  ): ContinueStatement {\n    return new ContinueStatement(label, range);\n  }\n\n  static createDoStatement(\n    body: Statement,\n    condition: Expression,\n    range: Range\n  ): DoStatement {\n    return new DoStatement(body, condition, range);\n  }\n\n  static createEmptyStatement(\n    range: Range\n  ): EmptyStatement {\n    return new EmptyStatement(range);\n  }\n\n  static createEnumDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    values: EnumValueDeclaration[],\n    range: Range\n  ): EnumDeclaration {\n    return new EnumDeclaration(name, decorators, flags, values, range);\n  }\n\n  static createEnumValueDeclaration(\n    name: IdentifierExpression,\n    flags: CommonFlags,\n    initializer: Expression | null,\n    range: Range\n  ): EnumValueDeclaration {\n    return new EnumValueDeclaration(name, flags, initializer, range);\n  }\n\n  static createExportStatement(\n    members: ExportMember[] | null,\n    path: StringLiteralExpression | null,\n    isDeclare: bool,\n    range: Range\n  ): ExportStatement {\n    return new ExportStatement(members, path, isDeclare, range);\n  }\n\n  static createExportDefaultStatement(\n    declaration: DeclarationStatement,\n    range: Range\n  ): ExportDefaultStatement {\n    return new ExportDefaultStatement(declaration, range);\n  }\n\n  static createExportImportStatement(\n    name: IdentifierExpression,\n    externalName: IdentifierExpression,\n    range: Range\n  ): ExportImportStatement {\n    return new ExportImportStatement(name, externalName, range);\n  }\n\n  static createExportMember(\n    localName: IdentifierExpression,\n    exportedName: IdentifierExpression | null,\n    range: Range\n  ): ExportMember {\n    if (!exportedName) exportedName = localName;\n    return new ExportMember(localName, exportedName, range);\n  }\n\n  static createExpressionStatement(\n    expression: Expression\n  ): ExpressionStatement {\n    return new ExpressionStatement(expression);\n  }\n\n  static createIfStatement(\n    condition: Expression,\n    ifTrue: Statement,\n    ifFalse: Statement | null,\n    range: Range\n  ): IfStatement {\n    return new IfStatement(condition, ifTrue, ifFalse, range);\n  }\n\n  static createImportStatement(\n    declarations: ImportDeclaration[] | null,\n    path: StringLiteralExpression,\n    range: Range\n  ): ImportStatement {\n    return new ImportStatement(declarations, null, path, range);\n  }\n\n  static createWildcardImportStatement(\n    namespaceName: IdentifierExpression,\n    path: StringLiteralExpression,\n    range: Range\n  ): ImportStatement {\n    return new ImportStatement(null, namespaceName, path, range);\n  }\n\n  static createImportDeclaration(\n    foreignName: IdentifierExpression,\n    name: IdentifierExpression | null,\n    range: Range\n  ): ImportDeclaration {\n    if (!name) name = foreignName;\n    return new ImportDeclaration(name, foreignName, range);\n  }\n\n  static createInterfaceDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    typeParameters: TypeParameterNode[] | null,\n    extendsType: NamedTypeNode | null,\n    implementsTypes: NamedTypeNode[] | null,\n    members: DeclarationStatement[],\n    range: Range\n  ): InterfaceDeclaration {\n    return new InterfaceDeclaration(name, decorators, flags, typeParameters, extendsType, implementsTypes, members, range);\n  }\n\n  static createFieldDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    type: TypeNode | null,\n    initializer: Expression | null,\n    range: Range\n  ): FieldDeclaration {\n    return new FieldDeclaration(name, decorators, flags, type, initializer, -1, range);\n  }\n\n  static createForStatement(\n    initializer: Statement | null,\n    condition: Expression | null,\n    incrementor: Expression | null,\n    body: Statement,\n    range: Range\n  ): ForStatement {\n    return new ForStatement(initializer, condition, incrementor, body, range);\n  }\n\n  static createForOfStatement(\n    variable: Statement,\n    iterable: Expression,\n    body: Statement,\n    range: Range\n  ): ForOfStatement {\n    return new ForOfStatement(variable, iterable, body, range);\n  }\n\n  static createFunctionDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    typeParameters: TypeParameterNode[] | null,\n    signature: FunctionTypeNode,\n    body: Statement | null,\n    arrowKind: ArrowKind,\n    range: Range\n  ): FunctionDeclaration {\n    return new FunctionDeclaration(name, decorators, flags, typeParameters, signature, body, arrowKind, range);\n  }\n\n  static createIndexSignature(\n    keyType: NamedTypeNode,\n    valueType: TypeNode,\n    flags: CommonFlags,\n    range: Range\n  ): IndexSignatureNode {\n    return new IndexSignatureNode(keyType, valueType, flags, range);\n  }\n\n  static createMethodDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    typeParameters: TypeParameterNode[] | null,\n    signature: FunctionTypeNode,\n    body: Statement | null,\n    range: Range\n  ): MethodDeclaration {\n    return new MethodDeclaration(name, decorators, flags, typeParameters, signature, body, range);\n  }\n\n  static createNamespaceDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    members: Statement[],\n    range: Range\n  ): NamespaceDeclaration {\n    return new NamespaceDeclaration(name, decorators, flags, members, range);\n  }\n\n  static createReturnStatement(\n    value: Expression | null,\n    range: Range\n  ): ReturnStatement {\n    return new ReturnStatement(value, range);\n  }\n\n  static createSwitchStatement(\n    condition: Expression,\n    cases: SwitchCase[],\n    range: Range\n  ): SwitchStatement {\n    return new SwitchStatement(condition, cases, range);\n  }\n\n  static createSwitchCase(\n    label: Expression | null,\n    statements: Statement[],\n    range: Range\n  ): SwitchCase {\n    return new SwitchCase(label, statements, range);\n  }\n\n  static createThrowStatement(\n    value: Expression,\n    range: Range\n  ): ThrowStatement {\n    return new ThrowStatement(value, range);\n  }\n\n  static createTryStatement(\n    bodyStatements: Statement[],\n    catchVariable: IdentifierExpression | null,\n    catchStatements: Statement[] | null,\n    finallyStatements: Statement[] | null,\n    range: Range\n  ): TryStatement {\n    return new TryStatement(bodyStatements, catchVariable, catchStatements, finallyStatements, range);\n  }\n\n  static createTypeDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    typeParameters: TypeParameterNode[] | null,\n    type: TypeNode,\n    range: Range\n  ): TypeDeclaration {\n    return new TypeDeclaration(name, decorators, flags, typeParameters, type, range);\n  }\n\n  static createModuleDeclaration(\n    name: string,\n    flags: CommonFlags,\n    range: Range\n  ): ModuleDeclaration {\n    return new ModuleDeclaration(name, flags, range);\n  }\n\n  static createVariableStatement(\n    decorators: DecoratorNode[] | null,\n    declarations: VariableDeclaration[],\n    range: Range\n  ): VariableStatement {\n    return new VariableStatement(decorators, declarations, range);\n  }\n\n  static createVariableDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    type: TypeNode | null,\n    initializer: Expression | null,\n    range: Range\n  ): VariableDeclaration {\n    return new VariableDeclaration(name, decorators, flags, type, initializer, range);\n  }\n\n  static createVoidStatement(\n    expression: Expression,\n    range: Range\n  ): VoidStatement {\n    return new VoidStatement(expression, range);\n  }\n\n  static createWhileStatement(\n    condition: Expression,\n    statement: Statement,\n    range: Range\n  ): WhileStatement {\n    return new WhileStatement(condition, statement, range);\n  }\n\n  /** Tests if this node is a literal of the specified kind. */\n  isLiteralKind(literalKind: LiteralKind): bool {\n    return this.kind == NodeKind.Literal\n        && (<LiteralExpression>changetype<Node>(this)).literalKind == literalKind; // TS\n  }\n\n  /** Tests if this node is a literal of a numeric kind (float or integer). */\n  get isNumericLiteral(): bool {\n    if (this.kind == NodeKind.Literal) {\n      switch ((<LiteralExpression>changetype<Node>(this)).literalKind) { // TS\n        case LiteralKind.Float:\n        case LiteralKind.Integer: return true;\n      }\n    }\n    return false;\n  }\n\n  /** Tests whether this node is guaranteed to compile to a constant value. */\n  get compilesToConst(): bool {\n    switch (this.kind) {\n      case NodeKind.Literal: {\n        switch ((<LiteralExpression>changetype<Node>(this)).literalKind) { // TS\n          case LiteralKind.Float:\n          case LiteralKind.Integer:\n          case LiteralKind.String: return true;\n        }\n        break;\n      }\n      case NodeKind.Null:\n      case NodeKind.True:\n      case NodeKind.False: return true;\n    }\n    return false;\n  }\n\n  private isAccessOn(kind: NodeKind): bool {\n    let node = changetype<Node>(this);\n    if (node.kind == NodeKind.Call) {\n      node = (<CallExpression>node).expression;\n    }\n    if (node.kind == NodeKind.PropertyAccess) {\n      let target = (<PropertyAccessExpression>node).expression;\n      if (target.kind == kind) return true;\n    }\n    return false;\n  }\n\n  /** Checks if this node accesses a method or property on `this`. */\n  get isAccessOnThis(): bool {\n    return this.isAccessOn(NodeKind.This);\n  }\n\n  /** Checks if this node accesses a method or property on `super`. */\n  get isAccessOnSuper(): bool {\n    return this.isAccessOn(NodeKind.Super);\n  }\n\n  get isEmpty(): bool {\n    return this.kind == NodeKind.Empty;\n  }\n}\n\n// types\n\nexport abstract class TypeNode extends Node {\n  constructor(\n    /** Kind of the type node. */\n    kind: NodeKind,\n    /** Whether nullable or not. */\n    public isNullable: bool,\n    /** Source range. */\n    range: Range\n  ) {\n    super(kind, range);\n  }\n\n  /** Whether this type node is currently in the process of being resolved. */\n  currentlyResolving: bool = false;\n\n  /** Tests if this type has a generic component matching one of the given type parameters. */\n  hasGenericComponent(typeParameterNodes: TypeParameterNode[]): bool {\n    if (this.kind == NodeKind.NamedType) {\n      let namedTypeNode = <NamedTypeNode>changetype<TypeNode>(this); // TS\n      if (!namedTypeNode.name.next) {\n        let typeArgumentNodes = namedTypeNode.typeArguments;\n        if (typeArgumentNodes && typeArgumentNodes.length > 0) {\n          for (let i = 0, k = typeArgumentNodes.length; i < k; ++i) {\n            if (typeArgumentNodes[i].hasGenericComponent(typeParameterNodes)) return true;\n          }\n        } else {\n          let name = namedTypeNode.name.identifier.text;\n          for (let i = 0, k = typeParameterNodes.length; i < k; ++i) {\n            if (typeParameterNodes[i].name.text == name) return true;\n          }\n        }\n      }\n    } else if (this.kind == NodeKind.FunctionType) {\n      let functionTypeNode = <FunctionTypeNode>changetype<TypeNode>(this); // TS\n      let parameterNodes = functionTypeNode.parameters;\n      for (let i = 0, k = parameterNodes.length; i < k; ++i) {\n        if (parameterNodes[i].type.hasGenericComponent(typeParameterNodes)) return true;\n      }\n      if (functionTypeNode.returnType.hasGenericComponent(typeParameterNodes)) return true;\n      let explicitThisType = functionTypeNode.explicitThisType;\n      if (explicitThisType && explicitThisType.hasGenericComponent(typeParameterNodes)) return true;\n    } else {\n      assert(false);\n    }\n    return false;\n  }\n}\n\n/** Represents a type name. */\nexport class TypeName extends Node {\n  constructor(\n    /** Identifier of this part. */\n    public identifier: IdentifierExpression,\n    /** Next part of the type name or `null` if this is the last part. */\n    public next: TypeName | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.TypeName, range);\n  }\n}\n\n/** Represents a named type. */\nexport class NamedTypeNode extends TypeNode {\n  constructor(\n    /** Type name. */\n    public name: TypeName,\n    /** Type argument references. */\n    public typeArguments: TypeNode[] | null,\n    /** Whether nullable or not. */\n    isNullable: bool,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.NamedType, isNullable, range);\n  }\n\n  /** Checks if this type node has type arguments. */\n  get hasTypeArguments(): bool {\n    let typeArguments = this.typeArguments;\n    return typeArguments != null && typeArguments.length > 0;\n  }\n\n  /** Tests if this type is \"null\". */\n  get isNull(): bool {\n    return this.name.identifier.text == \"null\";\n  }\n}\n\n/** Represents a function type. */\nexport class FunctionTypeNode extends TypeNode {\n  constructor(\n    /** Function parameters. */\n    public parameters: ParameterNode[],\n    /** Return type. */\n    public returnType: TypeNode,\n    /** Explicitly provided this type, if any. */\n    public explicitThisType: NamedTypeNode | null, // can't be a function\n    /** Whether nullable or not. */\n    isNullable: bool,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.FunctionType, isNullable, range);\n  }\n}\n\n/** Represents a type parameter. */\nexport class TypeParameterNode extends Node {\n  constructor(\n    /** Identifier reference. */\n    public name: IdentifierExpression,\n    /** Extended type reference, if any. */\n    public extendsType: NamedTypeNode | null, // can't be a function\n    /** Default type if omitted, if any. */\n    public defaultType: NamedTypeNode | null, // can't be a function\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.TypeParameter, range);\n  }\n}\n\n/** Represents the kind of a parameter. */\nexport const enum ParameterKind {\n  /** No specific flags. */\n  Default,\n  /** Is an optional parameter. */\n  Optional,\n  /** Is a rest parameter. */\n  Rest\n}\n\n/** Represents a function parameter. */\nexport class ParameterNode extends Node {\n  constructor(\n    /** Parameter kind. */\n    public parameterKind: ParameterKind,\n    /** Parameter name. */\n    public name: IdentifierExpression,\n    /** Parameter type. */\n    public type: TypeNode,\n    /** Initializer expression, if any. */\n    public initializer: Expression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Parameter, range);\n  }\n\n  /** Implicit field declaration, if applicable. */\n  implicitFieldDeclaration: FieldDeclaration | null = null;\n  /** Common flags indicating specific traits. */\n  flags: CommonFlags = CommonFlags.None;\n\n  /** Tests if this node has the specified flag or flags. */\n  is(flag: CommonFlags): bool { return (this.flags & flag) == flag; }\n  /** Tests if this node has one of the specified flags. */\n  isAny(flag: CommonFlags): bool { return (this.flags & flag) != 0; }\n  /** Sets a specific flag or flags. */\n  set(flag: CommonFlags): void { this.flags |= flag; }\n}\n\n// special\n\n/** Built-in decorator kinds. */\nexport enum DecoratorKind {\n  Custom,\n  Global,\n  Operator,\n  OperatorBinary,\n  OperatorPrefix,\n  OperatorPostfix,\n  Unmanaged,\n  Final,\n  Inline,\n  External,\n  ExternalJs,\n  Builtin,\n  Lazy,\n  Unsafe\n}\n\nexport namespace DecoratorKind {\n\n  /** Returns the kind of the specified decorator name node. Defaults to {@link DecoratorKind.CUSTOM}. */\n  export function fromNode(nameNode: Expression): DecoratorKind {\n    if (nameNode.kind == NodeKind.Identifier) {\n      let nameStr = (<IdentifierExpression>nameNode).text;\n      assert(nameStr.length);\n      switch (nameStr.charCodeAt(0)) {\n        case CharCode.b: {\n          if (nameStr == \"builtin\") return DecoratorKind.Builtin;\n          break;\n        }\n        case CharCode.e: {\n          if (nameStr == \"external\") return DecoratorKind.External;\n          break;\n        }\n        case CharCode.f: {\n          if (nameStr == \"final\") return DecoratorKind.Final;\n          break;\n        }\n        case CharCode.g: {\n          if (nameStr == \"global\") return DecoratorKind.Global;\n          break;\n        }\n        case CharCode.i: {\n          if (nameStr == \"inline\") return DecoratorKind.Inline;\n          break;\n        }\n        case CharCode.l: {\n          if (nameStr == \"lazy\") return DecoratorKind.Lazy;\n          break;\n        }\n        case CharCode.o: {\n          if (nameStr == \"operator\") return DecoratorKind.Operator;\n          break;\n        }\n        case CharCode.u: {\n          if (nameStr == \"unmanaged\") return DecoratorKind.Unmanaged;\n          if (nameStr == \"unsafe\") return DecoratorKind.Unsafe;\n          break;\n        }\n      }\n    } else if (nameNode.kind == NodeKind.PropertyAccess) {\n      let propertyAccessNode = <PropertyAccessExpression>nameNode;\n      let expression = propertyAccessNode.expression;\n      if (expression.kind == NodeKind.Identifier) {\n        let nameStr = (<IdentifierExpression>expression).text;\n        assert(nameStr.length);\n        let propStr = propertyAccessNode.property.text;\n        assert(propStr.length);\n        if (nameStr == \"operator\") {\n          switch (propStr.charCodeAt(0)) {\n            case CharCode.b: {\n              if (propStr == \"binary\") return DecoratorKind.OperatorBinary;\n              break;\n            }\n            case CharCode.p: {\n              if (propStr == \"prefix\") return DecoratorKind.OperatorPrefix;\n              if (propStr == \"postfix\") return DecoratorKind.OperatorPostfix;\n              break;\n            }\n          }\n        } else if (nameStr == \"external\") {\n          switch (propStr.charCodeAt(0)) {\n            case CharCode.j: {\n              if (propStr == \"js\") return DecoratorKind.ExternalJs;\n              break;\n            }\n          }\n        }\n      }\n    }\n    return DecoratorKind.Custom;\n  }\n}\n\n/** Represents a decorator. */\nexport class DecoratorNode extends Node {\n  constructor(\n    /** Built-in decorator kind, or custom. */\n    public decoratorKind: DecoratorKind,\n    /** Name expression. */\n    public name: Expression,\n    /** Argument expressions. */\n    public args: Expression[] | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Decorator, range);\n  }\n}\n\n/** Comment kinds. */\nexport const enum CommentKind {\n  /** Line comment. */\n  Line,\n  /** Triple-slash line comment. */\n  Triple,\n  /** Block comment. */\n  Block\n}\n\n/** Represents a comment. */\nexport class CommentNode extends Node {\n  constructor(\n    /** Comment kind. */\n    public commentKind: CommentKind,\n    /** Comment text. */\n    public text: string,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Comment, range);\n  }\n}\n\n// expressions\n\n/** Base class of all expression nodes. */\nexport abstract class Expression extends Node { }\n\n/** Represents an identifier expression. */\nexport class IdentifierExpression extends Expression {\n  constructor(\n    /** Textual name. */\n    public text: string,\n    /** Whether quoted or not. */\n    public isQuoted: bool,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Identifier, range);\n  }\n}\n\n/** Indicates the kind of a literal. */\nexport const enum LiteralKind {\n  Float,\n  Integer,\n  String,\n  Template,\n  RegExp,\n  Array,\n  Object\n}\n\n/** Base class of all literal expressions. */\nexport abstract class LiteralExpression extends Expression {\n  constructor(\n    /** Specific literal kind. */\n    public literalKind: LiteralKind,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Literal, range);\n  }\n}\n\n/** Represents an `[]` literal expression. */\nexport class ArrayLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Nested element expressions. */\n    public elementExpressions: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.Array, range);\n  }\n}\n\n/** Indicates the kind of an assertion. */\nexport const enum AssertionKind {\n  /** A prefix assertion, i.e. `<T>expr`. */\n  Prefix,\n  /** An as assertion, i.e. `expr as T`. */\n  As,\n  /** A non-null assertion, i.e. `!expr`. */\n  NonNull,\n  /** A const assertion, i.e. `expr as const`. */\n  Const\n}\n\n/** Represents an assertion expression. */\nexport class AssertionExpression extends Expression {\n  constructor(\n    /** Specific kind of this assertion. */\n    public assertionKind: AssertionKind,\n    /** Expression being asserted. */\n    public expression: Expression,\n    /** Target type, if applicable. */\n    public toType: TypeNode | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Assertion, range);\n  }\n}\n\n/** Represents a binary expression. */\nexport class BinaryExpression extends Expression {\n  constructor(\n    /** Operator token. */\n    public operator: Token,\n    /** Left-hand side expression */\n    public left: Expression,\n    /** Right-hand side expression. */\n    public right: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Binary, range);\n  }\n}\n\n/** Represents a call expression. */\nexport class CallExpression extends Expression {\n  constructor(\n    /** Called expression. Usually an identifier or property access expression. */\n    public expression: Expression,\n    /** Provided type arguments. */\n    public typeArguments: TypeNode[] | null,\n    /** Provided arguments. */\n    public args: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Call, range);\n  }\n\n  /** Gets the type arguments range for reporting. */\n  get typeArgumentsRange(): Range {\n    let typeArguments = this.typeArguments;\n    let numTypeArguments: i32;\n    if (typeArguments) {\n      if (numTypeArguments = typeArguments.length) {\n        return Range.join(typeArguments[0].range, typeArguments[numTypeArguments - 1].range);\n      }\n    }\n    return this.expression.range;\n  }\n\n  /** Gets the arguments range for reporting. */\n  get argumentsRange(): Range {\n    let args = this.args;\n    let numArguments = args.length;\n    if (numArguments) {\n      return Range.join(args[0].range, args[numArguments - 1].range);\n    }\n    return this.expression.range;\n  }\n}\n\n/** Represents a class expression using the 'class' keyword. */\nexport class ClassExpression extends Expression {\n  constructor(\n    /** Inline class declaration. */\n    public declaration: ClassDeclaration\n  ) {\n    super(NodeKind.Class, declaration.range);\n  }\n}\n\n/** Represents a comma expression composed of multiple expressions. */\nexport class CommaExpression extends Expression {\n  constructor(\n    /** Sequential expressions. */\n    public expressions: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Comma, range);\n  }\n}\n\n/** Represents a `constructor` expression. */\nexport class ConstructorExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"constructor\", false, range);\n    this.kind = NodeKind.Constructor;\n  }\n}\n\n/** Represents an element access expression, e.g., array access. */\nexport class ElementAccessExpression extends Expression {\n  constructor(\n    /** Expression being accessed. */\n    public expression: Expression,\n    /** Element of the expression being accessed. */\n    public elementExpression: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ElementAccess, range);\n  }\n}\n\n/** Represents a float literal expression. */\nexport class FloatLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Float value. */\n    public value: f64,\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.Float, range);\n  }\n}\n\n/** Represents a function expression using the 'function' keyword. */\nexport class FunctionExpression extends Expression {\n  constructor(\n    /** Inline function declaration. */\n    public declaration: FunctionDeclaration\n  ) {\n    super(NodeKind.Function, declaration.range);\n  }\n}\n\n/** Represents an `instanceof` expression. */\nexport class InstanceOfExpression extends Expression {\n  constructor(\n    /** Expression being asserted. */\n    public expression: Expression,\n    /** Type to test for. */\n    public isType: TypeNode,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.InstanceOf, range);\n  }\n}\n\n/** Represents an integer literal expression. */\nexport class IntegerLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Integer value. */\n    public value: i64,\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.Integer, range);\n  }\n}\n\n/** Represents a `new` expression. Like a call but with its own kind. */\nexport class NewExpression extends Expression {\n  constructor(\n    /** Type being constructed. */\n    public typeName: TypeName,\n    /** Provided type arguments. */\n    public typeArguments: TypeNode[] | null,\n    /** Provided arguments. */\n    public args: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.New, range);\n  }\n\n  /** Gets the type arguments range for reporting. */\n  get typeArgumentsRange(): Range {\n    let typeArguments = this.typeArguments;\n    let numTypeArguments: i32;\n    if (typeArguments && (numTypeArguments = typeArguments.length) > 0) {\n      return Range.join(typeArguments[0].range, typeArguments[numTypeArguments - 1].range);\n    }\n    return this.typeName.range;\n  }\n\n  /** Gets the arguments range for reporting. */\n  get argumentsRange(): Range {\n    let args = this.args;\n    let numArguments = args.length;\n    if (numArguments) {\n      return Range.join(args[0].range, args[numArguments - 1].range);\n    }\n    return this.typeName.range;\n  }\n}\n\n/** Represents a `null` expression. */\nexport class NullExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"null\", false, range);\n    this.kind = NodeKind.Null;\n  }\n}\n\n/** Represents an object literal expression. */\nexport class ObjectLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Field names. */\n    public names: IdentifierExpression[],\n    /** Field values. */\n    public values: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.Object, range);\n  }\n}\n\n/** Represents an omitted expression, e.g. within an array literal. */\nexport class OmittedExpression extends Expression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Omitted, range);\n  }\n}\n\n/** Represents a parenthesized expression. */\nexport class ParenthesizedExpression extends Expression {\n  constructor(\n    /** Expression in parenthesis. */\n    public expression: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Parenthesized, range);\n  }\n}\n\n/** Represents a property access expression. */\nexport class PropertyAccessExpression extends Expression {\n  constructor(\n    /** Expression being accessed. */\n    public expression: Expression,\n    /** Property of the expression being accessed. */\n    public property: IdentifierExpression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.PropertyAccess, range);\n  }\n}\n\n/** Represents a regular expression literal expression. */\nexport class RegexpLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Regular expression pattern. */\n    public pattern: string,\n    /** Regular expression flags. */\n    public patternFlags: string,\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.RegExp, range);\n  }\n}\n\n/** Represents a ternary expression, i.e., short if notation. */\nexport class TernaryExpression extends Expression {\n  constructor(\n    /** Condition expression. */\n    public condition: Expression,\n    /** Expression executed when condition is `true`. */\n    public ifThen: Expression,\n    /** Expression executed when condition is `false`. */\n    public ifElse: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Ternary, range);\n  }\n}\n\n/** Represents a string literal expression. */\nexport class StringLiteralExpression extends LiteralExpression {\n  constructor(\n    /** String value without quotes. */\n    public value: string,\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.String, range);\n  }\n}\n\n/** Represents a `super` expression. */\nexport class SuperExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"super\", false, range);\n    this.kind = NodeKind.Super;\n  }\n}\n\n/** Represents a template literal expression. */\nexport class TemplateLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Tag expression, if any. */\n    public tag: Expression | null,\n    /** String parts. */\n    public parts: string[],\n    /** Raw string parts. */\n    public rawParts: string[],\n    /** Expression parts. */\n    public expressions: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.Template, range);\n  }\n}\n\n/** Represents a `this` expression. */\nexport class ThisExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"this\", false, range);\n    this.kind = NodeKind.This;\n  }\n}\n\n/** Represents a `true` expression. */\nexport class TrueExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"true\", false, range);\n    this.kind = NodeKind.True;\n  }\n}\n\n/** Represents a `false` expression. */\nexport class FalseExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"false\", false, range);\n    this.kind = NodeKind.False;\n  }\n}\n\n/** Base class of all unary expressions. */\nexport abstract class UnaryExpression extends Expression {\n  constructor(\n    /** Unary expression kind. */\n    kind: NodeKind,\n    /** Operator token. */\n    public operator: Token,\n    /** Operand expression. */\n    public operand: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(kind, range);\n  }\n}\n\n/** Represents a unary postfix expression, e.g. a postfix increment. */\nexport class UnaryPostfixExpression extends UnaryExpression {\n  constructor(\n    /** Operator token. */\n    operator: Token,\n    /** Operand expression. */\n    operand: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.UnaryPostfix, operator, operand, range);\n  }\n}\n\n/** Represents a unary prefix expression, e.g. a negation. */\nexport class UnaryPrefixExpression extends UnaryExpression {\n  constructor(\n    /** Operator token. */\n    operator: Token,\n    /** Operand expression. */\n    operand: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.UnaryPrefix, operator, operand, range);\n  }\n}\n\n/** Represents a special pre-compiled expression. If the expression has side-effects, special care has to be taken. */\nexport class CompiledExpression extends Expression {\n  constructor(\n    /** Compiled expression. */\n    public expr: ExpressionRef,\n    /** Type of the compiled expression. */\n    public type: Type,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Compiled, range);\n  }\n}\n\n// statements\n\n/** Base class of all statement nodes. */\nexport abstract class Statement extends Node { }\n\n/** Indicates the specific kind of a source. */\nexport const enum SourceKind {\n  /** User-provided file. */\n  User = 0,\n  /** User-provided entry file. */\n  UserEntry = 1,\n  /** Library-provided file. */\n  Library = 2,\n  /** Library-provided entry file. */\n  LibraryEntry = 3\n}\n\n/** A top-level source node. */\nexport class Source extends Node {\n\n  /** Gets the special native source. */\n  static get native(): Source {\n    let source = Source._native;\n    if (!source) Source._native = source = new Source(SourceKind.LibraryEntry, LIBRARY_PREFIX + \"native.ts\", \"[native code]\");\n    return source;\n  }\n  private static _native: Source | null = null;\n\n  constructor(\n    /** Source kind. */\n    public sourceKind: SourceKind,\n    /** Normalized path with file extension. */\n    public normalizedPath: string,\n    /** Full source text. */\n    public text: string\n  ) {\n    super(NodeKind.Source, new Range(0, text.length));\n    let internalPath = mangleInternalPath(normalizedPath);\n    this.internalPath = internalPath;\n    let pos = internalPath.lastIndexOf(PATH_DELIMITER);\n    this.simplePath = pos >= 0 ? internalPath.substring(pos + 1) : internalPath;\n    this.range.source = this;\n  }\n\n  /** Path used internally. */\n  internalPath: string;\n  /** Simple path (last part without extension). */\n  simplePath: string;\n  /** Contained statements. */\n  statements: Statement[] = new Array();\n  /** Source map index. */\n  debugInfoIndex: i32 = -1;\n  /** Re-exported sources. */\n  exportPaths: string[] | null = null;\n\n  /** Checks if this source represents native code. */\n  get isNative(): bool {\n    return this.internalPath == LIBRARY_SUBST;\n  }\n\n  /** Checks if this source is part of the (standard) library. */\n  get isLibrary(): bool {\n    let kind = this.sourceKind;\n    return kind == SourceKind.Library || kind == SourceKind.LibraryEntry;\n  }\n\n  /** Cached line starts. */\n  private lineCache: i32[] | null = null;\n\n  /** Remembered column number. */\n  private lineColumn: i32 = 1;\n\n  /** Determines the line number at the specified position. Starts at `1`. */\n  lineAt(pos: i32): i32 {\n    assert(pos >= 0 && pos < 0x7fffffff);\n    let lineCache = this.lineCache;\n    if (!lineCache) {\n      this.lineCache = lineCache = [0];\n      let text = this.text;\n      let off = 0;\n      let end = text.length;\n      while (off < end) {\n        if (text.charCodeAt(off++) == CharCode.LineFeed) lineCache.push(off);\n      }\n      lineCache.push(0x7fffffff);\n    }\n    let l = 0;\n    let r = lineCache.length - 1;\n    while (l < r) {\n      let m = l + ((r - l) >> 1);\n      let s = unchecked(lineCache[m]);\n      if (pos < s) r = m;\n      else if (pos < unchecked(lineCache[m + 1])) {\n        this.lineColumn = pos - s + 1;\n        return m + 1;\n      }\n      else l = m + 1;\n    }\n    return assert(0);\n  }\n\n  /** Gets the column number at the last position queried with `lineAt`. Starts at `1`. */\n  columnAt(): i32 {\n    return this.lineColumn;\n  }\n}\n\n/** Base class of all declaration statements. */\nexport abstract class DeclarationStatement extends Statement {\n  constructor(\n    /** Declaration node kind. */\n    kind: NodeKind,\n    /** Simple name being declared. */\n    public name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    public decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    public flags: CommonFlags,\n    /** Source range. */\n    range: Range\n  ) {\n    super(kind, range);\n  }\n  /** Overridden module name from preceeding `module` statement. */\n  public overriddenModuleName: string | null = null;\n\n  /** Tests if this node has the specified flag or flags. */\n  is(flag: CommonFlags): bool { return (this.flags & flag) == flag; }\n  /** Tests if this node has one of the specified flags. */\n  isAny(flag: CommonFlags): bool { return (this.flags & flag) != 0; }\n  /** Sets a specific flag or flags. */\n  set(flag: CommonFlags): void { this.flags |= flag; }\n}\n\n/** Represents an index signature. */\nexport class IndexSignatureNode extends Node {\n  constructor(\n    /** Key type. */\n    public keyType: NamedTypeNode,\n    /** Value type. */\n    public valueType: TypeNode,\n    /** Common flags indicating specific traits. */\n    public flags: CommonFlags,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.IndexSignature, range);\n  }\n}\n\n/** Base class of all variable-like declaration statements. */\nexport abstract class VariableLikeDeclarationStatement extends DeclarationStatement {\n  constructor(\n    /** Variable-like declaration node kind. */\n    kind: NodeKind,\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Annotated type node, if any. */\n    public type: TypeNode | null,\n    /** Initializer expression, if any. */\n    public initializer: Expression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(kind, name, decorators, flags, range);\n  }\n}\n\n/** Represents a block statement. */\nexport class BlockStatement extends Statement {\n  constructor(\n    /** Contained statements. */\n    public statements: Statement[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Block, range);\n  }\n}\n\n/** Represents a `break` statement. */\nexport class BreakStatement extends Statement {\n  constructor(\n    /** Target label, if any. */\n    public label: IdentifierExpression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Break, range);\n  }\n}\n\n/** Represents a `class` declaration. */\nexport class ClassDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Accepted type parameters. */\n    public typeParameters: TypeParameterNode[] | null,\n    /** Base class type being extended, if any. */\n    public extendsType: NamedTypeNode | null, // can't be a function\n    /** Interface types being implemented, if any. */\n    public implementsTypes: NamedTypeNode[] | null, // can't be functions\n    /** Class member declarations. */\n    public members: DeclarationStatement[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ClassDeclaration, name, decorators, flags, range);\n  }\n\n  /** Index signature, if present. */\n  indexSignature: IndexSignatureNode | null = null;\n\n  get isGeneric(): bool {\n    let typeParameters = this.typeParameters;\n    return typeParameters != null && typeParameters.length > 0;\n  }\n}\n\n/** Represents a `continue` statement. */\nexport class ContinueStatement extends Statement {\n  constructor(\n    /** Target label, if applicable. */\n    public label: IdentifierExpression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Continue, range);\n  }\n}\n\n/** Represents a `do` statement. */\nexport class DoStatement extends Statement {\n  constructor(\n    /** Body statement being looped over. */\n    public body: Statement,\n    /** Condition when to repeat. */\n    public condition: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Do, range);\n  }\n}\n\n/** Represents an empty statement, i.e., a semicolon terminating nothing. */\nexport class EmptyStatement extends Statement {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Empty, range);\n  }\n}\n\n/** Represents an `enum` declaration. */\nexport class EnumDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Enum value declarations. */\n    public values: EnumValueDeclaration[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.EnumDeclaration, name, decorators, flags, range);\n  }\n}\n\n/** Represents a value of an `enum` declaration. */\nexport class EnumValueDeclaration extends VariableLikeDeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Initializer expression, if any. */\n    initializer: Expression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.EnumValueDeclaration, name, null, flags, null, initializer, range);\n  }\n}\n\n/** Represents an `export import` statement of an interface. */\nexport class ExportImportStatement extends Statement {\n  constructor(\n    /** Identifier being imported. */\n    public name: IdentifierExpression,\n    /** Identifier being exported. */\n    public externalName: IdentifierExpression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ExportImport, range);\n  }\n}\n\n/** Represents a member of an `export` statement. */\nexport class ExportMember extends Node {\n  constructor(\n    /** Local identifier. */\n    public localName: IdentifierExpression,\n    /** Exported identifier. */\n    public exportedName: IdentifierExpression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ExportMember, range);\n  }\n}\n\n/** Represents an `export` statement. */\nexport class ExportStatement extends Statement {\n  constructor(\n    /** Array of members if a set of named exports, or `null` if a file export. */\n    public members: ExportMember[] | null,\n    /** Path being exported from, if applicable. */\n    public path: StringLiteralExpression | null,\n    /** Whether this is a declared export. */\n    public isDeclare: bool,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Export, range);\n    if (path) {\n      let normalizedPath = normalizePath(path.value);\n      if (path.value.startsWith(\".\")) { // relative\n        normalizedPath = resolvePath(normalizedPath, range.source.internalPath);\n      } else { // absolute\n        if (!normalizedPath.startsWith(LIBRARY_PREFIX)) normalizedPath = LIBRARY_PREFIX + normalizedPath;\n      }\n      this.internalPath = normalizedPath;\n    } else {\n      this.internalPath = null;\n    }\n  }\n\n  /** Internal path being referenced, if `path` is set. */\n  internalPath: string | null;\n}\n\n/** Represents an `export default` statement. */\nexport class ExportDefaultStatement extends Statement {\n  constructor(\n    /** Declaration being exported as default. */\n    public declaration: DeclarationStatement,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ExportDefault, range);\n  }\n}\n\n/** Represents an expression that is used as a statement. */\nexport class ExpressionStatement extends Statement {\n  constructor(\n    /** Expression being used as a statement.*/\n    public expression: Expression\n  ) {\n    super(NodeKind.Expression, expression.range);\n  }\n}\n\n/** Represents a field declaration within a `class`. */\nexport class FieldDeclaration extends VariableLikeDeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Annotated type node, if any. */\n    type: TypeNode | null,\n    /** Initializer expression, if any. */\n    initializer: Expression | null,\n    /** Parameter index if declared as a constructor parameter, otherwise `-1`. */\n    public parameterIndex: i32,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.FieldDeclaration, name, decorators, flags, type, initializer, range);\n  }\n}\n\n/** Represents a `for` statement. */\nexport class ForStatement extends Statement {\n  constructor(\n    /** Initializer statement, if present. Either a `VariableStatement` or `ExpressionStatement`. */\n    public initializer: Statement | null,\n    /** Condition expression, if present. */\n    public condition: Expression | null,\n    /** Incrementor expression, if present. */\n    public incrementor: Expression | null,\n    /** Body statement being looped over. */\n    public body: Statement,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.For, range);\n  }\n}\n\n/** Represents a `for..of` statement. */\nexport class ForOfStatement extends Statement {\n  constructor(\n    /** Variable statement. Either a `VariableStatement` or `ExpressionStatement` of `IdentifierExpression`. */\n    public variable: Statement,\n    /** Iterable expression being iterated. */\n    public iterable: Expression,\n    /** Body statement being looped over. */\n    public body: Statement,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ForOf, range);\n  }\n}\n\n/** Indicates the kind of an array function. */\nexport const enum ArrowKind {\n  /** Not an arrow function. */\n  None,\n  /** Parenthesized parameter list. */\n  Parenthesized,\n  /** Single parameter without parenthesis. */\n  Single\n}\n\n/** Represents a `function` declaration. */\nexport class FunctionDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Type parameters, if any. */\n    public typeParameters: TypeParameterNode[] | null,\n    /** Function signature. */\n    public signature: FunctionTypeNode,\n    /** Body statement. Usually a block. */\n    public body: Statement | null,\n    /** Arrow function kind, if applicable. */\n    public arrowKind: ArrowKind,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.FunctionDeclaration, name, decorators, flags, range);\n  }\n\n  /** Gets if this function is generic. */\n  get isGeneric(): bool {\n    let typeParameters = this.typeParameters;\n    return typeParameters != null && typeParameters.length > 0;\n  }\n\n  /** Clones this function declaration. */\n  clone(): FunctionDeclaration {\n    return new FunctionDeclaration(\n      this.name,\n      this.decorators,\n      this.flags,\n      this.typeParameters,\n      this.signature,\n      this.body,\n      this.arrowKind,\n      this.range\n    );\n  }\n}\n\n/** Represents an `if` statement. */\nexport class IfStatement extends Statement {\n  constructor(\n    /** Condition. */\n    public condition: Expression,\n    /** Statement executed when condition is `true`. */\n    public ifTrue: Statement,\n    /** Statement executed when condition is `false`. */\n    public ifFalse: Statement | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.If, range);\n  }\n}\n\n/** Represents an `import` declaration part of an {@link ImportStatement}. */\nexport class ImportDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Identifier being imported. */\n    public foreignName: IdentifierExpression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ImportDeclaration, name, null, CommonFlags.None, range);\n  }\n}\n\n/** Represents an `import` statement. */\nexport class ImportStatement extends Statement {\n  constructor(\n    /** Array of member declarations or `null` if an asterisk import. */\n    public declarations: ImportDeclaration[] | null,\n    /** Name of the local namespace, if an asterisk import. */\n    public namespaceName: IdentifierExpression | null,\n    /** Path being imported from. */\n    public path: StringLiteralExpression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Import, range);\n    let normalizedPath = normalizePath(path.value);\n    if (path.value.startsWith(\".\")) { // relative in project\n      normalizedPath = resolvePath(normalizedPath, range.source.internalPath);\n    } else { // absolute in library\n      if (!normalizedPath.startsWith(LIBRARY_PREFIX)) normalizedPath = LIBRARY_PREFIX + normalizedPath;\n    }\n    this.internalPath = mangleInternalPath(normalizedPath);\n  }\n\n  /** Internal path being referenced. */\n  internalPath: string;\n}\n\n/** Represents an `interfarce` declaration. */\nexport class InterfaceDeclaration extends ClassDeclaration {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Accepted type parameters. */\n    typeParameters: TypeParameterNode[] | null,\n    /** Base class type being extended, if any. */\n    extendsType: NamedTypeNode | null, // can't be a function\n    /** Interface types being implemented, if any. */\n    implementsTypes: NamedTypeNode[] | null, // can't be functions\n    /** Class member declarations. */\n    members: DeclarationStatement[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(name, decorators, flags, typeParameters, extendsType, implementsTypes, members, range);\n    this.kind = NodeKind.InterfaceDeclaration;\n  }\n}\n\n/** Represents a method declaration within a `class`. */\nexport class MethodDeclaration extends FunctionDeclaration {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Type parameters, if any. */\n    typeParameters: TypeParameterNode[] | null,\n    /** Function signature. */\n    signature: FunctionTypeNode,\n    /** Body statement. Usually a block. */\n    body: Statement | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(name, decorators, flags, typeParameters, signature, body, ArrowKind.None, range);\n    this.kind = NodeKind.MethodDeclaration;\n  }\n}\n\n/** Represents a `namespace` declaration. */\nexport class NamespaceDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Array of namespace members. */\n    public members: Statement[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.NamespaceDeclaration, name, decorators, flags, range);\n  }\n}\n\n/** Represents a `return` statement. */\nexport class ReturnStatement extends Statement {\n  constructor(\n    /** Value expression being returned, if present. */\n    public value: Expression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Return, range);\n  }\n}\n\n/** Represents a single `case` within a `switch` statement. */\nexport class SwitchCase extends Node {\n  constructor(\n    /** Label expression. `null` indicates the default case. */\n    public label: Expression | null,\n    /** Contained statements. */\n    public statements: Statement[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.SwitchCase, range);\n  }\n\n  get isDefault(): bool {\n    return this.label == null;\n  }\n}\n\n/** Represents a `switch` statement. */\nexport class SwitchStatement extends Statement {\n  constructor(\n    /** Condition expression. */\n    public condition: Expression,\n    /** Contained cases. */\n    public cases: SwitchCase[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Switch, range);\n  }\n}\n\n/** Represents a `throw` statement. */\nexport class ThrowStatement extends Statement {\n  constructor(\n    /** Value expression being thrown. */\n    public value: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Throw, range);\n  }\n}\n\n/** Represents a `try` statement. */\nexport class TryStatement extends Statement {\n  constructor(\n    /** Contained statements. */\n    public bodyStatements: Statement[],\n    /** Exception variable name, if a `catch` clause is present. */\n    public catchVariable: IdentifierExpression | null,\n    /** Statements being executed on catch, if a `catch` clause is present. */\n    public catchStatements: Statement[] | null,\n    /** Statements being executed afterwards, if a `finally` clause is present. */\n    public finallyStatements: Statement[] | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Try, range);\n  }\n}\n\n/** Represents a `module` statement. */\nexport class ModuleDeclaration extends Statement {\n  constructor(\n    /** Module name. */\n    public moduleName: string,\n    /** Common flags indicating specific traits. */\n    public flags: CommonFlags,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Module, range);\n  }\n}\n\n/** Represents a `type` declaration. */\nexport class TypeDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Type parameters, if any. */\n    public typeParameters: TypeParameterNode[] | null,\n    /** Type being aliased. */\n    public type: TypeNode,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.TypeDeclaration, name, decorators, flags, range);\n  }\n}\n\n/** Represents a variable declaration part of a {@link VariableStatement}. */\nexport class VariableDeclaration extends VariableLikeDeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Annotated type node, if any. */\n    type: TypeNode | null,\n    /** Initializer expression, if any. */\n    initializer: Expression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.VariableDeclaration, name, decorators, flags, type, initializer, range);\n  }\n}\n\n/** Represents a variable statement wrapping {@link VariableDeclaration}s. */\nexport class VariableStatement extends Statement {\n  constructor(\n    /** Array of decorators. */\n    public decorators: DecoratorNode[] | null,\n    /** Array of member declarations. */\n    public declarations: VariableDeclaration[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Variable, range);\n  }\n}\n\n/** Represents a void statement dropping an expression's value. */\nexport class VoidStatement extends Statement {\n  constructor(\n    /** Expression being dropped. */\n    public expression: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Void, range);\n  }\n}\n\n/** Represents a `while` statement. */\nexport class WhileStatement extends Statement {\n  constructor(\n    /** Condition expression. */\n    public condition: Expression,\n    /** Body statement being looped over. */\n    public body: Statement,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.While, range);\n  }\n}\n\n/** Finds the first decorator matching the specified kind. */\nexport function findDecorator(kind: DecoratorKind, decorators: DecoratorNode[] | null): DecoratorNode | null {\n  if (decorators) {\n    for (let i = 0, k = decorators.length; i < k; ++i) {\n      let decorator = decorators[i];\n      if (decorator.decoratorKind == kind) return decorator;\n    }\n  }\n  return null;\n}\n\n/** Mangles an external to an internal path. */\nexport function mangleInternalPath(path: string): string {\n  if (path.endsWith(\"/\")) {\n    path += \"index\";\n  } else if (path.endsWith(\".ts\")) {\n    path = path.substring(0, path.length - 3);\n  }\n  return path;\n}\n\n/** Tests if the specified type node represents an omitted type. */\nexport function isTypeOmitted(type: TypeNode): bool {\n  if (type.kind == NodeKind.NamedType) {\n    let name = (<NamedTypeNode>type).name;\n    return !(name.next || name.identifier.text.length > 0);\n  }\n  return false;\n}\n", "/**\n * @fileoverview A TypeScript tokenizer modified for AssemblyScript.\n *\n * The `Tokenizer` scans over a source file and returns one syntactic token\n * at a time that the parser will combine to an abstract syntax tree.\n *\n * It skips over trivia like comments and whitespace and provides a general\n * mark/reset mechanism for the parser to utilize on ambiguous tokens, with\n * one token of lookahead otherwise.\n *\n * @license Apache-2.0\n */\n\nimport {\n  Range,\n  DiagnosticCode,\n  DiagnosticMessage,\n  DiagnosticEmitter\n} from \"./diagnostics\";\n\nimport {\n  Source,\n  CommentKind\n} from \"./ast\";\n\nimport {\n  CharCode,\n  isLineBreak,\n  isWhiteSpace,\n  isIdentifierStart,\n  isIdentifierPart,\n  isDecimal,\n  isOctal,\n  isHexBase,\n  isHighSurrogate,\n  combineSurrogates,\n  numCodeUnits\n} from \"./util\";\n\n/** Named token types. */\nexport const enum Token {\n\n  // keywords\n  // discarded: ANY, BOOLEAN, NEVER, NUMBER, STRING, SYMBOL, UNDEFINED, LESSTHAN_SLASH\n\n  Abstract,\n  As,\n  Async,\n  Await,        // ES2017\n  Break,        // ES2017\n  Case,         // ES2017\n  Catch,        // ES2017\n  Class,        // ES2017\n  Const,        // ES2017\n  Continue,     // ES2017\n  Constructor,\n  Debugger,     // ES2017\n  Declare,\n  Default,      // ES2017\n  Delete,       // ES2017\n  Do,           // ES2017\n  Else,         // ES2017\n  Enum,         // ES2017 future\n  Export,       // ES2017\n  Extends,      // ES2017\n  False,        // ES\n  Finally,      // ES2017\n  For,          // ES2017\n  From,         // AS possible identifier\n  Function,     // ES2017\n  Get,\n  If,           // ES2017\n  Implements,   // ES2017 non-lexical\n  Import,       // ES2017\n  In,           // ES2017\n  InstanceOf,   // ES2017\n  Interface,    // ES2017 non-lexical\n  Is,\n  KeyOf,\n  Let,          // ES2017 non-lexical\n  Module,       // AS possible identifier\n  Namespace,    // AS possible identifier\n  New,          // ES2017\n  Null,         // ES\n  Of,\n  Override,\n  Package,      // ES2017 non-lexical\n  Private,      // ES2017 non-lexical\n  Protected,    // ES2017 non-lexical\n  Public,       // ES2017 non-lexical\n  Readonly,\n  Return,       // ES2017\n  Set,\n  Static,       // ES2017 non-lexical\n  Super,        // ES2017\n  Switch,       // ES2017\n  This,         // ES2017\n  Throw,        // ES2017\n  True,         // ES\n  Try,          // ES2017\n  Type,         // AS possible identifier\n  TypeOf,       // ES2017\n  Var,          // ES2017\n  Void,         // ES2017\n  While,        // ES2017\n  With,         // ES2017\n  Yield,        // ES2017\n\n  // punctuation\n\n  OpenBrace,\n  CloseBrace,\n  OpenParen,\n  CloseParen,\n  OpenBracket,\n  CloseBracket,\n  Dot,\n  Dot_Dot_Dot,\n  Semicolon,\n  Comma,\n  LessThan,\n  GreaterThan,\n  LessThan_Equals,\n  GreaterThan_Equals,\n  Equals_Equals,\n  Exclamation_Equals,\n  Equals_Equals_Equals,\n  Exclamation_Equals_Equals,\n  Equals_GreaterThan,\n  Plus,\n  Minus,\n  Asterisk_Asterisk,\n  Asterisk,\n  Slash,\n  Percent,\n  Plus_Plus,\n  Minus_Minus,\n  LessThan_LessThan,\n  GreaterThan_GreaterThan,\n  GreaterThan_GreaterThan_GreaterThan,\n  Ampersand,\n  Bar,\n  Caret,\n  Exclamation,\n  Tilde,\n  Ampersand_Ampersand,\n  Bar_Bar,\n  Question,\n  Colon,\n  Equals,\n  Plus_Equals,\n  Minus_Equals,\n  Asterisk_Equals,\n  Asterisk_Asterisk_Equals,\n  Slash_Equals,\n  Percent_Equals,\n  LessThan_LessThan_Equals,\n  GreaterThan_GreaterThan_Equals,\n  GreaterThan_GreaterThan_GreaterThan_Equals,\n  Ampersand_Equals,\n  Bar_Equals,\n  Caret_Equals,\n  At,\n\n  // literals\n\n  Identifier,\n  StringLiteral,\n  IntegerLiteral,\n  FloatLiteral,\n  TemplateLiteral,\n\n  // meta\n\n  Invalid,\n  EndOfFile\n}\n\nexport const enum IdentifierHandling {\n  Default,\n  Prefer,\n  Always\n}\n\nexport function tokenFromKeyword(text: string): Token {\n  let len = text.length;\n  assert(len);\n  switch (text.charCodeAt(0)) {\n    case CharCode.a: {\n      if (len == 5) {\n        if (text == \"async\") return Token.Async;\n        if (text == \"await\") return Token.Await;\n        break;\n      }\n      if (text == \"as\") return Token.As;\n      if (text == \"abstract\") return Token.Abstract;\n      break;\n    }\n    case CharCode.b: {\n      if (text == \"break\") return Token.Break;\n      break;\n    }\n    case CharCode.c: {\n      if (len == 5) {\n        if (text == \"const\") return Token.Const;\n        if (text == \"class\") return Token.Class;\n        if (text == \"catch\") return Token.Catch;\n        break;\n      }\n      if (text == \"case\") return Token.Case;\n      if (text == \"continue\") return Token.Continue;\n      if (text == \"constructor\") return Token.Constructor;\n      break;\n    }\n    case CharCode.d: {\n      if (len == 7) {\n        if (text == \"default\") return Token.Default;\n        if (text == \"declare\") return Token.Declare;\n        break;\n      }\n      if (text == \"do\") return Token.Do;\n      if (text == \"delete\") return Token.Delete;\n      if (text == \"debugger\") return Token.Debugger;\n      break;\n    }\n    case CharCode.e: {\n      if (len == 4) {\n        if (text == \"else\") return Token.Else;\n        if (text == \"enum\") return Token.Enum;\n        break;\n      }\n      if (text == \"export\") return Token.Export;\n      if (text == \"extends\") return Token.Extends;\n      break;\n    }\n    case CharCode.f: {\n      if (len <= 5) {\n        if (text == \"false\") return Token.False;\n        if (text == \"for\") return Token.For;\n        if (text == \"from\") return Token.From;\n        break;\n      }\n      if (text == \"function\") return Token.Function;\n      if (text == \"finally\") return Token.Finally;\n      break;\n    }\n    case CharCode.g: {\n      if (text == \"get\") return Token.Get;\n      break;\n    }\n    case CharCode.i: {\n      if (len == 2) {\n        if (text == \"if\") return Token.If;\n        if (text == \"in\") return Token.In;\n        if (text == \"is\") return Token.Is;\n        break;\n      }\n      switch (text.charCodeAt(3)) {\n        case CharCode.l: {\n          if (text == \"implements\") return Token.Implements;\n          break;\n        }\n        case CharCode.o: {\n          if (text == \"import\") return Token.Import;\n          break;\n        }\n        case CharCode.t: {\n          if (text == \"instanceof\") return Token.InstanceOf;\n          break;\n        }\n        case CharCode.e: {\n          if (text == \"interface\") return Token.Interface;\n          break;\n        }\n      }\n      break;\n    }\n    case CharCode.k: {\n      if (text == \"keyof\") return Token.KeyOf;\n      break;\n    }\n    case CharCode.l: {\n      if (text == \"let\") return Token.Let;\n      break;\n    }\n    case CharCode.m: {\n      if (text == \"module\") return Token.Module;\n      break;\n    }\n    case CharCode.n: {\n      if (text == \"new\") return Token.New;\n      if (text == \"null\") return Token.Null;\n      if (text == \"namespace\") return Token.Namespace;\n      break;\n    }\n    case CharCode.o: {\n      if (text == \"of\") return Token.Of;\n      if (text == \"override\") return Token.Override;\n      break;\n    }\n    case CharCode.p: {\n      if (len == 7) {\n        if (text == \"private\") return Token.Private;\n        if (text == \"package\") return Token.Package;\n        break;\n      }\n      if (text == \"public\") return Token.Public;\n      if (text == \"protected\") return Token.Protected;\n      break;\n    }\n    case CharCode.r: {\n      if (text == \"return\") return Token.Return;\n      if (text == \"readonly\") return Token.Readonly;\n      break;\n    }\n    case CharCode.s: {\n      if (len == 6) {\n        if (text == \"switch\") return Token.Switch;\n        if (text == \"static\") return Token.Static;\n        break;\n      }\n      if (text == \"set\") return Token.Set;\n      if (text == \"super\") return Token.Super;\n      break;\n    }\n    case CharCode.t: {\n      if (len == 4) {\n        if (text == \"true\") return Token.True;\n        if (text == \"this\") return Token.This;\n        if (text == \"type\") return Token.Type;\n        break;\n      }\n      if (text == \"try\") return Token.Try;\n      if (text == \"throw\") return Token.Throw;\n      if (text == \"typeof\") return Token.TypeOf;\n      break;\n    }\n    case CharCode.v: {\n      if (text == \"var\") return Token.Var;\n      if (text == \"void\") return Token.Void;\n      break;\n    }\n    case CharCode.w: {\n      if (text == \"while\") return Token.While;\n      if (text == \"with\") return Token.With;\n      break;\n    }\n    case CharCode.y: {\n      if (text == \"yield\") return Token.Yield;\n      break;\n    }\n  }\n  return Token.Invalid;\n}\n\nexport function tokenIsAlsoIdentifier(token: Token): bool {\n  switch (token) {\n    case Token.Abstract:\n    case Token.As:\n    case Token.Constructor:\n    case Token.Declare:\n    case Token.Delete:\n    case Token.From:\n    case Token.For:\n    case Token.Get:\n    case Token.InstanceOf:\n    case Token.Is:\n    case Token.KeyOf:\n    case Token.Module:\n    case Token.Namespace:\n    case Token.Null:\n    case Token.Readonly:\n    case Token.Set:\n    case Token.Type:\n    case Token.Void: return true;\n    default: return false;\n  }\n}\n\nexport function isIllegalVariableIdentifier(name: string): bool {\n  assert(name.length);\n  switch (name.charCodeAt(0)) {\n    case CharCode.d: return name == \"delete\";\n    case CharCode.f: return name == \"for\";\n    case CharCode.i: return name == \"instanceof\";\n    case CharCode.n: return name == \"null\";\n    case CharCode.v: return name == \"void\";\n  }\n  return false;\n}\n\nexport function operatorTokenToString(token: Token): string {\n  switch (token) {\n    case Token.Delete: return \"delete\";\n    case Token.In: return \"in\";\n    case Token.InstanceOf: return \"instanceof\";\n    case Token.New: return \"new\";\n    case Token.TypeOf: return \"typeof\";\n    case Token.Void: return \"void\";\n    case Token.Yield: return \"yield\";\n    case Token.Dot_Dot_Dot: return \"...\";\n    case Token.Comma: return \",\";\n    case Token.LessThan: return \"<\";\n    case Token.GreaterThan: return \">\";\n    case Token.LessThan_Equals: return \"<=\";\n    case Token.GreaterThan_Equals: return \">=\";\n    case Token.Equals_Equals: return \"==\";\n    case Token.Exclamation_Equals: return \"!=\";\n    case Token.Equals_Equals_Equals: return \"===\";\n    case Token.Exclamation_Equals_Equals: return \"!==\";\n    case Token.Plus: return \"+\";\n    case Token.Minus: return \"-\";\n    case Token.Asterisk_Asterisk: return \"**\";\n    case Token.Asterisk: return \"*\";\n    case Token.Slash: return \"/\";\n    case Token.Percent: return \"%\";\n    case Token.Plus_Plus: return \"++\";\n    case Token.Minus_Minus: return \"--\";\n    case Token.LessThan_LessThan: return \"<<\";\n    case Token.GreaterThan_GreaterThan: return \">>\";\n    case Token.GreaterThan_GreaterThan_GreaterThan: return \">>>\";\n    case Token.Ampersand: return \"&\";\n    case Token.Bar: return \"|\";\n    case Token.Caret: return \"^\";\n    case Token.Exclamation: return \"!\";\n    case Token.Tilde: return \"~\";\n    case Token.Ampersand_Ampersand: return \"&&\";\n    case Token.Bar_Bar: return \"||\";\n    case Token.Equals: return \"=\";\n    case Token.Plus_Equals: return \"+=\";\n    case Token.Minus_Equals: return \"-=\";\n    case Token.Asterisk_Equals: return \"*=\";\n    case Token.Asterisk_Asterisk_Equals: return \"**=\";\n    case Token.Slash_Equals: return \"/=\";\n    case Token.Percent_Equals: return \"%=\";\n    case Token.LessThan_LessThan_Equals: return \"<<=\";\n    case Token.GreaterThan_GreaterThan_Equals: return \">>=\";\n    case Token.GreaterThan_GreaterThan_GreaterThan_Equals: return \">>>=\";\n    case Token.Ampersand_Equals: return \"&=\";\n    case Token.Bar_Equals: return \"|=\";\n    case Token.Caret_Equals: return \"^=\";\n    default: {\n      assert(false);\n      return \"\";\n    }\n  }\n}\n\n/** Handler for intercepting comments while tokenizing. */\nexport type CommentHandler = (kind: CommentKind, text: string, range: Range) => void;\n\n/** Whether a token begins on a new line, if known. */\nenum OnNewLine {\n  No,\n  Yes,\n  Unknown\n}\n\n/** Tokenizes a source to individual {@link Token}s. */\nexport class Tokenizer extends DiagnosticEmitter {\n\n  source: Source;\n  end: i32 = 0;\n\n  pos: i32 = 0;\n  // @ts-expect-error\n  token: Token = -1;\n  tokenPos: i32 = 0;\n\n  // @ts-expect-error\n  nextToken: Token = -1;\n  nextTokenPos: i32 = 0;\n  nextTokenOnNewLine: OnNewLine = OnNewLine.Unknown;\n\n  onComment: CommentHandler | null = null;\n\n  /** Constructs a new tokenizer. */\n  constructor(source: Source, diagnostics: DiagnosticMessage[] | null = null) {\n    super(diagnostics);\n\n    if (!diagnostics) diagnostics = [];\n    this.diagnostics = diagnostics;\n    this.source = source;\n\n    let text = source.text;\n    let end = text.length;\n    let pos = 0;\n    // skip bom\n    if (\n      pos < end &&\n      text.charCodeAt(pos) == CharCode.ByteOrderMark\n    ) {\n      ++pos;\n    }\n\n    // skip shebang\n    if (\n      pos + 1 < end &&\n      text.charCodeAt(pos) == CharCode.Hash &&\n      text.charCodeAt(pos + 1) == CharCode.Exclamation\n    ) {\n      pos += 2;\n      while (\n        pos < end &&\n        text.charCodeAt(pos) != CharCode.LineFeed\n      ) {\n        ++pos;\n      }\n      // 'next' now starts at lf or eof\n    }\n    this.pos = pos;\n    this.end = end;\n  }\n\n  next(identifierHandling: IdentifierHandling = IdentifierHandling.Default): Token {\n    this.clearNextToken();\n    let token: Token;\n    do token = this.unsafeNext(identifierHandling);\n    while (token == Token.Invalid);\n    this.token = token;\n    return token;\n  }\n\n  private unsafeNext(\n    identifierHandling: IdentifierHandling = IdentifierHandling.Default,\n    maxTokenLength: i32 = i32.MAX_VALUE\n  ): Token {\n    let text = this.source.text;\n    let end = this.end;\n    let pos = this.pos;\n    while (pos < end) {\n      this.tokenPos = pos;\n      let c = text.charCodeAt(pos);\n      switch (c) {\n        case CharCode.CarriageReturn: {\n          if (!(\n            ++pos < end &&\n            text.charCodeAt(pos) == CharCode.LineFeed\n          )) break;\n          // otherwise fall-through\n        }\n        case CharCode.LineFeed:\n        case CharCode.Tab:\n        case CharCode.VerticalTab:\n        case CharCode.FormFeed:\n        case CharCode.Space: {\n          ++pos;\n          break;\n        }\n        case CharCode.Exclamation: {\n          ++pos;\n          if (\n            maxTokenLength > 1 && pos < end &&\n            text.charCodeAt(pos) == CharCode.Equals\n          ) {\n            ++pos;\n            if (\n              maxTokenLength > 2 && pos < end &&\n              text.charCodeAt(pos) == CharCode.Equals\n            ) {\n              this.pos = pos + 1;\n              return Token.Exclamation_Equals_Equals;\n            }\n            this.pos = pos;\n            return Token.Exclamation_Equals;\n          }\n          this.pos = pos;\n          return Token.Exclamation;\n        }\n        case CharCode.DoubleQuote:\n        case CharCode.SingleQuote: {\n          this.pos = pos;\n          return Token.StringLiteral;\n        }\n        case CharCode.Backtick: {\n          this.pos = pos;\n          return Token.TemplateLiteral;\n        }\n        case CharCode.Percent: {\n          ++pos;\n          if (\n            maxTokenLength > 1 && pos < end &&\n            text.charCodeAt(pos) == CharCode.Equals\n          ) {\n            this.pos = pos + 1;\n            return Token.Percent_Equals;\n          }\n          this.pos = pos;\n          return Token.Percent;\n        }\n        case CharCode.Ampersand: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.Ampersand) {\n              this.pos = pos + 1;\n              return Token.Ampersand_Ampersand;\n            }\n            if (chr == CharCode.Equals) {\n              this.pos = pos + 1;\n              return Token.Ampersand_Equals;\n            }\n          }\n          this.pos = pos;\n          return Token.Ampersand;\n        }\n        case CharCode.OpenParen: {\n          this.pos = pos + 1;\n          return Token.OpenParen;\n        }\n        case CharCode.CloseParen: {\n          this.pos = pos + 1;\n          return Token.CloseParen;\n        }\n        case CharCode.Asterisk: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.Equals) {\n              this.pos = pos + 1;\n              return Token.Asterisk_Equals;\n            }\n            if (chr == CharCode.Asterisk) {\n              ++pos;\n              if (\n                maxTokenLength > 2 && pos < end &&\n                text.charCodeAt(pos) == CharCode.Equals\n              ) {\n                this.pos = pos + 1;\n                return Token.Asterisk_Asterisk_Equals;\n              }\n              this.pos = pos;\n              return Token.Asterisk_Asterisk;\n            }\n          }\n          this.pos = pos;\n          return Token.Asterisk;\n        }\n        case CharCode.Plus: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.Plus) {\n              this.pos = pos + 1;\n              return Token.Plus_Plus;\n            }\n            if (chr == CharCode.Equals) {\n              this.pos = pos + 1;\n              return Token.Plus_Equals;\n            }\n          }\n          this.pos = pos;\n          return Token.Plus;\n        }\n        case CharCode.Comma: {\n          this.pos = pos + 1;\n          return Token.Comma;\n        }\n        case CharCode.Minus: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.Minus) {\n              this.pos = pos + 1;\n              return Token.Minus_Minus;\n            }\n            if (chr == CharCode.Equals) {\n              this.pos = pos + 1;\n              return Token.Minus_Equals;\n            }\n          }\n          this.pos = pos;\n          return Token.Minus;\n        }\n        case CharCode.Dot: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (isDecimal(chr)) {\n              this.pos = pos - 1;\n              return Token.FloatLiteral; // expects a call to readFloat\n            }\n            if (\n              maxTokenLength > 2 && pos + 1 < end &&\n              chr == CharCode.Dot &&\n              text.charCodeAt(pos + 1) == CharCode.Dot\n            ) {\n              this.pos = pos + 2;\n              return Token.Dot_Dot_Dot;\n            }\n          }\n          this.pos = pos;\n          return Token.Dot;\n        }\n        case CharCode.Slash: {\n          let commentStartPos = pos;\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.Slash) { // single-line\n              let commentKind = CommentKind.Line;\n              if (\n                pos + 1 < end &&\n                text.charCodeAt(pos + 1) == CharCode.Slash\n              ) {\n                ++pos;\n                commentKind = CommentKind.Triple;\n              }\n              while (++pos < end) {\n                if (text.charCodeAt(pos) == CharCode.LineFeed) {\n                  ++pos;\n                  break;\n                }\n              }\n              if (this.onComment) {\n                this.onComment(\n                  commentKind,\n                  text.substring(commentStartPos, pos),\n                  this.range(commentStartPos, pos)\n                );\n              }\n              break;\n            }\n            if (chr == CharCode.Asterisk) { // multi-line\n              let closed = false;\n              while (++pos < end) {\n                c = text.charCodeAt(pos);\n                if (\n                  c == CharCode.Asterisk &&\n                  pos + 1 < end &&\n                  text.charCodeAt(pos + 1) == CharCode.Slash\n                ) {\n                  pos += 2;\n                  closed = true;\n                  break;\n                }\n              }\n              if (!closed) {\n                this.error(\n                  DiagnosticCode._0_expected,\n                  this.range(pos), \"*/\"\n                );\n              } else if (this.onComment) {\n                this.onComment(\n                  CommentKind.Block,\n                  text.substring(commentStartPos, pos),\n                  this.range(commentStartPos, pos)\n                );\n              }\n              break;\n            }\n            if (chr == CharCode.Equals) {\n              this.pos = pos + 1;\n              return Token.Slash_Equals;\n            }\n          }\n          this.pos = pos;\n          return Token.Slash;\n        }\n        case CharCode._0:\n        case CharCode._1:\n        case CharCode._2:\n        case CharCode._3:\n        case CharCode._4:\n        case CharCode._5:\n        case CharCode._6:\n        case CharCode._7:\n        case CharCode._8:\n        case CharCode._9: {\n          this.pos = pos;\n          return this.testInteger()\n            ? Token.IntegerLiteral // expects a call to readInteger\n            : Token.FloatLiteral;  // expects a call to readFloat\n        }\n        case CharCode.Colon: {\n          this.pos = pos + 1;\n          return Token.Colon;\n        }\n        case CharCode.Semicolon: {\n          this.pos = pos + 1;\n          return Token.Semicolon;\n        }\n        case CharCode.LessThan: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.LessThan) {\n              ++pos;\n              if (\n                maxTokenLength > 2 &&\n                pos < end &&\n                text.charCodeAt(pos) == CharCode.Equals\n              ) {\n                this.pos = pos + 1;\n                return Token.LessThan_LessThan_Equals;\n              }\n              this.pos = pos;\n              return Token.LessThan_LessThan;\n            }\n            if (chr == CharCode.Equals) {\n              this.pos = pos + 1;\n              return Token.LessThan_Equals;\n            }\n          }\n          this.pos = pos;\n          return Token.LessThan;\n        }\n        case CharCode.Equals: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.Equals) {\n              ++pos;\n              if (\n                maxTokenLength > 2 &&\n                pos < end &&\n                text.charCodeAt(pos) == CharCode.Equals\n              ) {\n                this.pos = pos + 1;\n                return Token.Equals_Equals_Equals;\n              }\n              this.pos = pos;\n              return Token.Equals_Equals;\n            }\n            if (chr == CharCode.GreaterThan) {\n              this.pos = pos + 1;\n              return Token.Equals_GreaterThan;\n            }\n          }\n          this.pos = pos;\n          return Token.Equals;\n        }\n        case CharCode.GreaterThan: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.GreaterThan) {\n              ++pos;\n              if (maxTokenLength > 2 && pos < end) {\n                chr = text.charCodeAt(pos);\n                if (chr == CharCode.GreaterThan) {\n                  ++pos;\n                  if (\n                    maxTokenLength > 3 && pos < end &&\n                    text.charCodeAt(pos) == CharCode.Equals\n                  ) {\n                    this.pos = pos + 1;\n                    return Token.GreaterThan_GreaterThan_GreaterThan_Equals;\n                  }\n                  this.pos = pos;\n                  return Token.GreaterThan_GreaterThan_GreaterThan;\n                }\n                if (chr == CharCode.Equals) {\n                  this.pos = pos + 1;\n                  return Token.GreaterThan_GreaterThan_Equals;\n                }\n              }\n              this.pos = pos;\n              return Token.GreaterThan_GreaterThan;\n            }\n            if (chr == CharCode.Equals) {\n              this.pos = pos + 1;\n              return Token.GreaterThan_Equals;\n            }\n          }\n          this.pos = pos;\n          return Token.GreaterThan;\n        }\n        case CharCode.Question: {\n          this.pos = pos + 1;\n          return Token.Question;\n        }\n        case CharCode.OpenBracket: {\n          this.pos = pos + 1;\n          return Token.OpenBracket;\n        }\n        case CharCode.CloseBracket: {\n          this.pos = pos + 1;\n          return Token.CloseBracket;\n        }\n        case CharCode.Caret: {\n          ++pos;\n          if (\n            maxTokenLength > 1 && pos < end &&\n            text.charCodeAt(pos) == CharCode.Equals\n          ) {\n            this.pos = pos + 1;\n            return Token.Caret_Equals;\n          }\n          this.pos = pos;\n          return Token.Caret;\n        }\n        case CharCode.OpenBrace: {\n          this.pos = pos + 1;\n          return Token.OpenBrace;\n        }\n        case CharCode.Bar: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.Bar) {\n              this.pos = pos + 1;\n              return Token.Bar_Bar;\n            }\n            if (chr == CharCode.Equals) {\n              this.pos = pos + 1;\n              return Token.Bar_Equals;\n            }\n          }\n          this.pos = pos;\n          return Token.Bar;\n        }\n        case CharCode.CloseBrace: {\n          this.pos = pos + 1;\n          return Token.CloseBrace;\n        }\n        case CharCode.Tilde: {\n          this.pos = pos + 1;\n          return Token.Tilde;\n        }\n        case CharCode.At: {\n          this.pos = pos + 1;\n          return Token.At;\n        }\n        default: {\n          // Unicode-aware from here on\n          if (isHighSurrogate(c) && pos + 1 < end) {\n            c = combineSurrogates(c, text.charCodeAt(pos + 1));\n          }\n          if (isIdentifierStart(c)) {\n            let posBefore = pos;\n            while (\n              (pos += numCodeUnits(c)) < end &&\n              isIdentifierPart(c = <i32>text.codePointAt(pos))\n            ) { /* nop */ }\n            if (identifierHandling != IdentifierHandling.Always) {\n              let maybeKeywordToken = tokenFromKeyword(text.substring(posBefore, pos));\n              if (\n                maybeKeywordToken != Token.Invalid &&\n                !(\n                  identifierHandling == IdentifierHandling.Prefer &&\n                  tokenIsAlsoIdentifier(maybeKeywordToken)\n                )\n              ) {\n                this.pos = pos;\n                return maybeKeywordToken;\n              }\n            }\n            this.pos = posBefore;\n            return Token.Identifier;\n          } else if (isWhiteSpace(c)) {\n            ++pos; // assume no supplementary whitespaces\n            break;\n          }\n          let start = pos;\n          pos += numCodeUnits(c);\n          this.error(\n            DiagnosticCode.Invalid_character,\n            this.range(start, pos)\n          );\n          this.pos = pos;\n          return Token.Invalid;\n        }\n      }\n    }\n    this.pos = pos;\n    return Token.EndOfFile;\n  }\n\n  peek(\n    identifierHandling: IdentifierHandling = IdentifierHandling.Default,\n    maxCompoundLength: i32 = i32.MAX_VALUE\n  ): Token {\n    let nextToken = this.nextToken;\n    if (nextToken < 0) {\n      let posBefore = this.pos;\n      let tokenBefore = this.token;\n      let tokenPosBefore = this.tokenPos;\n      do nextToken = this.unsafeNext(identifierHandling, maxCompoundLength);\n      while (nextToken == Token.Invalid);\n      this.nextToken = nextToken;\n      this.nextTokenPos = this.tokenPos;\n      this.nextTokenOnNewLine = OnNewLine.Unknown;\n      this.pos = posBefore;\n      this.token = tokenBefore;\n      this.tokenPos = tokenPosBefore;\n    }\n    return nextToken;\n  }\n\n  peekOnNewLine(): bool {\n    switch (this.nextTokenOnNewLine) {\n      case OnNewLine.No: return false;\n      case OnNewLine.Yes: return true;\n    }\n    this.peek();\n    let text = this.source.text;\n    for (let pos = this.pos, end = this.nextTokenPos; pos < end; ++pos) {\n      if (isLineBreak(text.charCodeAt(pos))) {\n        this.nextTokenOnNewLine = OnNewLine.Yes;\n        return true;\n      }\n    }\n    this.nextTokenOnNewLine = OnNewLine.No;\n    return false;\n  }\n\n  skipIdentifier(identifierHandling: IdentifierHandling = IdentifierHandling.Prefer): bool {\n    return this.skip(Token.Identifier, identifierHandling);\n  }\n\n  skip(token: Token, identifierHandling: IdentifierHandling = IdentifierHandling.Default): bool {\n    let posBefore = this.pos;\n    let tokenBefore = this.token;\n    let tokenPosBefore = this.tokenPos;\n    let maxCompoundLength = i32.MAX_VALUE;\n    if (token == Token.GreaterThan) {  // where parsing type arguments\n      maxCompoundLength = 1;\n    }\n    let nextToken: Token;\n    do nextToken = this.unsafeNext(identifierHandling, maxCompoundLength);\n    while (nextToken == Token.Invalid);\n    if (nextToken == token) {\n      this.token = token;\n      this.clearNextToken();\n      return true;\n    } else {\n      this.pos = posBefore;\n      this.token = tokenBefore;\n      this.tokenPos = tokenPosBefore;\n      return false;\n    }\n  }\n\n  mark(): State {\n    let state = reusableState;\n    if (state) {\n      reusableState = null;\n      state.pos = this.pos;\n      state.token = this.token;\n      state.tokenPos = this.tokenPos;\n    } else {\n      state = new State(this.pos, this.token, this.tokenPos);\n    }\n    return state;\n  }\n\n  discard(state: State): void {\n    reusableState = state;\n  }\n\n  reset(state: State): void {\n    this.pos = state.pos;\n    this.token = state.token;\n    this.tokenPos = state.tokenPos;\n    this.clearNextToken();\n  }\n\n  clearNextToken(): void {\n    // @ts-expect-error\n    this.nextToken = -1;\n    this.nextTokenPos = 0;\n    this.nextTokenOnNewLine = OnNewLine.Unknown;\n  }\n\n  range(start: i32 = -1, end: i32 = -1): Range {\n    if (start < 0) {\n      start = this.tokenPos;\n      end = this.pos;\n    } else if (end < 0) {\n      end = start;\n    }\n    let range = new Range(start, end);\n    range.source = this.source;\n    return range;\n  }\n\n  readIdentifier(): string {\n    let text = this.source.text;\n    let end = this.end;\n    let pos = this.pos;\n    let start = pos;\n    let c = <i32>text.codePointAt(pos);\n    assert(isIdentifierStart(c));\n    while (\n      (pos += numCodeUnits(c)) < end &&\n      isIdentifierPart(c = <i32>text.codePointAt(pos))\n    );\n    this.pos = pos;\n    return text.substring(start, pos);\n  }\n\n  readingTemplateString: bool = false;\n  readStringStart: i32 = 0;\n  readStringEnd: i32 = 0;\n\n  readString(quote: i32 = 0, isTaggedTemplate: bool = false): string {\n    let text = this.source.text;\n    let end = this.end;\n    let pos = this.pos;\n    if (!quote) quote = text.charCodeAt(pos++);\n    let start = pos;\n    this.readStringStart = start;\n    let result = \"\";\n\n    while (true) {\n      if (pos >= end) {\n        result += text.substring(start, pos);\n        this.error(\n          DiagnosticCode.Unterminated_string_literal,\n          this.range(start - 1, end)\n        );\n        this.readStringEnd = end;\n        break;\n      }\n      let c = text.charCodeAt(pos);\n      if (c == quote) {\n        this.readStringEnd = pos;\n        result += text.substring(start, pos++);\n        break;\n      }\n      if (c == CharCode.Backslash) {\n        result += text.substring(start, pos);\n        this.pos = pos; // save\n        result += this.readEscapeSequence(isTaggedTemplate);\n        pos = this.pos; // restore\n        start = pos;\n        continue;\n      }\n      if (quote == CharCode.Backtick) {\n        if (c == CharCode.Dollar && pos + 1 < end && text.charCodeAt(pos + 1) == CharCode.OpenBrace) {\n          result += text.substring(start, pos);\n          this.readStringEnd = pos;\n          this.pos = pos + 2;\n          this.readingTemplateString = true;\n          return result;\n        }\n      } else if (isLineBreak(c)) {\n        result += text.substring(start, pos);\n        this.error(\n          DiagnosticCode.Unterminated_string_literal,\n          this.range(start - 1, pos)\n        );\n        this.readStringEnd = pos;\n        break;\n      }\n      ++pos;\n    }\n    this.pos = pos;\n    this.readingTemplateString = false;\n    return result;\n  }\n\n  readEscapeSequence(isTaggedTemplate: bool = false): string {\n    // for context on isTaggedTemplate, see: https://tc39.es/proposal-template-literal-revision/\n    let start = this.pos;\n    let end = this.end;\n    if (++this.pos >= end) {\n      this.error(\n        DiagnosticCode.Unexpected_end_of_text,\n        this.range(end)\n      );\n      return \"\";\n    }\n\n    let text = this.source.text;\n    let c = text.charCodeAt(this.pos++);\n    switch (c) {\n      case CharCode._0: {\n        if (isTaggedTemplate && this.pos < end && isDecimal(text.charCodeAt(this.pos))) {\n          ++this.pos;\n          return text.substring(start, this.pos);\n        }\n        return \"\\0\";\n      }\n      case CharCode.b: return \"\\b\";\n      case CharCode.t: return \"\\t\";\n      case CharCode.n: return \"\\n\";\n      case CharCode.v: return \"\\v\";\n      case CharCode.f: return \"\\f\";\n      case CharCode.r: return \"\\r\";\n      case CharCode.SingleQuote: return \"'\";\n      case CharCode.DoubleQuote: return \"\\\"\";\n      case CharCode.u: {\n        if (\n          this.pos < end &&\n          text.charCodeAt(this.pos) == CharCode.OpenBrace\n        ) {\n          ++this.pos;\n          return this.readExtendedUnicodeEscape(isTaggedTemplate ? start : -1); // \\u{DDDDDDDD}\n        }\n        return this.readUnicodeEscape(isTaggedTemplate ? start : -1); // \\uDDDD\n      }\n      case CharCode.x: {\n        return this.readHexadecimalEscape(2, isTaggedTemplate ? start : - 1); // \\xDD\n      }\n      case CharCode.CarriageReturn: {\n        if (\n          this.pos < end &&\n          text.charCodeAt(this.pos) == CharCode.LineFeed\n        ) {\n          ++this.pos;\n        }\n        // fall through\n      }\n      case CharCode.LineFeed:\n      case CharCode.LineSeparator:\n      case CharCode.ParagraphSeparator: return \"\";\n      default: return String.fromCodePoint(c);\n    }\n  }\n\n  readRegexpPattern(): string {\n    let text = this.source.text;\n    let start = this.pos;\n    let end = this.end;\n    let escaped = false;\n    while (true) {\n      if (this.pos >= end) {\n        this.error(\n          DiagnosticCode.Unterminated_regular_expression_literal,\n          this.range(start, end)\n        );\n        break;\n      }\n      if (text.charCodeAt(this.pos) == CharCode.Backslash) {\n        ++this.pos;\n        escaped = true;\n        continue;\n      }\n      let c = text.charCodeAt(this.pos);\n      if (!escaped && c == CharCode.Slash) break;\n      if (isLineBreak(c)) {\n        this.error(\n          DiagnosticCode.Unterminated_regular_expression_literal,\n          this.range(start, this.pos)\n        );\n        break;\n      }\n      ++this.pos;\n      escaped = false;\n    }\n    return text.substring(start, this.pos);\n  }\n\n  readRegexpFlags(): string {\n    let text = this.source.text;\n    let start = this.pos;\n    let end = this.end;\n    let flags = 0;\n    while (this.pos < end) {\n      let c: i32 = text.charCodeAt(this.pos);\n      if (!isIdentifierPart(c)) break;\n      ++this.pos;\n\n      // make sure each supported flag is unique\n      switch (c) {\n        case CharCode.g: {\n          flags |= flags & 1 ? -1 : 1;\n          break;\n        }\n        case CharCode.i: {\n          flags |= flags & 2 ? -1 : 2;\n          break;\n        }\n        case CharCode.m: {\n          flags |= flags & 4 ? -1 : 4;\n          break;\n        }\n        default: {\n          flags = -1;\n          break;\n        }\n      }\n    }\n    if (flags == -1) {\n      this.error(\n        DiagnosticCode.Invalid_regular_expression_flags,\n        this.range(start, this.pos)\n      );\n    }\n    return text.substring(start, this.pos);\n  }\n\n  testInteger(): bool {\n    let text = this.source.text;\n    let pos = this.pos;\n    let end = this.end;\n    if (pos + 1 < end && text.charCodeAt(pos) == CharCode._0) {\n      switch (text.charCodeAt(pos + 2) | 32) {\n        case CharCode.x:\n        case CharCode.b:\n        case CharCode.o: return true;\n      }\n    }\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n      if (c == CharCode.Dot || (c | 32) == CharCode.e) return false;\n      if (c != CharCode._ && (c < CharCode._0 || c > CharCode._9)) break;\n      // does not validate separator placement (this is done in readXYInteger)\n      pos++;\n    }\n    return true;\n  }\n\n  readInteger(): i64 {\n    let text = this.source.text;\n    let pos = this.pos;\n    if (pos + 2 < this.end && text.charCodeAt(pos) == CharCode._0) {\n      switch (text.charCodeAt(pos + 1) | 32) {\n        case CharCode.x: {\n          this.pos = pos + 2;\n          return this.readHexInteger();\n        }\n        case CharCode.b: {\n          this.pos = pos + 2;\n          return this.readBinaryInteger();\n        }\n        case CharCode.o: {\n          this.pos = pos + 2;\n          return this.readOctalInteger();\n        }\n      }\n      if (isOctal(text.charCodeAt(pos + 1))) {\n        let start = pos;\n        this.pos = pos + 1;\n        let value = this.readOctalInteger();\n        this.error(\n          DiagnosticCode.Octal_literals_are_not_allowed_in_strict_mode,\n          this.range(start, this.pos)\n        );\n        return value;\n      }\n    }\n    return this.readDecimalInteger();\n  }\n\n  readHexInteger(): i64 {\n    let text = this.source.text;\n    let pos = this.pos;\n    let end = this.end;\n    let start = pos;\n    let sepEnd = start;\n    let value = i64_zero;\n    let i64_4 = i64_new(4);\n    let nextValue = value;\n    let overflowOccurred = false;\n\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n      if (isDecimal(c)) {\n        // (value << 4) + c - CharCode._0\n        nextValue = i64_add(\n          i64_shl(value, i64_4),\n          i64_new(c - CharCode._0)\n        );\n      } else if (isHexBase(c)) {\n        // (value << 4) + (c | 32) + (10 - CharCode.a)\n        nextValue = i64_add(\n          i64_shl(value, i64_4),\n          i64_new((c | 32) + (10 - CharCode.a))\n        );\n      } else if (c == CharCode._) {\n        if (sepEnd == pos) {\n          this.error(\n            sepEnd == start\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\n            this.range(pos)\n          );\n        }\n        sepEnd = pos + 1;\n      } else {\n        break;\n      }\n      if (i64_gt_u(value, nextValue)) {\n        // Unsigned overflow occurred\n        overflowOccurred = true;\n      }\n      value = nextValue;\n      ++pos;\n    }\n    if (pos == start) {\n      this.error(\n        DiagnosticCode.Hexadecimal_digit_expected,\n        this.range(start)\n      );\n    } else if (sepEnd == pos) {\n      this.error(\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\n        this.range(sepEnd - 1)\n      );\n    }\n    if (overflowOccurred) {\n      this.error(\n        DiagnosticCode.Literal_0_does_not_fit_into_i64_or_u64_types,\n        this.range(start - 2, pos),\n        this.source.text.substring(start - 2, pos)\n      );\n    }\n    this.pos = pos;\n    return value;\n  }\n\n  readDecimalInteger(): i64 {\n    let text = this.source.text;\n    let pos = this.pos;\n    let end = this.end;\n    let start = pos;\n    let sepEnd = start;\n    let value = i64_zero;\n    let i64_10 = i64_new(10);\n    let nextValue = value;\n    let overflowOccurred = false;\n\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n      if (isDecimal(c)) {\n        // value = value * 10 + c - CharCode._0;\n        nextValue = i64_add(\n          i64_mul(value, i64_10),\n          i64_new(c - CharCode._0)\n        );\n      } else if (c == CharCode._) {\n        if (sepEnd == pos) {\n          this.error(\n            sepEnd == start\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\n            this.range(pos)\n          );\n        } else if (pos - 1 == start && text.charCodeAt(pos - 1) == CharCode._0) {\n          this.error(\n            DiagnosticCode.Numeric_separators_are_not_allowed_here,\n            this.range(pos)\n          );\n        }\n        sepEnd = pos + 1;\n      } else {\n        break;\n      }\n      if (i64_gt_u(value, nextValue)) {\n        // Unsigned overflow occurred\n        overflowOccurred = true;\n      }\n      value = nextValue;\n      ++pos;\n    }\n    if (pos == start) {\n      this.error(\n        DiagnosticCode.Digit_expected,\n        this.range(start)\n      );\n    } else if (sepEnd == pos) {\n      this.error(\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\n        this.range(sepEnd - 1)\n      );\n    } else if (overflowOccurred) {\n      this.error(\n        DiagnosticCode.Literal_0_does_not_fit_into_i64_or_u64_types,\n        this.range(start, pos),\n        this.source.text.substring(start, pos)\n      );\n    }\n    this.pos = pos;\n    return value;\n  }\n\n  readOctalInteger(): i64 {\n    let text = this.source.text;\n    let pos = this.pos;\n    let end = this.end;\n    let start = pos;\n    let sepEnd = start;\n    let value = i64_zero;\n    let i64_3 = i64_new(3);\n    let nextValue = value;\n    let overflowOccurred = false;\n\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n      if (isOctal(c)) {\n        // (value << 3) + c - CharCode._0\n        nextValue = i64_add(\n          i64_shl(value, i64_3),\n          i64_new(c - CharCode._0)\n        );\n      } else if (c == CharCode._) {\n        if (sepEnd == pos) {\n          this.error(\n            sepEnd == start\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\n            this.range(pos)\n          );\n        }\n        sepEnd = pos + 1;\n      } else {\n        break;\n      }\n      if (i64_gt_u(value, nextValue)) {\n        // Unsigned overflow occurred\n        overflowOccurred = true;\n      }\n      value = nextValue;\n      ++pos;\n    }\n    if (pos == start) {\n      this.error(\n        DiagnosticCode.Octal_digit_expected,\n        this.range(start)\n      );\n    } else if (sepEnd == pos) {\n      this.error(\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\n        this.range(sepEnd - 1)\n      );\n    } else if (overflowOccurred) {\n      this.error(\n        DiagnosticCode.Literal_0_does_not_fit_into_i64_or_u64_types,\n        this.range(start - 2, pos),\n        this.source.text.substring(start - 2, pos)\n      );\n    }\n    this.pos = pos;\n    return value;\n  }\n\n  readBinaryInteger(): i64 {\n    let text = this.source.text;\n    let pos = this.pos;\n    let end = this.end;\n    let start = pos;\n    let sepEnd = start;\n    let value = i64_zero;\n    let nextValue = value;\n    let overflowOccurred = false;\n\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n      if (c == CharCode._0) {\n        // value << 1 | 0\n        nextValue = i64_shl(value, i64_one);\n      } else if (c == CharCode._1) {\n        // value << 1 | 1\n        nextValue = i64_or(\n          i64_shl(value, i64_one),\n          i64_one\n        );\n      } else if (c == CharCode._) {\n        if (sepEnd == pos) {\n          this.error(\n            sepEnd == start\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\n            this.range(pos)\n          );\n        }\n        sepEnd = pos + 1;\n      } else {\n        break;\n      }\n      if (i64_gt(value, nextValue)) {\n        // Overflow occurred\n        overflowOccurred = true;\n      }\n      value = nextValue;\n      ++pos;\n    }\n    if (pos == start) {\n      this.error(\n        DiagnosticCode.Binary_digit_expected,\n        this.range(start)\n      );\n    } else if (sepEnd == pos) {\n      this.error(\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\n        this.range(sepEnd - 1)\n      );\n    } else if (overflowOccurred) {\n      this.error(\n        DiagnosticCode.Literal_0_does_not_fit_into_i64_or_u64_types,\n        this.range(start - 2, pos),\n        this.source.text.substring(start - 2, pos)\n      );\n    }\n    this.pos = pos;\n    return value;\n  }\n\n  readFloat(): f64 {\n    // let text = this.source.text;\n    // if (text.charCodeAt(this.pos) == CharCode._0 && this.pos + 2 < this.end) {\n    //   switch (text.charCodeAt(this.pos + 1)) {\n    //     case CharCode.X:\n    //     case CharCode.x: {\n    //       this.pos += 2;\n    //       return this.readHexFloat();\n    //     }\n    //   }\n    // }\n    return this.readDecimalFloat();\n  }\n\n  readDecimalFloat(): f64 {\n    let text = this.source.text;\n    let end = this.end;\n    let start = this.pos;\n    let sepCount = this.readDecimalFloatPartial(false);\n    if (this.pos < end && text.charCodeAt(this.pos) == CharCode.Dot) {\n      ++this.pos;\n      sepCount += this.readDecimalFloatPartial();\n    }\n    if (this.pos < end) {\n      let c = text.charCodeAt(this.pos);\n      if ((c | 32) == CharCode.e) {\n        if (\n          ++this.pos < end &&\n          (c = text.charCodeAt(this.pos)) == CharCode.Minus || c == CharCode.Plus &&\n          isDecimal(text.charCodeAt(this.pos + 1))\n        ) {\n          ++this.pos;\n        }\n        sepCount += this.readDecimalFloatPartial();\n      }\n    }\n    let result = text.substring(start, this.pos);\n    if (sepCount) result = result.replaceAll(\"_\", \"\");\n    return parseFloat(result);\n  }\n\n  /** Reads past one section of a decimal float literal. Returns the number of separators encountered. */\n  private readDecimalFloatPartial(allowLeadingZeroSep: bool = true): u32 {\n    let text = this.source.text;\n    let pos = this.pos;\n    let start = pos;\n    let end = this.end;\n    let sepEnd = start;\n    let sepCount = 0;\n\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n\n      if (c == CharCode._) {\n        if (sepEnd == pos) {\n          this.error(\n            sepEnd == start\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\n            this.range(pos)\n          );\n        } else if (!allowLeadingZeroSep && pos - 1 == start && text.charCodeAt(pos - 1) == CharCode._0) {\n          this.error(\n            DiagnosticCode.Numeric_separators_are_not_allowed_here,\n            this.range(pos)\n          );\n        }\n        sepEnd = pos + 1;\n        ++sepCount;\n      } else if (!isDecimal(c)) {\n        break;\n      }\n      ++pos;\n    }\n\n    if (pos != start && sepEnd == pos) {\n      this.error(\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\n        this.range(sepEnd - 1)\n      );\n    }\n\n    this.pos = pos;\n    return sepCount;\n  }\n\n  readHexFloat(): f64 {\n    throw new Error(\"not implemented\"); // TBD\n  }\n\n  readHexadecimalEscape(remain: i32 = 2, startIfTaggedTemplate: i32 = -1): string {\n    let value = 0;\n    let text = this.source.text;\n    let pos = this.pos;\n    let end = this.end;\n    while (pos < end) {\n      let c = text.charCodeAt(pos++);\n      if (isDecimal(c)) {\n        value = (value << 4) + c - CharCode._0;\n      } else if (isHexBase(c)) {\n        value = (value << 4) + (c | 32) + (10 - CharCode.a);\n      } else if (~startIfTaggedTemplate) {\n        this.pos = --pos;\n        return text.substring(startIfTaggedTemplate, pos);\n      } else {\n        this.pos = pos;\n        this.error(\n          DiagnosticCode.Hexadecimal_digit_expected,\n          this.range(pos - 1, pos)\n        );\n        return \"\";\n      }\n      if (--remain == 0) break;\n    }\n    if (remain) { // invalid\n      this.pos = pos;\n      if (~startIfTaggedTemplate) {\n        return text.substring(startIfTaggedTemplate, pos);\n      }\n      this.error(\n        DiagnosticCode.Unexpected_end_of_text,\n        this.range(pos)\n      );\n      return \"\";\n    }\n    this.pos = pos;\n    return String.fromCodePoint(value);\n  }\n\n  checkForIdentifierStartAfterNumericLiteral(): void {\n    // TODO: BigInt n\n    let pos = this.pos;\n    if (pos < this.end && isIdentifierStart(this.source.text.charCodeAt(pos))) {\n      this.error(\n        DiagnosticCode.An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal,\n        this.range(pos)\n      );\n    }\n  }\n\n  readUnicodeEscape(startIfTaggedTemplate: i32 = -1): string {\n    return this.readHexadecimalEscape(4, startIfTaggedTemplate);\n  }\n\n  private readExtendedUnicodeEscape(startIfTaggedTemplate: i32 = -1): string {\n    let start = this.pos;\n    let value = this.readHexInteger();\n    let value32 = i64_low(value);\n    let invalid = false;\n\n    assert(!i64_high(value));\n    if (value32 > 0x10FFFF) {\n      if (startIfTaggedTemplate == -1) {\n        this.error(\n          DiagnosticCode.An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive,\n          this.range(start, this.pos)\n        );\n      }\n      invalid = true;\n    }\n\n    let end = this.end;\n    let text = this.source.text;\n    if (this.pos >= end) {\n      if (startIfTaggedTemplate == -1) {\n        this.error(\n          DiagnosticCode.Unexpected_end_of_text,\n          this.range(start, end)\n        );\n      }\n      invalid = true;\n    } else if (text.charCodeAt(this.pos) == CharCode.CloseBrace) {\n      ++this.pos;\n    } else {\n      if (startIfTaggedTemplate == -1) {\n        this.error(\n          DiagnosticCode.Unterminated_Unicode_escape_sequence,\n          this.range(start, this.pos)\n        );\n      }\n      invalid = true;\n    }\n\n    if (invalid) {\n      return ~startIfTaggedTemplate\n        ? text.substring(startIfTaggedTemplate, this.pos)\n        : \"\";\n    }\n    return String.fromCodePoint(value32);\n  }\n}\n\n/** Tokenizer state as returned by {@link Tokenizer#mark} and consumed by {@link Tokenizer#reset}. */\nexport class State {\n  constructor(\n    /** Current position. */\n    public pos: i32,\n    /** Current token. */\n    public token: Token,\n    /** Current token's position. */\n    public tokenPos: i32\n  ) {}\n}\n\n// Reusable state object to reduce allocations\nlet reusableState: State | null = null;\n", "/**\n * @fileoverview A thin wrapper around Binaryen's C-API.\n *\n * The AssemblyScript compiler utilizes Binaryen's C-API directly. Even\n * though it currently imports binaryen.js, none of the JS APIs it\n * provides are used.\n *\n * @license Apache-2.0\n */\n\nimport { BuiltinNames } from \"./builtins\";\nimport { CommonNames, Target } from \"./common\";\nimport {\n  isHighSurrogate,\n  isLowSurrogate,\n  combineSurrogates,\n  SURROGATE_HIGH,\n  SURROGATE_LOW\n} from \"./util\";\nimport {\n  Type,\n  TypeFlags,\n  TypeKind\n} from \"./types\";\nimport {\n  ElementKind,\n  PropertyPrototype\n} from \"./program\";\nimport * as binaryen from \"./glue/binaryen\";\n\n/** A Binaryen-compatible index. */\nexport type Index = binaryen.Index;\n/** Reference to a Binaryen-compatible string. */\nexport type StringRef = binaryen.StringRef;\n/** Reference to a Binaryen module. */\nexport type ModuleRef = binaryen.ModuleRef;\n/** Reference to a Binaryen function. */\nexport type FunctionRef = binaryen.FunctionRef;\n/** Reference to a Binaryen expression. */\nexport type ExpressionRef = binaryen.ExpressionRef;\n/** Reference to a Binaryen global. */\nexport type GlobalRef = binaryen.GlobalRef;\n/** Reference to a Binaryen tag. */\nexport type TagRef = binaryen.TagRef;\n/** Reference to a Binaryen import. */\nexport type ImportRef = binaryen.ImportRef;\n/** Reference to a Binaryen export. */\nexport type ExportRef = binaryen.ExportRef;\n/** Reference to a Binaryen relooper. */\nexport type RelooperRef = binaryen.RelooperRef;\n/** Reference to a Binaryen relooper block. */\nexport type RelooperBlockRef = binaryen.RelooperBlockRef;\n\n// The following constants must be updated by running scripts/update-constants.\n// This is necessary because the functions are not yet callable with Binaryen\n// compiled to WebAssembly, requiring awaiting the ready promise first. Note\n// that this essentially fixes the compiler to specific versions of Binaryen\n// sometimes, because these constants can differ between Binaryen versions.\n\n/** Reference to a Binaryen type. */\nexport type TypeRef = binaryen.TypeRef;\nexport namespace TypeRef {\n  // special types\n  export const None: TypeRef = 0 /* _BinaryenTypeNone */;\n  export const Unreachable: TypeRef = 1 /* _BinaryenTypeUnreachable */;\n  // value types\n  export const I32: TypeRef = 2 /* _BinaryenTypeInt32 */;\n  export const I64: TypeRef = 3 /* _BinaryenTypeInt64 */;\n  export const F32: TypeRef = 4 /* _BinaryenTypeFloat32 */;\n  export const F64: TypeRef = 5 /* _BinaryenTypeFloat64 */;\n  export const V128: TypeRef = 6 /* _BinaryenTypeVec128 */;\n  // reference/gc types\n  export const Funcref = binaryen._BinaryenTypeFuncref();\n  export const Externref = binaryen._BinaryenTypeExternref();\n  export const Anyref = binaryen._BinaryenTypeAnyref();\n  export const Eqref = binaryen._BinaryenTypeEqref();\n  export const Structref = binaryen._BinaryenTypeStructref();\n  export const Arrayref = binaryen._BinaryenTypeArrayref();\n  export const I31ref = binaryen._BinaryenTypeI31ref();\n  export const Stringref = binaryen._BinaryenTypeStringref();\n  export const Noneref = binaryen._BinaryenTypeNullref();\n  export const Nofuncref = binaryen._BinaryenTypeNullFuncref();\n  export const Noexternref = binaryen._BinaryenTypeNullExternref();\n}\n\n/** Reference to a Binaryen heap type. */\nexport type HeapTypeRef = binaryen.HeapTypeRef;\nexport namespace HeapTypeRef {\n\n  //        any                  extern      func\n  //         |                      |          |\n  //     __ eq __          ?     noextern    (...)\n  //    /    |   \\         |                   |\n  // i31  struct  array  string              nofunc\n  //  |      |      |      |\n  // none  (...)  (...)    ?\n  //         |      |\n  //        none   none\n  //\n  // where (...) represents the concrete subtypes\n\n  export const Extern: HeapTypeRef = 8 /* _BinaryenHeapTypeExt */;\n  export const Func: HeapTypeRef = 16 /* _BinaryenHeapTypeFunc */;\n  export const Any: HeapTypeRef = 32 /* _BinaryenHeapTypeAny */;\n  export const Eq: HeapTypeRef = 40 /* _BinaryenHeapTypeEq */;\n  export const I31: HeapTypeRef = 48 /* _BinaryenHeapTypeI31 */;\n  export const Struct: HeapTypeRef = 56 /* _BinaryenHeapTypeStruct */;\n  export const Array: HeapTypeRef = 64 /* _BinaryenHeapTypeArray */;\n  export const Exn: HeapTypeRef = 7 /* TODO: BinaryenHeapTypeExn */;\n  export const String: HeapTypeRef = 80 /* _BinaryenHeapTypeString */;\n  export const None: HeapTypeRef = 88 /* _BinaryenHeapTypeNone */;\n  export const Noextern: HeapTypeRef = 96 /* _BinaryenHeapTypeNoext */;\n  export const Nofunc: HeapTypeRef = 104 /* _BinaryenHeapTypeNofunc */;\n\n  export function isBottom(ht: HeapTypeRef): bool {\n    return binaryen._BinaryenHeapTypeIsBottom(ht);\n  }\n\n  export function getBottom(ht: HeapTypeRef): HeapTypeRef {\n    return binaryen._BinaryenHeapTypeGetBottom(ht);\n  }\n\n  export function isSubtype(ht: HeapTypeRef, superHt: HeapTypeRef): bool {\n    return binaryen._BinaryenHeapTypeIsSubType(ht, superHt);\n  }\n\n  export function leastUpperBound(a: HeapTypeRef, b: HeapTypeRef): HeapTypeRef {\n    // see binaryen/src/wasm/wasm-type.cpp\n    if (a == b) return a;\n    if (getBottom(a) != getBottom(b)) return -1;\n    if (isBottom(a)) return b;\n    if (isBottom(b)) return a;\n    if (a > b) {\n      let t = a;\n      a = b;\n      b = t;\n    }\n    switch (a) {\n      case HeapTypeRef.Extern: return b == HeapTypeRef.String ? a : -1;\n      case HeapTypeRef.Func: return -1;\n      case HeapTypeRef.Any: return a;\n      case HeapTypeRef.Eq: {\n        return b == HeapTypeRef.I31 || b == HeapTypeRef.Struct || b == HeapTypeRef.Array\n          ? HeapTypeRef.Eq\n          : HeapTypeRef.Any;\n      }\n      case HeapTypeRef.I31: {\n        return b == HeapTypeRef.Struct || b == HeapTypeRef.Array\n          ? HeapTypeRef.Eq\n          : HeapTypeRef.Any;\n      }\n      case HeapTypeRef.Struct: {\n        return b == HeapTypeRef.Array\n          ? HeapTypeRef.Eq\n          : HeapTypeRef.Any;\n      }\n      case HeapTypeRef.Array: return HeapTypeRef.Any;\n    }\n    assert(false);\n    return -1;\n  }\n}\n\n/** Packed array element respectively struct field types. */\nexport type PackedType = binaryen.PackedType;\nexport namespace PackedType {\n  export const NotPacked: PackedType = 0 /* _BinaryenPackedTypeNotPacked */;\n  export const I8: PackedType = 1 /* _BinaryenPackedTypeInt8 */;\n  export const I16: PackedType = 2 /* _BinaryenPackedTypeInt16 */;\n}\n\n/** Type builder error reasons. */\nexport type TypeBuilderErrorReason = binaryen.TypeBuilderErrorReason;\nexport namespace TypeBuilderErrorReason {\n  /** Indicates a cycle in the supertype relation. */\n  export const SelfSupertype: TypeBuilderErrorReason = 0 /* _TypeBuilderErrorReasonSelfSupertype */;\n  /** Indicates that the declared supertype of a type is invalid. */\n  export const InvalidSupertype: TypeBuilderErrorReason = 1 /* _TypeBuilderErrorReasonInvalidSupertype */;\n  /** Indicates that the declared supertype is an invalid forward reference. */\n  export const ForwardSupertypeReference: TypeBuilderErrorReason = 2 /* _TypeBuilderErrorReasonForwardSupertypeReference */;\n  /** Indicates that a child of a type is an invalid forward reference. */\n  export const ForwardChildReference: TypeBuilderErrorReason = 3 /* _TypeBuilderErrorReasonForwardChildReference */;\n  /** Converts a type builder error reason to a string. */\n  export function toString(reason: TypeBuilderErrorReason): string {\n    switch (reason) {\n      case SelfSupertype: return \"SelfSupertype\";\n      case InvalidSupertype: return \"InvalidSupertype\";\n      case ForwardSupertypeReference: return \"ForwardSupertypeReference\";\n      case ForwardChildReference: return \"ForwardChildReference\";\n    }\n    assert(false);\n    return \"\";\n  }\n}\n\n/** Binaryen feature constants. */\nexport const enum FeatureFlags {\n  MVP = 0 /* _BinaryenFeatureMVP */,\n  Atomics = 1 /* _BinaryenFeatureAtomics */,\n  MutableGlobals = 2 /* _BinaryenFeatureMutableGlobals */,\n  TruncSat = 4 /* _BinaryenFeatureNontrappingFPToInt */,\n  SIMD = 8 /* _BinaryenFeatureSIMD128 */,\n  BulkMemory = 16 /* _BinaryenFeatureBulkMemory */,\n  SignExt = 32 /* _BinaryenFeatureSignExt */,\n  ExceptionHandling = 64 /* _BinaryenFeatureExceptionHandling */,\n  TailCall = 128 /* _BinaryenFeatureTailCall */,\n  ReferenceTypes = 256 /* _BinaryenFeatureReferenceTypes */,\n  MultiValue = 512 /* _BinaryenFeatureMultivalue */,\n  GC = 1024 /* _BinaryenFeatureGC */,\n  Memory64 = 2048 /* _BinaryenFeatureMemory64 */,\n  RelaxedSIMD = 4096 /* _BinaryenFeatureRelaxedSIMD */,\n  ExtendedConst = 8192 /* _BinaryenFeatureExtendedConst */,\n  Stringref = 16384 /* _BinaryenFeatureStrings */,\n  MultiMemory = 32768 /* _BinaryenFeatureMultiMemory */,\n  StackSwitching = 65536 /* _BinaryenFeatureStackSwitching */,\n  SharedEverything = 131072 /* _BinaryenFeatureSharedEverything */,\n  FP16 = 262144 /* _BinaryenFeatureFP16 */,\n  BulkMemoryOpt = 524288 /* _BinaryenFeatureBulkMemoryOpt */,\n  CallIndirectOverlong = 1048576 /* _BinaryenFeatureCallIndirectOverlong */,\n  All = 4194303 /* _BinaryenFeatureAll */\n}\n\n/** Binaryen expression id constants. See wasm-delegations.def in Binaryen. */\nexport const enum ExpressionId {\n  Invalid = 0 /* _BinaryenInvalidId */,\n  Block = 1 /* _BinaryenBlockId */,\n  If = 2 /* _BinaryenIfId */,\n  Loop = 3 /* _BinaryenLoopId */,\n  Break = 4 /* _BinaryenBreakId */,\n  Switch = 5 /* _BinaryenSwitchId */,\n  Call = 6 /* _BinaryenCallId */,\n  CallIndirect = 7 /* _BinaryenCallIndirectId */,\n  LocalGet = 8 /* _BinaryenLocalGetId */,\n  LocalSet = 9 /* _BinaryenLocalSetId */,\n  GlobalGet = 10 /* _BinaryenGlobalGetId */,\n  GlobalSet = 11 /* _BinaryenGlobalSetId */,\n  Load = 12 /* _BinaryenLoadId */,\n  Store = 13 /* _BinaryenStoreId */,\n  Const = 14 /* _BinaryenConstId */,\n  Unary = 15 /* _BinaryenUnaryId */,\n  Binary = 16 /* _BinaryenBinaryId */,\n  Select = 17 /* _BinaryenSelectId */,\n  Drop = 18 /* _BinaryenDropId */,\n  Return = 19 /* _BinaryenReturnId */,\n  MemorySize = 20 /* _BinaryenMemorySizeId */,\n  MemoryGrow = 21 /* _BinaryenMemoryGrowId */,\n  Nop = 22 /* _BinaryenNopId */,\n  Unreachable = 23 /* _BinaryenUnreachableId */,\n  AtomicRMW = 24 /* _BinaryenAtomicRMWId */,\n  AtomicCmpxchg = 25 /* _BinaryenAtomicCmpxchgId */,\n  AtomicWait = 26 /* _BinaryenAtomicWaitId */,\n  AtomicNotify = 27 /* _BinaryenAtomicNotifyId */,\n  AtomicFence = 28 /* _BinaryenAtomicFenceId */,\n  SIMDExtract = 29 /* _BinaryenSIMDExtractId */,\n  SIMDReplace = 30 /* _BinaryenSIMDReplaceId */,\n  SIMDShuffle = 31 /* _BinaryenSIMDShuffleId */,\n  SIMDTernary = 32 /* _BinaryenSIMDTernaryId */,\n  SIMDShift = 33 /* _BinaryenSIMDShiftId */,\n  SIMDLoad = 34 /* _BinaryenSIMDLoadId */,\n  SIMDLoadStoreLane = 35 /* _BinaryenSIMDLoadStoreLaneId */,\n  MemoryInit = 36 /* _BinaryenMemoryInitId */,\n  DataDrop = 37 /* _BinaryenDataDropId */,\n  MemoryCopy = 38 /* _BinaryenMemoryCopyId */,\n  MemoryFill = 39 /* _BinaryenMemoryFillId */,\n  Pop = 40 /* _BinaryenPopId */,\n  RefNull = 41 /* _BinaryenRefNullId */,\n  RefIsNull = 42 /* _BinaryenRefIsNullId */,\n  RefFunc = 43 /* _BinaryenRefFuncId */,\n  RefEq = 44 /* _BinaryenRefEqId */,\n  TableGet = 45 /* _BinaryenTableGetId */,\n  TableSet = 46 /* _BinaryenTableSetId */,\n  TableSize = 47 /* _BinaryenTableSizeId */,\n  TableGrow = 48 /* _BinaryenTableGrowId */,\n  TableFill = 49 /* _BinaryenTableFillId */,\n  TableCopy = 50 /* _BinaryenTableCopyId */,\n  TableInit = 51 /* _BinaryenTableInitId */,\n  Try = 52 /* _BinaryenTryId */,\n  TryTable = 53 /* _BinaryenTryTableId */,\n  Throw = 54 /* _BinaryenThrowId */,\n  Rethrow = 55 /* _BinaryenRethrowId */,\n  ThrowRef = 56 /* _BinaryenThrowRefId */,\n  TupleMake = 57 /* _BinaryenTupleMakeId */,\n  TupleExtract = 58 /* _BinaryenTupleExtractId */,\n  RefI31 = 59 /* _BinaryenRefI31Id */,\n  I31Get = 60 /* _BinaryenI31GetId */,\n  CallRef = 61 /* _BinaryenCallRefId */,\n  RefTest = 62 /* _BinaryenRefTestId */,\n  RefCast = 63 /* _BinaryenRefCastId */,\n  RefGetDesc = 64 /* _BinaryenRefGetDescId */,\n  BrOn = 65 /* _BinaryenBrOnId */,\n  StructNew = 66 /* _BinaryenStructNewId */,\n  StructGet = 67 /* _BinaryenStructGetId */,\n  StructSet = 68 /* _BinaryenStructSetId */,\n  StructRMW = 69 /* _BinaryenStructRMWId */,\n  StructCmpxchg = 70 /* _BinaryenStructCmpxchgId */,\n  ArrayNew = 71 /* _BinaryenArrayNewId */,\n  ArrayNewData = 72 /* _BinaryenArrayNewDataId */,\n  ArrayNewElem = 73 /* _BinaryenArrayNewElemId */,\n  ArrayNewFixed = 74 /* _BinaryenArrayNewFixedId */,\n  ArrayGet = 75 /* _BinaryenArrayGetId */,\n  ArraySet = 76 /* _BinaryenArraySetId */,\n  ArrayLen = 77 /* _BinaryenArrayLenId */,\n  ArrayCopy = 78 /* _BinaryenArrayCopyId */,\n  ArrayFill = 79 /* _BinaryenArrayFillId */,\n  ArrayInitData = 80 /* _BinaryenArrayInitDataId */,\n  ArrayInitElem = 81 /* _BinaryenArrayInitElemId */,\n  RefAs = 82 /* _BinaryenRefAsId */,\n  StringNew = 83 /* _BinaryenStringNewId */,\n  StringConst = 84 /* _BinaryenStringConstId */,\n  StringMeasure = 85 /* _BinaryenStringMeasureId */,\n  StringEncode = 86 /* _BinaryenStringEncodeId */,\n  StringConcat = 87 /* _BinaryenStringConcatId */,\n  StringEq = 88 /* _BinaryenStringEqId */,\n  StringWTF16Get = 89 /* _BinaryenStringWTF16GetId */,\n  StringSliceWTF = 90 /* _BinaryenStringSliceWTFId */,\n  ContNew = 91 /* _BinaryenContNewId */,\n  ContBind = 92 /* _BinaryenContBindId */,\n  Suspend = 93 /* _BinaryenSuspendId */,\n  Resume = 94 /* _BinaryenResumeId */,\n  ResumeThrow = 95 /* _BinaryenResumeThrowId */,\n  StackSwitch = 96 /* _BinaryenStackSwitchId */\n}\n\n/** Binaryen external kind constants. */\nexport const enum ExternalKind {\n  Function = 0 /* _BinaryenExternalFunction */,\n  Table = 1 /* _BinaryenExternalTable */,\n  Memory = 2 /* _BinaryenExternalMemory */,\n  Global = 3 /* _BinaryenExternalGlobal */,\n  Tag = 4 /* _BinaryenExternalTag */\n}\n\n/** Binaryen unary operation constants. */\nexport const enum UnaryOp {\n  /** i32.clz */\n  ClzI32 = 0 /* _BinaryenClzInt32 */,\n  /** i64.clz */\n  ClzI64 = 1 /* _BinaryenClzInt64 */,\n  /** i32.ctz */\n  CtzI32 = 2 /* _BinaryenCtzInt32 */,\n  /** i64.ctz */\n  CtzI64 = 3 /* _BinaryenCtzInt64 */,\n  /** i32.popcnt */\n  PopcntI32 = 4 /* _BinaryenPopcntInt32 */,\n  /** i64.popcnt */\n  PopcntI64 = 5 /* _BinaryenPopcntInt64 */,\n  /** f32.neg */\n  NegF32 = 6 /* _BinaryenNegFloat32 */,\n  /** f64.neg */\n  NegF64 = 7 /* _BinaryenNegFloat64 */,\n  /** f32.abs */\n  AbsF32 = 8 /* _BinaryenAbsFloat32 */,\n  /** f64.abs */\n  AbsF64 = 9 /* _BinaryenAbsFloat64 */,\n  /** f32.ceil */\n  CeilF32 = 10 /* _BinaryenCeilFloat32 */,\n  /** f64.ceil */\n  CeilF64 = 11 /* _BinaryenCeilFloat64 */,\n  /** f32.floor */\n  FloorF32 = 12 /* _BinaryenFloorFloat32 */,\n  /** f64.floor */\n  FloorF64 = 13 /* _BinaryenFloorFloat64 */,\n  /** f32.trunc */\n  TruncF32 = 14 /* _BinaryenTruncFloat32 */,\n  /** f64.trunc */\n  TruncF64 = 15 /* _BinaryenTruncFloat64 */,\n  /** f32.nearest */\n  NearestF32 = 16 /* _BinaryenNearestFloat32 */,\n  /** f64.nearest */\n  NearestF64 = 17 /* _BinaryenNearestFloat64 */,\n  /** f32.sqrt */\n  SqrtF32 = 18 /* _BinaryenSqrtFloat32 */,\n  /** f64.sqrt */\n  SqrtF64 = 19 /* _BinaryenSqrtFloat64 */,\n  /** i32.eqz */\n  EqzI32 = 20 /* _BinaryenEqZInt32 */,\n  /** i64.eqz */\n  EqzI64 = 21 /* _BinaryenEqZInt64 */,\n  /** i64.extend_i32_s */\n  ExtendI32ToI64 = 22 /* _BinaryenExtendSInt32 */,\n  /** i64.extend_i32_u */\n  ExtendU32ToU64 = 23 /* _BinaryenExtendUInt32 */,\n  /** i32.wrap_i64 */\n  WrapI64ToI32 = 24 /* _BinaryenWrapInt64 */,\n  /** i32.trunc_f32_s */\n  TruncF32ToI32 = 25 /* _BinaryenTruncSFloat32ToInt32 */,\n  /** i64.trunc_f32_s */\n  TruncF32ToI64 = 26 /* _BinaryenTruncSFloat32ToInt64 */,\n  /** i32.trunc_f32_u */\n  TruncF32ToU32 = 27 /* _BinaryenTruncUFloat32ToInt32 */,\n  /** i64.trunc_f32_u */\n  TruncF32ToU64 = 28 /* _BinaryenTruncUFloat32ToInt64 */,\n  /** i32.trunc_f64_s */\n  TruncF64ToI32 = 29 /* _BinaryenTruncSFloat64ToInt32 */,\n  /** i64.trunc_f64_s */\n  TruncF64ToI64 = 30 /* _BinaryenTruncSFloat64ToInt64 */,\n  /** i32.trunc_f64_u */\n  TruncF64ToU32 = 31 /* _BinaryenTruncUFloat64ToInt32 */,\n  /** i64.trunc_f64_u */\n  TruncF64ToU64 = 32 /* _BinaryenTruncUFloat64ToInt64 */,\n  /** i32.reinterpret_f32 */\n  ReinterpretF32ToI32 = 33 /* _BinaryenReinterpretFloat32 */,\n  /** i64.reinterpret_f64 */\n  ReinterpretF64ToI64 = 34 /* _BinaryenReinterpretFloat64 */,\n  /** f32.convert_i32_s */\n  ConvertI32ToF32 = 35 /* _BinaryenConvertSInt32ToFloat32 */,\n  /** f64.convert_i32_s */\n  ConvertI32ToF64 = 36 /* _BinaryenConvertSInt32ToFloat64 */,\n  /** f32.convert_i32_u */\n  ConvertU32ToF32 = 37 /* _BinaryenConvertUInt32ToFloat32 */,\n  /** f64.convert_i32_u */\n  ConvertU32ToF64 = 38 /* _BinaryenConvertUInt32ToFloat64 */,\n  /** f32.convert_i64_s */\n  ConvertI64ToF32 = 39 /* _BinaryenConvertSInt64ToFloat32 */,\n  /** f64.convert_i64_s */\n  ConvertI64ToF64 = 40 /* _BinaryenConvertSInt64ToFloat64 */,\n  /** f32.convert_i64_u */\n  ConvertU64ToF32 = 41 /* _BinaryenConvertUInt64ToFloat32 */,\n  /** f64.convert_i64_u */\n  ConvertU64ToF64 = 42 /* _BinaryenConvertUInt64ToFloat64 */,\n  /** f64.promote.f32 */\n  PromoteF32ToF64 = 43 /* _BinaryenPromoteFloat32 */,\n  /** f32.demote_f64 */\n  DemoteF64ToF32 = 44 /* _BinaryenDemoteFloat64 */,\n  /** f32.reinterpret_i32 */\n  ReinterpretI32ToF32 = 45 /* _BinaryenReinterpretInt32 */,\n  /** f64.reinterpret_i64 */\n  ReinterpretI64ToF64 = 46 /* _BinaryenReinterpretInt64 */,\n\n  // see: https://github.com/WebAssembly/sign-extension-ops\n\n  /** i32.extend8_s */\n  Extend8I32 = 47 /* _BinaryenExtendS8Int32 */,\n  /** i32.extend16_s */\n  Extend16I32 = 48 /* _BinaryenExtendS16Int32 */,\n  /** i64.extend8_s */\n  Extend8I64 = 49 /* _BinaryenExtendS8Int64 */,\n  /** i64.extend16_s */\n  Extend16I64 = 50 /* _BinaryenExtendS16Int64 */,\n  /** i64.extend32_s (i64 in, i64 out) */\n  Extend32I64 = 51 /* _BinaryenExtendS32Int64 */,\n\n  // see: https://github.com/WebAssembly/nontrapping-float-to-int-conversions\n\n  /** i32.trunc_sat_f32_s */\n  TruncSatF32ToI32 = 52 /* _BinaryenTruncSatSFloat32ToInt32 */,\n  /** i32.trunc_sat_f32_u */\n  TruncSatF32ToU32 = 53 /* _BinaryenTruncSatUFloat32ToInt32 */,\n  /** i32.trunc_sat_f64_s */\n  TruncSatF64ToI32 = 54 /* _BinaryenTruncSatSFloat64ToInt32 */,\n  /** i32.trunc_sat_f64_u */\n  TruncSatF64ToU32 = 55 /* _BinaryenTruncSatUFloat64ToInt32 */,\n  /** i64.trunc_sat_f32_s */\n  TruncSatF32ToI64 = 56 /* _BinaryenTruncSatSFloat32ToInt64 */,\n  /** i64.trunc_sat_f32_u */\n  TruncSatF32ToU64 = 57 /* _BinaryenTruncSatUFloat32ToInt64 */,\n  /** i64.trunc_sat_f64_s */\n  TruncSatF64ToI64 = 58 /* _BinaryenTruncSatSFloat64ToInt64 */,\n  /** i64.trunc_sat_f64_u */\n  TruncSatF64ToU64 = 59 /* _BinaryenTruncSatUFloat64ToInt64 */,\n\n  // see: https://github.com/WebAssembly/simd\n\n  /** i8x16.splat */\n  SplatI8x16 = 60 /* _BinaryenSplatVecI8x16 */,\n  /** i16x8.splat */\n  SplatI16x8 = 61 /* _BinaryenSplatVecI16x8 */,\n  /** i32x4.splat */\n  SplatI32x4 = 62 /* _BinaryenSplatVecI32x4 */,\n  /** i64x2.splat */\n  SplatI64x2 = 63 /* _BinaryenSplatVecI64x2 */,\n  /** f32x4.splat */\n  SplatF32x4 = 64 /* _BinaryenSplatVecF32x4 */,\n  /** f64x2.splat */\n  SplatF64x2 = 65 /* _BinaryenSplatVecF64x2 */,\n  /** v128.not */\n  NotV128 = 66 /* _BinaryenNotVec128 */,\n  /** v128.any_true */\n  AnyTrueV128 = 67 /* _BinaryenAnyTrueVec128 */,\n  /** i8x16.abs */\n  AbsI8x16 = 68 /* _BinaryenAbsVecI8x16 */,\n  /** i8x16.neg */\n  NegI8x16 = 69 /* _BinaryenNegVecI8x16 */,\n  /** i8x16.all_true */\n  AllTrueI8x16 = 70 /* _BinaryenAllTrueVecI8x16 */,\n  /** i8x16.bitmask */\n  BitmaskI8x16 = 71 /* _BinaryenBitmaskVecI8x16 */,\n  /** i8x16.popcnt */\n  PopcntI8x16 = 72 /* _BinaryenPopcntVecI8x16 */,\n  /** i16x8.abs */\n  AbsI16x8 = 73 /* _BinaryenAbsVecI16x8 */,\n  /** i16x8.neg */\n  NegI16x8 = 74 /* _BinaryenNegVecI16x8 */,\n  /** i16x8.all_true */\n  AllTrueI16x8 = 75 /* _BinaryenAllTrueVecI16x8 */,\n  /** i16x8.bitmask */\n  BitmaskI16x8 = 76 /* _BinaryenBitmaskVecI16x8 */,\n  /** i32x4.abs */\n  AbsI32x4 = 77 /* _BinaryenAbsVecI32x4 */,\n  /** i32x4.neg */\n  NegI32x4 = 78 /* _BinaryenNegVecI32x4 */,\n  /** i32x4.all_true */\n  AllTrueI32x4 = 79 /* _BinaryenAllTrueVecI32x4 */,\n  /** i32x4.bitmask */\n  BitmaskI32x4 = 80 /* _BinaryenBitmaskVecI32x4 */,\n  /** i64x2.abs */\n  AbsI64x2 = 81 /* _BinaryenAbsVecI64x2 */,\n  /** i64x2.neg */\n  NegI64x2 = 82 /* _BinaryenNegVecI64x2 */,\n  /** i64x2.all_true */\n  AllTrueI64x2 = 83 /* _BinaryenAllTrueVecI64x2 */,\n  /** i64x2.bitmask */\n  BitmaskI64x2 = 84 /* _BinaryenBitmaskVecI64x2 */,\n  // FIXME FIXME FIXME DONT FORGET TODO: F16 (not in C API yet)\n  /** f32x4.abs */\n  AbsF32x4 = 92 /* _BinaryenAbsVecF32x4 */,\n  /** f32x4.neg */\n  NegF32x4 = 93 /* _BinaryenNegVecF32x4 */,\n  /** f32x4.sqrt */\n  SqrtF32x4 = 94 /* _BinaryenSqrtVecF32x4 */,\n  /** f32x4.ceil */\n  CeilF32x4 = 95 /* _BinaryenCeilVecF32x4 */,\n  /** f32x4.floor */\n  FloorF32x4 = 96 /* _BinaryenFloorVecF32x4 */,\n  /** f32x4.trunc */\n  TruncF32x4 = 97 /* _BinaryenTruncVecF32x4 */,\n  /** f32x4.nearest */\n  NearestF32x4 = 98 /* _BinaryenNearestVecF32x4 */,\n  /** f64x2.abs */\n  AbsF64x2 = 99 /* _BinaryenAbsVecF64x2 */,\n  /** f64x2.neg */\n  NegF64x2 = 100 /* _BinaryenNegVecF64x2 */,\n  /** f64x2.sqrt */\n  SqrtF64x2 = 101 /* _BinaryenSqrtVecF64x2 */,\n  /** f64x2.ceil */\n  CeilF64x2 = 102 /* _BinaryenCeilVecF64x2 */,\n  /** f64x2.floor */\n  FloorF64x2 = 103 /* _BinaryenFloorVecF64x2 */,\n  /** f64x2.trunc */\n  TruncF64x2 = 104 /* _BinaryenTruncVecF64x2 */,\n  /** f64x2.nearest */\n  NearestF64x2 = 105 /* _BinaryenNearestVecF64x2 */,\n  /** i16x8.extadd_pairwise_i8x16_s */\n  ExtaddPairwiseI8x16ToI16x8 = 106 /* _BinaryenExtAddPairwiseSVecI8x16ToI16x8 */,\n  /** i16x8.extadd_pairwise.i8x16_u */\n  ExtaddPairwiseU8x16ToU16x8 = 107 /* _BinaryenExtAddPairwiseUVecI8x16ToI16x8 */,\n  /** i32x4.extadd_pairwise.i16x8_s */\n  ExtaddPairwiseI16x8ToI32x4 = 108 /* _BinaryenExtAddPairwiseSVecI16x8ToI32x4 */,\n  /** i32x4.extadd_pairwise.i64x8_u */\n  ExtaddPairwiseU16x8ToU32x4 = 109 /* _BinaryenExtAddPairwiseUVecI16x8ToI32x4 */,\n  /** i32x4.trunc_sat_f32x4_s */\n  TruncSatF32x4ToI32x4 = 110 /* _BinaryenTruncSatSVecF32x4ToVecI32x4 */,\n  /** i32x4.trunc_sat_f32x4_u */\n  TruncSatF32x4ToU32x4 = 111 /* _BinaryenTruncSatUVecF32x4ToVecI32x4 */,\n  /** f32x4.convert_i32x4_s */\n  ConvertI32x4ToF32x4 = 112 /* _BinaryenConvertSVecI32x4ToVecF32x4 */,\n  /** f32x4.convert_i32x4_u */\n  ConvertU32x4ToF32x4 = 113 /* _BinaryenConvertUVecI32x4ToVecF32x4 */,\n  /** i16x8.extend_low_i8x16_s */\n  ExtendLowI8x16ToI16x8 = 114 /* _BinaryenExtendLowSVecI8x16ToVecI16x8 */,\n  /** i16x8.extend_high_i8x16_s */\n  ExtendHighI8x16ToI16x8 = 115 /* _BinaryenExtendHighSVecI8x16ToVecI16x8 */,\n  /** i16x8.extend_low_i8x16_u */\n  ExtendLowU8x16ToU16x8 = 116 /* _BinaryenExtendLowUVecI8x16ToVecI16x8 */,\n  /** i16x8.extend_high_i8x16_u */\n  ExtendHighU8x16ToU16x8 = 117 /* _BinaryenExtendHighUVecI8x16ToVecI16x8 */,\n  /** i32x4.extend_low_i16x8_s */\n  ExtendLowI16x8ToI32x4 = 118 /* _BinaryenExtendLowSVecI16x8ToVecI32x4 */,\n  /** i32x4.extend_high_i16x8_s */\n  ExtendHighI16x8ToI32x4 = 119 /* _BinaryenExtendHighSVecI16x8ToVecI32x4 */,\n  /** i32x4.extend_low_i16x8_u */\n  ExtendLowU16x8ToU32x4 = 120 /* _BinaryenExtendLowUVecI16x8ToVecI32x4 */,\n  /** i32x4.extend_high_i16x8_u */\n  ExtendHighU16x8ToU32x4 = 121 /* _BinaryenExtendHighUVecI16x8ToVecI32x4 */,\n  /** i64x2.extend_low_i32x4_s */\n  ExtendLowI32x4ToI64x2 = 122 /* _BinaryenExtendLowSVecI32x4ToVecI64x2 */,\n  /** i64x2.extend_high_i32x4_s */\n  ExtendHighI32x4ToI64x2 = 123 /* _BinaryenExtendHighSVecI32x4ToVecI64x2 */,\n  /** i64x2.extend_low_i32x4_u */\n  ExtendLowU32x4ToU64x2 = 124 /* _BinaryenExtendLowUVecI32x4ToVecI64x2 */,\n  /** i64x2.extend_high_i32x4_u */\n  ExtendHighU32x4ToU64x2 = 125 /* _BinaryenExtendHighUVecI32x4ToVecI64x2 */,\n  /** f32x4.convert_i32x4_s */\n  ConvertLowI32x4ToF64x2 = 126 /* _BinaryenConvertLowSVecI32x4ToVecF64x2 */,\n  /** f32x4.convert_i32x4_u */\n  ConvertLowU32x4ToF64x2 = 127 /* _BinaryenConvertLowUVecI32x4ToVecF64x2 */,\n  /** i32x4.trunc_sat_f64x2_s_zero */\n  TruncSatF64x2ToI32x4Zero = 128 /* _BinaryenTruncSatZeroSVecF64x2ToVecI32x4 */,\n  /** i32x4.trunc_sat_f64x2_u_zero */\n  TruncSatF64x2ToU32x4Zero = 129 /* _BinaryenTruncSatZeroUVecF64x2ToVecI32x4 */,\n  /** f32x4.demote_f64x2_zero */\n  DemoteZeroF64x2ToF32x4 = 130 /* _BinaryenDemoteZeroVecF64x2ToVecF32x4 */,\n  /** f64x2.promote_low_f32x4 */\n  PromoteLowF32x4ToF64x2 = 131 /* _BinaryenPromoteLowVecF32x4ToVecF64x2 */,\n  /** i32x4.relaxed_trunc_f32x4_s */\n  RelaxedTruncF32x4ToI32x4 = 132 /* _BinaryenRelaxedTruncSVecF32x4ToVecI32x4 */,\n  /** i32x4.relaxed_trunc_f32x4_u */\n  RelaxedTruncF32x4ToU32x4 = 133 /* _BinaryenRelaxedTruncUVecF32x4ToVecI32x4 */,\n  /** i32x4.relaxed_trunc_f64x2_s_zero */\n  RelaxedTruncF64x2ToI32x4Zero = 134 /* _BinaryenRelaxedTruncZeroSVecF64x2ToVecI32x4 */,\n  /** i32x4.relaxed_trunc_f64x2_u_zero */\n  RelaxedTruncF64x2ToU32x4Zero = 135 /* _BinaryenRelaxedTruncZeroUVecF64x2ToVecI32x4 */,\n\n  _last = RelaxedTruncF64x2ToU32x4Zero,\n\n  // Target dependent\n\n  /** i32.clz or i64.clz, depending on target word size */\n  ClzSize,\n  /** i32.ctz or i64.ctz, depending on target word size */\n  CtzSize,\n  /** i32.popcnt or i64.popcnt, depending on target word size */\n  PopcntSize,\n  /** i32.eqz or i64.eqz, depending on target word size */\n  EqzSize\n}\n\n/** Binaryen binary operation constants. */\nexport const enum BinaryOp {\n  /** i32.add */\n  AddI32 = 0 /* _BinaryenAddInt32 */,\n  /** i32.sub */\n  SubI32 = 1 /* _BinaryenSubInt32 */,\n  /** i32.mul */\n  MulI32 = 2 /* _BinaryenMulInt32 */,\n  /** i32.div_s */\n  DivI32 = 3 /* _BinaryenDivSInt32 */,\n  /** i32.div_u */\n  DivU32 = 4 /* _BinaryenDivUInt32 */,\n  /** i32.rem_s */\n  RemI32 = 5 /* _BinaryenRemSInt32 */,\n  /** i32.rem_u */\n  RemU32 = 6 /* _BinaryenRemUInt32 */,\n  /** i32.and */\n  AndI32 = 7 /* _BinaryenAndInt32 */,\n  /** i32.or */\n  OrI32 = 8 /* _BinaryenOrInt32 */,\n  /** i32.xor */\n  XorI32 = 9 /* _BinaryenXorInt32 */,\n  /** i32.shl */\n  ShlI32 = 10 /* _BinaryenShlInt32 */,\n  /** i32.shr_s */\n  ShrI32 = 11 /* _BinaryenShrSInt32 */,\n  /** i32.shr_u */\n  ShrU32 = 12 /* _BinaryenShrUInt32 */,\n  /** i32.rotl */\n  RotlI32 = 13 /* _BinaryenRotLInt32 */,\n  /** i32.rotr */\n  RotrI32 = 14 /* _BinaryenRotRInt32 */,\n  /** i32.eq */\n  EqI32 = 15 /* _BinaryenEqInt32 */,\n  /** i32.ne */\n  NeI32 = 16 /* _BinaryenNeInt32 */,\n  /** i32.lt_s */\n  LtI32 = 17 /* _BinaryenLtSInt32 */,\n  /** i32.lt_u */\n  LtU32 = 18 /* _BinaryenLtUInt32 */,\n  /** i32.le_s */\n  LeI32 = 19 /* _BinaryenLeSInt32 */,\n  /** i32.le_u */\n  LeU32 = 20 /* _BinaryenLeUInt32 */,\n  /** i32.gt_s */\n  GtI32 = 21 /* _BinaryenGtSInt32 */,\n  /** i32.gt_u */\n  GtU32 = 22 /* _BinaryenGtUInt32 */,\n  /** i32.ge_s */\n  GeI32 = 23 /* _BinaryenGeSInt32 */,\n  /** i32.ge_u */\n  GeU32 = 24 /* _BinaryenGeUInt32 */,\n  /** i64.add */\n  AddI64 = 25 /* _BinaryenAddInt64 */,\n  /** i64.sub */\n  SubI64 = 26 /* _BinaryenSubInt64 */,\n  /** i64.mul */\n  MulI64 = 27 /* _BinaryenMulInt64 */,\n  /** i64.div_s */\n  DivI64 = 28 /* _BinaryenDivSInt64 */,\n  /** i64.div_u */\n  DivU64 = 29 /* _BinaryenDivUInt64 */,\n  /** i64.rem_s */\n  RemI64 = 30 /* _BinaryenRemSInt64 */,\n  /** i64.rem_u */\n  RemU64 = 31 /* _BinaryenRemUInt64 */,\n  /** i64.and */\n  AndI64 = 32 /* _BinaryenAndInt64 */,\n  /** i64.or */\n  OrI64 = 33 /* _BinaryenOrInt64 */,\n  /** i64.xor */\n  XorI64 = 34 /* _BinaryenXorInt64 */,\n  /** i64.shl */\n  ShlI64 = 35 /* _BinaryenShlInt64 */,\n  /** i64.shr_s */\n  ShrI64 = 36 /* _BinaryenShrSInt64 */,\n  /** i64.shr_u */\n  ShrU64 = 37 /* _BinaryenShrUInt64 */,\n  /** i64.rotl */\n  RotlI64 = 38 /* _BinaryenRotLInt64 */,\n  /** i64.rotr */\n  RotrI64 = 39 /* _BinaryenRotRInt64 */,\n  /** i64.eq */\n  EqI64 = 40 /* _BinaryenEqInt64 */,\n  /** i64.ne */\n  NeI64 = 41 /* _BinaryenNeInt64 */,\n  /** i64.lt_s */\n  LtI64 = 42 /* _BinaryenLtSInt64 */,\n  /** i64.lt_u */\n  LtU64 = 43 /* _BinaryenLtUInt64 */,\n  /** i64.le_s */\n  LeI64 = 44 /* _BinaryenLeSInt64 */,\n  /** i64.le_u */\n  LeU64 = 45 /* _BinaryenLeUInt64 */,\n  /** i64.gt_s */\n  GtI64 = 46 /* _BinaryenGtSInt64 */,\n  /** i64.gt_u */\n  GtU64 = 47 /* _BinaryenGtUInt64 */,\n  /** i64.ge_s */\n  GeI64 = 48 /* _BinaryenGeSInt64 */,\n  /** i64.ge_u */\n  GeU64 = 49 /* _BinaryenGeUInt64 */,\n  /** f32.add */\n  AddF32 = 50 /* _BinaryenAddFloat32 */,\n  /** f32.sub */\n  SubF32 = 51 /* _BinaryenSubFloat32 */,\n  /** f32.mul */\n  MulF32 = 52 /* _BinaryenMulFloat32 */,\n  /** f32.div */\n  DivF32 = 53 /* _BinaryenDivFloat32 */,\n  /** f32.copysign */\n  CopysignF32 = 54 /* _BinaryenCopySignFloat32 */,\n  /** f32.min */\n  MinF32 = 55 /* _BinaryenMinFloat32 */,\n  /** f32.max */\n  MaxF32 = 56 /* _BinaryenMaxFloat32 */,\n  /** f32.eq */\n  EqF32 = 57 /* _BinaryenEqFloat32 */,\n  /** f32.ne */\n  NeF32 = 58 /* _BinaryenNeFloat32 */,\n  /** f32.lt */\n  LtF32 = 59 /* _BinaryenLtFloat32 */,\n  /** f32.le */\n  LeF32 = 60 /* _BinaryenLeFloat32 */,\n  /** f32.gt */\n  GtF32 = 61 /* _BinaryenGtFloat32 */,\n  /** f32.ge */\n  GeF32 = 62 /* _BinaryenGeFloat32 */,\n  /** f64.add */\n  AddF64 = 63 /* _BinaryenAddFloat64 */,\n  /** f64.sub */\n  SubF64 = 64 /* _BinaryenSubFloat64 */,\n  /** f64.mul */\n  MulF64 = 65 /* _BinaryenMulFloat64 */,\n  /** f64.div */\n  DivF64 = 66 /* _BinaryenDivFloat64 */,\n  /** f64.copysign */\n  CopysignF64 = 67 /* _BinaryenCopySignFloat64 */,\n  /** f64.min */\n  MinF64 = 68 /* _BinaryenMinFloat64 */,\n  /** f64.max */\n  MaxF64 = 69 /* _BinaryenMaxFloat64 */,\n  /** f64.eq */\n  EqF64 = 70 /* _BinaryenEqFloat64 */,\n  /** f64.ne */\n  NeF64 = 71 /* _BinaryenNeFloat64 */,\n  /** f64.lt */\n  LtF64 = 72 /* _BinaryenLtFloat64 */,\n  /** f64.le */\n  LeF64 = 73 /* _BinaryenLeFloat64 */,\n  /** f64.gt */\n  GtF64 = 74 /* _BinaryenGtFloat64 */,\n  /** f64.ge */\n  GeF64 = 75 /* _BinaryenGeFloat64 */,\n\n  // see: https://github.com/WebAssembly/simd\n\n  /** i8x16.eq */\n  EqI8x16 = 76 /* _BinaryenEqVecI8x16 */,\n  /** i8x16.he */\n  NeI8x16 = 77 /* _BinaryenNeVecI8x16 */,\n  /** i8x16.lt_s */\n  LtI8x16 = 78 /* _BinaryenLtSVecI8x16 */,\n  /** i8x16.lt_u */\n  LtU8x16 = 79 /* _BinaryenLtUVecI8x16 */,\n  /** i8x16.gt_s */\n  GtI8x16 = 80 /* _BinaryenGtSVecI8x16 */,\n  /** i8x16.gt_u */\n  GtU8x16 = 81 /* _BinaryenGtUVecI8x16 */,\n  /** i8x16.le_s */\n  LeI8x16 = 82 /* _BinaryenLeSVecI8x16 */,\n  /** i8x16.le_u */\n  LeU8x16 = 83 /* _BinaryenLeUVecI8x16 */,\n  /** i8x16.ge_s */\n  GeI8x16 = 84 /* _BinaryenGeSVecI8x16 */,\n  /** i8x16.ge_u */\n  GeU8x16 = 85 /* _BinaryenGeUVecI8x16 */,\n  /** i16x8.eq */\n  EqI16x8 = 86 /* _BinaryenEqVecI16x8 */,\n  /** i16x8.ne */\n  NeI16x8 = 87 /* _BinaryenNeVecI16x8 */,\n  /** i16x8.lt_s */\n  LtI16x8 = 88 /* _BinaryenLtSVecI16x8 */,\n  /** i16x8.lt_u */\n  LtU16x8 = 89 /* _BinaryenLtUVecI16x8 */,\n  /** i16x8.gt_s */\n  GtI16x8 = 90 /* _BinaryenGtSVecI16x8 */,\n  /** i16x8.gt_u */\n  GtU16x8 = 91 /* _BinaryenGtUVecI16x8 */,\n  /** i16x8.le_s */\n  LeI16x8 = 92 /* _BinaryenLeSVecI16x8 */,\n  /** i16x8.le_u */\n  LeU16x8 = 93 /* _BinaryenLeUVecI16x8 */,\n  /** i16x8.ge_s */\n  GeI16x8 = 94 /* _BinaryenGeSVecI16x8 */,\n  /** i16x8.ge_u */\n  GeU16x8 = 95 /* _BinaryenGeUVecI16x8 */,\n  /** i32x4.eq */\n  EqI32x4 = 96 /* _BinaryenEqVecI32x4 */,\n  /** i32x4.ne */\n  NeI32x4 = 97 /* _BinaryenNeVecI32x4 */,\n  /** i32x4.lt_s */\n  LtI32x4 = 98 /* _BinaryenLtSVecI32x4 */,\n  /** i32x4.lt_u */\n  LtU32x4 = 99 /* _BinaryenLtUVecI32x4 */,\n  /** i32x4.gt_s */\n  GtI32x4 = 100 /* _BinaryenGtSVecI32x4 */,\n  /** i32x4.gt_u */\n  GtU32x4 = 101 /* _BinaryenGtUVecI32x4 */,\n  /** i32x4.le_s */\n  LeI32x4 = 102 /* _BinaryenLeSVecI32x4 */,\n  /** i32x4.le_u */\n  LeU32x4 = 103 /* _BinaryenLeUVecI32x4 */,\n  /** i32x4.ge_s */\n  GeI32x4 = 104 /* _BinaryenGeSVecI32x4 */,\n  /** i32x4.ge_u */\n  GeU32x4 = 105 /* _BinaryenGeUVecI32x4 */,\n  /** i64x2.eq */\n  EqI64x2 = 106 /* _BinaryenEqVecI64x2 */,\n  /** i64x2.ne */\n  NeI64x2 = 107 /* _BinaryenNeVecI64x2 */,\n  /** i64x2.lt_s */\n  LtI64x2 = 108 /* _BinaryenLtSVecI64x2 */,\n  /** i64x2.gt_s */\n  GtI64x2 = 109 /* _BinaryenGtSVecI64x2 */,\n  /** i64x2.le_s */\n  LeI64x2 = 110 /* _BinaryenLeSVecI64x2 */,\n  /** i64x2.ge_s */\n  GeI64x2 = 111 /* _BinaryenGeSVecI64x2 */,\n  /** f32x4.eq */\n  EqF32x4 = 118 /* _BinaryenEqVecF32x4 */,\n  /** f32x4.ne */\n  NeF32x4 = 119 /* _BinaryenNeVecF32x4 */,\n  /** f32x4.lt */\n  LtF32x4 = 120 /* _BinaryenLtVecF32x4 */,\n  /** f32x4.gt */\n  GtF32x4 = 121 /* _BinaryenGtVecF32x4 */,\n  /** f32x4.le */\n  LeF32x4 = 122 /* _BinaryenLeVecF32x4 */,\n  /** f32x4.ge */\n  GeF32x4 = 123 /* _BinaryenGeVecF32x4 */,\n  /** f64x2.eq */\n  EqF64x2 = 124 /* _BinaryenEqVecF64x2 */,\n  /** f64x2.ne */\n  NeF64x2 = 125 /* _BinaryenNeVecF64x2 */,\n  /** f64x2.lt */\n  LtF64x2 = 126 /* _BinaryenLtVecF64x2 */,\n  /** f64x2.gt */\n  GtF64x2 = 127 /* _BinaryenGtVecF64x2 */,\n  /** f64x2.le */\n  LeF64x2 = 128 /* _BinaryenLeVecF64x2 */,\n  /** f64x2.ge */\n  GeF64x2 = 129 /* _BinaryenGeVecF64x2 */,\n  /** v128.and */\n  AndV128 = 130 /* _BinaryenAndVec128 */,\n  /** v128.or */\n  OrV128 = 131 /* _BinaryenOrVec128 */,\n  /** v128.xor */\n  XorV128 = 132 /* _BinaryenXorVec128 */,\n  /** v128.andnot */\n  AndnotV128 = 133 /* _BinaryenAndNotVec128 */,\n  /** i8x16.add */\n  AddI8x16 = 134 /* _BinaryenAddVecI8x16 */,\n  /** i8x16.add_sat_s */\n  AddSatI8x16 = 135 /* _BinaryenAddSatSVecI8x16 */,\n  /** i8x16.add_sat_u */\n  AddSatU8x16 = 136 /* _BinaryenAddSatUVecI8x16 */,\n  /** i8x16.sub */\n  SubI8x16 = 137 /* _BinaryenSubVecI8x16 */,\n  /** i8x16.sub_sat_s */\n  SubSatI8x16 = 138 /* _BinaryenSubSatSVecI8x16 */,\n  /** i8x16.sub_sat_u */\n  SubSatU8x16 = 139 /* _BinaryenSubSatUVecI8x16 */,\n  /** i8x16.min_s */\n  MinI8x16 = 140 /* _BinaryenMinSVecI8x16 */,\n  /** i8x16.min_u */\n  MinU8x16 = 141 /* _BinaryenMinUVecI8x16 */,\n  /** i8x16.max_s */\n  MaxI8x16 = 142 /* _BinaryenMaxSVecI8x16 */,\n  /** i8x16.max_u */\n  MaxU8x16 = 143 /* _BinaryenMaxUVecI8x16 */,\n  /** i8x16.avgr_u */\n  AvgrU8x16 = 144 /* _BinaryenAvgrUVecI8x16 */,\n  /** i16x8.add */\n  AddI16x8 = 145 /* _BinaryenAddVecI16x8 */,\n  /** i16x8.add_sat_s */\n  AddSatI16x8 = 146 /* _BinaryenAddSatSVecI16x8 */,\n  /** i16x8.add_sat_u */\n  AddSatU16x8 = 147 /* _BinaryenAddSatUVecI16x8 */,\n  /** i16x8.sub */\n  SubI16x8 = 148 /* _BinaryenSubVecI16x8 */,\n  /** i16x8.sub_sat_s */\n  SubSatI16x8 = 149 /* _BinaryenSubSatSVecI16x8 */,\n  /** i16x8.sub_sat_u */\n  SubSatU16x8 = 150 /* _BinaryenSubSatUVecI16x8 */,\n  /** i16x8.mul */\n  MulI16x8 = 151 /* _BinaryenMulVecI16x8 */,\n  /** i16x8.min_s */\n  MinI16x8 = 152 /* _BinaryenMinSVecI16x8 */,\n  /** i16x8.min_u */\n  MinU16x8 = 153 /* _BinaryenMinUVecI16x8 */,\n  /** i16x8.max_s */\n  MaxI16x8 = 154 /* _BinaryenMaxSVecI16x8 */,\n  /** i16x8.max_u */\n  MaxU16x8 = 155 /* _BinaryenMaxUVecI16x8 */,\n  /** i16x8.avgr_u */\n  AvgrU16x8 = 156 /* _BinaryenAvgrUVecI16x8 */,\n  /** i16x8.q15mulr_sat_s */\n  Q15mulrSatI16x8 = 157 /* _BinaryenQ15MulrSatSVecI16x8 */,\n  /** i16x8.extmul_low_i8x16_s */\n  ExtmulLowI16x8 = 158 /* _BinaryenExtMulLowSVecI16x8 */,\n  /** i16x8.extmul_high_i8x16_s */\n  ExtmulHighI16x8 = 159 /* _BinaryenExtMulHighSVecI16x8 */,\n  /** i16x8.extmul_low_i8x16_u */\n  ExtmulLowU16x8 = 160 /* _BinaryenExtMulLowUVecI16x8 */,\n  /** i16x8.extmul_high_i8x16_u */\n  ExtmulHighU16x8 = 161 /* _BinaryenExtMulHighUVecI16x8 */,\n  /** i32x4.add */\n  AddI32x4 = 162 /* _BinaryenAddVecI32x4 */,\n  /** i32x4.sub */\n  SubI32x4 = 163 /* _BinaryenSubVecI32x4 */,\n  /** i32x4.mul */\n  MulI32x4 = 164 /* _BinaryenMulVecI32x4 */,\n  /** i32x4.min_s */\n  MinI32x4 = 165 /* _BinaryenMinSVecI32x4 */,\n  /** i32x4.min_u */\n  MinU32x4 = 166 /* _BinaryenMinUVecI32x4 */,\n  /** i32x4.max_s */\n  MaxI32x4 = 167 /* _BinaryenMaxSVecI32x4 */,\n  /** i32x4.max_u */\n  MaxU32x4 = 168 /* _BinaryenMaxUVecI32x4 */,\n  /** i32x4.dot_i16x8_s */\n  DotI16x8 = 169 /* _BinaryenDotSVecI16x8ToVecI32x4 */,\n  /** i32x4.extmul_low_i16x8_s */\n  ExtmulLowI32x4 = 170 /* _BinaryenExtMulLowSVecI32x4 */,\n  /** i32x4.extmul_high_i16x8_s */\n  ExtmulHighI32x4 = 171 /* _BinaryenExtMulHighSVecI32x4 */,\n  /** i32x4.extmul_low_i16x8_u */\n  ExtmulLowU32x4 = 172 /* _BinaryenExtMulLowUVecI32x4 */,\n  /** i32x4.extmul_high_i16x8_u */\n  ExtmulHighU32x4 = 173 /* _BinaryenExtMulHighUVecI32x4 */,\n  /** i64x2.add */\n  AddI64x2 = 174 /* _BinaryenAddVecI64x2 */,\n  /** i64x2.sub */\n  SubI64x2 = 175 /* _BinaryenSubVecI64x2 */,\n  /** i64x2.mul */\n  MulI64x2 = 176 /* _BinaryenMulVecI64x2 */,\n  /** i64x2.extmul_low_i32x4_s */\n  ExtmulLowI64x2 = 177 /* _BinaryenExtMulLowSVecI64x2 */,\n  /** i64x2.extmul_high_i32x4_s */\n  ExtmulHighI64x2 = 178 /* _BinaryenExtMulHighSVecI64x2 */,\n  /** i64x2.extmul_low_i32x4_u */\n  ExtmulLowU64x2 = 179 /* _BinaryenExtMulLowUVecI64x2 */,\n  /** i64x2.extmul_high_i32x4_u */\n  ExtmulHighU64x2 = 180 /* _BinaryenExtMulHighUVecI64x2 */,\n  /** f32x4.add */\n  AddF32x4 = 189 /* _BinaryenAddVecF32x4 */,\n  /** f32x4.sub */\n  SubF32x4 = 190 /* _BinaryenSubVecF32x4 */,\n  /** f32x4.mul */\n  MulF32x4 = 191 /* _BinaryenMulVecF32x4 */,\n  /** f32x4.div */\n  DivF32x4 = 192 /* _BinaryenDivVecF32x4 */,\n  /** f32x4.min */\n  MinF32x4 = 193 /* _BinaryenMinVecF32x4 */,\n  /** f32x4.max */\n  MaxF32x4 = 194 /* _BinaryenMaxVecF32x4 */,\n  /** f32x4.pmin */\n  PminF32x4 = 195 /* _BinaryenPMinVecF32x4 */,\n  /** f32x4.pmax */\n  PmaxF32x4 = 196 /* _BinaryenPMaxVecF32x4 */,\n  /** f64x2.add */\n  AddF64x2 = 197 /* _BinaryenAddVecF64x2 */,\n  /** f64x2.sub */\n  SubF64x2 = 198 /* _BinaryenSubVecF64x2 */,\n  /** f64x2.mul */\n  MulF64x2 = 199 /* _BinaryenMulVecF64x2 */,\n  /** f64x2.div */\n  DivF64x2 = 200 /* _BinaryenDivVecF64x2 */,\n  /** f64x2.min */\n  MinF64x2 = 201 /* _BinaryenMinVecF64x2 */,\n  /** f64x2.max */\n  MaxF64x2 = 202 /* _BinaryenMaxVecF64x2 */,\n  /** f64x2.pmin */\n  PminF64x2 = 203 /* _BinaryenPMinVecF64x2 */,\n  /** f64x2.pmax */\n  PmaxF64x2 = 204 /* _BinaryenPMaxVecF64x2 */,\n  /** i8x16.narrow_i16x8_s */\n  NarrowI16x8ToI8x16 = 205 /* _BinaryenNarrowSVecI16x8ToVecI8x16 */,\n  /** i8x16.narrow_i16x8_u */\n  NarrowU16x8ToU8x16 = 206 /* _BinaryenNarrowUVecI16x8ToVecI8x16 */,\n  /** i16x8.narrow_i32x4_s */\n  NarrowI32x4ToI16x8 = 207 /* _BinaryenNarrowSVecI32x4ToVecI16x8 */,\n  /** i16x8.narrow_i32x4_u */\n  NarrowU32x4ToU16x8 = 208 /* _BinaryenNarrowUVecI32x4ToVecI16x8 */,\n  /** i8x16.swizzle */\n  SwizzleI8x16 = 209 /* _BinaryenSwizzleVecI8x16 */,\n  /** i8x16.relaxed_swizzle */\n  RelaxedSwizzleI8x16 = 210 /* _BinaryenRelaxedSwizzleVecI8x16 */,\n  /** f32x4.relaxed_min */\n  RelaxedMinF32x4 = 211 /* _BinaryenRelaxedMinVecF32x4 */,\n  /** f32x4.relaxed_max */\n  RelaxedMaxF32x4 = 212 /* _BinaryenRelaxedMaxVecF32x4 */,\n  /** f64x2.relaxed_min */\n  RelaxedMinF64x2 = 213 /* _BinaryenRelaxedMinVecF64x2 */,\n  /** f64x2.relaxed_max */\n  RelaxedMaxF64x2 = 214 /* _BinaryenRelaxedMaxVecF64x2 */,\n  /** i16x8.relaxed_q15mulr_s */\n  RelaxedQ15MulrI16x8 = 215 /* _BinaryenRelaxedQ15MulrSVecI16x8 */,\n  /** i16x8.relaxed_dot_i8x16_i7x16_s */\n  RelaxedDotI8x16I7x16ToI16x8 = 216 /* _BinaryenDotI8x16I7x16SToVecI16x8 */,\n\n  _last = RelaxedDotI8x16I7x16ToI16x8,\n\n  // Target dependent\n\n  /** i32.add or i64.add, depending on target word size */\n  AddSize,\n  /** i32.sub or i64.sub, depending on target word size */\n  SubSize,\n  /** i32.mul or i64.mul, depending on target word size */\n  MulSize,\n  /** i32.div_s or i64.div_s, depending on target word size */\n  DivISize,\n  /** i32.div_u or i64.div_u, depending on target word size */\n  DivUSize,\n  /** i32.rem_s or i64.rem_s, depending on target word size */\n  RemISize,\n  /** i32.rem_u or i64.rem_u, depending on target word size */\n  RemUSize,\n  /** i32.and or i64.and, depending on target word size */\n  AndSize,\n  /** i32.or or i64.or, depending on target word size */\n  OrSize,\n  /** i32.xor or i64.xor, depending on target word size */\n  XorSize,\n  /** i32.shl or i64.shl, depending on target word size */\n  ShlSize,\n  /** i32.shr_s or i64.shr_s, depending on target word size */\n  ShrISize,\n  /** i32.shr_u or i64.shr_u, depending on target word size */\n  ShrUSize,\n  /** i32.rotl or i64.rotl, depending on target word size */\n  RotlSize,\n  /** i32.rotr or i64.rotr, depending on target word size */\n  RotrSize,\n  /** i32.eq or i64.eq, depending on target word size */\n  EqSize,\n  /** i32.ne or i64.ne, depending on target word size */\n  NeSize,\n  /** i32.lt_s or i64.lt_s, depending on target word size */\n  LtISize,\n  /** i32.lt_u or i64.lt_u, depending on target word size */\n  LtUSize,\n  /** i32.le_s or i64.le_s, depending on target word size */\n  LeISize,\n  /** i32.le_u or i64.le_u, depending on target word size */\n  LeUSize,\n  /** i32.gt_s or i64.gt_s, depending on target word size */\n  GtISize,\n  /** i32.gt_u or i64.gt_u, depending on target word size */\n  GtUSize,\n  /** i32.ge_s or i64.ge_s, depending on target word size */\n  GeISize,\n  /** i32.ge_u or i64.ge_u, depending on target word size */\n  GeUSize\n}\n\n/** Binaryen atomic read-modify-write operation constants. */\nexport const enum AtomicRMWOp {\n  /** i32.atomic.rmw.add, i32.atomic.rmw8.add_u, i32.atomic.rmw16.add_u, i64.atomic.rmw.add, i64.atomic.rmw8.add_u, i64.atomic.rmw16.add_u, i64.atomic.rmw32.add_u */\n  Add = 0 /* _BinaryenAtomicRMWAdd */,\n  /** i32.atomic.rmw.sub, i32.atomic.rmw8.sub_u, i32.atomic.rmw16.sub_u, i64.atomic.rmw.sub, i64.atomic.rmw8.sub_u, i64.atomic.rmw16.sub_u, i64.atomic.rmw32.sub_u */\n  Sub = 1 /* _BinaryenAtomicRMWSub */,\n  /** i32.atomic.rmw.and, i32.atomic.rmw8.and_u, i32.atomic.rmw16.and_u, i64.atomic.rmw.and, i64.atomic.rmw8.and_u, i64.atomic.rmw16.and_u, i64.atomic.rmw32.and_u */\n  And = 2 /* _BinaryenAtomicRMWAnd */,\n  /** i32.atomic.rmw.or, i32.atomic.rmw8.or_u, i32.atomic.rmw16.or_u, i64.atomic.rmw.or, i64.atomic.rmw8.or_u, i64.atomic.rmw16.or_u, i64.atomic.rmw32.or_u */\n  Or = 3 /* _BinaryenAtomicRMWOr */,\n  /** i32.atomic.rmw.xor, i32.atomic.rmw8.xor_u, i32.atomic.rmw16.xor_u, i64.atomic.rmw.xor, i64.atomic.rmw8.xor_u, i64.atomic.rmw16.xor_u, i64.atomic.rmw32.xor_u */\n  Xor = 4 /* _BinaryenAtomicRMWXor */,\n  /** i32.atomic.rmw.xchg, i32.atomic.rmw8.xchg_u, i32.atomic.rmw16.xchg_u, i64.atomic.rmw.xchg, i64.atomic.rmw8.xchg_u, i64.atomic.rmw16.xchg_u, i64.atomic.rmw32.xchg_u */\n  Xchg = 5 /* _BinaryenAtomicRMWXchg */\n}\n\n/** Binaryen SIMD extract operation constants. */\nexport const enum SIMDExtractOp {\n  /** i8x16.extract_lane_s */\n  ExtractLaneI8x16 = 0 /* _BinaryenExtractLaneSVecI8x16 */,\n  /** i8x16.extract_lane_u */\n  ExtractLaneU8x16 = 1 /* _BinaryenExtractLaneUVecI8x16 */,\n  /** i16x8.extract_lane_s */\n  ExtractLaneI16x8 = 2 /* _BinaryenExtractLaneSVecI16x8 */,\n  /** i16x8.extract_lane_u */\n  ExtractLaneU16x8 = 3 /* _BinaryenExtractLaneUVecI16x8 */,\n  /** i32x4.extract_lane_s */\n  ExtractLaneI32x4 = 4 /* _BinaryenExtractLaneVecI32x4 */,\n  /** i32x4.extract_lane_u */\n  ExtractLaneI64x2 = 5 /* _BinaryenExtractLaneVecI64x2 */,\n  /** i64x2.extract_lane_s */\n  ExtractLaneF32x4 = 7 /* _BinaryenExtractLaneVecF32x4 */,\n  /** i64x2.extract_lane_u */\n  ExtractLaneF64x2 = 8 /* _BinaryenExtractLaneVecF64x2 */,\n}\n\n/** Binaryen SIMD replace operation constants. */\nexport const enum SIMDReplaceOp {\n  /** i8x16.replace_lane */\n  ReplaceLaneI8x16 = 0 /* _BinaryenReplaceLaneVecI8x16 */,\n  /** i16x8.replace_lane */\n  ReplaceLaneI16x8 = 1 /* _BinaryenReplaceLaneVecI16x8 */,\n  /** i32x4.replace_lane */\n  ReplaceLaneI32x4 = 2 /* _BinaryenReplaceLaneVecI32x4 */,\n  /** i64x2.replace_lane */\n  ReplaceLaneI64x2 = 3 /* _BinaryenReplaceLaneVecI64x2 */,\n  /** f32x4.replace_lane */\n  ReplaceLaneF32x4 = 5 /* _BinaryenReplaceLaneVecF32x4 */,\n  /** f64x2.replace_lane */\n  ReplaceLaneF64x2 = 6 /* _BinaryenReplaceLaneVecF64x2 */\n}\n\n/** Binaryen SIMD shift operation constants. */\nexport const enum SIMDShiftOp {\n  /** i8x16.shl */\n  ShlI8x16 = 0 /* _BinaryenShlVecI8x16 */,\n  /** i8x16.shr_s */\n  ShrI8x16 = 1 /* _BinaryenShrSVecI8x16 */,\n  /** i8x16.shr_u */\n  ShrU8x16 = 2 /* _BinaryenShrUVecI8x16 */,\n  /** i16x8.shl */\n  ShlI16x8 = 3 /* _BinaryenShlVecI16x8 */,\n  /** i16x8.shr_s */\n  ShrI16x8 = 4 /* _BinaryenShrSVecI16x8 */,\n  /** i16x8.shr_u */\n  ShrU16x8 = 5 /* _BinaryenShrUVecI16x8 */,\n  /** i16x8.shl */\n  ShlI32x4 = 6 /* _BinaryenShlVecI32x4 */,\n  /** i32x4.shr_s */\n  ShrI32x4 = 7 /* _BinaryenShrSVecI32x4 */,\n  /** i32x4.shr_u */\n  ShrU32x4 = 8 /* _BinaryenShrUVecI32x4 */,\n  /** i64x2.shl */\n  ShlI64x2 = 9 /* _BinaryenShlVecI64x2 */,\n  /** i64x2.shr_u */\n  ShrI64x2 = 10 /* _BinaryenShrSVecI64x2 */,\n  /** i64x2.shr_u */\n  ShrU64x2 = 11 /* _BinaryenShrUVecI64x2 */\n}\n\n/** Binaryen SIMD load operation constants. */\nexport const enum SIMDLoadOp {\n  /** v128.load8_splat */\n  Load8Splat = 0 /* _BinaryenLoad8SplatVec128 */,\n  /** v128.load16_splat */\n  Load16Splat = 1 /* _BinaryenLoad16SplatVec128 */,\n  /** v128.load32_splat */\n  Load32Splat = 2 /* _BinaryenLoad32SplatVec128 */,\n  /** v128.load64_splat */\n  Load64Splat = 3 /* _BinaryenLoad64SplatVec128 */,\n  /** v128.load8x8_s */\n  Load8x8S = 4 /* _BinaryenLoad8x8SVec128 */,\n  /** v128.load8x8_u */\n  Load8x8U = 5 /* _BinaryenLoad8x8UVec128 */,\n  /** v128.load16x4_s */\n  Load16x4S = 6 /* _BinaryenLoad16x4SVec128 */,\n  /** v128.load16x4_u */\n  Load16x4U = 7 /* _BinaryenLoad16x4UVec128 */,\n  /** v128.load32x2_s */\n  Load32x2S = 8 /* _BinaryenLoad32x2SVec128 */,\n  /** v128.load32x2_u */\n  Load32x2U = 9 /* _BinaryenLoad32x2UVec128 */,\n  /** v128.load32_zero */\n  Load32Zero = 10 /* _BinaryenLoad32ZeroVec128 */,\n  /** v128.load64_zero */\n  Load64Zero = 11 /* _BinaryenLoad64ZeroVec128 */,\n}\n\n/** Binaryen SIMD load/store lane operation constants. */\nexport const enum SIMDLoadStoreLaneOp {\n  /** v128.load8_lane */\n  Load8Lane = 0 /* _BinaryenLoad8LaneVec128 */,\n  /** v128.load16_lane */\n  Load16Lane = 1 /* _BinaryenLoad16LaneVec128 */,\n  /** v128.load32_lane */\n  Load32Lane = 2 /* _BinaryenLoad32LaneVec128 */,\n  /** v128.load64_lane */\n  Load64Lane = 3 /* _BinaryenLoad64LaneVec128 */,\n  /** v128.store8_lane */\n  Store8Lane = 4 /* _BinaryenStore8LaneVec128 */,\n  /** v128.store16_lane */\n  Store16Lane = 5 /* _BinaryenStore16LaneVec128 */,\n  /** v128.store32_lane */\n  Store32Lane = 6 /* _BinaryenStore32LaneVec128 */,\n  /** v128.store64_lane */\n  Store64Lane = 7 /* _BinaryenStore64LaneVec128 */,\n}\n\n/** Binaryen SIMD ternary operation constants. */\nexport const enum SIMDTernaryOp {\n  /** v128.bitselect */\n  Bitselect = 0 /* _BinaryenBitselectVec128 */,\n\n  // Relaxed SIMD for F16\n  /** f16x8.relaxed_madd */\n  RelaxedMaddVecF16x8 = 1 /* TODO_BinaryenRelaxedMaddVecF16x8 */,\n  /** f16x8.relaxed_nmadd */\n  RelaxedNmaddVecF16x8 = 2 /* TODO_BinaryenRelaxedNmaddVecF16x8 */,\n\n  /** f32x4.relaxed_madd */\n  RelaxedMaddF32x4 = 3 /* _BinaryenRelaxedMaddVecF32x4 */,\n  /** f32x4.relaxed_nmadd */\n  RelaxedNmaddF32x4 = 4 /* _BinaryenRelaxedNmaddVecF32x4 */,\n  /** f64x2.relaxed_madd */\n  RelaxedMaddF64x2 = 5 /* _BinaryenRelaxedMaddVecF64x2 */,\n  /** f64x2.relaxed_nmadd */\n  RelaxedNmaddF64x2 = 6 /* _BinaryenRelaxedNmaddVecF64x2 */,\n  /** i8x16.relaxed_laneselect */\n  RelaxedLaneselectI8x16 = 7 /* _BinaryenLaneselectI8x16 */,\n  /** i16x8.relaxed_laneselect */\n  RelaxedLaneselectI16x8 = 8 /* _BinaryenLaneselectI16x8 */,\n  /** i32x4.relaxed_laneselect */\n  RelaxedLaneselectI32x4 = 9 /* _BinaryenLaneselectI32x4 */,\n  /** i64x2.relaxed_laneselect */\n  RelaxedLaneselectI64x2 = 10 /* _BinaryenLaneselectI64x2 */,\n  /** i32x4.relaxed_dot_i8x16_i7x16_add_s */\n  RelaxedDotI8x16I7x16AddToI32x4 = 11 /* _BinaryenDotI8x16I7x16AddSToVecI32x4 */,\n}\n\n/** Binaryen RefAs operation constants. */\nexport const enum RefAsOp {\n  /** ref.as_non_null */\n  NonNull = 0 /* _BinaryenRefAsNonNull */,\n  /** any.convert_extern */\n  ExternInternalize = 1 /* _BinaryenRefAsAnyConvertExtern */,\n  /** extern.convert_any */\n  ExternExternalize = 2 /* _BinaryenRefAsExternConvertAny */\n}\n\n/** Binaryen BrOn operation constants. */\nexport const enum BrOnOp {\n  /** br_on_null */\n  Null = 0 /* _BinaryenBrOnNull */,\n  /** br_on_non_null */\n  NonNull = 1 /* _BinaryenBrOnNonNull */,\n  /** br_on_cast */\n  Cast = 2 /* _BinaryenBrOnCast */,\n  /** br_on_cast_fail */\n  CastFail = 3 /* _BinaryenBrOnCastFail */\n}\n\n/** Binaryen StringNew operation constants. */\nexport const enum StringNewOp {\n  /** string.new_wtf8_array replace */\n  LossyUTF8Array = 0 /* _BinaryenStringNewLossyUTF8Array */,\n  /** string.new_wtf16_array */\n  WTF16Array = 1 /* _BinaryenStringNewWTF16Array */,\n  /** string.from_code_point */\n  FromCodePoint = 2 /* _BinaryenStringNewFromCodePoint */\n}\n\n/** Binaryen StringMeasure operation constants. */\nexport const enum StringMeasureOp {\n  /** string.measure_wtf8 utf8 */\n  UTF8 = 0 /* _BinaryenStringMeasureUTF8 */,\n  /** string.measure_wtf16 */\n  WTF16 = 1 /* _BinaryenStringMeasureWTF16 */,\n}\n\n/** Binaryen StringEncode operation constants. */\nexport const enum StringEncodeOp {\n  /** string.encode_lossy_utf8_array utf8 */\n  LossyUTF8Array = 0 /* _BinaryenStringEncodeLossyUTF8Array */,\n  /** string.encode_wtf16_array */\n  WTF16Array = 1 /* _BinaryenStringEncodeWTF16Array */\n}\n\n/** Binaryen StringEq operation constants. */\nexport const enum StringEqOp {\n  /** string.eq */\n  Equal = 0 /* _BinaryenStringEqEqual */,\n  /** string.compare */\n  Compare = 1 /* _BinaryenStringEqCompare */\n}\n\n/** Binaryen expression runner flags. */\nexport const enum ExpressionRunnerFlags {\n  Default = 0 /* _ExpressionRunnerFlagsDefault */,\n  PreserveSideeffects = 1 /* _ExpressionRunnerFlagsPreserveSideeffects */\n}\n\nexport class MemorySegment {\n  constructor(\n    /** Segment data. */\n    public buffer: Uint8Array,\n    /** Segment offset. */\n    public offset: i64\n  ) {}\n}\n\nexport class Module {\n  constructor(\n    /** Binaryen module reference. */\n    public ref: ModuleRef,\n    /** Whether a shadow stack is used. */\n    public useShadowStack: bool,\n    /** Architecture-dependent size type. */\n    public sizeType: TypeRef\n  ) {\n    assert(sizeType == TypeRef.I32 || sizeType == TypeRef.I64);\n    this.lit = binaryen._malloc(binaryen._BinaryenSizeofLiteral());\n  }\n\n  private lit: usize;\n\n  static create(useShadowStack: bool, sizeType: TypeRef): Module {\n    return new Module(binaryen._BinaryenModuleCreate(), useShadowStack, sizeType);\n  }\n\n  static createFrom(buffer: Uint8Array, useShadowStack: bool, sizeType: TypeRef): Module {\n    let cArr = allocU8Array(buffer);\n    let module = new Module(binaryen._BinaryenModuleRead(cArr, buffer.length), useShadowStack, sizeType);\n    binaryen._free(changetype<usize>(cArr));\n    return module;\n  }\n\n  // constants\n\n  i32(value: i32): ExpressionRef {\n    let out = this.lit;\n    binaryen._BinaryenLiteralInt32(out, value);\n    return binaryen._BinaryenConst(this.ref, out);\n  }\n\n  i64(valueLow: i32, valueHigh: i32 = 0): ExpressionRef {\n    let out = this.lit;\n    binaryen._BinaryenLiteralInt64(out, valueLow, valueHigh);\n    return binaryen._BinaryenConst(this.ref, out);\n  }\n\n  // isize<T>(value: T): ExpressionRef {\n  //   if (i64_is(value)) {\n  //     if (this.sizeType == TypeRef.I64) {\n  //       return this.i64(i64_low(value), i64_high(value));\n  //     }\n  //     assert(i64_is_i32(value));\n  //     return this.i32(i64_low(value));\n  //   }\n  //   return this.sizeType == TypeRef.I64\n  //     ? this.i64(i32(value), i32(value) < 0 ? -1 : 0)\n  //     : this.i32(i32(value));\n  // }\n\n  usize<T>(value: T): ExpressionRef {\n    if (i64_is(value)) {\n      if (this.sizeType == TypeRef.I64) {\n        return this.i64(i64_low(value), i64_high(value));\n      }\n      assert(i64_is_u32(value));\n      return this.i32(i64_low(value));\n    }\n    return this.sizeType == TypeRef.I64\n      ? this.i64(i32(value))\n      : this.i32(i32(value));\n  }\n\n  f32(value: f32): ExpressionRef {\n    let out = this.lit;\n    binaryen._BinaryenLiteralFloat32(out, value);\n    return binaryen._BinaryenConst(this.ref, out);\n  }\n\n  f64(value: f64): ExpressionRef {\n    let out = this.lit;\n    binaryen._BinaryenLiteralFloat64(out, value);\n    return binaryen._BinaryenConst(this.ref, out);\n  }\n\n  v128(bytes: Uint8Array): ExpressionRef {\n    assert(bytes.length == 16);\n    let out = this.lit;\n    for (let i = 0; i < 16; ++i) {\n      binaryen.__i32_store8(out + i, unchecked(bytes[i]));\n    }\n    binaryen._BinaryenLiteralVec128(out, out);\n    return binaryen._BinaryenConst(this.ref, out);\n  }\n\n  ref_null(type: TypeRef): ExpressionRef {\n    // TODO: Provide the desired bottom type directly? Currently, Binaryen does\n    // this under the hood, but this API could change to take a heap type.\n    // type = binaryen._BinaryenTypeFromHeapType(\n    //   binaryen._BinaryenHeapTypeGetBottom(\n    //     binaryen._BinaryenTypeGetHeapType(type)\n    //   ),\n    //   true\n    // );\n    return binaryen._BinaryenRefNull(this.ref, type);\n  }\n\n  ref_eq(left: ExpressionRef, right: ExpressionRef): ExpressionRef {\n    return binaryen._BinaryenRefEq(this.ref, left, right);\n  }\n\n  string_eq(left: ExpressionRef, right: ExpressionRef): ExpressionRef {\n    return binaryen._BinaryenStringEq(this.ref, StringEqOp.Equal, left, right);\n  }\n\n  string_compare(left: ExpressionRef, right: ExpressionRef): ExpressionRef {\n    return binaryen._BinaryenStringEq(this.ref, StringEqOp.Compare, left, right);\n  }\n\n  // expressions\n\n  unary(\n    op: UnaryOp,\n    value: ExpressionRef\n  ): ExpressionRef {\n    if (op > UnaryOp._last) {\n      let isWam64 = this.sizeType == TypeRef.I64;\n      switch (op) {\n        case UnaryOp.ClzSize:    op = isWam64 ? UnaryOp.ClzI64    : UnaryOp.ClzI32; break;\n        case UnaryOp.CtzSize:    op = isWam64 ? UnaryOp.CtzI64    : UnaryOp.CtzI32; break;\n        case UnaryOp.PopcntSize: op = isWam64 ? UnaryOp.PopcntI64 : UnaryOp.PopcntI32; break;\n        case UnaryOp.EqzSize:    op = isWam64 ? UnaryOp.EqzI64    : UnaryOp.EqzI32; break;\n        default: assert(false);\n      }\n    }\n    return binaryen._BinaryenUnary(this.ref, op, value);\n  }\n\n  binary(\n    op: BinaryOp,\n    left: ExpressionRef,\n    right: ExpressionRef\n  ): ExpressionRef {\n    if (op > BinaryOp._last) {\n      let isWasm64 = this.sizeType == TypeRef.I64;\n      switch (op) {\n        case BinaryOp.AddSize:  op = isWasm64 ? BinaryOp.AddI64  : BinaryOp.AddI32; break;\n        case BinaryOp.SubSize:  op = isWasm64 ? BinaryOp.SubI64  : BinaryOp.SubI32; break;\n        case BinaryOp.MulSize:  op = isWasm64 ? BinaryOp.MulI64  : BinaryOp.MulI32; break;\n        case BinaryOp.DivISize: op = isWasm64 ? BinaryOp.DivI64  : BinaryOp.DivI32; break;\n        case BinaryOp.DivUSize: op = isWasm64 ? BinaryOp.DivU64  : BinaryOp.DivU32; break;\n        case BinaryOp.RemISize: op = isWasm64 ? BinaryOp.RemI64  : BinaryOp.RemI32; break;\n        case BinaryOp.RemUSize: op = isWasm64 ? BinaryOp.RemU64  : BinaryOp.RemU32; break;\n        case BinaryOp.AndSize:  op = isWasm64 ? BinaryOp.AndI64  : BinaryOp.AndI32; break;\n        case BinaryOp.OrSize:   op = isWasm64 ? BinaryOp.OrI64   : BinaryOp.OrI32; break;\n        case BinaryOp.XorSize:  op = isWasm64 ? BinaryOp.XorI64  : BinaryOp.XorI32; break;\n        case BinaryOp.ShlSize:  op = isWasm64 ? BinaryOp.ShlI64  : BinaryOp.ShlI32; break;\n        case BinaryOp.ShrISize: op = isWasm64 ? BinaryOp.ShrI64  : BinaryOp.ShrI32; break;\n        case BinaryOp.ShrUSize: op = isWasm64 ? BinaryOp.ShrU64  : BinaryOp.ShrU32; break;\n        case BinaryOp.RotlSize: op = isWasm64 ? BinaryOp.RotlI64 : BinaryOp.RotlI32; break;\n        case BinaryOp.RotrSize: op = isWasm64 ? BinaryOp.RotrI64 : BinaryOp.RotrI32; break;\n        case BinaryOp.EqSize:   op = isWasm64 ? BinaryOp.EqI64   : BinaryOp.EqI32; break;\n        case BinaryOp.NeSize:   op = isWasm64 ? BinaryOp.NeI64   : BinaryOp.NeI32; break;\n        case BinaryOp.LtISize:  op = isWasm64 ? BinaryOp.LtI64   : BinaryOp.LtI32; break;\n        case BinaryOp.LtUSize:  op = isWasm64 ? BinaryOp.LtU64   : BinaryOp.LtU32; break;\n        case BinaryOp.LeISize:  op = isWasm64 ? BinaryOp.LeI64   : BinaryOp.LeI32; break;\n        case BinaryOp.LeUSize:  op = isWasm64 ? BinaryOp.LeU64   : BinaryOp.LeU32; break;\n        case BinaryOp.GtISize:  op = isWasm64 ? BinaryOp.GtI64   : BinaryOp.GtI32; break;\n        case BinaryOp.GtUSize:  op = isWasm64 ? BinaryOp.GtU64   : BinaryOp.GtU32; break;\n        case BinaryOp.GeISize:  op = isWasm64 ? BinaryOp.GeI64   : BinaryOp.GeI32; break;\n        case BinaryOp.GeUSize:  op = isWasm64 ? BinaryOp.GeU64   : BinaryOp.GeU32; break;\n        default: assert(false);\n      }\n    }\n    return binaryen._BinaryenBinary(this.ref, op, left, right);\n  }\n\n  memory_size(name: string = CommonNames.DefaultMemory, is64: bool = false): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenMemorySize(this.ref, cStr, is64);\n  }\n\n  memory_grow(delta: ExpressionRef, name: string = CommonNames.DefaultMemory, is64: bool = false): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenMemoryGrow(this.ref, delta, cStr, is64);\n  }\n\n  table_size(name: string): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenTableSize(this.ref, cStr);\n  }\n\n  table_grow(name: string, delta: ExpressionRef, value: ExpressionRef = 0): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenTableGrow(this.ref, cStr, value, delta);\n  }\n\n  local_get(\n    index: i32,\n    type: TypeRef\n  ): ExpressionRef {\n    return binaryen._BinaryenLocalGet(this.ref, index, type);\n  }\n\n  tostack(value: ExpressionRef): ExpressionRef {\n    if (this.useShadowStack) {\n      let type = binaryen._BinaryenExpressionGetType(value);\n      assert(type == TypeRef.I32 || type == TypeRef.Unreachable);\n      return this.call(BuiltinNames.tostack, [ value ], type);\n    }\n    return value;\n  }\n\n  local_tee(\n    index: i32,\n    value: ExpressionRef,\n    isManaged: bool,\n    type: TypeRef = -1,\n  ): ExpressionRef {\n    if (type == -1) type = binaryen._BinaryenExpressionGetType(value);\n    if (isManaged && this.useShadowStack) {\n      value = this.tostack(value);\n    }\n    return binaryen._BinaryenLocalTee(this.ref, index, value, type);\n  }\n\n  global_get(\n    name: string,\n    type: TypeRef\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGlobalGet(this.ref, cStr, type);\n  }\n\n  table_get(\n    name: string,\n    index: ExpressionRef,\n    type: TypeRef\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenTableGet(this.ref, cStr, index, type);\n  }\n\n  load(\n    bytes: Index,\n    signed: bool,\n    ptr: ExpressionRef,\n    type: TypeRef,\n    offset: Index = 0,\n    align: Index = bytes, // naturally aligned by default\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenLoad(this.ref, bytes, signed, offset, align, type, ptr, cStr);\n  }\n\n  store(\n    bytes: Index,\n    ptr: ExpressionRef,\n    value: ExpressionRef,\n    type: TypeRef,\n    offset: Index = 0,\n    align: Index = bytes, // naturally aligned by default\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenStore(this.ref, bytes, offset, align, ptr, value, type, cStr);\n  }\n\n  atomic_load(\n    bytes: Index,\n    ptr: ExpressionRef,\n    type: TypeRef,\n    offset: Index = 0,\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAtomicLoad(this.ref, bytes, offset, type, ptr, cStr);\n  }\n\n  atomic_store(\n    bytes: Index,\n    ptr: ExpressionRef,\n    value: ExpressionRef,\n    type: TypeRef,\n    offset: Index = 0,\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAtomicStore(this.ref, bytes, offset, ptr, value, type, cStr);\n  }\n\n  atomic_rmw(\n    op: AtomicRMWOp,\n    bytes: Index,\n    offset: Index,\n    ptr: ExpressionRef,\n    value: ExpressionRef,\n    type: TypeRef,\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAtomicRMW(this.ref, op, bytes, offset, ptr, value, type, cStr);\n  }\n\n  atomic_cmpxchg(\n    bytes: Index,\n    offset: Index,\n    ptr: ExpressionRef,\n    expected: ExpressionRef,\n    replacement: ExpressionRef,\n    type: TypeRef,\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAtomicCmpxchg(this.ref, bytes, offset, ptr, expected, replacement, type, cStr);\n  }\n\n  atomic_wait(\n    ptr: ExpressionRef,\n    expected: ExpressionRef,\n    timeout: ExpressionRef,\n    expectedType: TypeRef,\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAtomicWait(this.ref, ptr, expected, timeout, expectedType, cStr);\n  }\n\n  atomic_notify(\n    ptr: ExpressionRef,\n    notifyCount: ExpressionRef,\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAtomicNotify(this.ref, ptr, notifyCount, cStr);\n  }\n\n  atomic_fence(name: string | null = null): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAtomicFence(this.ref, cStr);\n  }\n\n  // statements\n\n  local_set(\n    index: Index,\n    value: ExpressionRef,\n    isManaged: bool\n  ): ExpressionRef {\n    if (isManaged && this.useShadowStack) {\n      value = this.tostack(value);\n    }\n    return binaryen._BinaryenLocalSet(this.ref, index, value);\n  }\n\n  global_set(\n    name: string,\n    value: ExpressionRef\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGlobalSet(this.ref, cStr, value);\n  }\n\n  table_set(\n    name: string,\n    index: ExpressionRef,\n    value: ExpressionRef\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenTableSet(this.ref, cStr, index, value);\n  }\n\n  block(\n    label: string | null,\n    children: ExpressionRef[],\n    type: TypeRef = TypeRef.None\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(label);\n    let cArr = allocPtrArray(children);\n    let ret = binaryen._BinaryenBlock(this.ref, cStr, cArr, children.length, type);\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  /** Attempts to trivially flatten a series of expressions instead of emitting a block. */\n  flatten(\n    stmts: ExpressionRef[],\n    type: TypeRef = TypeRef.None\n  ): ExpressionRef {\n    let length = stmts.length;\n    if (length == 0) return this.nop(); // usually filtered out again\n    if (length == 1) {\n      let single = stmts[0];\n      switch (getExpressionId(single)) {\n        case ExpressionId.Return:\n        case ExpressionId.Throw:\n        case ExpressionId.Unreachable: {\n          // type does no matter, terminates anyway\n          return single;\n        }\n      }\n      let singleType = getExpressionType(single);\n      if (singleType != TypeRef.Unreachable && singleType != type) {\n        // can happen when there was a diagnostic prior\n        return this.unreachable();\n      }\n      return single;\n    }\n    return this.block(null, stmts, type);\n  }\n\n  br(\n    label: string | null,\n    condition: ExpressionRef = 0,\n    value: ExpressionRef = 0\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(label);\n    return binaryen._BinaryenBreak(this.ref, cStr, condition, value);\n  }\n\n  drop(\n    expression: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenDrop(this.ref, expression);\n  }\n\n  /** Drops an expression if it evaluates to a value. */\n  maybeDrop(\n    expression: ExpressionRef\n  ): ExpressionRef {\n    let type = binaryen._BinaryenExpressionGetType(expression);\n    if (type != TypeRef.None && type != TypeRef.Unreachable) {\n      return binaryen._BinaryenDrop(this.ref, expression);\n    }\n    return expression;\n  }\n\n  maybeDropCondition(condition: ExpressionRef, result: ExpressionRef): ExpressionRef {\n    // FIXME: This is necessary because Binaryen's ExpressionRunner bails early\n    // when encountering a local with an unknown value. This helper only drops\n    // the pre-evaluated condition if it has relevant side effects.\n    // see WebAssembly/binaryen#1237\n    if ((getSideEffects(condition, this.ref) & ~(SideEffects.ReadsLocal | SideEffects.ReadsGlobal)) != 0) {\n      return this.block(null, [\n        this.drop(condition),\n        result\n      ], getExpressionType(result));\n    }\n    return result;\n  }\n\n  loop(\n    label: string | null,\n    body: ExpressionRef\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(label);\n    return binaryen._BinaryenLoop(this.ref, cStr, body);\n  }\n\n  if(\n    condition: ExpressionRef,\n    ifTrue: ExpressionRef,\n    ifFalse: ExpressionRef = 0\n  ): ExpressionRef {\n    return binaryen._BinaryenIf(this.ref, condition, ifTrue, ifFalse);\n  }\n\n  nop(): ExpressionRef {\n    return binaryen._BinaryenNop(this.ref);\n  }\n\n  return(\n    expression: ExpressionRef = 0\n  ): ExpressionRef {\n    return binaryen._BinaryenReturn(this.ref, expression);\n  }\n\n  select(\n    ifTrue: ExpressionRef,\n    ifFalse: ExpressionRef,\n    condition: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenSelect(this.ref, condition, ifTrue, ifFalse);\n  }\n\n  switch(\n    names: string[],\n    defaultName: string | null,\n    condition: ExpressionRef,\n    value: ExpressionRef = 0\n  ): ExpressionRef {\n    let numNames = names.length;\n    let strs = new Array<StringRef>(numNames);\n    for (let i = 0; i < numNames; ++i) {\n      unchecked(strs[i] = this.allocStringCached(names[i]));\n    }\n    let cArr = allocPtrArray(strs);\n    let cStr = this.allocStringCached(defaultName);\n    let ret = binaryen._BinaryenSwitch(this.ref, cArr, numNames, cStr, condition, value);\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  call(\n    target: string,\n    operands: ExpressionRef[] | null,\n    returnType: TypeRef,\n    isReturn: bool = false\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(target);\n    let cArr = allocPtrArray(operands);\n    let ret = isReturn\n      ? binaryen._BinaryenReturnCall(\n          this.ref, cStr, cArr, operands ? operands.length : 0, returnType\n        )\n      : binaryen._BinaryenCall(\n          this.ref, cStr, cArr, operands ? operands.length : 0, returnType\n        );\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  return_call(\n    target: string,\n    operands: ExpressionRef[] | null,\n    returnType: TypeRef\n  ): ExpressionRef {\n    return this.call(target, operands, returnType, true);\n  }\n\n  call_indirect(\n    tableName: string | null,\n    index: ExpressionRef,\n    operands: ExpressionRef[] | null,\n    params: TypeRef,\n    results: TypeRef,\n    isReturn: bool = false\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(tableName != null\n      ? tableName\n      : CommonNames.DefaultTable\n    );\n    let cArr = allocPtrArray(operands);\n    let ret = isReturn\n      ? binaryen._BinaryenReturnCallIndirect(\n          this.ref, cStr, index, cArr, operands ? operands.length : 0, params, results\n        )\n      : binaryen._BinaryenCallIndirect(\n          this.ref, cStr, index, cArr, operands ? operands.length : 0, params, results\n        );\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  return_call_indirect(\n    tableName: string | null,\n    index: ExpressionRef,\n    operands: ExpressionRef[] | null,\n    params: TypeRef,\n    results: TypeRef\n  ): ExpressionRef {\n    return this.call_indirect(tableName, index, operands, params, results, true);\n  }\n\n  unreachable(): ExpressionRef {\n    return binaryen._BinaryenUnreachable(this.ref);\n  }\n\n  // bulk memory\n\n  memory_copy(\n    dest: ExpressionRef,\n    source: ExpressionRef,\n    size: ExpressionRef,\n    destName: string = CommonNames.DefaultMemory,\n    sourceName: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr1 = this.allocStringCached(destName);\n    let cStr2 = this.allocStringCached(sourceName);\n    return binaryen._BinaryenMemoryCopy(this.ref, dest, source, size, cStr1, cStr2);\n  }\n\n  memory_fill(\n    dest: ExpressionRef,\n    value: ExpressionRef,\n    size: ExpressionRef,\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenMemoryFill(this.ref, dest, value, size, cStr);\n  }\n\n  // exception handling\n\n  try(\n    name: string | null,\n    body: ExpressionRef,\n    catchTags: string[],\n    catchBodies: ExpressionRef[],\n    delegateTarget: string | null = null\n  ): ExpressionRef {\n    let numCatchTags = catchTags.length;\n    let strs = new Array<TagRef>(numCatchTags);\n    for (let i = 0; i < numCatchTags; ++i) {\n      strs[i] = this.allocStringCached(catchTags[i]);\n    }\n    let cArr1 = allocPtrArray(strs);\n    let cArr2 = allocPtrArray(catchBodies);\n    let cStr1 = this.allocStringCached(name);\n    let cStr2 = this.allocStringCached(delegateTarget);\n    let ret = binaryen._BinaryenTry(\n      this.ref, cStr1, body, cArr1, numCatchTags, cArr2, catchBodies.length, cStr2\n    );\n    binaryen._free(cArr2);\n    binaryen._free(cArr1);\n    return ret;\n  }\n\n  throw(\n    tagName: string,\n    operands: ExpressionRef[]\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(tagName);\n    let cArr = allocPtrArray(operands);\n    let ret = binaryen._BinaryenThrow(this.ref, cStr, cArr, operands.length);\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  rethrow(\n    target: string\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(target);\n    return binaryen._BinaryenRethrow(this.ref, cStr);\n  }\n\n  // multi value (pseudo instructions)\n\n  pop(\n    type: TypeRef\n  ): ExpressionRef {\n    return binaryen._BinaryenPop(this.ref, type);\n  }\n\n  tuple_make(operands: ExpressionRef[]): ExpressionRef {\n    let cArr = allocPtrArray(operands);\n    let ret = binaryen._BinaryenTupleMake(this.ref, cArr, operands.length);\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  tuple_extract(tuple: ExpressionRef, index: Index): ExpressionRef {\n    return binaryen._BinaryenTupleExtract(this.ref, tuple, index);\n  }\n\n  // simd\n\n  simd_extract(\n    op: SIMDExtractOp,\n    vec: ExpressionRef,\n    idx: u8\n  ): ExpressionRef {\n    return binaryen._BinaryenSIMDExtract(this.ref, op, vec, idx);\n  }\n\n  simd_replace(\n    op: SIMDReplaceOp,\n    vec: ExpressionRef,\n    idx: u8,\n    value: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenSIMDReplace(this.ref, op, vec, idx, value);\n  }\n\n  simd_shuffle(\n    vec1: ExpressionRef,\n    vec2: ExpressionRef,\n    mask: Uint8Array\n  ): ExpressionRef {\n    assert(mask.length == 16);\n    let cArr = allocU8Array(mask);\n    let ret = binaryen._BinaryenSIMDShuffle(this.ref, vec1, vec2, cArr);\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  simd_ternary(\n    op: SIMDTernaryOp,\n    a: ExpressionRef,\n    b: ExpressionRef,\n    c: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenSIMDTernary(this.ref, op, a, b, c);\n  }\n\n  simd_shift(\n    op: SIMDShiftOp,\n    vec: ExpressionRef,\n    shift: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenSIMDShift(this.ref, op, vec, shift);\n  }\n\n  simd_load(\n    op: SIMDLoadOp,\n    ptr: ExpressionRef,\n    offset: u32,\n    align: u32,\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenSIMDLoad(this.ref, op, offset, align, ptr, cStr);\n  }\n\n  simd_loadstorelane(\n    op: SIMDLoadStoreLaneOp,\n    ptr: ExpressionRef,\n    offset: u32,\n    align: u32,\n    index: u8,\n    vec: ExpressionRef,\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenSIMDLoadStoreLane(this.ref, op, offset, align, index, ptr, vec, cStr);\n  }\n\n  // reference types / gc\n\n  ref_is_null(\n    expr: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenRefIsNull(this.ref, expr);\n  }\n\n  ref_as(\n    op: RefAsOp,\n    expr: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenRefAs(this.ref, op, expr);\n  }\n\n  ref_as_nonnull(\n    expr: ExpressionRef\n  ): ExpressionRef {\n    if (isNullableType(getExpressionType(expr))) {\n      return binaryen._BinaryenRefAs(this.ref, RefAsOp.NonNull, expr);\n    } else {\n      return expr;\n    }\n  }\n\n  ref_func(\n    name: string,\n    type: TypeRef\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenRefFunc(this.ref, cStr, binaryen._BinaryenTypeGetHeapType(type));\n  }\n\n  i31_new(\n    value: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenRefI31(this.ref, value);\n  }\n\n  i31_get(\n    expr: ExpressionRef,\n    signed: bool\n  ): ExpressionRef {\n    return binaryen._BinaryenI31Get(this.ref, expr, signed);\n  }\n\n  // globals\n\n  addGlobal(\n    name: string,\n    type: TypeRef,\n    mutable: bool,\n    initializer: ExpressionRef\n  ): GlobalRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAddGlobal(this.ref, cStr, type, mutable, initializer);\n  }\n\n  getGlobal(\n    name: string\n  ): GlobalRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGetGlobal(this.ref, cStr);\n  }\n\n  removeGlobal(\n    name: string\n  ): bool {\n    let cStr = this.allocStringCached(name);\n    if (!binaryen._BinaryenGetGlobal(this.ref, cStr)) return false;\n    binaryen._BinaryenRemoveGlobal(this.ref, cStr);\n    return true;\n  }\n\n  // tags\n\n  addTag(\n    name: string,\n    params: TypeRef,\n    results: TypeRef\n  ): TagRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAddTag(this.ref, cStr, params, results);\n  }\n\n  getTag(\n    name: string\n  ): TagRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGetTag(this.ref, cStr);\n  }\n\n  removeTag(\n    name: string\n  ): void {\n    let cStr = this.allocStringCached(name);\n    binaryen._BinaryenRemoveTag(this.ref, cStr);\n  }\n\n  // functions\n\n  addFunction(\n    name: string,\n    params: TypeRef,\n    results: TypeRef,\n    varTypes: TypeRef[] | null,\n    body: ExpressionRef\n  ): FunctionRef {\n    let cStr = this.allocStringCached(name);\n    let cArr = allocPtrArray(varTypes);\n    let ret = binaryen._BinaryenAddFunction(\n      this.ref,\n      cStr,\n      params,\n      results,\n      cArr,\n      varTypes ? varTypes.length : 0,\n      body\n    );\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  setLocalName(funcRef: FunctionRef, index: u32, name: string): void {\n    binaryen._BinaryenFunctionSetLocalName(funcRef, index, this.allocStringCached(name));\n  }\n\n  getFunction(\n    name: string\n  ): FunctionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGetFunction(this.ref, cStr);\n  }\n\n  removeFunction(name: string): void {\n    let cStr = this.allocStringCached(name);\n    binaryen._BinaryenRemoveFunction(this.ref, cStr);\n  }\n\n  hasFunction(name: string): bool {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGetFunction(this.ref, cStr) != 0;\n  }\n\n  private hasTemporaryFunction: bool = false;\n\n  addTemporaryFunction(\n    result: TypeRef,\n    paramTypes: TypeRef[] | null,\n    body: ExpressionRef\n  ): FunctionRef {\n    this.hasTemporaryFunction = assert(!this.hasTemporaryFunction);\n    let tempName = this.allocStringCached(\"\");\n    let cArr = allocPtrArray(paramTypes);\n    let ret = binaryen._BinaryenAddFunction(this.ref,\n      tempName,\n      createType(paramTypes),\n      result,\n      0, 0,\n      body\n    );\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  removeTemporaryFunction(): void {\n    this.hasTemporaryFunction = !assert(this.hasTemporaryFunction);\n    let tempName = this.allocStringCached(\"\");\n    binaryen._BinaryenRemoveFunction(this.ref, tempName);\n  }\n\n  setStart(func: FunctionRef): void {\n    binaryen._BinaryenSetStart(this.ref, func);\n  }\n\n  // exports\n\n  addFunctionExport(\n    internalName: string,\n    externalName: string\n  ): ExportRef {\n    let cStr1 = this.allocStringCached(internalName);\n    let cStr2 = this.allocStringCached(externalName);\n    return binaryen._BinaryenAddFunctionExport(this.ref, cStr1, cStr2);\n  }\n\n  addTableExport(\n    internalName: string,\n    externalName: string\n  ): ExportRef {\n    let cStr1 = this.allocStringCached(internalName);\n    let cStr2 = this.allocStringCached(externalName);\n    return binaryen._BinaryenAddTableExport(this.ref, cStr1, cStr2);\n  }\n\n  addMemoryExport(\n    internalName: string,\n    externalName: string\n  ): ExportRef {\n    let cStr1 = this.allocStringCached(internalName);\n    let cStr2 = this.allocStringCached(externalName);\n    return binaryen._BinaryenAddMemoryExport(this.ref, cStr1, cStr2);\n  }\n\n  addGlobalExport(\n    internalName: string,\n    externalName: string\n  ): ExportRef {\n    let cStr1 = this.allocStringCached(internalName);\n    let cStr2 = this.allocStringCached(externalName);\n    return binaryen._BinaryenAddGlobalExport(this.ref, cStr1, cStr2);\n  }\n\n  addTagExport(\n    internalName: string,\n    externalName: string\n  ): ExportRef {\n    let cStr1 = this.allocStringCached(internalName);\n    let cStr2 = this.allocStringCached(externalName);\n    return binaryen._BinaryenAddTagExport(this.ref, cStr1, cStr2);\n  }\n\n  removeExport(externalName: string): void {\n    let cStr = this.allocStringCached(externalName);\n    binaryen._BinaryenRemoveExport(this.ref, cStr);\n  }\n\n  hasExport(externalName: string): bool {\n    let cStr = this.allocStringCached(externalName);\n    return binaryen._BinaryenGetExport(this.ref, cStr) != 0;\n  }\n\n  // imports\n\n  addFunctionImport(\n    internalName: string,\n    externalModuleName: string,\n    externalBaseName: string,\n    params: TypeRef,\n    results: TypeRef\n  ): void {\n    let cStr1 = this.allocStringCached(internalName);\n    let cStr2 = this.allocStringCached(externalModuleName);\n    let cStr3 = this.allocStringCached(externalBaseName);\n    binaryen._BinaryenAddFunctionImport(this.ref, cStr1, cStr2, cStr3, params, results);\n  }\n\n  addTableImport(\n    internalName: string,\n    externalModuleName: string,\n    externalBaseName: string\n  ): void {\n    let cStr1 = this.allocStringCached(internalName);\n    let cStr2 = this.allocStringCached(externalModuleName);\n    let cStr3 = this.allocStringCached(externalBaseName);\n    binaryen._BinaryenAddTableImport(this.ref, cStr1, cStr2, cStr3);\n  }\n\n  addMemoryImport(\n    internalName: string,\n    externalModuleName: string,\n    externalBaseName: string,\n    shared: bool = false,\n  ): void {\n    let cStr1 = this.allocStringCached(internalName);\n    let cStr2 = this.allocStringCached(externalModuleName);\n    let cStr3 = this.allocStringCached(externalBaseName);\n    binaryen._BinaryenAddMemoryImport(this.ref, cStr1, cStr2, cStr3, shared);\n  }\n\n  addGlobalImport(\n    internalName: string,\n    externalModuleName: string,\n    externalBaseName: string,\n    globalType: TypeRef,\n    mutable: bool = false\n  ): void {\n    let cStr1 = this.allocStringCached(internalName);\n    let cStr2 = this.allocStringCached(externalModuleName);\n    let cStr3 = this.allocStringCached(externalBaseName);\n    binaryen._BinaryenAddGlobalImport(this.ref, cStr1, cStr2, cStr3, globalType, mutable);\n  }\n\n  addTagImport(\n    internalName: string,\n    externalModuleName: string,\n    externalBaseName: string,\n    params: TypeRef,\n    results: TypeRef\n  ): void {\n    let cStr1 = this.allocStringCached(internalName);\n    let cStr2 = this.allocStringCached(externalModuleName);\n    let cStr3 = this.allocStringCached(externalBaseName);\n    binaryen._BinaryenAddTagImport(\n      this.ref, cStr1, cStr2, cStr3, params, results\n    );\n  }\n\n  // memory\n\n  /** Unlimited memory constant. */\n  static readonly UNLIMITED_MEMORY: Index = <Index>-1;\n\n  setMemory(\n    initial: Index,\n    maximum: Index,\n    segments: MemorySegment[],\n    target: Target,\n    exportName: string | null = null,\n    name: string = CommonNames.DefaultMemory,\n    shared: bool = false\n  ): void {\n    let cExportName = this.allocStringCached(exportName);\n    let cName = this.allocStringCached(name);\n    let k = segments.length;\n    let segs = new Array<usize>(k);\n    let isPassive = new Uint8Array(k);\n    let offsets = new Array<ExpressionRef>(k);\n    let sizes = new Array<Index>(k);\n    for (let i = 0; i < k; ++i) {\n      let segment = unchecked(segments[i]);\n      let buffer = segment.buffer;\n      let offset = segment.offset;\n      unchecked(segs[i] = allocU8Array(buffer));\n      unchecked(isPassive[i] = 0); // no passive segments currently\n      unchecked(offsets[i] = target == Target.Wasm64\n        ? this.i64(i64_low(offset), i64_high(offset))\n        : this.i32(i64_low(offset))\n      );\n      unchecked(sizes[i] = buffer.length);\n    }\n    let cSegs = allocPtrArray(segs);\n    let cIsPassive = allocU8Array(isPassive);\n    let cOffsets = allocPtrArray(offsets);\n    let cSizes = allocU32Array(sizes);\n    binaryen._BinaryenSetMemory(\n      this.ref,\n      initial, maximum,\n      cExportName,\n      0, cSegs, cIsPassive,\n      cOffsets, cSizes,\n      k,\n      shared, false,\n      cName\n    );\n    binaryen._free(cSizes);\n    binaryen._free(cOffsets);\n    binaryen._free(cIsPassive);\n    binaryen._free(cSegs);\n    for (let i = k - 1; i >= 0; --i) {\n      binaryen._free(unchecked(segs[i]));\n    }\n  }\n\n  // table\n\n  /** Unlimited table constant. */\n  static readonly UNLIMITED_TABLE: Index = <Index>-1;\n\n  addFunctionTable(\n    name: string,\n    initial: Index,\n    maximum: Index,\n    funcs: string[],\n    offset: ExpressionRef\n  ): void {\n    let cStr = this.allocStringCached(name);\n    let numNames = funcs.length;\n    let names = new Array<StringRef>(numNames);\n    for (let i = 0; i < numNames; ++i) {\n      unchecked(names[i] = this.allocStringCached(funcs[i]));\n    }\n    let cArr = allocPtrArray(names);\n    let tableRef = binaryen._BinaryenGetTable(this.ref, cStr);\n    if (!tableRef) {\n      tableRef = binaryen._BinaryenAddTable(this.ref, cStr, initial, maximum, TypeRef.Funcref);\n    } else {\n      binaryen._BinaryenTableSetInitial(tableRef, initial);\n      binaryen._BinaryenTableSetMax(tableRef, maximum);\n    }\n    binaryen._BinaryenAddActiveElementSegment(this.ref, cStr, cStr, cArr, numNames, offset);\n    binaryen._free(cArr);\n  }\n\n  /* setFunctionTable(\n    initial: Index,\n    maximum: Index,\n    funcs: string[],\n    offset: ExpressionRef\n  ): void {\n    let numNames = funcs.length;\n    let names = new Array<CString>(numNames);\n    for (let i = 0; i < numNames; ++i) {\n      names[i] = this.allocStringCached(funcs[i]);\n    }\n    let cArr = allocPtrArray(names);\n    binaryen._BinaryenSetFunctionTable(\n      this.ref, initial, maximum, cArr, numNames, offset\n    );\n    binaryen._free(cArr);\n  } */\n\n  // sections\n\n  addCustomSection(name: string, contents: Uint8Array): void {\n    let cStr = this.allocStringCached(name);\n    let cArr = allocU8Array(contents);\n    binaryen._BinaryenAddCustomSection(this.ref, cStr, cArr, contents.length);\n    binaryen._free(cArr);\n  }\n\n  // meta (global)\n\n  getOptimizeLevel(): i32 {\n    return binaryen._BinaryenGetOptimizeLevel();\n  }\n\n  setOptimizeLevel(level: i32): void {\n    binaryen._BinaryenSetOptimizeLevel(level);\n  }\n\n  getShrinkLevel(): i32 {\n    return binaryen._BinaryenGetShrinkLevel();\n  }\n\n  setShrinkLevel(level: i32): void {\n    binaryen._BinaryenSetShrinkLevel(level);\n  }\n\n  getDebugInfo(): boolean {\n    return binaryen._BinaryenGetDebugInfo();\n  }\n\n  setDebugInfo(on: bool): void {\n    binaryen._BinaryenSetDebugInfo(on);\n  }\n\n  getClosedWorld(): bool {\n    return binaryen._BinaryenGetClosedWorld();\n  }\n\n  setClosedWorld(on: bool): void {\n    binaryen._BinaryenSetClosedWorld(on);\n  }\n\n  getLowMemoryUnused(): bool {\n    return binaryen._BinaryenGetLowMemoryUnused();\n  }\n\n  setLowMemoryUnused(on: bool): void {\n    binaryen._BinaryenSetLowMemoryUnused(on);\n  }\n\n  getZeroFilledMemory(): bool {\n    return binaryen._BinaryenGetZeroFilledMemory();\n  }\n\n  setZeroFilledMemory(on: bool): void {\n    binaryen._BinaryenSetZeroFilledMemory(on);\n  }\n\n  getFastMath(): bool {\n    return binaryen._BinaryenGetFastMath();\n  }\n\n  setFastMath(on: bool): void {\n    binaryen._BinaryenSetFastMath(on);\n  }\n\n  getGenerateStackIR(): bool {\n    return binaryen._BinaryenGetGenerateStackIR();\n  }\n\n  setGenerateStackIR(on: bool): void {\n    binaryen._BinaryenSetGenerateStackIR(on);\n  }\n\n  getOptimizeStackIR(): bool {\n    return binaryen._BinaryenGetOptimizeStackIR();\n  }\n\n  setOptimizeStackIR(on: bool): void {\n    binaryen._BinaryenSetOptimizeStackIR(on);\n  }\n\n  getPassArgument(key: string): string | null {\n    let cStr = this.allocStringCached(key);\n    let ptr = binaryen._BinaryenGetPassArgument(cStr);\n    return ptr ? readString(ptr) : null;\n  }\n\n  setPassArgument(key: string, value: string | null): void {\n    let cStr1 = this.allocStringCached(key);\n    let cStr2 = this.allocStringCached(value);\n    binaryen._BinaryenSetPassArgument(cStr1, cStr2);\n  }\n\n  clearPassArguments(): void {\n    binaryen._BinaryenClearPassArguments();\n  }\n\n  getAlwaysInlineMaxSize(): Index {\n    return binaryen._BinaryenGetAlwaysInlineMaxSize();\n  }\n\n  setAlwaysInlineMaxSize(size: Index): void {\n    binaryen._BinaryenSetAlwaysInlineMaxSize(size);\n  }\n\n  getFlexibleInlineMaxSize(): Index {\n    return binaryen._BinaryenGetFlexibleInlineMaxSize();\n  }\n\n  setFlexibleInlineMaxSize(size: Index): void {\n    binaryen._BinaryenSetFlexibleInlineMaxSize(size);\n  }\n\n  getOneCallerInlineMaxSize(): Index {\n    return binaryen._BinaryenGetOneCallerInlineMaxSize();\n  }\n\n  setOneCallerInlineMaxSize(size: Index): void {\n    binaryen._BinaryenSetOneCallerInlineMaxSize(size);\n  }\n\n  getAllowInliningFunctionsWithLoops(): bool {\n    return binaryen._BinaryenGetAllowInliningFunctionsWithLoops();\n  }\n\n  setAllowInliningFunctionsWithLoops(enabled: bool): void {\n    binaryen._BinaryenSetAllowInliningFunctionsWithLoops(enabled);\n  }\n\n  // meta (module)\n\n  getFeatures(): FeatureFlags {\n    return binaryen._BinaryenModuleGetFeatures(this.ref);\n  }\n\n  setFeatures(featureFlags: FeatureFlags): void {\n    if (featureFlags & FeatureFlags.BulkMemory) featureFlags |= FeatureFlags.BulkMemoryOpt;\n    binaryen._BinaryenModuleSetFeatures(this.ref, featureFlags);\n  }\n\n  runPasses(passes: string[], func: FunctionRef = 0): void {\n    let numNames = passes.length;\n    let cStrs = new Array<StringRef>(numNames);\n    for (let i = 0; i < numNames; ++i) {\n      cStrs[i] = allocString(passes[i]);\n    }\n    let cArr = allocPtrArray(cStrs);\n    if (func) {\n      binaryen._BinaryenFunctionRunPasses(func, this.ref, cArr, numNames);\n    } else {\n      binaryen._BinaryenModuleRunPasses(this.ref, cArr, numNames);\n    }\n    binaryen._free(cArr);\n    for (let i = numNames - 1; i >= 0; --i) binaryen._free(cStrs[i]);\n  }\n\n  optimize(\n    optimizeLevel: i32,\n    shrinkLevel: i32,\n    debugInfo: bool = false,\n    zeroFilledMemory: bool = false\n  ): void {\n    // Implicitly run costly non-LLVM optimizations on -O3 or -Oz\n    if (optimizeLevel >= 3 || shrinkLevel >= 2) optimizeLevel = 4;\n\n    this.setOptimizeLevel(optimizeLevel);\n    this.setShrinkLevel(shrinkLevel);\n    this.setDebugInfo(debugInfo);\n    this.setZeroFilledMemory(zeroFilledMemory);\n    this.setFastMath(true);\n    this.clearPassArguments();\n\n    // OptimizationOptions#parse in src/tools/optimization-options.h\n    const stackIR = optimizeLevel >= 2 || shrinkLevel >= 1;\n    this.setGenerateStackIR(stackIR);\n    this.setOptimizeStackIR(stackIR);\n\n    // Tweak inlining limits based on optimization levels\n    if (optimizeLevel >= 2 && shrinkLevel == 0) {\n      this.setAlwaysInlineMaxSize(12);\n      this.setFlexibleInlineMaxSize(70);\n      this.setOneCallerInlineMaxSize(200);\n      this.setAllowInliningFunctionsWithLoops(optimizeLevel >= 3);\n    } else {\n      this.setAlwaysInlineMaxSize(\n        optimizeLevel <= 1 || shrinkLevel >= 2\n          ? 2\n          : 6\n      );\n      this.setFlexibleInlineMaxSize(65);\n      this.setOneCallerInlineMaxSize(80);\n      this.setAllowInliningFunctionsWithLoops(false);\n    }\n\n    // Pass order here differs substantially from Binaryen's defaults\n    // see: Binaryen/src/pass.cpp\n    if (optimizeLevel > 0 || shrinkLevel > 0) {\n      let passes = new Array<string>();\n\n      // --- PassRunner::addDefaultGlobalOptimizationPrePasses ---\n\n      passes.push(\"duplicate-function-elimination\");\n      passes.push(\"remove-unused-module-elements\"); // +\n\n      // --- PassRunner::addDefaultFunctionOptimizationPasses ---\n      if (optimizeLevel >= 2) {\n        passes.push(\"once-reduction\");\n        passes.push(\"inlining\");\n        passes.push(\"simplify-globals-optimizing\");\n      }\n      if (optimizeLevel >= 3 || shrinkLevel >= 1) {\n        passes.push(\"rse\");\n        passes.push(\"vacuum\");\n        passes.push(\"code-folding\");\n        passes.push(\"ssa-nomerge\");\n        passes.push(\"local-cse\");\n        passes.push(\"remove-unused-brs\");\n        passes.push(\"remove-unused-names\");\n        passes.push(\"merge-blocks\");\n        passes.push(\"precompute-propagate\");\n        passes.push(\"simplify-globals-optimizing\");\n        passes.push(\"gufa-optimizing\");\n        passes.push(\"dae-optimizing\");\n      }\n      if (optimizeLevel >= 3) {\n        passes.push(\"simplify-locals-nostructure\");\n        passes.push(\"flatten\");\n        passes.push(\"vacuum\");\n        passes.push(\"simplify-locals-notee-nostructure\");\n        passes.push(\"vacuum\");\n        passes.push(\"licm\");\n        passes.push(\"merge-locals\");\n        passes.push(\"reorder-locals\");\n      }\n      passes.push(\"optimize-instructions\");\n      if (optimizeLevel >= 3 || shrinkLevel >= 1) {\n        passes.push(\"dce\");\n      }\n      passes.push(\"remove-unused-brs\");\n      passes.push(\"remove-unused-names\");\n      if (optimizeLevel >= 3 || shrinkLevel >= 2) {\n        passes.push(\"inlining\");\n        passes.push(\"precompute-propagate\");\n        passes.push(\"simplify-globals-optimizing\");\n      } else {\n        passes.push(\"precompute\");\n      }\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"pick-load-signs\");\n      }\n      passes.push(\"simplify-locals-notee-nostructure\");\n      passes.push(\"vacuum\");\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"local-cse\");\n      }\n      passes.push(\"reorder-locals\");\n      passes.push(\"coalesce-locals\");\n      passes.push(\"simplify-locals\");\n      passes.push(\"coalesce-locals\");\n      passes.push(\"reorder-locals\");\n      passes.push(\"vacuum\");\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"rse\");\n        passes.push(\"vacuum\");\n      }\n      if (optimizeLevel >= 3 || shrinkLevel >= 1) {\n        passes.push(\"merge-locals\");\n        passes.push(\"vacuum\");\n      }\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"simplify-globals-optimizing\");\n        passes.push(\"simplify-globals-optimizing\");\n      }\n      passes.push(\"remove-unused-brs\");\n      passes.push(\"remove-unused-names\");\n      passes.push(\"merge-blocks\");\n      if (optimizeLevel >= 3) {\n        passes.push(\"optimize-instructions\");\n      }\n\n      // --- PassRunner::addDefaultGlobalOptimizationPostPasses ---\n\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"simplify-globals-optimizing\");\n        passes.push(\"dae-optimizing\");\n      }\n      if (optimizeLevel >= 2 || shrinkLevel >= 2) {\n        passes.push(\"inlining-optimizing\");\n      }\n      if (this.getLowMemoryUnused()) {\n        if (optimizeLevel >= 3 || shrinkLevel >= 1) {\n          passes.push(\"optimize-added-constants-propagate\");\n        } else {\n          passes.push(\"optimize-added-constants\");\n        }\n      }\n      passes.push(\"duplicate-import-elimination\");\n      if (optimizeLevel >= 2 || shrinkLevel >= 2) {\n        passes.push(\"simplify-globals-optimizing\");\n      } else {\n        passes.push(\"simplify-globals\");\n        passes.push(\"vacuum\");\n      }\n      if (optimizeLevel >= 2 && (this.getFeatures() & FeatureFlags.GC) != 0) {\n        passes.push(\"heap2local\");\n        passes.push(\"merge-locals\");\n        passes.push(\"local-subtyping\");\n      }\n      // precompute works best after global optimizations\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"precompute-propagate\");\n        passes.push(\"simplify-globals-optimizing\");\n        passes.push(\"simplify-globals-optimizing\");\n      } else {\n        passes.push(\"precompute\");\n      }\n      passes.push(\"directize\"); // replace indirect with direct calls\n      passes.push(\"dae-optimizing\"); // reduce arity\n      passes.push(\"inlining-optimizing\"); // and inline if possible\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"code-folding\");\n        passes.push(\"ssa-nomerge\");\n        passes.push(\"rse\");\n        // move code on early return (after CFG cleanup)\n        passes.push(\"code-pushing\");\n        if (optimizeLevel >= 3) {\n          // very expensive, so O3 only\n          passes.push(\"simplify-globals\");\n          passes.push(\"vacuum\");\n\n          passes.push(\"precompute-propagate\");\n\n          // replace indirect with direct calls again and inline\n          passes.push(\"inlining-optimizing\");\n          passes.push(\"directize\");\n          passes.push(\"dae-optimizing\");\n          passes.push(\"local-cse\");\n\n          passes.push(\"merge-locals\");\n          passes.push(\"coalesce-locals\");\n          passes.push(\"simplify-locals\");\n          passes.push(\"vacuum\");\n\n          passes.push(\"inlining\");\n          passes.push(\"precompute-propagate\");\n          passes.push(\"rse\");\n          passes.push(\"vacuum\");\n          passes.push(\"ssa-nomerge\");\n          passes.push(\"simplify-locals\");\n          passes.push(\"coalesce-locals\");\n        }\n        passes.push(\"optimize-instructions\");\n        passes.push(\"remove-unused-brs\");\n        passes.push(\"remove-unused-names\");\n        passes.push(\"merge-blocks\");\n        passes.push(\"vacuum\");\n\n        passes.push(\"simplify-globals-optimizing\");\n        passes.push(\"reorder-globals\");\n        passes.push(\"remove-unused-brs\");\n        passes.push(\"optimize-instructions\");\n      }\n      // clean up\n      passes.push(\"duplicate-function-elimination\");\n      if (shrinkLevel >= 2) {\n        passes.push(\"merge-similar-functions\");\n      }\n      passes.push(\"memory-packing\");\n      passes.push(\"remove-unused-module-elements\");\n\n      this.runPasses(passes);\n    }\n  }\n\n  validate(): bool {\n    return binaryen._BinaryenModuleValidate(this.ref) == 1;\n  }\n\n  interpret(): void {\n    binaryen._BinaryenModuleInterpret(this.ref);\n  }\n\n  toBinary(sourceMapUrl: string | null = null): BinaryModule {\n    assert(\n      binaryen._BinaryenSizeofLiteral() >=\n      binaryen._BinaryenSizeofAllocateAndWriteResult()\n    );\n\n    // now safely reuse lit buffer for BinaryenModuleAllocateAndWriteResult\n    let resPtr = this.lit;\n    let urlPtr = allocString(sourceMapUrl);\n\n    binaryen._BinaryenModuleAllocateAndWrite(resPtr, this.ref, urlPtr);\n\n    // read BinaryenModuleAllocateAndWriteResult struct\n    let binaryPtr = binaryen.__i32_load(resPtr + 0) as usize; // non-nullabe\n    let binaryLen = binaryen.__i32_load(resPtr + 4);\n    let srcMapPtr = binaryen.__i32_load(resPtr + 8) as usize; // nullable\n\n    let binary = new BinaryModule(\n      readBuffer(assert(binaryPtr), binaryLen),\n      readString(srcMapPtr)\n    );\n\n    if (urlPtr) binaryen._free(urlPtr);\n    if (srcMapPtr) binaryen._free(srcMapPtr);\n    binaryen._free(binaryPtr);\n\n    return binary;\n  }\n\n  toText(watFormat: bool = true): string {\n    let textPtr = watFormat\n      ? binaryen._BinaryenModuleAllocateAndWriteStackIR(this.ref)\n      : binaryen._BinaryenModuleAllocateAndWriteText(this.ref);\n    let text = readString(textPtr);\n    if (textPtr) binaryen._free(textPtr);\n    return text || \"\";\n  }\n\n  private cachedStringsToPointers: Map<string,usize> = new Map();\n  private cachedPointersToStrings: Map<usize,string | null> = new Map();\n\n  allocStringCached(str: string | null): usize {\n    if (str == null) return 0;\n    let cached = this.cachedStringsToPointers;\n    if (cached.has(str)) return changetype<usize>(cached.get(str));\n    let ptr = allocString(str);\n    cached.set(str, ptr);\n    return ptr;\n  }\n\n  readStringCached(ptr: usize): string | null {\n    // Binaryen internalizes names, so using this method where it's safe can\n    // avoid quite a bit of unnecessary garbage.\n    if (ptr == 0) return null;\n    let cached = this.cachedPointersToStrings;\n    if (cached.has(ptr)) return changetype<string>(cached.get(ptr));\n    let str = readString(ptr);\n    cached.set(ptr, str);\n    return str;\n  }\n\n  dispose(): void {\n    assert(this.ref);\n    // TODO: for (let ptr of this.cachedStrings.values()) {\n    for (let _values = Map_values(this.cachedStringsToPointers), i = 0, k = _values.length; i < k; ++i) {\n      let ptr = unchecked(_values[i]);\n      binaryen._free(ptr);\n    }\n    this.cachedStringsToPointers.clear();\n    this.cachedPointersToStrings.clear();\n    binaryen._free(this.lit);\n    binaryen._BinaryenModuleDispose(this.ref);\n    this.ref = 0;\n  }\n\n  createRelooper(): Relooper {\n    return Relooper.create(this);\n  }\n\n  /** Makes a copy of a trivial expression (doesn't contain subexpressions). Returns `0` if non-trivial. */\n  tryCopyTrivialExpression(expr: ExpressionRef): ExpressionRef {\n    switch (binaryen._BinaryenExpressionGetId(expr)) {\n      case ExpressionId.LocalGet:\n      case ExpressionId.GlobalGet:\n      case ExpressionId.Const:\n      case ExpressionId.MemorySize:\n      case ExpressionId.Nop:\n      case ExpressionId.Unreachable:\n      case ExpressionId.DataDrop:\n      case ExpressionId.RefNull: return this.copyExpression(expr);\n    }\n    return 0;\n  }\n\n  /** Makes a copy of any expression including all subexpressions. */\n  copyExpression(expr: ExpressionRef): ExpressionRef {\n    // TODO: Copy debug location as well (needs Binaryen support)\n    return binaryen._BinaryenExpressionCopy(expr, this.ref);\n  }\n\n  runExpression(\n    expr: ExpressionRef,\n    flags: ExpressionRunnerFlags,\n    maxDepth: i32 = 50,\n    maxLoopIterations: i32 = 1\n  ): ExpressionRef {\n    let runner = binaryen._ExpressionRunnerCreate(this.ref, flags, maxDepth, maxLoopIterations);\n    let precomp = binaryen._ExpressionRunnerRunAndDispose(runner, expr);\n    if (precomp) {\n      if (!this.isConstExpression(precomp)) return 0;\n      assert(getExpressionType(precomp) == getExpressionType(expr));\n    }\n    return precomp;\n  }\n\n  isConstExpression(expr: ExpressionRef): bool {\n    switch (getExpressionId(expr)) {\n      case ExpressionId.Const:\n      case ExpressionId.RefNull:\n      case ExpressionId.RefFunc:\n      case ExpressionId.RefI31: return true;\n      case ExpressionId.Binary: {\n        if (this.getFeatures() & FeatureFlags.ExtendedConst) {\n          switch (getBinaryOp(expr)) {\n            case BinaryOp.AddI32:\n            case BinaryOp.SubI32:\n            case BinaryOp.MulI32:\n            case BinaryOp.AddI64:\n            case BinaryOp.SubI64:\n            case BinaryOp.MulI64:\n              return (\n                this.isConstExpression(getBinaryLeft(expr)) &&\n                this.isConstExpression(getBinaryRight(expr))\n              );\n          }\n        }\n        break;\n      }\n    }\n    return false;\n  }\n\n  // source map generation\n\n  addDebugInfoFile(name: string): Index {\n    let cStr = allocString(name);\n    let ret = binaryen._BinaryenModuleAddDebugInfoFileName(this.ref, cStr);\n    binaryen._free(cStr);\n    return ret;\n  }\n\n  getDebugInfoFile(index: Index): string | null {\n    return readString(binaryen._BinaryenModuleGetDebugInfoFileName(this.ref, index));\n  }\n\n  setDebugLocation(\n    func: FunctionRef,\n    expr: ExpressionRef,\n    fileIndex: Index,\n    lineNumber: Index,\n    columnNumber: Index\n  ): void {\n    binaryen._BinaryenFunctionSetDebugLocation(func, expr, fileIndex, lineNumber, columnNumber);\n  }\n}\n\n// types\n\nexport function createType(types: TypeRef[] | null): TypeRef {\n  if (!types) return TypeRef.None;\n  switch (types.length) {\n    case 0: return TypeRef.None;\n    case 1: return types[0];\n  }\n  let cArr = allocPtrArray(types);\n  let ret = binaryen._BinaryenTypeCreate(cArr, types.length);\n  binaryen._free(cArr);\n  return ret;\n}\n\nexport function expandType(type: TypeRef): TypeRef[] {\n  let arity = binaryen._BinaryenTypeArity(type);\n  let cArr = binaryen._malloc(<usize>arity << 2);\n  binaryen._BinaryenTypeExpand(type, cArr);\n  let types = new Array<TypeRef>(arity);\n  for (let i: u32 = 0; i < arity; ++i) {\n    unchecked(types[i] = binaryen.__i32_load(cArr + (<usize>i << 2)));\n  }\n  binaryen._free(cArr);\n  return types;\n}\n\nexport function isNullableType(type: TypeRef): bool {\n  return binaryen._BinaryenTypeIsNullable(type);\n}\n\n// expressions\n\nexport function getExpressionId(expr: ExpressionRef): ExpressionId {\n  return binaryen._BinaryenExpressionGetId(expr);\n}\n\nexport function getExpressionType(expr: ExpressionRef): TypeRef {\n  return binaryen._BinaryenExpressionGetType(expr);\n}\n\nexport function getConstValueI32(expr: ExpressionRef): i32 {\n  return binaryen._BinaryenConstGetValueI32(expr);\n}\n\nexport function getConstValueI64Low(expr: ExpressionRef): i32 {\n  return binaryen._BinaryenConstGetValueI64Low(expr);\n}\n\nexport function getConstValueI64High(expr: ExpressionRef): i32 {\n  return binaryen._BinaryenConstGetValueI64High(expr);\n}\n\nexport function getConstValueInteger(expr: ExpressionRef, isWasm64: bool): i64 {\n  let lo: i32 = 0;\n  let hi: i32 = 0;\n  if (isWasm64) {\n    lo = getConstValueI64Low(expr);\n    hi = getConstValueI64High(expr);\n  } else {\n    lo = getConstValueI32(expr);\n  }\n  return i64_new(lo, hi);\n}\n\nexport function getConstValueF32(expr: ExpressionRef): f32 {\n  return binaryen._BinaryenConstGetValueF32(expr);\n}\n\nexport function getConstValueF64(expr: ExpressionRef): f64 {\n  return binaryen._BinaryenConstGetValueF64(expr);\n}\n\nexport function getConstValueV128(expr: ExpressionRef): Uint8Array {\n  let cArr = binaryen._malloc(16);\n  binaryen._BinaryenConstGetValueV128(expr, cArr);\n  let out = new Uint8Array(16);\n  for (let i = 0; i < 16; ++i) {\n    out[i] = binaryen.__i32_load8_u(cArr + i);\n  }\n  binaryen._free(cArr);\n  return out;\n}\n\nexport function isConstZero(expr: ExpressionRef): bool {\n  if (getExpressionId(expr) != ExpressionId.Const) return false;\n  let type = getExpressionType(expr);\n  if (type == TypeRef.I32) return getConstValueI32(expr) == 0;\n  if (type == TypeRef.I64) return (getConstValueI64Low(expr) | getConstValueI64High(expr)) == 0;\n  if (type == TypeRef.F32) return getConstValueF32(expr) == 0;\n  if (type == TypeRef.F64) return getConstValueF64(expr) == 0;\n  return false;\n}\n\nexport function isConstNonZero(expr: ExpressionRef): bool {\n  if (getExpressionId(expr) != ExpressionId.Const) return false;\n  let type = getExpressionType(expr);\n  if (type == TypeRef.I32) return getConstValueI32(expr) != 0;\n  if (type == TypeRef.I64) return (getConstValueI64Low(expr) | getConstValueI64High(expr)) != 0;\n  if (type == TypeRef.F32) return getConstValueF32(expr) != 0;\n  if (type == TypeRef.F64) return getConstValueF64(expr) != 0;\n  return false;\n}\n\nexport function isConstNegZero(expr: ExpressionRef): bool {\n  if (getExpressionId(expr) != ExpressionId.Const) return false;\n  let type = getExpressionType(expr);\n  if (type == TypeRef.F32) {\n    let d = getConstValueF32(expr);\n    return d == 0 && f32_as_i32(d) < 0;\n  }\n  if (type == TypeRef.F64) {\n    let d = getConstValueF64(expr);\n    return d == 0 && i64_signbit(f64_as_i64(d));\n  }\n  return false;\n}\n\nexport function isConstNaN(expr: ExpressionRef): bool {\n  if (getExpressionId(expr) != ExpressionId.Const) return false;\n  let type = getExpressionType(expr);\n  if (type == TypeRef.F32) return isNaN(getConstValueF32(expr));\n  if (type == TypeRef.F64) return isNaN(getConstValueF64(expr));\n  return false;\n}\n\nexport function isConstExpressionNaN(module: Module, expr: ExpressionRef): bool {\n  let id = getExpressionId(expr);\n  let type = getExpressionType(expr);\n  if (type == TypeRef.F32 || type == TypeRef.F64) {\n    if (id == ExpressionId.Const) {\n      return isNaN(\n        type == TypeRef.F32\n          ? getConstValueF32(expr)\n          : getConstValueF64(expr)\n      );\n    } else if (id == ExpressionId.GlobalGet) {\n      let precomp = module.runExpression(expr, ExpressionRunnerFlags.Default, 8);\n      if (precomp) {\n        return isNaN(\n          type == TypeRef.F32\n            ? getConstValueF32(precomp)\n            : getConstValueF64(precomp)\n        );\n      }\n    }\n  }\n  return false;\n}\n\nexport function getLocalGetIndex(expr: ExpressionRef): Index {\n  return binaryen._BinaryenLocalGetGetIndex(expr);\n}\n\nexport function getLocalSetIndex(expr: ExpressionRef): Index {\n  return binaryen._BinaryenLocalSetGetIndex(expr);\n}\n\nexport function getLocalSetValue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenLocalSetGetValue(expr);\n}\n\nexport function isLocalTee(expr: ExpressionRef): bool {\n  return binaryen._BinaryenLocalSetIsTee(expr);\n}\n\nexport function getGlobalGetName(expr: ExpressionRef): string | null {\n  return readString(binaryen._BinaryenGlobalGetGetName(expr));\n}\n\nexport function getBinaryOp(expr: ExpressionRef): BinaryOp {\n  return binaryen._BinaryenBinaryGetOp(expr);\n}\n\nexport function getBinaryLeft(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenBinaryGetLeft(expr);\n}\n\nexport function getBinaryRight(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenBinaryGetRight(expr);\n}\n\nexport function getUnaryOp(expr: ExpressionRef): UnaryOp {\n  return binaryen._BinaryenUnaryGetOp(expr);\n}\n\nexport function getUnaryValue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenUnaryGetValue(expr);\n}\n\nexport function getLoadBytes(expr: ExpressionRef): u32 {\n  return binaryen._BinaryenLoadGetBytes(expr);\n}\n\nexport function getLoadOffset(expr: ExpressionRef): u32 {\n  return binaryen._BinaryenLoadGetOffset(expr);\n}\n\nexport function getLoadPtr(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenLoadGetPtr(expr);\n}\n\nexport function isLoadSigned(expr: ExpressionRef): bool {\n  return binaryen._BinaryenLoadIsSigned(expr);\n}\n\nexport function getStoreBytes(expr: ExpressionRef): u32 {\n  return binaryen._BinaryenStoreGetBytes(expr);\n}\n\nexport function getStoreOffset(expr: ExpressionRef): u32 {\n  return binaryen._BinaryenStoreGetOffset(expr);\n}\n\nexport function getStorePtr(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenStoreGetPtr(expr);\n}\n\nexport function getStoreValue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenStoreGetValue(expr);\n}\n\nexport function getBlockName(expr: ExpressionRef): string | null {\n  return readString(binaryen._BinaryenBlockGetName(expr));\n}\n\nexport function getBlockChildCount(expr: ExpressionRef): Index {\n  return binaryen._BinaryenBlockGetNumChildren(expr);\n}\n\nexport function getBlockChildAt(expr: ExpressionRef, index: Index): ExpressionRef {\n  return binaryen._BinaryenBlockGetChildAt(expr, index);\n}\n\nexport function getIfCondition(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenIfGetCondition(expr);\n}\n\nexport function getIfTrue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenIfGetIfTrue(expr);\n}\n\nexport function getIfFalse(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenIfGetIfFalse(expr);\n}\n\nexport function getLoopName(expr: ExpressionRef): string | null {\n  return readString(binaryen._BinaryenLoopGetName(expr));\n}\n\nexport function getLoopBody(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenLoopGetBody(expr);\n}\n\nexport function getBreakName(expr: ExpressionRef): string | null {\n  return readString(binaryen._BinaryenBreakGetName(expr));\n}\n\nexport function getBreakCondition(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenBreakGetCondition(expr);\n}\n\nexport function getSelectThen(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenSelectGetIfTrue(expr);\n}\n\nexport function getSelectElse(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenSelectGetIfFalse(expr);\n}\n\nexport function getSelectCondition(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenSelectGetCondition(expr);\n}\n\nexport function getDropValue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenDropGetValue(expr);\n}\n\nexport function getReturnValue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenReturnGetValue(expr);\n}\n\nexport function getCallTarget(expr: ExpressionRef): string | null {\n  return readString(binaryen._BinaryenCallGetTarget(expr));\n}\n\nexport function getCallOperandCount(expr: ExpressionRef): i32 {\n  return binaryen._BinaryenCallGetNumOperands(expr);\n}\n\nexport function getCallOperandAt(expr: ExpressionRef, index: Index): ExpressionRef {\n  return binaryen._BinaryenCallGetOperandAt(expr, index);\n}\n\nexport function getMemoryGrowDelta(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenMemoryGrowGetDelta(expr);\n}\n\n// functions\n\nexport function getFunctionBody(func: FunctionRef): ExpressionRef {\n  return binaryen._BinaryenFunctionGetBody(func);\n}\n\nexport function getFunctionName(func: FunctionRef): string | null {\n  return readString(binaryen._BinaryenFunctionGetName(func));\n}\n\nexport function getFunctionParams(func: FunctionRef): TypeRef {\n  return binaryen._BinaryenFunctionGetParams(func);\n}\n\nexport function getFunctionResults(func: FunctionRef): TypeRef {\n  return binaryen._BinaryenFunctionGetResults(func);\n}\n\nexport function getFunctionVars(func: FunctionRef): TypeRef[] {\n  let count = binaryen._BinaryenFunctionGetNumVars(func);\n  let types = new Array<TypeRef>(count);\n  for (let i: Index = 0; i < count; ++i) {\n    unchecked(types[i] = binaryen._BinaryenFunctionGetVar(func, i));\n  }\n  return types;\n}\n\n// globals\n\nexport function getGlobalName(global: GlobalRef): string | null {\n  return readString(binaryen._BinaryenGlobalGetName(global));\n}\n\nexport function getGlobalType(global: GlobalRef): TypeRef {\n  return binaryen._BinaryenGlobalGetType(global);\n}\n\nexport function isGlobalMutable(global: GlobalRef): bool {\n  return binaryen._BinaryenGlobalIsMutable(global);\n}\n\nexport function getGlobalInit(global: GlobalRef): ExpressionRef {\n  return binaryen._BinaryenGlobalGetInitExpr(global);\n}\n\n// tags\n\nexport function getTagName(tag: TagRef): string | null {\n  return readString(binaryen._BinaryenTagGetName(tag));\n}\n\nexport function getTagParams(tag: TagRef): TypeRef {\n  return binaryen._BinaryenTagGetParams(tag);\n}\n\nexport function getTagResults(tag: TagRef): TypeRef {\n  return binaryen._BinaryenTagGetResults(tag);\n}\n\nexport class Relooper {\n  constructor(\n    /** Module this relooper belongs to. */\n    public module: Module,\n    /** Binaryen relooper reference. */\n    public ref: RelooperRef\n  ) {}\n\n  static create(module: Module): Relooper {\n    return new Relooper(module, binaryen._RelooperCreate(module.ref));\n  }\n\n  addBlock(code: ExpressionRef): RelooperBlockRef {\n    return binaryen._RelooperAddBlock(this.ref, code);\n  }\n\n  addBranch(\n    from: RelooperBlockRef,\n    to: RelooperBlockRef,\n    condition: ExpressionRef = 0,\n    code: ExpressionRef = 0\n  ): void {\n    binaryen._RelooperAddBranch(from, to, condition, code);\n  }\n\n  addBlockWithSwitch(code: ExpressionRef, condition: ExpressionRef): RelooperBlockRef {\n    return binaryen._RelooperAddBlockWithSwitch(this.ref, code, condition);\n  }\n\n  addBranchForSwitch(\n    from: RelooperBlockRef,\n    to: RelooperBlockRef,\n    indexes: i32[],\n    code: ExpressionRef = 0\n  ): void {\n    let cArr = allocI32Array(indexes);\n    binaryen._RelooperAddBranchForSwitch(from, to, cArr, indexes.length, code);\n    binaryen._free(cArr);\n  }\n\n  renderAndDispose(entry: RelooperBlockRef, labelHelper: Index): ExpressionRef {\n    return binaryen._RelooperRenderAndDispose(this.ref, entry, labelHelper);\n  }\n}\n\n/** Builds a switch using a sequence of `br_if`s. */\nexport class SwitchBuilder {\n  // This is useful because Binaryen understands sequences of `br_if`s and\n  // knows how to make a `br_table` from such a sequence if switched over\n  // values are considered dense enough, respectively a size-efficient sequence\n  // of `if`s if not, depending on optimization levels.\n\n  private module: Module;\n  private condition: ExpressionRef;\n  private values: i32[] = new Array();\n  private indexes: i32[] = new Array();\n  private cases: ExpressionRef[][] = new Array();\n  private defaultIndex: i32 = -1;\n\n  /** Creates a new builder using the specified i32 condition. */\n  constructor(module: Module, condition: ExpressionRef) {\n    this.module = module;\n    this.condition = condition;\n  }\n\n  /** Links a case to the specified branch, replace old case if it is linked. */\n  addOrReplaceCase(value: i32, code: ExpressionRef[]): void {\n    const valueIndex = this.values.indexOf(value);\n    const codeIndex =  this.addCode(code);\n    if (valueIndex >= 0) {\n      this.indexes[valueIndex] = codeIndex;\n    } else {\n      this.values.push(value);\n      this.indexes.push(codeIndex);\n    }\n  }\n\n  /** Links a case to the specified branch. */\n  addCase(value: i32, code: ExpressionRef[]): void {\n    this.values.push(value);\n    this.indexes.push(this.addCode(code));\n  }\n\n  private addCode(code: ExpressionRef[]): i32 {\n    let cases = this.cases;\n    let index = cases.indexOf(code);\n    if (index < 0) {\n      index = cases.length;\n      cases.push(code);\n    }\n    return index;\n  }\n\n  /** Links the default branch. */\n  addDefault(code: ExpressionRef[]): void {\n    assert(this.defaultIndex == -1);\n    let cases = this.cases;\n    this.defaultIndex = cases.length;\n    cases.push(code);\n  }\n\n  /** Renders the switch to a block. */\n  render(localIndex: i32, labelPostfix: string = \"\"): ExpressionRef {\n    let module = this.module;\n    let cases = this.cases;\n    let numCases = cases.length;\n    if (!numCases) {\n      return module.drop(this.condition);\n    }\n    let values = this.values;\n    let numValues = values.length;\n    let indexes = this.indexes;\n    let entry = new Array<ExpressionRef>(1 + numValues + 1);\n    let labels = new Array<string>(numCases);\n    for (let i = 0; i < numCases; ++i) {\n      unchecked(labels[i] = `case${i}${labelPostfix}`);\n    }\n    entry[0] = module.local_set(localIndex, this.condition, false); // u32\n    for (let i = 0; i < numValues; ++i) {\n      let index = unchecked(indexes[i]);\n      unchecked(entry[1 + i] = module.br(labels[index],\n        module.binary(BinaryOp.EqI32,\n          module.local_get(localIndex, TypeRef.I32),\n          module.i32(values[i])\n        )\n      ));\n    }\n    let defaultIndex = this.defaultIndex;\n    let defaultLabel = `default${labelPostfix}`;\n    entry[1 + numValues] = module.br(\n      ~defaultIndex\n        ? labels[defaultIndex]\n        : defaultLabel\n    );\n    let current = module.block(labels[0], entry);\n    for (let i = 1; i < numCases; ++i) {\n      let block = cases[i - 1];\n      block.unshift(current);\n      current = module.block(unchecked(labels[i]), block);\n    }\n    let lastCase = cases[numCases - 1];\n    lastCase.unshift(current);\n    return module.block(\n      ~defaultIndex\n        ? null\n        : defaultLabel,\n      lastCase\n    );\n  }\n}\n\nexport const enum SideEffects {\n  None = 0 /* _BinaryenSideEffectNone */,\n  Branches = 1 /* _BinaryenSideEffectBranches */,\n  Calls = 2 /* _BinaryenSideEffectCalls */,\n  ReadsLocal = 4 /* _BinaryenSideEffectReadsLocal */,\n  WritesLocal = 8 /* _BinaryenSideEffectWritesLocal */,\n  ReadsGlobal = 16 /* _BinaryenSideEffectReadsGlobal */,\n  WritesGlobal = 32 /* _BinaryenSideEffectWritesGlobal */,\n  ReadsMemory = 64 /* _BinaryenSideEffectReadsMemory */,\n  WritesMemory = 128 /* _BinaryenSideEffectWritesMemory */,\n  ReadsTable = 256 /* _BinaryenSideEffectReadsTable */,\n  WritesTable = 512 /* _BinaryenSideEffectWritesTable */,\n  ImplicitTrap = 1024 /* _BinaryenSideEffectImplicitTrap */,\n  IsAtomic = 2048 /* _BinaryenSideEffectIsAtomic */,\n  Throws = 4096 /* _BinaryenSideEffectThrows */,\n  DanglingPop = 8192 /* _BinaryenSideEffectDanglingPop */,\n  TrapsNeverHappen = 16384 /* _BinaryenSideEffectTrapsNeverHappen */,\n  Any = 32767 /* _BinaryenSideEffectAny */\n}\n\nexport function getSideEffects(expr: ExpressionRef, module: ModuleRef): SideEffects {\n  return binaryen._BinaryenExpressionGetSideEffects(expr, module);\n}\n\nexport function mustPreserveSideEffects(expr: ExpressionRef, module: ModuleRef): bool {\n  return (getSideEffects(expr, module) & ~(SideEffects.ReadsLocal | SideEffects.ReadsGlobal)) != SideEffects.None;\n}\n\n// helpers\n// can't do stack allocation here: STACKTOP is a global in WASM but a hidden variable in asm.js\n\nfunction allocU8Array(u8s: Uint8Array | null): usize {\n  if (!u8s) return 0;\n  let len = u8s.length;\n  let ptr = binaryen._malloc(len);\n  for (let i = 0; i < len; ++i) {\n    binaryen.__i32_store8(ptr + i, unchecked(u8s[i]));\n  }\n  return ptr;\n}\n\nfunction allocI32Array(i32s: i32[] | null): usize {\n  if (!i32s) return 0;\n  let len = i32s.length;\n  let ptr = binaryen._malloc(len << 2);\n  let idx = ptr;\n  for (let i = 0; i < len; ++i) {\n    let val = unchecked(i32s[i]);\n    binaryen.__i32_store(idx, val);\n    idx += 4;\n  }\n  return ptr;\n}\n\nfunction allocU32Array(u32s: u32[] | null): usize {\n  if (!u32s) return 0;\n  let len = u32s.length;\n  let ptr = binaryen._malloc(len << 2);\n  let idx = ptr;\n  for (let i = 0; i < len; ++i) {\n    let val = unchecked(u32s[i]);\n    binaryen.__i32_store(idx, val);\n    idx += 4;\n  }\n  return ptr;\n}\n\nexport function allocPtrArray(ptrs: usize[] | null): usize {\n  if (!ptrs) return 0;\n  // TODO: WASM64\n  assert(ASC_TARGET != Target.Wasm64);\n  let len = ptrs.length;\n  let ptr = binaryen._malloc(len << 2);\n  let idx = ptr;\n  for (let i = 0, k = len; i < k; ++i) {\n    let val = unchecked(ptrs[i]);\n    binaryen.__i32_store(idx, <i32>val);\n    idx += 4;\n  }\n  return ptr;\n}\n\nfunction stringLengthUTF8(str: string): usize {\n  let len = 0;\n  for (let i = 0, k = str.length; i < k; ++i) {\n    let c1 = str.charCodeAt(i) >>> 0;\n    if (c1 <= 0x7F) {\n      len += 1;\n    } else if (c1 <= 0x7FF) {\n      len += 2;\n    } else if (\n      isHighSurrogate(c1) && i + 1 < k &&\n      isLowSurrogate(str.charCodeAt(i + 1))\n    ) {\n      i++;\n      len += 4;\n    } else {\n      len += 3;\n    }\n  }\n  return len;\n}\n\nfunction allocString(str: string | null): usize {\n  if (str == null) return 0;\n  let len = stringLengthUTF8(str);\n  let ptr = binaryen._malloc(len + 1) >>> 0;\n  let idx = ptr;\n  if (len == str.length) {\n    // fast path when all chars are ascii\n    for (let i = 0, k = str.length; i < k; ++i) {\n      let u = str.charCodeAt(i) >>> 0;\n      binaryen.__i32_store8(idx++, u as u8);\n    }\n  } else {\n    for (let i = 0, k = str.length; i < k; ++i) {\n      let c1 = str.charCodeAt(i) >>> 0, c2: i32;\n      if (c1 <= 0x7F) {\n        binaryen.__i32_store8(idx++, c1 as u8);\n      } else if (c1 <= 0x7FF) {\n        binaryen.__i32_store8(idx++, (0xC0 |  (c1 >>> 6)       ) as u8);\n        binaryen.__i32_store8(idx++, (0x80 | ( c1         & 63)) as u8);\n      } else if (\n        isHighSurrogate(c1) && i + 1 < k &&\n        isLowSurrogate(c2 = str.charCodeAt(i + 1))\n      ) {\n        c1 = combineSurrogates(c1, c2);\n        ++i;\n        binaryen.__i32_store8(idx++, (0xF0 |  (c1 >>> 18)      ) as u8);\n        binaryen.__i32_store8(idx++, (0x80 | ((c1 >>> 12) & 63)) as u8);\n        binaryen.__i32_store8(idx++, (0x80 | ((c1 >>>  6) & 63)) as u8);\n        binaryen.__i32_store8(idx++, (0x80 | ( c1         & 63)) as u8);\n      } else {\n        binaryen.__i32_store8(idx++, (0xE0 |  (c1 >>> 12)      ) as u8);\n        binaryen.__i32_store8(idx++, (0x80 | ((c1 >>>  6) & 63)) as u8);\n        binaryen.__i32_store8(idx++, (0x80 | ( c1         & 63)) as u8);\n      }\n    }\n  }\n  binaryen.__i32_store8(idx, 0); // \\0\n  return ptr;\n}\n\nfunction readBuffer(ptr: usize, len: i32): Uint8Array {\n  let ret = new Uint8Array(len);\n  for (let i = 0; i < len; ++i) {\n    unchecked(ret[i] = binaryen.__i32_load8_u(ptr + <usize>i));\n  }\n  return ret;\n}\n\nexport function readString(ptr: usize): string | null {\n  if (!ptr) return null;\n  let arr = new Array<i32>();\n  // the following is based on Emscripten's UTF8ArrayToString\n  let cp: u32;\n  let u1: u32, u2: u32, u3: u32;\n  while (cp = binaryen.__i32_load8_u(ptr++)) {\n    if (!(cp & 0x80)) {\n      arr.push(cp);\n      continue;\n    }\n    u1 = binaryen.__i32_load8_u(ptr++) & 63;\n    if ((cp & 0xE0) == 0xC0) {\n      arr.push(((cp & 31) << 6) | u1);\n      continue;\n    }\n    u2 = binaryen.__i32_load8_u(ptr++) & 63;\n    if ((cp & 0xF0) == 0xE0) {\n      cp = ((cp & 15) << 12) | (u1 << 6) | u2;\n    } else {\n      u3 = binaryen.__i32_load8_u(ptr++) & 63;\n      if ((cp & 0xF8) == 0xF0) {\n        cp = ((cp & 7) << 18) | (u1 << 12) | (u2 << 6) | u3;\n      } else {\n        assert(false, \"Invalid UTF8 sequence during readString\");\n      }\n    }\n    if (cp < 0x10000) {\n      arr.push(cp);\n    } else {\n      let ch = cp - 0x10000;\n      arr.push(SURROGATE_HIGH | (ch >>> 10));\n      arr.push(SURROGATE_LOW | (ch & 0x3FF));\n    }\n  }\n  // TODO: implement and use String.fromCodePoints\n  return String.fromCharCodes(arr);\n}\n\n/** Result structure of {@link Module#toBinary}. */\nexport class BinaryModule {\n  constructor(\n    /** WebAssembly binary. */\n    public output: Uint8Array,\n    /** Source map, if generated. */\n    public sourceMap: string | null\n  ) {}\n}\n\n// TypeBuilder\n\nconst DEBUG_TYPEBUILDER = false;\n\n/** Ensures that the given potentially complex type has a corresponding GC type. */\nexport function ensureType(type: Type): TypeRef {\n  // Obtain basic type if applicable\n  if (type == Type.void) return TypeRef.None;\n  let typeRef = tryEnsureBasicType(type);\n  if (typeRef) return typeRef;\n\n  // From here on we are dealing with heap types independent of nullability.\n  // Nullability is applied again when returning the final type.\n  let originalType = type;\n  type = type.nonNullableType;\n\n  // Obtain cached type if already built. Guaranteed to be not a temp type.\n  if (typeRef = type.ref) {\n    return binaryen._BinaryenTypeFromHeapType(\n      binaryen._BinaryenTypeGetHeapType(typeRef),\n      originalType.is(TypeFlags.Nullable) // apply nullability\n    );\n  }\n\n  // Otherwise use a type builder\n  if (ASC_TARGET) {\n    // @ts-ignore: Wasm only\n    assert(sizeof<usize>() == 4); // ABI code below assumes 32-bit pointers\n  }\n  let builder = binaryen._TypeBuilderCreate(0);\n  let seen = new Map<Type,HeapTypeRef>();\n  prepareType(builder, seen, type); // drop temp return\n  let size = binaryen._TypeBuilderGetSize(builder);\n  let out = binaryen._malloc(max(4 * size, 8)); // either each heap type or index + reason\n  if (!binaryen._TypeBuilderBuildAndDispose(builder, out, out, out + 4)) {\n    let errorIndex = binaryen.__i32_load(out);\n    let errorReason = binaryen.__i32_load(out + 4);\n    binaryen._free(out);\n    throw new Error(`type builder error at index ${errorIndex}: ${TypeBuilderErrorReason.toString(errorReason)}`);\n  }\n\n  // Assign all the built types to their respective non-nullable type\n  for (let _keys = Map_keys(seen), i = 0, k = _keys.length; i < k; ++i) {\n    let seenType = _keys[i];\n    assert(!seenType.is(TypeFlags.Nullable)); // non-nullable only\n    let heapType = <HeapTypeRef>binaryen.__i32_load(out + 4 * i);\n    let fullType = binaryen._BinaryenTypeFromHeapType(heapType, false);\n    assert(!seenType.ref);\n    seenType.ref = fullType;\n    if (DEBUG_TYPEBUILDER) {\n      console.log(` set ${seenType.toString()}`);\n    }\n    let classInstance = seenType.getClass();\n    if (classInstance) {\n      let module = classInstance.program.module;\n      binaryen._BinaryenModuleSetTypeName(module.ref, heapType, module.allocStringCached(classInstance.internalName));\n      let members = classInstance.members;\n      if (members) {\n        let numFieldsInType = binaryen._BinaryenStructTypeGetNumFields(heapType);\n        let numFieldsInClass = 0;\n        for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n          let member = _values[i];\n          if (member.kind != ElementKind.PropertyPrototype) continue;\n          // only interested in fields (resolved during class finalization)\n          let property = (<PropertyPrototype>member).instance;\n          if (!property || !property.isField) continue;\n          binaryen._BinaryenModuleSetFieldName(module.ref, heapType, numFieldsInClass++, module.allocStringCached(property.name));\n        }\n        assert(numFieldsInType == numFieldsInClass);\n      }\n    }\n  }\n  binaryen._free(out);\n\n  // Initial type should now exist in its non-nullable variant\n  if (DEBUG_TYPEBUILDER) {\n    console.log(` finalize ${type.toString()}`);\n  }\n  typeRef = assert(type.ref);\n  return binaryen._BinaryenTypeFromHeapType(\n    binaryen._BinaryenTypeGetHeapType(typeRef),\n    originalType.is(TypeFlags.Nullable) // apply nullability\n  );\n}\n\n/** Obtains the basic type of the given type, if any. */\nfunction tryEnsureBasicType(type: Type): TypeRef {\n  switch (type.kind) {\n    case TypeKind.Bool:\n    case TypeKind.I8:\n    case TypeKind.U8:\n    case TypeKind.I16:\n    case TypeKind.U16:\n    case TypeKind.I32:\n    case TypeKind.U32: return TypeRef.I32;\n    case TypeKind.I64:\n    case TypeKind.U64: return TypeRef.I64;\n    case TypeKind.Isize:\n    case TypeKind.Usize: {\n      if (type.isInternalReference) break; // non-basic\n      return type.size == 64 ? TypeRef.I64 : TypeRef.I32;\n    }\n    case TypeKind.F32: return TypeRef.F32;\n    case TypeKind.F64: return TypeRef.F64;\n    case TypeKind.V128: return TypeRef.V128;\n    case TypeKind.Func: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Func, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.Extern: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Extern, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.Any: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Any, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.Eq: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Eq, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.Struct: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Struct, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.Array: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Array, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.I31: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.I31, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.String: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.String, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.Void: assert(false); // invalid here\n  }\n  return 0; // non-basic\n}\n\n/** Determines the packed GC type of the given type, if applicable. */\nfunction determinePackedType(type: Type): PackedType {\n  switch (type.kind) {\n    case TypeKind.Bool:\n    case TypeKind.I8:\n    case TypeKind.U8: return PackedType.I8;\n    case TypeKind.I16:\n    case TypeKind.U16: return PackedType.I16;\n  }\n  return PackedType.NotPacked;\n}\n\n/** Recursively prepares the given GC type, potentially returning a temporary type. */\nfunction prepareType(builder: binaryen.TypeBuilderRef, seen: Map<Type,HeapTypeRef>, type: Type): TypeRef {\n  // Obtain basic type if applicable\n  if (type == Type.void) return TypeRef.None;\n  let typeRef = tryEnsureBasicType(type);\n  if (typeRef) return typeRef;\n\n  assert(!type.is(TypeFlags.Nullable)); // operating on non-nullable types only\n\n  // Reuse existing type\n  if (typeRef = type.ref) return typeRef;\n\n  // Reuse seen temporary type if it exists\n  if (seen.has(type)) {\n    if (DEBUG_TYPEBUILDER) {\n      console.log(` prepare ${type.toString()} (seen)`);\n    }\n    return changetype<HeapTypeRef>(seen.get(type));\n  }\n\n  if (DEBUG_TYPEBUILDER) {\n    console.log(`prepare ${type.toString()}`);\n  }\n\n  // Otherwise construct a new class type. Note that arrays are not supported, as these would\n  // have to involve a Wasm-level `array`, either wrapped in `Array` or `Uint8Array` etc., or\n  // directly representing an `ArrayBuffer` or `StaticArray`. TBD.\n  let classReference = type.getClass();\n  if (classReference) {\n    // Make sure the base type has been built prior, at a lower index\n    let base = classReference.base;\n    let baseRef: HeapTypeRef = 0;\n    if (base) baseRef = prepareType(builder, seen, base.type); // might be temporary, is non-nullable\n\n    // Block this index with a temporary type and cache\n    let index = binaryen._TypeBuilderGetSize(builder);\n    binaryen._TypeBuilderGrow(builder, 1);\n    if (DEBUG_TYPEBUILDER) {\n      console.log(` block [${index}]: ${type.toString()}`);\n    }\n    let heapTypeRef = binaryen._TypeBuilderGetTempHeapType(builder, index);\n    typeRef = binaryen._TypeBuilderGetTempRefType(builder, heapTypeRef, false);\n    seen.set(type, typeRef);\n\n    // Populate the struct type (TODO: names)\n    let fieldTypes = new Array<TypeRef>();\n    let packedTypes = new Array<PackedType>();\n    let fieldMutables = new Array<u32>();\n    let members = classReference.members;\n    if (members) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let member = _values[i];\n        if (member.kind != ElementKind.PropertyPrototype) continue;\n        // only interested in fields (resolved during class finalization)\n        let property = (<PropertyPrototype>member).instance;\n        if (!property || !property.isField) continue;\n        let fieldType = property.type;\n        if (DEBUG_TYPEBUILDER) {\n          console.log(`  field ${fieldType.toString()}`);\n        }\n        if (fieldType.is(TypeFlags.Nullable)) {\n          fieldTypes.push(\n            binaryen._TypeBuilderGetTempRefType(\n              builder,\n              binaryen._BinaryenTypeGetHeapType(\n                prepareType(builder, seen, fieldType.nonNullableType)\n              ),\n              true\n            )\n          );\n        } else {\n          fieldTypes.push(prepareType(builder, seen, fieldType));\n        }\n        packedTypes.push(determinePackedType(fieldType));\n        fieldMutables.push(1);\n      }\n    }\n    let cArrFT = allocPtrArray(fieldTypes);\n    let cArrPT = allocU32Array(packedTypes);\n    let cArrFM = allocU32Array(fieldMutables);\n    if (DEBUG_TYPEBUILDER) {\n      console.log(` concretize [${index}]: ${type.toString()}`);\n    }\n    binaryen._TypeBuilderSetStructType(builder, index, cArrFT, cArrPT, cArrFM, fieldTypes.length);\n    if (base) {\n      if (DEBUG_TYPEBUILDER) {\n        console.log(` set super [${index}]: ${type.toString()} <: ${base.type.toString()} ${baseRef == base.type.ref ? \" (known)\" : \"\"}`);\n      }\n      binaryen._TypeBuilderSetSubType(builder, index, binaryen._BinaryenTypeGetHeapType(baseRef));\n    }\n    binaryen._free(cArrFM);\n    binaryen._free(cArrPT);\n    binaryen._free(cArrFT);\n    return typeRef;\n  }\n\n  // Respectively a new signature type\n  let signatureReference = type.getSignature();\n  if (signatureReference) {\n\n    // Block this index with a temporary type and cache\n    let index = binaryen._TypeBuilderGetSize(builder);\n    binaryen._TypeBuilderGrow(builder, 1);\n    let tempTypeRef = binaryen._TypeBuilderGetTempRefType(\n      builder,\n      binaryen._TypeBuilderGetTempHeapType(builder, index),\n      false\n    );\n    seen.set(type, tempTypeRef);\n\n    let paramTypes = new Array<TypeRef>();\n    let resultTypes = new Array<TypeRef>();\n    let parameterTypes = signatureReference.parameterTypes;\n    for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n      let paramType = parameterTypes[i];\n      if (paramType.is(TypeFlags.Nullable)) {\n        paramTypes.push(\n          binaryen._TypeBuilderGetTempRefType(\n            builder,\n            binaryen._BinaryenTypeGetHeapType(\n              prepareType(builder, seen, paramType.nonNullableType)\n            ),\n            true\n          )\n        );\n      } else {\n        paramTypes.push(prepareType(builder, seen, paramType));\n      }\n    }\n    let returnType = signatureReference.returnType;\n    resultTypes.push(\n      returnType == Type.void\n        ? TypeRef.None\n        : returnType.is(TypeFlags.Nullable)\n          ? binaryen._TypeBuilderGetTempRefType(\n              builder,\n              binaryen._BinaryenTypeGetHeapType(\n                prepareType(builder, seen, returnType.nonNullableType)\n              ),\n              true\n            )\n          : prepareType(builder, seen, returnType)\n    );\n    let tempParamType: TypeRef;\n    if (paramTypes.length > 1) {\n      let cArrPT = allocPtrArray(paramTypes);\n      tempParamType = binaryen._TypeBuilderGetTempTupleType(builder, cArrPT, paramTypes.length);\n      binaryen._free(cArrPT);\n    } else {\n      tempParamType = paramTypes.length ? paramTypes[0] : TypeRef.None;\n    }\n    let tempResultType: TypeRef;\n    if (resultTypes.length > 1) {\n      let cArrRT = allocPtrArray(resultTypes);\n      tempResultType = binaryen._TypeBuilderGetTempTupleType(builder, cArrRT, resultTypes.length);\n      binaryen._free(cArrRT);\n    } else {\n      tempResultType = resultTypes[0];\n    }\n    if (DEBUG_TYPEBUILDER) {\n      console.log(` concretize [${index}]: ${type.toString()}`);\n    }\n    binaryen._TypeBuilderSetSignatureType(builder, index, tempParamType, tempResultType);\n    return tempTypeRef;\n  }\n\n  throw new Error(`unexpected complex type: ${type.toString()}`);\n}\n", "/**\n * @fileoverview A concurrent code flow analyzer.\n *\n * Flows keep track of compilation state and can be queried for various\n * conditions, like whether the current branch always terminates, whether\n * a local is known to be non-null or whether an expression has possibly\n * overflown its value range.\n *\n * To accomplish this, compilation of each function begins with a clean\n * flow populated with initial local states etc. While compilation\n * progresses, statements and expressions update flow state while control\n * constructs fork, potentially add scoped locals and later merge these\n * forked branches as necessary.\n *\n * @license Apache-2.0\n */\n\nimport {\n  Type,\n  TypeFlags,\n  TypeKind\n} from \"./types\";\n\nimport {\n  Program,\n  Local,\n  Function,\n  Element,\n  ElementKind,\n  Class,\n  TypedElement,\n  mangleInternalName,\n  Property,\n  PropertyPrototype,\n  TypeDefinition\n} from \"./program\";\n\nimport {\n  TypeRef,\n  ExpressionId,\n  ExpressionRef,\n  BinaryOp,\n  UnaryOp,\n\n  getExpressionId,\n  getLocalGetIndex,\n  isLocalTee,\n  getLocalSetValue,\n  getGlobalGetName,\n  getBinaryOp,\n  getBinaryLeft,\n  getConstValueI32,\n  getBinaryRight,\n  getUnaryOp,\n  getExpressionType,\n  getConstValueI64Low,\n  getConstValueF32,\n  getConstValueF64,\n  getLoadBytes,\n  isLoadSigned,\n  getBlockName,\n  getBlockChildCount,\n  getBlockChildAt,\n  getIfTrue,\n  getIfFalse,\n  getSelectThen,\n  getSelectElse,\n  getCallTarget,\n  getLocalSetIndex,\n  getIfCondition,\n  getUnaryValue,\n  getCallOperandAt,\n  getCallOperandCount,\n  isConstZero,\n  isConstNonZero\n} from \"./module\";\n\nimport {\n  CommonFlags\n} from \"./common\";\n\nimport {\n  UncheckedBehavior\n} from \"./compiler\";\n\nimport {\n  DiagnosticCode\n} from \"./diagnostics\";\n\nimport {\n  Node\n} from \"./ast\";\n\nimport {\n  cloneMap\n} from \"./util\";\n\nimport {\n  BuiltinNames\n} from \"./builtins\";\n\n/** Control flow flags indicating specific conditions. */\nexport const enum FlowFlags {\n  /** No specific conditions. */\n  None = 0,\n\n  // categorical\n\n  /** This flow always returns. */\n  Returns = 1 << 0,\n  /** This flow always returns a wrapped value. */\n  ReturnsWrapped = 1 << 1,\n  /** This flow always returns a non-null value. */\n  ReturnsNonNull = 1 << 2,\n  /** This flow always throws. */\n  Throws = 1 << 3,\n  /** This flow always breaks. */\n  Breaks = 1 << 4,\n  /** This flow always continues. */\n  Continues = 1 << 5,\n  /** This flow always accesses `this`. Constructors only. */\n  AccessesThis = 1 << 6,\n  /** This flow always calls `super`. Constructors only. */\n  CallsSuper = 1 << 7,\n  /** This flow always terminates (returns, throws or continues). */\n  Terminates = 1 << 8, // Note that this doesn't cover BREAKS, which is separate\n\n  // conditional\n\n  /** This flow conditionally returns in a child flow. */\n  ConditionallyReturns = 1 << 9,\n  /** This flow conditionally throws in a child flow. */\n  ConditionallyThrows = 1 << 10,\n  /** This flow conditionally breaks in a child flow. */\n  ConditionallyBreaks = 1 << 11,\n  /** This flow conditionally continues in a child flow. */\n  ConditionallyContinues = 1 << 12,\n  /** This flow conditionally accesses `this` in a child flow. Constructors only. */\n  ConditionallyAccessesThis = 1 << 13,\n  /** This flow may return a non-this value. Constructors only. */\n  MayReturnNonThis = 1 << 14,\n\n  // other\n\n  /** This is a flow with explicitly disabled bounds checking. */\n  UncheckedContext = 1 << 15,\n  /** This is a flow compiling a constructor parameter. */\n  CtorParamContext = 1 << 16,\n  /** This is a flow where all function calls are inlined if possible. */\n  InlineContext = 1 << 17,\n\n  // masks\n\n  /** Any categorical flag. */\n  AnyCategorical = FlowFlags.Returns\n                 | FlowFlags.ReturnsWrapped\n                 | FlowFlags.ReturnsNonNull\n                 | FlowFlags.Throws\n                 | FlowFlags.Breaks\n                 | FlowFlags.Continues\n                 | FlowFlags.AccessesThis\n                 | FlowFlags.CallsSuper\n                 | FlowFlags.Terminates,\n\n  /** Any conditional flag. */\n  AnyConditional = FlowFlags.ConditionallyReturns\n                 | FlowFlags.ConditionallyThrows\n                 | FlowFlags.ConditionallyBreaks\n                 | FlowFlags.ConditionallyContinues\n                 | FlowFlags.ConditionallyAccessesThis\n}\n\n/** Flags indicating the current state of a local. */\nexport const enum LocalFlags {\n  /** No specific conditions. */\n  None = 0,\n\n  /** Local is constant. */\n  Constant = 1 << 0,\n  /** Local is properly wrapped. Relevant for small integers. */\n  Wrapped = 1 << 1,\n  /** Local is non-null. */\n  NonNull = 1 << 2,\n  /** Local is initialized. */\n  Initialized = 1 << 3\n}\n\n/** Flags indicating the current state of a field. */\nexport const enum FieldFlags {\n  None = 0,\n  Initialized = 1 << 0\n}\n\n/** Condition kinds. */\nexport const enum ConditionKind {\n  /** Outcome of the condition is unknown */\n  Unknown,\n  /** Condition is always true. */\n  True,\n  /** Condition is always false. */\n  False\n}\n\n/** A control flow evaluator. */\nexport class Flow {\n\n  /** Creates the default top-level flow of the specified function. */\n  static createDefault(targetFunction: Function): Flow {\n    let flow = new Flow(targetFunction);\n    if (targetFunction.is(CommonFlags.Constructor)) {\n      flow.initThisFieldFlags();\n    }\n    if (targetFunction.program.options.uncheckedBehavior === UncheckedBehavior.Always) {\n      flow.set(FlowFlags.UncheckedContext);\n    }\n    return flow;\n  }\n\n  /** Creates an inline flow, compiling `inlineFunction` into `targetFunction`. */\n  static createInline(targetFunction: Function, inlineFunction: Function): Flow {\n    // Note that `targetFunction` and `inlineFunction` can be the same function\n    // when it is inlined into itself.\n    let flow = new Flow(targetFunction, inlineFunction);\n    flow.inlineReturnLabel = `${inlineFunction.internalName}|inlined.${(inlineFunction.nextInlineId++)}`;\n    if (inlineFunction.is(CommonFlags.Constructor)) {\n      flow.initThisFieldFlags();\n    }\n    if (targetFunction.program.options.uncheckedBehavior === UncheckedBehavior.Always) {\n      flow.set(FlowFlags.UncheckedContext);\n    }\n    return flow;\n  }\n\n  private constructor(\n    /** Target function this flow generates code into. */\n    public targetFunction: Function,\n    /** Inline function this flow generates code from, if any. */\n    public inlineFunction: Function | null = null\n  ) {\n    // Setup is performed above so inline ids and field flags are not reset\n    // when forking flows, which also uses the constructor.\n  }\n\n  /** Parent flow. */\n  parent: Flow | null = null;\n  /** Outer flow. Only relevant for first-class functions. */\n  outer: Flow | null = null;\n  /** Flow flags indicating specific conditions. */\n  flags: FlowFlags = FlowFlags.None;\n  /** The label we break to when encountering a continue statement. */\n  continueLabel: string | null = null;\n  /** The label we break to when encountering a break statement. */\n  breakLabel: string | null = null;\n  /** Scoped local variables. */\n  scopedLocals: Map<string,Local> | null = null;\n  /** Scoped type alias. */\n  scopedTypeAlias: Map<string,TypeDefinition> | null = null;\n  /** Local flags. */\n  localFlags: LocalFlags[] = [];\n  /** Field flags on `this`. Constructors only. */\n  thisFieldFlags: Map<Property,FieldFlags> | null = null;\n  /** The label we break to when encountering a return statement, when inlining. */\n  inlineReturnLabel: string | null = null;\n  /** Alternative flows if a compound expression is true-ish. */\n  trueFlows: Map<ExpressionRef,Flow> | null = null;\n  /** Alternative flows if a compound expression is false-ish. */\n  falseFlows: Map<ExpressionRef,Flow> | null = null;\n\n  /** Tests if this is an inline flow. */\n  get isInline(): bool {\n    return this.inlineFunction != null;\n  }\n\n  /** Gets the source function being compiled. Differs from target when inlining. */\n  get sourceFunction(): Function {\n    // Obtaining the source function is useful when resolving elements relative\n    // to their source location. Note that the source function does not necessarily\n    // materialize in the binary, as it might be inlined. Code, locals, etc. must\n    // always be added to / maintained in the materializing target function instead.\n    let inlineFunction = this.inlineFunction;\n    if (inlineFunction) return inlineFunction;\n    return this.targetFunction;\n  }\n\n  /** Gets the program this flow belongs to. */\n  get program(): Program {\n    return this.targetFunction.program;\n  }\n\n  /** Gets the current return type. */\n  get returnType(): Type {\n    return this.sourceFunction.signature.returnType;\n  }\n\n  /** Gets the current contextual type arguments. */\n  get contextualTypeArguments(): Map<string,Type> | null {\n    return this.sourceFunction.contextualTypeArguments;\n  }\n\n  /** Tests if this flow has the specified flag or flags. */\n  is(flag: FlowFlags): bool { return (this.flags & flag) == flag; }\n  /** Tests if this flow has one of the specified flags. */\n  isAny(flag: FlowFlags): bool { return (this.flags & flag) != 0; }\n  /** Sets the specified flag or flags. */\n  set(flag: FlowFlags): void { this.flags |= flag; }\n  /** Unsets the specified flag or flags. */\n  unset(flag: FlowFlags): void { this.flags &= ~flag; }\n\n  deriveConditionalFlags(): FlowFlags {\n    let condiFlags = this.flags & FlowFlags.AnyConditional;\n    if (this.is(FlowFlags.Returns)) {\n      condiFlags |= FlowFlags.ConditionallyReturns;\n    }\n    if (this.is(FlowFlags.Throws)) {\n      condiFlags |= FlowFlags.ConditionallyThrows;\n    }\n    if (this.is(FlowFlags.Breaks)) {\n      condiFlags |= FlowFlags.ConditionallyBreaks;\n    }\n    if (this.is(FlowFlags.Continues)) {\n      condiFlags |= FlowFlags.ConditionallyContinues;\n    }\n    if (this.is(FlowFlags.AccessesThis)) {\n      condiFlags |= FlowFlags.ConditionallyAccessesThis;\n    }\n    return condiFlags;\n  }\n\n  /** Forks this flow to a child flow. */\n  fork(\n    /** Whether a new break context is established, e.g. by a block. */\n    newBreakContext: bool = false,\n    /** Whether a new continue context is established, e.g. by a loop. */\n    newContinueContext: bool = newBreakContext\n  ): Flow {\n    let branch = new Flow(this.targetFunction, this.inlineFunction);\n    branch.parent = this;\n    branch.flags = this.flags;\n    branch.outer = this.outer;\n    if (newBreakContext) {\n      branch.flags &= ~(\n        FlowFlags.Breaks |\n        FlowFlags.ConditionallyBreaks\n      );\n    } else {\n      branch.breakLabel = this.breakLabel;\n    }\n    if (newContinueContext) {\n      branch.flags &= ~(\n        FlowFlags.Continues |\n        FlowFlags.ConditionallyContinues\n      );\n    } else {\n      branch.continueLabel = this.continueLabel;\n    }\n    branch.localFlags = this.localFlags.slice();\n    if (this.sourceFunction.is(CommonFlags.Constructor)) {\n      let thisFieldFlags = assert(this.thisFieldFlags);\n      branch.thisFieldFlags = cloneMap(thisFieldFlags);\n    } else {\n      assert(!this.thisFieldFlags);\n    }\n    branch.inlineReturnLabel = this.inlineReturnLabel;\n    return branch;\n  }\n\n  /** Forks this flow to a child flow where `condExpr` is true-ish. */\n  forkThen(\n    /** Condition that turned out to be true. */\n    condExpr: ExpressionRef,\n    /** Whether a new break context is established, e.g. by a block. */\n    newBreakContext: bool = false,\n    /** Whether a new continue context is established, e.g. by a loop. */\n    newContinueContext: bool = newBreakContext\n  ): Flow {\n    let flow = this.fork(newBreakContext, newContinueContext);\n    let trueFlows = this.trueFlows;\n    if (trueFlows && trueFlows.has(condExpr)) {\n      flow.inherit(changetype<Flow>(trueFlows.get(condExpr)));\n    }\n    flow.inheritNonnullIfTrue(condExpr);\n    return flow;\n  }\n\n  /** Remembers the alternative flow if `condExpr` turns out `true`. */\n  noteThen(condExpr: ExpressionRef, trueFlow: Flow): void {\n    let trueFlows = this.trueFlows;\n    if (!trueFlows) this.trueFlows = trueFlows = new Map();\n    trueFlows.set(condExpr, trueFlow);\n  }\n\n  /** Forks this flow to a child flow where `condExpr` is false-ish. */\n  forkElse(\n    /** Condition that turned out to be false. */\n    condExpr: ExpressionRef\n  ): Flow {\n    let flow = this.fork();\n    let falseFlows = this.falseFlows;\n    if (falseFlows && falseFlows.has(condExpr)) {\n      flow.inherit(changetype<Flow>(falseFlows.get(condExpr)));\n    }\n    flow.inheritNonnullIfFalse(condExpr);\n    return flow;\n  }\n\n  /** Remembers the alternative flow if `condExpr` turns out `false`. */\n  noteElse(condExpr: ExpressionRef, falseFlow: Flow): void {\n    let falseFlows = this.falseFlows;\n    if (!falseFlows) this.falseFlows = falseFlows = new Map();\n    falseFlows.set(condExpr, falseFlow);\n  }\n\n  addScopedTypeAlias(name: string, definition: TypeDefinition): void {\n    let scopedTypeAlias = this.scopedTypeAlias;\n    if (!scopedTypeAlias) this.scopedTypeAlias = scopedTypeAlias = new Map();\n    scopedTypeAlias.set(name, definition);\n  }\n\n  lookupScopedTypeAlias(name: string): TypeDefinition | null {\n    let current: Flow | null = this;\n    do {\n      let scopedTypeAlias = current.scopedTypeAlias;\n      if (scopedTypeAlias && scopedTypeAlias.has(name)) {\n        return assert(scopedTypeAlias.get(name));\n      }\n      current = current.parent;\n    } while (current);\n    return null;\n  }\n\n  lookupTypeAlias(name: string): TypeDefinition | null {\n    let definition: TypeDefinition | null = null;\n    if (definition = this.lookupScopedTypeAlias(name)) return definition;\n\n    let sourceParent = this.sourceFunction.parent;\n    if (sourceParent.kind == ElementKind.Function) {\n      // lookup parent function.\n      let parentFunction = <Function>sourceParent;\n      return parentFunction.flow.lookupTypeAlias(name);\n    }\n    \n    return null;\n  }\n\n  /** Gets a free temporary local of the specified type. */\n  getTempLocal(type: Type): Local {\n    let local = this.targetFunction.addLocal(type);\n    this.unsetLocalFlag(local.index, ~0);\n    return local;\n  }\n\n  /** Gets the scoped local of the specified name. */\n  getScopedLocal(name: string): Local | null {\n    let scopedLocals = this.scopedLocals;\n    if (scopedLocals && scopedLocals.has(name)) return assert(scopedLocals.get(name));\n    return null;\n  }\n\n  /** Adds a new scoped local of the specified name. */\n  addScopedLocal(name: string, type: Type): Local {\n    let scopedLocal = this.getTempLocal(type);\n    scopedLocal.name = name;\n    scopedLocal.internalName = mangleInternalName(name, scopedLocal.parent, false);\n    let scopedLocals = this.scopedLocals;\n    if (!scopedLocals) this.scopedLocals = scopedLocals = new Map();\n    else assert(!scopedLocals.has(name));\n    scopedLocal.set(CommonFlags.Scoped);\n    scopedLocals.set(name, scopedLocal);\n    return scopedLocal;\n  }\n\n  /** Adds a new scoped dummy local of the specified name. */\n  addScopedDummyLocal(name: string, type: Type, declarationNode: Node): Local {\n    let scopedDummy = new Local(name, -1, type, this.targetFunction);\n    let scopedLocals = this.scopedLocals;\n    if (!scopedLocals) this.scopedLocals = scopedLocals = new Map();\n    else if (scopedLocals.has(name)) {\n      this.program.error(\n        DiagnosticCode.Cannot_redeclare_block_scoped_variable_0,\n        declarationNode.range, name\n      );\n    }\n    scopedDummy.set(CommonFlags.Scoped);\n    scopedLocals.set(name, scopedDummy);\n    return scopedDummy;\n  }\n\n  /** Adds a new scoped alias for the specified local. For example `super` aliased to the `this` local. */\n  addScopedAlias(name: string, type: Type, index: i32, reportNode: Node | null = null): Local {\n    let scopedLocals = this.scopedLocals;\n    if (!scopedLocals) {\n      this.scopedLocals = scopedLocals = new Map();\n    } else if (scopedLocals.has(name)) {\n      let existingLocal = assert(scopedLocals.get(name));\n      if (reportNode) {\n        if (!existingLocal.declaration.range.source.isNative) {\n          this.program.errorRelated(\n            DiagnosticCode.Duplicate_identifier_0,\n            reportNode.range,\n            existingLocal.declaration.name.range,\n            name\n          );\n        } else {\n          this.program.error(\n            DiagnosticCode.Duplicate_identifier_0,\n            reportNode.range, name\n          );\n        }\n      }\n      return existingLocal;\n    }\n    assert(index < this.targetFunction.localsByIndex.length);\n    let scopedAlias = new Local(name, index, type, this.targetFunction);\n    scopedAlias.set(CommonFlags.Scoped);\n    scopedLocals.set(name, scopedAlias);\n    return scopedAlias;\n  }\n\n  /** Frees a single scoped local by its name. */\n  freeScopedDummyLocal(name: string): void {\n    let scopedLocals = assert(this.scopedLocals);\n    assert(scopedLocals.has(name));\n    let local = assert(scopedLocals.get(name));\n    assert(local.index == -1);\n    scopedLocals.delete(name);\n  }\n\n  /** Looks up the local of the specified name in the current scope. */\n  lookupLocal(name: string): Local | null {\n    let current: Flow | null = this;\n    do {\n      let scope = current.scopedLocals;\n      if (scope && scope.has(name)) return assert(scope.get(name));\n      current = current.parent;\n    } while (current);\n    return null;\n  }\n\n  /** Looks up the element with the specified name relative to the scope of this flow. */\n  lookup(name: string): Element | null {\n    let element = this.lookupLocal(name);\n    if (element) return element;\n    return this.sourceFunction.lookup(name);\n  }\n\n  /** Tests if the local at the specified index has the specified flag or flags. */\n  isLocalFlag(index: i32, flag: LocalFlags, defaultIfInlined: bool = true): bool {\n    if (index < 0) return defaultIfInlined;\n    let localFlags = this.localFlags;\n    return index < localFlags.length && (unchecked(localFlags[index]) & flag) == flag;\n  }\n\n  /** Tests if the local at the specified index has any of the specified flags. */\n  isAnyLocalFlag(index: i32, flag: LocalFlags, defaultIfInlined: bool = true): bool {\n    if (index < 0) return defaultIfInlined;\n    let localFlags = this.localFlags;\n    return index < localFlags.length && (unchecked(localFlags[index]) & flag) != 0;\n  }\n\n  /** Sets the specified flag or flags on the local at the specified index. */\n  setLocalFlag(index: i32, flag: LocalFlags): void {\n    if (index < 0) return;\n    let localFlags = this.localFlags;\n    let flags = index < localFlags.length ? unchecked(localFlags[index]) : 0;\n    localFlags[index] = flags | flag;\n  }\n\n  /** Unsets the specified flag or flags on the local at the specified index. */\n  unsetLocalFlag(index: i32, flag: LocalFlags): void {\n    if (index < 0) return;\n    let localFlags = this.localFlags;\n    let flags = index < localFlags.length ? unchecked(localFlags[index]) : 0;\n    localFlags[index] = flags & ~flag;\n  }\n\n  /** Initializes `this` field flags. */\n  initThisFieldFlags(): void {\n    let sourceFunction = this.sourceFunction;\n    assert(sourceFunction.is(CommonFlags.Constructor));\n    let parent = sourceFunction.parent;\n    assert(parent.kind == ElementKind.Class);\n    let classInstance = <Class>parent;\n    this.thisFieldFlags = new Map();\n    let members = classInstance.members;\n    if (members) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let member = _values[i];\n        if (member.kind != ElementKind.PropertyPrototype) continue;\n        // only interested in fields (resolved during class finalization)\n        let property = (<PropertyPrototype>member).instance;\n        if (!property || !property.isField) continue;\n        if (\n          // guaranteed by super\n          property.prototype.parent != classInstance ||\n          // has field initializer\n          property.initializerNode ||\n          // is initialized as a ctor parameter\n          property.prototype.parameterIndex != -1 ||\n          // is safe to initialize with zero\n          property.type.isAny(TypeFlags.Value | TypeFlags.Nullable)\n        ) {\n          this.setThisFieldFlag(property, FieldFlags.Initialized);\n        }\n      }\n    }\n  }\n\n  /** Tests if the specified `this` field has the specified flag or flags. */\n  isThisFieldFlag(field: Property, flag: FieldFlags): bool {\n    let fieldFlags = this.thisFieldFlags;\n    if (fieldFlags != null && fieldFlags.has(field)) {\n      return (changetype<FieldFlags>(fieldFlags.get(field)) & flag) == flag;\n    }\n    return false;\n  }\n\n  /** Sets the specified flag or flags on the given `this` field. */\n  setThisFieldFlag(field: Property, flag: FieldFlags): void {\n    let fieldFlags = this.thisFieldFlags;\n    if (fieldFlags) {\n      assert(this.sourceFunction.is(CommonFlags.Constructor));\n      if (fieldFlags.has(field)) {\n        let flags = changetype<FieldFlags>(fieldFlags.get(field));\n        fieldFlags.set(field, flags | flag);\n      } else {\n        fieldFlags.set(field, flag);\n      }\n    } else {\n      assert(!this.sourceFunction.is(CommonFlags.Constructor));\n    }\n  }\n\n  /** Pushes a new control flow label, for example when entering a loop that one can `break` from. */\n  pushControlFlowLabel(): i32 {\n    let targetFunction = this.targetFunction;\n    let id = targetFunction.nextBreakId++;\n    let stack = targetFunction.breakStack;\n    if (!stack) targetFunction.breakStack = [ id ];\n    else stack.push(id);\n    return id;\n  }\n\n  /** Pops the most recent control flow label and validates that it matches. */\n  popControlFlowLabel(expectedLabel: i32): void {\n    let targetFunction = this.targetFunction;\n    let stack = assert(targetFunction.breakStack); // should exist\n    assert(stack.length); // should not be empty\n    assert(stack.pop() == expectedLabel); // should match\n  }\n\n  /** Inherits flags of another flow into this one, i.e. a finished inner block. */\n  inherit(other: Flow): void {\n    assert(other.targetFunction == this.targetFunction);\n    let otherFlags = other.flags;\n\n    // respective inner flags are irrelevant if contexts differ\n    if (this.breakLabel != other.breakLabel) {\n      if (otherFlags & (FlowFlags.Breaks | FlowFlags.ConditionallyBreaks)) {\n        otherFlags &= ~FlowFlags.Terminates;\n      }\n      otherFlags &= ~(FlowFlags.Breaks | FlowFlags.ConditionallyBreaks);\n    }\n    if (this.continueLabel != other.continueLabel) {\n      otherFlags &= ~(FlowFlags.Continues | FlowFlags.ConditionallyContinues);\n    }\n\n    this.flags = this.flags | otherFlags; // what happens before is still true\n    this.localFlags = other.localFlags;\n    this.thisFieldFlags = other.thisFieldFlags;\n  }\n\n\n  /** Merges only the side effects of a branch, i.e. when not taken. */\n  mergeSideEffects(other: Flow): void {\n    assert(other.targetFunction == this.targetFunction);\n\n    let thisFlags = this.flags;\n    let otherFlags = other.flags;\n    let newFlags = FlowFlags.None;\n\n    if (thisFlags & FlowFlags.Returns) { // nothing can change that\n      newFlags |= FlowFlags.Returns;\n    } else if (otherFlags & FlowFlags.Returns) {\n      newFlags |= FlowFlags.ConditionallyReturns;\n    } else {\n      newFlags |= (thisFlags | otherFlags) & FlowFlags.ConditionallyReturns;\n    }\n\n    // must be the case in both\n    newFlags |= thisFlags & otherFlags & FlowFlags.ReturnsWrapped;\n    newFlags |= thisFlags & otherFlags & FlowFlags.ReturnsNonNull;\n\n    if (thisFlags & FlowFlags.Throws) { // nothing can change that\n      newFlags |= FlowFlags.Throws;\n    } else if (otherFlags & FlowFlags.Throws) {\n      newFlags |= FlowFlags.ConditionallyThrows;\n    } else {\n      newFlags |= (thisFlags | otherFlags) & FlowFlags.ConditionallyThrows;\n    }\n\n    if (thisFlags & FlowFlags.Breaks) { // nothing can change that\n      newFlags |= FlowFlags.Breaks;\n    } else if (other.breakLabel == this.breakLabel) {\n      if (otherFlags & FlowFlags.Breaks) {\n        newFlags |= FlowFlags.ConditionallyBreaks;\n      } else {\n        newFlags |= (thisFlags | otherFlags) & FlowFlags.ConditionallyBreaks;\n      }\n    } else {\n      newFlags |= thisFlags & FlowFlags.ConditionallyBreaks;\n    }\n\n    if (thisFlags & FlowFlags.Continues) { // nothing can change that\n      newFlags |= FlowFlags.Continues;\n    } else if (other.continueLabel == this.continueLabel) {\n      if (otherFlags & FlowFlags.Continues) {\n        newFlags |= FlowFlags.ConditionallyContinues;\n      } else {\n        newFlags |= (thisFlags | otherFlags) & FlowFlags.ConditionallyContinues;\n      }\n    } else {\n      newFlags |= thisFlags & FlowFlags.ConditionallyContinues;\n    }\n\n    if (thisFlags & FlowFlags.AccessesThis) { // can become conditional\n      if (otherFlags & FlowFlags.AccessesThis) {\n        newFlags |= FlowFlags.AccessesThis;\n      } else {\n        newFlags |= FlowFlags.ConditionallyAccessesThis;\n      }\n    } else if (otherFlags & FlowFlags.AccessesThis) {\n      newFlags |= FlowFlags.ConditionallyAccessesThis;\n    }\n\n    // may be the case in any\n    newFlags |= (thisFlags | otherFlags) & FlowFlags.MayReturnNonThis;\n\n    // must be the case in both\n    newFlags |= thisFlags & otherFlags & FlowFlags.CallsSuper;\n\n    if (thisFlags & FlowFlags.Terminates) { // nothing can change that\n      newFlags |= FlowFlags.Terminates;\n    }\n\n    this.flags = newFlags | (thisFlags & (FlowFlags.UncheckedContext | FlowFlags.CtorParamContext));\n  }\n\n  /** Merges a branch joining again with this flow, i.e. then without else. */\n  mergeBranch(other: Flow): void {\n    this.mergeSideEffects(other);\n\n    // Local flags matter if the branch does not terminate\n    let thisLocalFlags = this.localFlags;\n    let numThisLocalFlags = thisLocalFlags.length;\n    let otherLocalFlags = other.localFlags;\n    let numOtherLocalFlags = otherLocalFlags.length;\n    let maxLocalFlags = max(numThisLocalFlags, numOtherLocalFlags);\n    for (let i = 0; i < maxLocalFlags; ++i) {\n      let thisFlags = i < numThisLocalFlags ? thisLocalFlags[i] : 0;\n      let otherFlags = i < numOtherLocalFlags ? otherLocalFlags[i] : 0;\n      thisLocalFlags[i] = thisFlags & otherFlags & (\n        LocalFlags.Constant  |\n        LocalFlags.Wrapped   |\n        LocalFlags.NonNull   |\n        LocalFlags.Initialized\n      );\n    }\n\n    // field flags do not matter here since there's only INITIALIZED, which can\n    // only be set if it has been observed prior to entering the branch.\n  }\n\n  /** Inherits two alternate branches to become this flow, i.e. then with else. */\n  inheritAlternatives(left: Flow, right: Flow): void {\n    assert(left.targetFunction == right.targetFunction);\n    assert(left.targetFunction == this.targetFunction);\n    // Differs from `mergeBranch` in that the alternatives are intersected to\n    // then become this branch.\n\n    let leftFlags = left.flags;\n    let rightFlags = right.flags;\n    let newFlags = FlowFlags.None;\n\n    if (leftFlags & FlowFlags.Returns) {\n      if (rightFlags & FlowFlags.Returns) {\n        newFlags |= FlowFlags.Returns;\n      } else {\n        newFlags |= FlowFlags.ConditionallyReturns;\n      }\n    } else if (rightFlags & FlowFlags.Returns) {\n      newFlags |= FlowFlags.ConditionallyReturns;\n    } else {\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.ConditionallyReturns;\n    }\n\n    if ((leftFlags & FlowFlags.ReturnsWrapped) && (rightFlags & FlowFlags.ReturnsWrapped)) {\n      newFlags |= FlowFlags.ReturnsWrapped;\n    }\n\n    if ((leftFlags & FlowFlags.ReturnsNonNull) && (rightFlags & FlowFlags.ReturnsNonNull)) {\n      newFlags |= FlowFlags.ReturnsNonNull;\n    }\n\n    if (leftFlags & FlowFlags.Throws) {\n      if (rightFlags & FlowFlags.Throws) {\n        newFlags |= FlowFlags.Throws;\n      } else {\n        newFlags |= FlowFlags.ConditionallyThrows;\n      }\n    } else if (rightFlags & FlowFlags.Throws) {\n      newFlags |= FlowFlags.ConditionallyThrows;\n    } else {\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.ConditionallyThrows;\n    }\n\n    if (leftFlags & FlowFlags.Breaks) {\n      if (rightFlags & FlowFlags.Breaks) {\n        newFlags |= FlowFlags.Breaks;\n      } else {\n        newFlags |= FlowFlags.ConditionallyBreaks;\n      }\n    } else if (rightFlags & FlowFlags.Breaks) {\n      newFlags |= FlowFlags.ConditionallyBreaks;\n    } else {\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.ConditionallyBreaks;\n    }\n\n    if (leftFlags & FlowFlags.Continues) {\n      if (rightFlags & FlowFlags.Continues) {\n        newFlags |= FlowFlags.Continues;\n      } else {\n        newFlags |= FlowFlags.ConditionallyContinues;\n      }\n    } else if (rightFlags & FlowFlags.Continues) {\n      newFlags |= FlowFlags.ConditionallyContinues;\n    } else {\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.ConditionallyContinues;\n    }\n\n    if (leftFlags & FlowFlags.AccessesThis) {\n      if (rightFlags & FlowFlags.AccessesThis) {\n        newFlags |= FlowFlags.AccessesThis;\n      } else {\n        newFlags |= FlowFlags.ConditionallyAccessesThis;\n      }\n    } else if (rightFlags & FlowFlags.AccessesThis) {\n      newFlags |= FlowFlags.ConditionallyAccessesThis;\n    } else {\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.ConditionallyAccessesThis;\n    }\n\n    newFlags |= (leftFlags | rightFlags) & FlowFlags.MayReturnNonThis;\n\n    if ((leftFlags & FlowFlags.CallsSuper) && (rightFlags & FlowFlags.CallsSuper)) {\n      newFlags |= FlowFlags.CallsSuper;\n    }\n\n    if ((leftFlags & FlowFlags.Terminates) && (rightFlags & FlowFlags.Terminates)) {\n      newFlags |= FlowFlags.Terminates;\n    }\n\n    this.flags = newFlags | (this.flags & (FlowFlags.UncheckedContext | FlowFlags.CtorParamContext));\n\n    // local flags\n    let thisLocalFlags = this.localFlags;\n    if (leftFlags & FlowFlags.Terminates) {\n      if (!(rightFlags & FlowFlags.Terminates)) {\n        let rightLocalFlags = right.localFlags;\n        for (let i = 0, k = rightLocalFlags.length; i < k; ++i) {\n          thisLocalFlags[i] = rightLocalFlags[i];\n        }\n      }\n    } else if (rightFlags & FlowFlags.Terminates) {\n      let leftLocalFlags = left.localFlags;\n      for (let i = 0, k = leftLocalFlags.length; i < k; ++i) {\n        thisLocalFlags[i] = leftLocalFlags[i];\n      }\n    } else {\n      let leftLocalFlags = left.localFlags;\n      let numLeftLocalFlags = leftLocalFlags.length;\n      let rightLocalFlags = right.localFlags;\n      let numRightLocalFlags = rightLocalFlags.length;\n      let maxLocalFlags = max(numLeftLocalFlags, numRightLocalFlags);\n      for (let i = 0; i < maxLocalFlags; ++i) {\n        let leftFlags = i < numLeftLocalFlags ? leftLocalFlags[i] : 0;\n        let rightFlags = i < numRightLocalFlags ? rightLocalFlags[i] : 0;\n        thisLocalFlags[i] = leftFlags & rightFlags & (\n          LocalFlags.Constant  |\n          LocalFlags.Wrapped   |\n          LocalFlags.NonNull   |\n          LocalFlags.Initialized\n        );\n      }\n    }\n\n    // field flags (currently only INITIALIZED, so can simplify)\n    let leftFieldFlags = left.thisFieldFlags;\n    if (leftFieldFlags) {\n      let newFieldFlags = new Map<Property,FieldFlags>();\n      let rightFieldFlags = assert(right.thisFieldFlags);\n      for (let _keys = Map_keys(leftFieldFlags), i = 0, k = _keys.length; i < k; ++i) {\n        let key = _keys[i];\n        let leftFlags = changetype<FieldFlags>(leftFieldFlags.get(key));\n        if (\n          (leftFlags & FieldFlags.Initialized) != 0 && rightFieldFlags.has(key) &&\n          (changetype<FieldFlags>(rightFieldFlags.get(key)) & FieldFlags.Initialized)\n        ) {\n          newFieldFlags.set(key, FieldFlags.Initialized);\n        }\n      }\n      this.thisFieldFlags = newFieldFlags;\n    } else {\n      assert(!right.thisFieldFlags);\n    }\n  }\n\n  /** Tests if recompilation is needed due to incompatible local flags between loops, and resets if necessary. */\n  resetIfNeedsRecompile(\n    /** Resulting flow of the current compilation attempt. */\n    other: Flow,\n    /** Number of locals before the compilation attempt. */\n    numLocalsBefore: i32\n  ): bool {\n    let numThisLocalFlags = this.localFlags.length;\n    let numOtherLocalFlags = other.localFlags.length;\n    let targetFunction = this.targetFunction;\n    assert(targetFunction == other.targetFunction);\n    let localsByIndex = targetFunction.localsByIndex;\n    assert(localsByIndex == other.targetFunction.localsByIndex);\n    let needsRecompile = false;\n    for (let i = 0, k = min<i32>(numThisLocalFlags, numOtherLocalFlags); i < k; ++i) {\n      let local = localsByIndex[i];\n      let type = local.type;\n      if (type.isShortIntegerValue) {\n        if (this.isLocalFlag(i, LocalFlags.Wrapped) && !other.isLocalFlag(i, LocalFlags.Wrapped)) {\n          this.unsetLocalFlag(i, LocalFlags.Wrapped); // assume not wrapped\n          needsRecompile = true;\n        }\n      }\n      if (type.isNullableReference) {\n        if (this.isLocalFlag(i, LocalFlags.NonNull) && !other.isLocalFlag(i, LocalFlags.NonNull)) {\n          this.unsetLocalFlag(i, LocalFlags.NonNull); // assume possibly null\n          needsRecompile = true;\n        }\n      }\n    }\n    if (needsRecompile) {\n      // Reset function locals to state before the compilation attempt\n      assert(localsByIndex.length >= numLocalsBefore);\n      localsByIndex.length = numLocalsBefore;\n      if (this.localFlags.length > numLocalsBefore) {\n        this.localFlags.length = numLocalsBefore;\n      }\n    }\n    return needsRecompile;\n  }\n\n  /** Checks if an expression of the specified type is known to be non-null, even if the type might be nullable. */\n  isNonnull(expr: ExpressionRef, type: Type): bool {\n    if (!type.isNullableReference) return true;\n    // below, only teeLocal/getLocal are relevant because these are the only expressions that\n    // depend on a dynamic nullable state (flag = LocalFlags.NonNull), while everything else\n    // has already been handled by the nullable type check above.\n    switch (getExpressionId(expr)) {\n      case ExpressionId.LocalSet: {\n        if (!isLocalTee(expr)) break;\n        let local = this.targetFunction.localsByIndex[getLocalSetIndex(expr)];\n        return !local.type.isNullableReference || this.isLocalFlag(local.index, LocalFlags.NonNull, false);\n      }\n      case ExpressionId.LocalGet: {\n        let local = this.targetFunction.localsByIndex[getLocalGetIndex(expr)];\n        return !local.type.isNullableReference || this.isLocalFlag(local.index, LocalFlags.NonNull, false);\n      }\n    }\n    return false;\n  }\n\n  /** Updates local states to reflect that this branch is only taken when `expr` is true-ish. */\n  private inheritNonnullIfTrue(\n    /** Expression being true. */\n    expr: ExpressionRef,\n    /** If specified, only set the flag if also nonnull in this flow. */\n    iff: Flow | null = null\n  ): void {\n    // A: `expr` is true-ish -> Q: how did that happen?\n\n    // The iff argument is useful in situations like\n    //\n    //  if (!ref) {\n    //    ref = new Ref();\n    //  }\n    //  // inheritNonnullIfFalse(`!ref`, thenFlow) -> ref != null\n    //\n\n    switch (getExpressionId(expr)) {\n      case ExpressionId.LocalSet: {\n        if (!isLocalTee(expr)) break;\n        let local = this.targetFunction.localsByIndex[getLocalSetIndex(expr)];\n        if (!iff || iff.isLocalFlag(local.index, LocalFlags.NonNull)) {\n          this.setLocalFlag(local.index, LocalFlags.NonNull);\n        }\n        this.inheritNonnullIfTrue(getLocalSetValue(expr), iff); // must have been true-ish as well\n        break;\n      }\n      case ExpressionId.LocalGet: {\n        let local = this.targetFunction.localsByIndex[getLocalGetIndex(expr)];\n        if (!iff || iff.isLocalFlag(local.index, LocalFlags.NonNull)) {\n          this.setLocalFlag(local.index, LocalFlags.NonNull);\n        }\n        break;\n      }\n      case ExpressionId.If: {\n        let ifFalse = getIfFalse(expr);\n        if (ifFalse && isConstZero(ifFalse)) {\n          // Logical AND: (if (condition ifTrue 0))\n          // the only way this had become true is if condition and ifTrue are true\n          this.inheritNonnullIfTrue(getIfCondition(expr), iff);\n          this.inheritNonnullIfTrue(getIfTrue(expr), iff);\n        }\n        break;\n      }\n      case ExpressionId.Unary: {\n        switch (getUnaryOp(expr)) {\n          case UnaryOp.EqzI32:\n          case UnaryOp.EqzI64: {\n            this.inheritNonnullIfFalse(getUnaryValue(expr), iff); // !value -> value must have been false\n            break;\n          }\n        }\n        break;\n      }\n      case ExpressionId.Binary: {\n        switch (getBinaryOp(expr)) {\n          case BinaryOp.EqI32:\n          case BinaryOp.EqI64: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (isConstNonZero(left)) {\n              this.inheritNonnullIfTrue(right, iff); // TRUE == right -> right must have been true\n            } else if (isConstNonZero(right)) {\n              this.inheritNonnullIfTrue(left, iff); // left == TRUE -> left must have been true\n            }\n            break;\n          }\n          case BinaryOp.NeI32:\n          case BinaryOp.NeI64: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (isConstZero(left)) {\n              this.inheritNonnullIfTrue(right, iff); // FALSE != right -> right must have been true\n            } else if (isConstZero(right)) {\n              this.inheritNonnullIfTrue(left, iff); // left != FALSE -> left must have been true\n            }\n            break;\n          }\n        }\n        break;\n      }\n      case ExpressionId.Call: {\n        // handle string eq/ne/not overloads\n        let name = getCallTarget(expr);\n        if (name == BuiltinNames.String_eq) {\n          assert(getCallOperandCount(expr) == 2);\n          let left = getCallOperandAt(expr, 0);\n          let right = getCallOperandAt(expr, 1);\n          if (isConstNonZero(left)) {\n            this.inheritNonnullIfTrue(right, iff); // TRUE == right -> right must have been true\n          } else if (isConstNonZero(right)) {\n            this.inheritNonnullIfTrue(left, iff); // left == TRUE -> left must have been true\n          }\n        } else if (name == BuiltinNames.String_ne) {\n          assert(getCallOperandCount(expr) == 2);\n          let left = getCallOperandAt(expr, 0);\n          let right = getCallOperandAt(expr, 1);\n          if (isConstZero(left)) {\n            this.inheritNonnullIfTrue(right, iff); // FALSE != right -> right must have been true\n          } else if (isConstZero(right)) {\n            this.inheritNonnullIfTrue(left, iff); // left != FALSE -> left must have been true\n          }\n        } else if (name == BuiltinNames.String_not) {\n          assert(getCallOperandCount(expr) == 1);\n          this.inheritNonnullIfFalse(getCallOperandAt(expr, 0), iff); // !value -> value must have been false\n        } else if (name == BuiltinNames.tostack) {\n          assert(getCallOperandCount(expr) == 1);\n          this.inheritNonnullIfTrue(getCallOperandAt(expr, 0), iff);\n        }\n        break;\n      }\n    }\n  }\n\n  /** Updates local states to reflect that this branch is only taken when `expr` is false-ish. */\n  private inheritNonnullIfFalse(\n    /** Expression being false. */\n    expr: ExpressionRef,\n    /** If specified, only set the flag if also nonnull in this flow. */\n    iff: Flow | null = null\n  ): void {\n    // A: `expr` is false-ish -> Q: how did that happen?\n    switch (getExpressionId(expr)) {\n      case ExpressionId.Unary: {\n        switch (getUnaryOp(expr)) {\n          case UnaryOp.EqzI32:\n          case UnaryOp.EqzI64: {\n            this.inheritNonnullIfTrue(getUnaryValue(expr), iff); // !value -> value must have been true\n            break;\n          }\n        }\n        break;\n      }\n      case ExpressionId.If: {\n        let ifTrue = getIfTrue(expr);\n        let ifFalse = getIfFalse(expr);\n        if (ifFalse && isConstNonZero(ifTrue)) {\n          // Logical OR: (if (condition 1 ifFalse))\n          // the only way this had become false is if condition and ifFalse are false\n          this.inheritNonnullIfFalse(getIfCondition(expr), iff);\n          this.inheritNonnullIfFalse(getIfFalse(expr), iff);\n        }\n        break;\n      }\n      case ExpressionId.Binary: {\n        switch (getBinaryOp(expr)) {\n          // remember: we want to know how the _entire_ expression became FALSE (!)\n          case BinaryOp.EqI32:\n          case BinaryOp.EqI64: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (isConstZero(left)) {\n              this.inheritNonnullIfTrue(right, iff); // !(FALSE == right) -> right must have been true\n            } else if (isConstZero(right)) {\n              this.inheritNonnullIfTrue(left, iff); // !(left == FALSE) -> left must have been true\n            }\n            break;\n          }\n          case BinaryOp.NeI32:\n          case BinaryOp.NeI64: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (isConstNonZero(left)) {\n              this.inheritNonnullIfTrue(right, iff); // !(TRUE != right) -> right must have been true\n            } else if (isConstNonZero(right)) {\n              this.inheritNonnullIfTrue(left, iff); // !(left != TRUE) -> left must have been true\n            }\n            break;\n          }\n        }\n        break;\n      }\n      case ExpressionId.Call: {\n        // handle string eq/ne/not overloads\n        let name = getCallTarget(expr);\n        if (name == BuiltinNames.String_eq) {\n          assert(getCallOperandCount(expr) == 2);\n          let left = getCallOperandAt(expr, 0);\n          let right = getCallOperandAt(expr, 1);\n          if (isConstZero(left)) {\n            this.inheritNonnullIfTrue(right, iff); // !(FALSE == right) -> right must have been true\n          } else if (isConstZero(right)) {\n            this.inheritNonnullIfTrue(left, iff); // !(left == FALSE) -> left must have been true\n          }\n        } else if (name == BuiltinNames.String_ne) {\n          assert(getCallOperandCount(expr) == 2);\n          let left = getCallOperandAt(expr, 0);\n          let right = getCallOperandAt(expr, 1);\n          if (isConstNonZero(left)) {\n            this.inheritNonnullIfTrue(right, iff); // !(TRUE != right) -> right must have been true\n          } else if (isConstNonZero(right)) {\n            this.inheritNonnullIfTrue(left, iff); // !(left != TRUE) -> left must have been true\n          }\n        } else if (name == BuiltinNames.String_not) {\n          assert(getCallOperandCount(expr) == 1);\n          this.inheritNonnullIfTrue(getCallOperandAt(expr, 0), iff); // !(!value) -> value must have been true\n        } else if (name == BuiltinNames.tostack) {\n          assert(getCallOperandCount(expr) == 1);\n          this.inheritNonnullIfFalse(getCallOperandAt(expr, 0), iff);\n        }\n        break;\n      }\n    }\n  }\n\n  /**\n   * Tests if an expression can possibly overflow in the context of this flow. Assumes that the\n   * expression might already have overflown and returns `false` only if the operation neglects\n   * any possible combination of garbage bits being present.\n   */\n  canOverflow(expr: ExpressionRef, type: Type): bool {\n    // TODO: the following catches most common and a few uncommon cases, but there are additional\n    // opportunities here, obviously.\n\n    // types other than i8, u8, i16, u16 and bool do not overflow\n    if (!type.isShortIntegerValue) return false;\n\n    let operand: ExpressionRef;\n    switch (getExpressionId(expr)) {\n\n      // overflows if the local isn't wrapped or the conversion does\n      case ExpressionId.LocalGet: {\n        let local = this.targetFunction.localsByIndex[getLocalGetIndex(expr)];\n        return !this.isLocalFlag(local.index, LocalFlags.Wrapped, true)\n            || canConversionOverflow(local.type, type);\n      }\n\n      // overflows if the value does\n      case ExpressionId.LocalSet: { // tee\n        assert(isLocalTee(expr));\n        return this.canOverflow(getLocalSetValue(expr), type);\n      }\n\n      // overflows if the conversion does (globals are wrapped on set)\n      case ExpressionId.GlobalGet: {\n        // TODO: this is inefficient because it has to read a string\n        let global = assert(this.program.elementsByName.get(assert(getGlobalGetName(expr))));\n        assert(global.kind == ElementKind.Global || global.kind == ElementKind.EnumValue);\n        return canConversionOverflow((<TypedElement>global).type, type);\n      }\n\n      case ExpressionId.Binary: {\n        switch (getBinaryOp(expr)) {\n\n          // comparisons do not overflow (result is 0 or 1)\n          case BinaryOp.EqI32:\n          case BinaryOp.EqI64:\n          case BinaryOp.EqF32:\n          case BinaryOp.EqF64:\n          case BinaryOp.NeI32:\n          case BinaryOp.NeI64:\n          case BinaryOp.NeF32:\n          case BinaryOp.NeF64:\n          case BinaryOp.LtI32:\n          case BinaryOp.LtU32:\n          case BinaryOp.LtI64:\n          case BinaryOp.LtU64:\n          case BinaryOp.LtF32:\n          case BinaryOp.LtF64:\n          case BinaryOp.LeI32:\n          case BinaryOp.LeU32:\n          case BinaryOp.LeI64:\n          case BinaryOp.LeU64:\n          case BinaryOp.LeF32:\n          case BinaryOp.LeF64:\n          case BinaryOp.GtI32:\n          case BinaryOp.GtU32:\n          case BinaryOp.GtI64:\n          case BinaryOp.GtU64:\n          case BinaryOp.GtF32:\n          case BinaryOp.GtF64:\n          case BinaryOp.GeI32:\n          case BinaryOp.GeU32:\n          case BinaryOp.GeI64:\n          case BinaryOp.GeU64:\n          case BinaryOp.GeF32:\n          case BinaryOp.GeF64: return false;\n\n          // result won't overflow if one side is 0 or if one side is 1 and the other wrapped\n          case BinaryOp.MulI32: {\n            return !(\n              (\n                getExpressionId(operand = getBinaryLeft(expr)) == ExpressionId.Const &&\n                (\n                  getConstValueI32(operand) == 0 ||\n                  (\n                    getConstValueI32(operand) == 1 &&\n                    !this.canOverflow(getBinaryRight(expr), type)\n                  )\n                )\n              ) || (\n                getExpressionId(operand = getBinaryRight(expr)) == ExpressionId.Const &&\n                (\n                  getConstValueI32(operand) == 0 ||\n                  (\n                    getConstValueI32(operand) == 1 &&\n                    !this.canOverflow(getBinaryLeft(expr), type)\n                  )\n                )\n              )\n            );\n          }\n\n          // result won't overflow if one side is a constant less than this type's mask or one side\n          // is wrapped\n          case BinaryOp.AndI32: {\n            // note that computeSmallIntegerMask returns the mask minus the MSB for signed types\n            // because signed value garbage bits must be guaranteed to be equal to the MSB.\n            return !(\n              (\n                (\n                  getExpressionId(operand = getBinaryLeft(expr)) == ExpressionId.Const &&\n                  getConstValueI32(operand) <= type.computeSmallIntegerMask(Type.i32)\n                ) || !this.canOverflow(operand, type)\n              ) || (\n                (\n                  getExpressionId(operand = getBinaryRight(expr)) == ExpressionId.Const &&\n                  getConstValueI32(operand) <= type.computeSmallIntegerMask(Type.i32)\n                ) || !this.canOverflow(operand, type)\n              )\n            );\n          }\n\n          // overflows if the shift doesn't clear potential garbage bits\n          case BinaryOp.ShlI32: {\n            let shift = 32 - type.size;\n            return getExpressionId(operand = getBinaryRight(expr)) != ExpressionId.Const\n                || getConstValueI32(operand) < shift;\n          }\n\n          // overflows if the value does and the shift doesn't clear potential garbage bits\n          case BinaryOp.ShrI32: {\n            let shift = 32 - type.size;\n            return this.canOverflow(getBinaryLeft(expr), type) && (\n              getExpressionId(operand = getBinaryRight(expr)) != ExpressionId.Const ||\n              getConstValueI32(operand) < shift\n            );\n          }\n\n          // overflows if the shift does not clear potential garbage bits. if an unsigned value is\n          // wrapped, it can't overflow.\n          case BinaryOp.ShrU32: {\n            let shift = 32 - type.size;\n            return type.isSignedIntegerValue\n              ? !(\n                  getExpressionId(operand = getBinaryRight(expr)) == ExpressionId.Const &&\n                  getConstValueI32(operand) > shift // must clear MSB\n                )\n              : this.canOverflow(getBinaryLeft(expr), type) &&\n                !(\n                  getExpressionId(operand = getBinaryRight(expr)) == ExpressionId.Const &&\n                  getConstValueI32(operand) >= shift // can leave MSB\n                );\n          }\n\n          // overflows if any side does\n          case BinaryOp.DivU32:\n          case BinaryOp.RemI32:\n          case BinaryOp.RemU32: {\n            return this.canOverflow(getBinaryLeft(expr), type)\n                || this.canOverflow(getBinaryRight(expr), type);\n          }\n        }\n        break;\n      }\n\n      case ExpressionId.Unary: {\n        switch (getUnaryOp(expr)) {\n\n          // comparisons do not overflow (result is 0 or 1)\n          case UnaryOp.EqzI32:\n          case UnaryOp.EqzI64: return false;\n\n          // overflow if the maximum result (32) cannot be represented in the target type\n          case UnaryOp.ClzI32:\n          case UnaryOp.CtzI32:\n          case UnaryOp.PopcntI32: return type.size < 7;\n\n          // sign extensions overflow if result can have high garbage bits in the target type\n          case UnaryOp.Extend8I32: return type.size < (type.isUnsignedIntegerValue ? 32 : 8);\n          case UnaryOp.Extend8I64: return type.size < (type.isUnsignedIntegerValue ? 64 : 8);\n          case UnaryOp.Extend16I32: return type.size < (type.isUnsignedIntegerValue ? 32 : 16);\n          case UnaryOp.Extend16I64: return type.size < (type.isUnsignedIntegerValue ? 64 : 16);\n          case UnaryOp.Extend32I64: return type.size < (type.isUnsignedIntegerValue ? 64 : 32);\n        }\n        break;\n      }\n\n      // overflows if the value cannot be represented in the target type\n      case ExpressionId.Const: {\n        let value: i32 = 0;\n        switch (<u32>getExpressionType(expr)) {\n          case <u32>TypeRef.I32: { value = getConstValueI32(expr); break; }\n          case <u32>TypeRef.I64: { value = getConstValueI64Low(expr); break; } // discards upper bits\n          case <u32>TypeRef.F32: { value = i32(getConstValueF32(expr)); break; }\n          case <u32>TypeRef.F64: { value = i32(getConstValueF64(expr)); break; }\n          case <u32>TypeRef.V128: return false;\n          default: assert(false);\n        }\n        switch (type.kind) {\n          case TypeKind.Bool: return (value & ~1) != 0;\n          case TypeKind.I8:   return value < <i32>i8.MIN_VALUE  || value > <i32>i8.MAX_VALUE;\n          case TypeKind.I16:  return value < <i32>i16.MIN_VALUE || value > <i32>i16.MAX_VALUE;\n          case TypeKind.U8:   return value < 0 || value > <i32>u8.MAX_VALUE;\n          case TypeKind.U16:  return value < 0 || value > <i32>u16.MAX_VALUE;\n        }\n        break;\n      }\n\n      // overflows if the conversion does\n      case ExpressionId.Load: {\n        let fromType: Type;\n        let signed = isLoadSigned(expr);\n        switch (getLoadBytes(expr)) {\n          case 1:  { fromType = signed ? Type.i8  : Type.u8;  break; }\n          case 2:  { fromType = signed ? Type.i16 : Type.u16; break; }\n          default: { fromType = signed ? Type.i32 : Type.u32; break; }\n        }\n        return canConversionOverflow(fromType, type);\n      }\n\n      // overflows if the result does, which is either\n      // - the last expression of the block, by contract, if the block doesn't have a label\n      // - the last expression or the value of an inner br if the block has a label (TODO)\n      case ExpressionId.Block: {\n        if (!getBlockName(expr)) {\n          let size = assert(getBlockChildCount(expr));\n          let last = getBlockChildAt(expr, size - 1);\n          return this.canOverflow(last, type);\n        }\n        break;\n      }\n\n      // overflows if either side does\n      case ExpressionId.If: {\n        return this.canOverflow(getIfTrue(expr), type)\n            || this.canOverflow(assert(getIfFalse(expr)), type);\n      }\n\n      // overflows if either side does\n      case ExpressionId.Select: {\n        return this.canOverflow(getSelectThen(expr), type)\n            || this.canOverflow(getSelectElse(expr), type);\n      }\n\n      // overflows if the call does not return a wrapped value or the conversion does\n      case ExpressionId.Call: {\n        let program = this.program;\n        let instancesByName = program.instancesByName;\n        let instanceName = assert(getCallTarget(expr));\n        if (instancesByName.has(instanceName)) {\n          let instance = assert(instancesByName.get(instanceName));\n          assert(instance.kind == ElementKind.Function);\n          let functionInstance = <Function>instance;\n          let returnType = functionInstance.signature.returnType;\n          return !functionInstance.flow.is(FlowFlags.ReturnsWrapped)\n              || canConversionOverflow(returnType, type);\n        }\n        return false; // assume no overflow for builtins\n      }\n\n      // doesn't technically overflow\n      case ExpressionId.Unreachable: return false;\n    }\n    return true;\n  }\n\n  toString(): string {\n    let levels = 0;\n    let parent = this.parent;\n    while (parent) {\n      parent = parent.parent;\n      ++levels;\n    }\n    let sb = new Array<string>();\n    if (this.is(FlowFlags.Returns)) sb.push(\"RETURNS\");\n    if (this.is(FlowFlags.ReturnsWrapped)) sb.push(\"RETURNS_WRAPPED\");\n    if (this.is(FlowFlags.ReturnsNonNull)) sb.push(\"RETURNS_NONNULL\");\n    if (this.is(FlowFlags.Throws)) sb.push(\"THROWS\");\n    if (this.is(FlowFlags.Breaks)) sb.push(\"BREAKS\");\n    if (this.is(FlowFlags.Continues)) sb.push(\"CONTINUES\");\n    if (this.is(FlowFlags.AccessesThis)) sb.push(\"ACCESSES_THIS\");\n    if (this.is(FlowFlags.CallsSuper)) sb.push(\"CALLS_SUPER\");\n    if (this.is(FlowFlags.Terminates)) sb.push(\"TERMINATES\");\n    if (this.is(FlowFlags.ConditionallyReturns)) sb.push(\"CONDITIONALLY_RETURNS\");\n    if (this.is(FlowFlags.ConditionallyThrows)) sb.push(\"CONDITIONALLY_THROWS\");\n    if (this.is(FlowFlags.ConditionallyBreaks)) sb.push(\"CONDITIONALLY_BREAKS\");\n    if (this.is(FlowFlags.ConditionallyContinues)) sb.push(\"CONDITIONALLY_CONTINUES\");\n    if (this.is(FlowFlags.ConditionallyAccessesThis)) sb.push(\"CONDITIONALLY_ACCESSES_THIS\");\n    if (this.is(FlowFlags.MayReturnNonThis)) sb.push(\"MAY_RETURN_NONTHIS\");\n    return `Flow(${this.sourceFunction})[${levels}] ${sb.join(\" \")}`;\n  }\n}\n\n/** Tests if a conversion from one type to another can technically overflow. */\nfunction canConversionOverflow(fromType: Type, toType: Type): bool {\n  return toType.isShortIntegerValue && (\n    !fromType.isIntegerValue ||                                    // i.e. float to small int\n    fromType.size > toType.size ||                                 // larger int to small int\n    fromType.isSignedIntegerValue != toType.isSignedIntegerValue   // signedness mismatch\n  );\n}\n", "/**\n * @fileoverview Resolve infrastructure to obtain types and elements.\n *\n * Similar to the compiler making instructions of expressions, the resolver\n * obtains metadata of expressions. As such, for each `compileX` method in\n * the compiler there is one `lookupX` method in the resolver returning the\n * respective IR element, respectively one `resolveX` method returning the\n * respective type of an expression. It is also able to make new elements,\n * like instances of classes given its concrete type arguments.\n *\n * @license Apache-2.0\n */\n\nimport {\n  Range,\n  DiagnosticEmitter,\n  DiagnosticCode\n} from \"./diagnostics\";\n\nimport {\n  Program,\n  ElementKind,\n  OperatorKind,\n  Element,\n  Class,\n  ClassPrototype,\n  Interface,\n  Function,\n  FunctionPrototype,\n  VariableLikeElement,\n  Property,\n  PropertyPrototype,\n  Global,\n  TypeDefinition,\n  TypedElement,\n  IndexSignature,\n  isTypedElement,\n  InterfacePrototype,\n  DeclaredElement\n} from \"./program\";\n\nimport {\n  Flow\n} from \"./flow\";\n\nimport {\n  FunctionTypeNode,\n  ParameterKind,\n  TypeNode,\n  NodeKind,\n  NamedTypeNode,\n  TypeName,\n  TypeParameterNode,\n  Node,\n  IdentifierExpression,\n  CallExpression,\n  ElementAccessExpression,\n  PropertyAccessExpression,\n  LiteralExpression,\n  LiteralKind,\n  ParenthesizedExpression,\n  AssertionExpression,\n  Expression,\n  IntegerLiteralExpression,\n  UnaryPrefixExpression,\n  UnaryPostfixExpression,\n  AssertionKind,\n  BinaryExpression,\n  ThisExpression,\n  SuperExpression,\n  CommaExpression,\n  InstanceOfExpression,\n  TernaryExpression,\n  isTypeOmitted,\n  FunctionExpression,\n  NewExpression,\n  ArrayLiteralExpression,\n  ArrowKind,\n  ExpressionStatement\n} from \"./ast\";\n\nimport {\n  Type,\n  Signature,\n  typesToString,\n  TypeKind,\n  TypeFlags\n} from \"./types\";\n\nimport {\n  CommonFlags,\n  CommonNames\n} from \"./common\";\n\nimport {\n  cloneMap,\n  isPowerOf2\n} from \"./util\";\n\nimport {\n  Token,\n  operatorTokenToString\n} from \"./tokenizer\";\n\nimport {\n  BuiltinNames\n} from \"./builtins\";\n\n/** Indicates whether errors are reported or not. */\nexport const enum ReportMode {\n  /** Report errors. */\n  Report,\n  /** Swallow errors. */\n  Swallow\n}\n\n/** Provides tools to resolve types and expressions. */\nexport class Resolver extends DiagnosticEmitter {\n\n  /** The program this resolver belongs to. */\n  program: Program;\n\n  /** Target expression of the previously resolved property or element access. */\n  currentThisExpression: Expression | null = null;\n  /** Element expression of the previously resolved element access. */\n  currentElementExpression : Expression | null = null;\n  /** Whether a new override has been discovered. */\n  discoveredOverride: bool = false;\n\n  /** Constructs the resolver for the specified program. */\n  constructor(\n    /** The program to construct a resolver for. */\n    program: Program\n  ) {\n    super(program.diagnostics);\n    this.program = program;\n  }\n\n  // ====================================================== Types ======================================================\n\n  /** Resolves a {@link TypeNode} to a concrete {@link Type}. */\n  resolveType(\n    /** The type to resolve. */\n    node: TypeNode,\n    /** The flow */\n    flow: Flow | null,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    if (node.currentlyResolving) {\n      this.error(\n        DiagnosticCode.Not_implemented_0,\n        node.range, \"Recursive types\"\n      );\n      return null;\n    }\n    node.currentlyResolving = true;\n    let resolved: Type | null = null;\n    switch (node.kind) {\n      case NodeKind.NamedType: {\n        resolved = this.resolveNamedType(<NamedTypeNode>node, flow, ctxElement, ctxTypes, reportMode);\n        break;\n      }\n      case NodeKind.FunctionType: {\n        resolved = this.resolveFunctionType(<FunctionTypeNode>node, flow, ctxElement, ctxTypes, reportMode);\n        break;\n      }\n      default: assert(false);\n    }\n    node.currentlyResolving = false;\n    return resolved;\n  }\n\n  /** Resolves a {@link NamedTypeNode} to a concrete {@link Type}. */\n  private resolveNamedType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** The flow */\n    flow: Flow | null,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let nameNode = node.name;\n    let typeArgumentNodes = node.typeArguments;\n    let isSimpleType = !nameNode.next;\n\n    // Look up in contextual types if a simple type\n    if (isSimpleType) {\n      let simpleName = nameNode.identifier.text;\n      if (ctxTypes && ctxTypes.has(simpleName)) {\n        let type = assert(ctxTypes.get(simpleName));\n        if (typeArgumentNodes && typeArgumentNodes.length > 0) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Type_0_is_not_generic,\n              node.range, type.toString()\n            );\n          }\n        }\n        if (node.isNullable) {\n          if (type.isReference) return type.asNullable();\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Type_0_cannot_be_nullable,\n              node.range, type.toString()\n            );\n          }\n        }\n        return type;\n      }\n    }\n\n    // Look up in context\n    let element = this.resolveTypeName(nameNode, flow, ctxElement, reportMode);\n    if (!element) return null;\n\n    // Use shadow type if present (i.e. namespace sharing a type)\n    let shadowType = element.shadowType;\n    if (shadowType) {\n      element = shadowType;\n\n    } else {\n\n      // Handle enums (become i32)\n      if (element.kind == ElementKind.Enum) {\n        if (typeArgumentNodes && typeArgumentNodes.length > 0) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Type_0_is_not_generic,\n              node.range, element.internalName\n            );\n          }\n        }\n        if (node.isNullable) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Type_0_cannot_be_nullable,\n              node.range, `${element.name}/i32`\n            );\n          }\n        }\n        return Type.i32;\n      }\n\n      // Handle classes and interfaces\n      if (\n        element.kind == ElementKind.ClassPrototype ||\n        element.kind == ElementKind.InterfacePrototype\n      ) {\n        let instance = this.resolveClassInclTypeArguments(\n          <ClassPrototype>element,\n          typeArgumentNodes,\n          flow,\n          ctxElement,\n          cloneMap(ctxTypes), // don't inherit\n          node,\n          reportMode\n        );\n        if (!instance) return null;\n        return node.isNullable ? instance.type.asNullable() : instance.type;\n      }\n    }\n\n    // Handle type definitions\n    if (element.kind == ElementKind.TypeDefinition) {\n      let typeDefinition = <TypeDefinition>element;\n\n      // Shortcut already resolved (mostly builtins)\n      if (element.is(CommonFlags.Resolved)) {\n        if (typeArgumentNodes && typeArgumentNodes.length > 0) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Type_0_is_not_generic,\n              node.range, element.internalName\n            );\n          }\n        }\n        let type = typeDefinition.type;\n        if (node.isNullable) {\n          if (type.isReference) return type.asNullable();\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Type_0_cannot_be_nullable,\n              nameNode.range, nameNode.identifier.text\n            );\n          }\n        }\n        return type;\n      }\n\n      // Handle special built-in types\n      if (isSimpleType) {\n        let text = nameNode.identifier.text;\n        if (text == CommonNames.native)   return this.resolveBuiltinNativeType(node, ctxElement, ctxTypes, reportMode);\n        if (text == CommonNames.indexof)  return this.resolveBuiltinIndexofType(node, ctxElement, ctxTypes, reportMode);\n        if (text == CommonNames.valueof)  return this.resolveBuiltinValueofType(node, ctxElement, ctxTypes, reportMode);\n        if (text == CommonNames.returnof) return this.resolveBuiltinReturnTypeType(node, ctxElement, ctxTypes, reportMode);\n        if (text == CommonNames.nonnull)  return this.resolveBuiltinNotNullableType(node, ctxElement, ctxTypes, reportMode);\n      }\n\n      // Resolve normally\n      let typeParameterNodes = typeDefinition.typeParameterNodes;\n      let typeArguments: Type[] | null = null;\n      if (typeParameterNodes) {\n        typeArguments = this.resolveTypeArguments(\n          typeParameterNodes,\n          typeArgumentNodes,\n          flow,\n          ctxElement,\n          ctxTypes = cloneMap(ctxTypes), // update\n          node,\n          reportMode\n        );\n        if (!typeArguments) return null;\n      } else if (typeArgumentNodes && typeArgumentNodes.length > 0) {\n        this.error(\n          DiagnosticCode.Type_0_is_not_generic,\n          node.range, nameNode.identifier.text\n        );\n      }\n      let type = this.resolveType(\n        typeDefinition.typeNode,\n        flow,\n        element,\n        ctxTypes,\n        reportMode\n      );\n      if (!type) return null;\n      if (node.isNullable) {\n        if (type.isReference) return type.asNullable();\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Type_0_cannot_be_nullable,\n            nameNode.range, nameNode.identifier.text\n          );\n        }\n      }\n      return type;\n    }\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode.Cannot_find_name_0,\n        nameNode.range, nameNode.identifier.text\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a {@link FunctionTypeNode} to a concrete {@link Type}. */\n  private resolveFunctionType(\n    /** The type to resolve. */\n    node: FunctionTypeNode,\n    /** The flow */\n    flow: Flow | null,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let explicitThisType = node.explicitThisType;\n    let thisType: Type | null = null;\n    if (explicitThisType) {\n      thisType = this.resolveType(\n        explicitThisType,\n        flow,\n        ctxElement,\n        ctxTypes,\n        reportMode\n      );\n      if (!thisType) return null;\n    }\n    let parameterNodes = node.parameters;\n    let numParameters = parameterNodes.length;\n    let parameterTypes = new Array<Type>(numParameters);\n    let requiredParameters = 0;\n    let hasRest = false;\n    for (let i = 0; i < numParameters; ++i) {\n      let parameterNode = parameterNodes[i];\n      switch (parameterNode.parameterKind) {\n        case ParameterKind.Default: {\n          requiredParameters = i + 1;\n          break;\n        }\n        case ParameterKind.Rest: {\n          assert(i == numParameters - 1);\n          hasRest = true;\n          break;\n        }\n      }\n      let parameterTypeNode = parameterNode.type;\n      if (isTypeOmitted(parameterTypeNode)) {\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            parameterTypeNode.range\n          );\n        }\n        return null;\n      }\n      let parameterType = this.resolveType(\n        parameterTypeNode,\n        flow,\n        ctxElement,\n        ctxTypes,\n        reportMode\n      );\n      if (!parameterType) return null;\n      parameterTypes[i] = parameterType;\n    }\n    let returnTypeNode = node.returnType;\n    let returnType: Type | null;\n    if (isTypeOmitted(returnTypeNode)) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Type_expected,\n          returnTypeNode.range\n        );\n      }\n      returnType = Type.void;\n    } else {\n      returnType = this.resolveType(\n        returnTypeNode,\n        flow,\n        ctxElement,\n        ctxTypes,\n        reportMode\n      );\n      if (!returnType) return null;\n    }\n    let signature = Signature.create(this.program, parameterTypes, returnType, thisType, requiredParameters, hasRest);\n    return node.isNullable ? signature.type.asNullable() : signature.type;\n  }\n\n  private resolveBuiltinNativeType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    const typeArgumentNode = this.ensureOneTypeArgument(node, reportMode);\n    if (!typeArgumentNode) return null;\n    let typeArgument = this.resolveType(typeArgumentNode, null, ctxElement, ctxTypes, reportMode);\n    if (!typeArgument) return null;\n    switch (typeArgument.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:  return Type.i32;\n      case TypeKind.Isize: if (!this.program.options.isWasm64) return Type.i32;\n      case TypeKind.I64:  return Type.i64;\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.Bool: return Type.u32;\n      case TypeKind.Usize: if (!this.program.options.isWasm64) return Type.u32;\n      case TypeKind.U64:  return Type.u64;\n      case TypeKind.F32:  return Type.f32;\n      case TypeKind.F64:  return Type.f64;\n      case TypeKind.V128: return Type.v128;\n      case TypeKind.Void: return Type.void;\n      default: assert(false);\n    }\n    return null;\n  }\n\n  private resolveBuiltinIndexofType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    const typeArgumentNode = this.ensureOneTypeArgument(node, reportMode);\n    if (!typeArgumentNode) return null;\n    let typeArgument = this.resolveType(typeArgumentNode, null, ctxElement, ctxTypes, reportMode);\n    if (!typeArgument) return null;\n    let classReference = typeArgument.classReference;\n    if (!classReference) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Index_signature_is_missing_in_type_0,\n          typeArgumentNode.range, typeArgument.toString()\n        );\n      }\n      return null;\n    }\n    let overload = classReference.lookupOverload(OperatorKind.IndexedGet);\n    if (overload) {\n      let parameterTypes = overload.signature.parameterTypes;\n      if (overload.is(CommonFlags.Static)) {\n        assert(parameterTypes.length == 2);\n        return parameterTypes[1];\n      } else {\n        assert(parameterTypes.length == 1);\n        return parameterTypes[0];\n      }\n    }\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode.Index_signature_is_missing_in_type_0,\n        typeArgumentNode.range, typeArgument.toString()\n      );\n    }\n    return null;\n  }\n\n  private resolveBuiltinValueofType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    const typeArgumentNode = this.ensureOneTypeArgument(node, reportMode);\n    if (!typeArgumentNode) return null;\n    let typeArgument = this.resolveType(typeArgumentNode, null, ctxElement, ctxTypes, reportMode);\n    if (!typeArgument) return null;\n    let classReference = typeArgument.getClassOrWrapper(this.program);\n    if (classReference) {\n      let overload = classReference.lookupOverload(OperatorKind.IndexedGet);\n      if (overload) return overload.signature.returnType;\n    }\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode.Index_signature_is_missing_in_type_0,\n        typeArgumentNode.range, typeArgument.toString()\n      );\n    }\n    return null;\n  }\n\n  private resolveBuiltinReturnTypeType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventualy diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    const typeArgumentNode = this.ensureOneTypeArgument(node, reportMode);\n    if (!typeArgumentNode) return null;\n    let typeArgument = this.resolveType(typeArgumentNode, null, ctxElement, ctxTypes, reportMode);\n    if (!typeArgument) return null;\n    let signatureReference = typeArgument.getSignature();\n    if (signatureReference) return signatureReference.returnType;\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode.Type_0_has_no_call_signatures,\n        typeArgumentNode.range, typeArgument.toString()\n      );\n    }\n    return null;\n  }\n\n  private resolveBuiltinNotNullableType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    const typeArgumentNode = this.ensureOneTypeArgument(node, reportMode);\n    if (!typeArgumentNode) return null;\n    let typeArgument = this.resolveType(typeArgumentNode, null, ctxElement, ctxTypes, reportMode);\n    if (!typeArgument) return null;\n    if (!typeArgument.isNullableReference) return typeArgument;\n    return typeArgument.nonNullableType;\n  }\n\n  /** Resolves a type name to the program element it refers to. */\n  resolveTypeName(\n    /** The type name to resolve. */\n    node: TypeName,\n    /** The flow */\n    flow: Flow | null,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let element: Element | null = null;\n    if (flow) element = flow.lookupTypeAlias(node.identifier.text);\n    if (!element) element = ctxElement.lookup(node.identifier.text, true);\n    if (!element) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Cannot_find_name_0,\n          node.range, node.identifier.text\n        );\n      }\n      return null;\n    }\n    let prev = node;\n    let next = node.next;\n    while (next) {\n      if (!(element = element.getMember(next.identifier.text))) {\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Property_0_does_not_exist_on_type_1,\n            next.range, next.identifier.text, prev.identifier.text\n          );\n        }\n        return null;\n      }\n      prev = next;\n      next = next.next;\n    }\n    return element;\n  }\n\n  /** Resolves an array of type arguments to concrete types. */\n  resolveTypeArguments(\n    /** Type parameter nodes present. */\n    typeParameters: TypeParameterNode[],\n    /** Type argument nodes provided. */\n    typeArgumentNodes: TypeNode[] | null,\n    /** Flow */\n    flow: Flow | null,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. Updated in place with the new set of contextual types. */\n    ctxTypes: Map<string,Type> = new Map(),\n    /** Alternative report node in case of empty type arguments. */\n    alternativeReportNode: Node | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type[] | null {\n    let minParameterCount = 0;\n    let maxParameterCount = 0;\n    for (let i = 0, k = typeParameters.length; i < k; ++i) {\n      if (!typeParameters[i].defaultType) ++minParameterCount;\n      ++maxParameterCount;\n    }\n    let argumentCount = typeArgumentNodes ? typeArgumentNodes.length : 0;\n    if (argumentCount < minParameterCount || argumentCount > maxParameterCount) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Expected_0_type_arguments_but_got_1,\n          argumentCount\n            ? Range.join(\n                typeArgumentNodes![0].range,\n                typeArgumentNodes![argumentCount - 1].range\n              )\n            : alternativeReportNode!.range,\n          (argumentCount < minParameterCount ? minParameterCount : maxParameterCount).toString(),\n          argumentCount.toString()\n        );\n      }\n      return null;\n    }\n    let typeArguments = new Array<Type>(maxParameterCount);\n    let oldCtxTypes = cloneMap(ctxTypes);\n    ctxTypes.clear();\n    for (let i = 0; i < maxParameterCount; ++i) {\n      let type = i < argumentCount\n        ? this.resolveType( // reports\n            typeArgumentNodes![i],\n            flow,\n            ctxElement,\n            oldCtxTypes, // update\n            reportMode\n          )\n        : this.resolveType( // reports\n            assert(typeParameters[i].defaultType),\n            flow,\n            ctxElement,\n            cloneMap(ctxTypes), // don't update\n            reportMode\n          );\n      if (!type) return null;\n      // TODO: check extendsType\n      ctxTypes.set(typeParameters[i].name.text, type);\n      typeArguments[i] = type;\n    }\n    return typeArguments;\n  }\n\n  /** Resolves respectively infers the concrete instance of a function by call context. */\n  maybeInferCall(\n    node: CallExpression,\n    prototype: FunctionPrototype,\n    ctxFlow: Flow,\n    reportMode: ReportMode = ReportMode.Report\n  ): Function | null {\n    let typeArguments = node.typeArguments;\n\n    // resolve generic call if type arguments have been provided\n    if (typeArguments) {\n      if (!prototype.is(CommonFlags.Generic)) {\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_generic,\n            node.expression.range, prototype.internalName\n          );\n        }\n        return null;\n      }\n      return this.resolveFunctionInclTypeArguments(\n        prototype,\n        typeArguments,\n        ctxFlow.sourceFunction,\n        cloneMap(ctxFlow.contextualTypeArguments), // don't inherit\n        node,\n        reportMode\n      );\n    }\n\n    // infer generic call if type arguments have been omitted\n    if (prototype.is(CommonFlags.Generic)) {\n      let resolvedTypeArguments = this.inferGenericTypeArguments(\n        node,\n        prototype,\n        prototype.typeParameterNodes,\n        ctxFlow,\n        reportMode,\n      );\n      if (!resolvedTypeArguments) {\n        return null;\n      }     \n      return this.resolveFunction(\n        prototype,\n        resolvedTypeArguments,\n        cloneMap(ctxFlow.contextualTypeArguments),\n        reportMode\n      );\n    }\n\n    // otherwise resolve the non-generic call as usual\n    return this.resolveFunction(prototype, null, new Map(), reportMode);\n  }\n\n  private inferGenericTypeArguments(\n    node: Expression,\n    prototype: FunctionPrototype,\n    typeParameterNodes: TypeParameterNode[] | null,\n    ctxFlow: Flow,\n    reportMode: ReportMode = ReportMode.Report,\n  ): Type[] | null {\n\n    if (!typeParameterNodes) {\n      return null;\n    }\n\n    let contextualTypeArguments = cloneMap(ctxFlow.contextualTypeArguments);\n\n    // fill up contextual types with auto for each generic component\n    let numTypeParameters = typeParameterNodes.length;\n    let typeParameterNames = new Set<string>();\n    for (let i = 0; i < numTypeParameters; ++i) {\n      let name = typeParameterNodes[i].name.text;\n      contextualTypeArguments.set(name, Type.auto);\n      typeParameterNames.add(name);\n    }\n\n    let parameterNodes = prototype.functionTypeNode.parameters;\n    let numParameters = parameterNodes.length;\n\n    let argumentNodes: Expression[];\n    let argumentsRange: Range;\n    switch (node.kind) {\n      case NodeKind.Call: {\n        const expr = node as CallExpression;\n        argumentNodes = expr.args;\n        argumentsRange = expr.argumentsRange;\n        break;\n      }\n      case NodeKind.New: {\n        const expr = node as NewExpression;\n        argumentNodes = expr.args;\n        argumentsRange = expr.argumentsRange;\n        break;\n      }\n      default: {\n        assert(false);\n        return null;\n      }\n    }\n\n    let numArguments = argumentNodes.length;\n\n    // infer types with generic components while updating contextual types\n    for (let i = 0; i < numParameters; ++i) {\n      let argumentExpression = i < numArguments\n        ? argumentNodes[i]\n        : parameterNodes[i].initializer;\n      if (!argumentExpression) {\n        // optional but not have initializer should be handled in the other place\n        if (parameterNodes[i].parameterKind == ParameterKind.Optional) {\n          continue;\n        }\n        if (reportMode == ReportMode.Report) {\n          if (parameterNodes[i].parameterKind == ParameterKind.Rest) {\n            // rest params are optional, but one element is needed for type inference\n            this.error(\n              DiagnosticCode.Type_argument_expected,\n              argumentsRange.atEnd\n            );\n          } else {\n            // missing initializer -> too few arguments\n            this.error(\n              DiagnosticCode.Expected_0_arguments_but_got_1,\n              node.range, numParameters.toString(), numArguments.toString()\n            );\n          }\n        }\n        return null;\n      }\n      let typeNode = parameterNodes[i].type;\n      if (parameterNodes[i].parameterKind == ParameterKind.Rest) {\n        typeNode = (<NamedTypeNode> typeNode).typeArguments![0];\n      }\n      if (typeNode.hasGenericComponent(typeParameterNodes)) {\n        let type = this.resolveExpression(argumentExpression, ctxFlow, Type.auto, ReportMode.Swallow);\n        if (type) {\n          this.propagateInferredGenericTypes(\n            typeNode,\n            type,\n            prototype,\n            contextualTypeArguments,\n            typeParameterNames\n          );\n        }\n      }\n    }\n\n    // apply concrete types to the generic function signature\n    let resolvedTypeArguments = new Array<Type>(numTypeParameters);\n    for (let i = 0; i < numTypeParameters; ++i) {\n      let typeParameterNode = typeParameterNodes[i];\n      let name = typeParameterNode.name.text;\n      if (contextualTypeArguments.has(name)) {\n        let inferredType = assert(contextualTypeArguments.get(name));\n        if (inferredType != Type.auto) {\n          resolvedTypeArguments[i] = inferredType;\n          continue;\n        }\n        let defaultType = typeParameterNode.defaultType;\n        if (defaultType) {\n          // Default parameters are resolved in context of the called function, not the calling function\n          let parent = prototype.parent;\n          let defaultTypeContextualTypeArguments: Map<string, Type> | null = null;\n          if (parent.kind == ElementKind.Class) {\n            defaultTypeContextualTypeArguments = (<Class>parent).contextualTypeArguments;\n          } else if (parent.kind == ElementKind.Function) {\n            defaultTypeContextualTypeArguments = (<Function>parent).contextualTypeArguments;\n          }\n          let resolvedDefaultType = this.resolveType(\n            defaultType,\n            null,\n            prototype,\n            defaultTypeContextualTypeArguments,\n            reportMode\n          );\n          if (!resolvedDefaultType) return null;\n          resolvedTypeArguments[i] = resolvedDefaultType;\n          continue;\n        }\n      }\n      // unused template, e.g. `function test<T>(): void {...}` called as `test()`\n      // invalid because the type is effectively unknown inside the function body\n      if (reportMode == ReportMode.Report) {\n        let range: Range;\n        switch (node.kind) {\n          case NodeKind.Call:\n            range = (<CallExpression>node).expression.range;\n            break;\n          case NodeKind.New:\n            range = (<NewExpression>node).typeName.range;\n            break;\n          default:\n            assert(false);\n            return null;\n        }\n        this.error(\n          DiagnosticCode.Type_argument_expected,\n          range.atEnd\n        );\n      }\n      return null;\n    }\n\n    return resolvedTypeArguments;\n  }\n\n  /** Updates contextual types with a possibly encapsulated inferred type. */\n  private propagateInferredGenericTypes(\n    /** The inferred type node. */\n    node: TypeNode,\n    /** The inferred type. */\n    type: Type,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`, with unknown types initialized to `auto`. */\n    ctxTypes: Map<string,Type>,\n    /** The names of the type parameters being inferred. */\n    typeParameterNames: Set<string>\n  ): void {\n    if (node.kind == NodeKind.NamedType) {\n      let namedTypeNode = <NamedTypeNode>node;\n      let typeArgumentNodes = namedTypeNode.typeArguments;\n      if (typeArgumentNodes && typeArgumentNodes.length > 0) { // foo<T>(bar: Array<T>)\n        let classReference = type.classReference;\n        if (classReference) {\n          let classPrototype = this.resolveTypeName(namedTypeNode.name, null, ctxElement);\n          if (!classPrototype || classPrototype.kind != ElementKind.ClassPrototype) return;\n          if (classReference.prototype == <ClassPrototype>classPrototype) {\n            let typeArguments = classReference.typeArguments;\n            if (typeArguments && typeArguments.length == typeArgumentNodes.length) {\n              for (let i = 0, k = typeArguments.length; i < k; ++i) {\n                this.propagateInferredGenericTypes(\n                  typeArgumentNodes[i],\n                  typeArguments[i],\n                  ctxElement,\n                  ctxTypes,\n                  typeParameterNames\n                );\n              }\n              return;\n            }\n          }\n        }\n      } else { // foo<T>(bar: T)\n        let name = namedTypeNode.name.identifier.text;\n        if (ctxTypes.has(name)) {\n          let currentType = assert(ctxTypes.get(name));\n          if (\n            currentType == Type.auto ||\n            (typeParameterNames.has(name) && currentType.isAssignableTo(type))\n          ) ctxTypes.set(name, type);\n        }\n      }\n    } else if (node.kind == NodeKind.FunctionType) { // foo<T>(bar: (baz: T) => i32))\n      let functionTypeNode = <FunctionTypeNode>node;\n      let parameterNodes = functionTypeNode.parameters;\n      let signatureReference = type.signatureReference;\n      if (signatureReference) {\n        let parameterTypes = signatureReference.parameterTypes;\n        for (let i = 0, k = min(parameterTypes.length, parameterNodes.length) ; i < k; ++i) {\n          this.propagateInferredGenericTypes(\n            parameterNodes[i].type,\n            parameterTypes[i],\n            ctxElement,\n            ctxTypes,\n            typeParameterNames\n          );\n        }\n        let returnType = signatureReference.returnType;\n        if (returnType != Type.void) {\n          this.propagateInferredGenericTypes(\n            functionTypeNode.returnType,\n            returnType,\n            ctxElement,\n            ctxTypes,\n            typeParameterNames\n          );\n        }\n        let thisType = signatureReference.thisType;\n        let explicitThisType = functionTypeNode.explicitThisType;\n        if (thisType && explicitThisType) {\n          this.propagateInferredGenericTypes(\n            explicitThisType,\n            thisType,\n            ctxElement,\n            ctxTypes,\n            typeParameterNames\n          );\n        }\n        return;\n      }\n    }\n  }\n\n  /** Gets the concrete type of an element. */\n  getTypeOfElement(element: Element): Type | null {\n    let kind = element.kind;\n    if (kind == ElementKind.Global) {\n      if (!this.ensureResolvedLazyGlobal(<Global>element, ReportMode.Swallow)) return null;\n    }\n    if (isTypedElement(kind)) {\n      let type = (<TypedElement>element).type;\n      let classReference = type.getClassOrWrapper(this.program);\n      if (classReference) {\n        let wrappedType = classReference.wrappedType;\n        if (wrappedType) type = wrappedType;\n      }\n      return type;\n    }\n    return null;\n  }\n\n  /** Gets the element of a concrete type. */\n  getElementOfType(type: Type): Element | null {\n    let classReference = type.getClassOrWrapper(this.program);\n    if (classReference) return classReference;\n    return null;\n  }\n\n  // =================================================== Expressions ===================================================\n\n  /** Looks up the program element the specified expression refers to. */\n  lookupExpression(\n    /** The expression to look up. */\n    node: Expression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    while (node.kind == NodeKind.Parenthesized) { // skip\n      node = (<ParenthesizedExpression>node).expression;\n    }\n    switch (node.kind) {\n      case NodeKind.Assertion: {\n        return this.lookupAssertionExpression(\n          <AssertionExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Binary: {\n        return this.lookupBinaryExpression(\n          <BinaryExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Call: {\n        return this.lookupCallExpression(\n          <CallExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Comma: {\n        return this.lookupCommaExpression(\n          <CommaExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.ElementAccess: {\n        return this.lookupElementAccessExpression(\n          <ElementAccessExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Function: {\n        return this.lookupFunctionExpression(\n          <FunctionExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Identifier:\n      case NodeKind.False:\n      case NodeKind.Null:\n      case NodeKind.True: {\n        return this.lookupIdentifierExpression(\n          <IdentifierExpression>node,\n          ctxFlow, ctxFlow.sourceFunction, reportMode\n        );\n      }\n      case NodeKind.This: {\n        return this.lookupThisExpression(\n          <ThisExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Super: {\n        return this.lookupSuperExpression(\n          <SuperExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.InstanceOf: {\n        return this.lookupInstanceOfExpression(\n          <InstanceOfExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Literal: {\n        return this.lookupLiteralExpression(\n          <LiteralExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.New: {\n        return this.lookupNewExpression(\n          <NewExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.PropertyAccess: {\n        return this.lookupPropertyAccessExpression(\n          <PropertyAccessExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Ternary: {\n        return this.lookupTernaryExpression(\n          <TernaryExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.UnaryPostfix: {\n        return this.lookupUnaryPostfixExpression(\n          <UnaryPostfixExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.UnaryPrefix: {\n        return this.lookupUnaryPrefixExpression(\n          <UnaryPrefixExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** resolving expressions */\n  private resolvingExpressions: Set<Expression> = new Set();\n\n  /** Resolves an expression to its static type. */\n  resolveExpression(\n    /** The expression to resolve. */\n    node: Expression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    const resolvingExpressions = this.resolvingExpressions;\n    if (resolvingExpressions.has(node)) return null;\n    resolvingExpressions.add(node);\n    const resolved = this.doResolveExpression(node, ctxFlow, ctxType, reportMode);\n    resolvingExpressions.delete(node);\n    return resolved;\n  }\n\n  /** Resolves an expression to its static type. (may cause stack overflow) */\n  private doResolveExpression(\n    node: Expression,\n    ctxFlow: Flow,\n    ctxType: Type = Type.auto,\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    while (node.kind == NodeKind.Parenthesized) { // skip\n      node = (<ParenthesizedExpression>node).expression;\n    }\n    switch (node.kind) {\n      case NodeKind.Assertion: {\n        return this.resolveAssertionExpression(\n          <AssertionExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Binary: {\n        return this.resolveBinaryExpression(\n          <BinaryExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Call: {\n        return this.resolveCallExpression(\n          <CallExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Comma: {\n        return this.resolveCommaExpression(\n          <CommaExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.ElementAccess: {\n        return this.resolveElementAccessExpression(\n          <ElementAccessExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Function: {\n        return this.resolveFunctionExpression(\n          <FunctionExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Identifier:\n      case NodeKind.False:\n      case NodeKind.Null:\n      case NodeKind.True: {\n        return this.resolveIdentifierExpression(\n          <IdentifierExpression>node,\n          ctxFlow, ctxType, ctxFlow.sourceFunction, reportMode\n        );\n      }\n      case NodeKind.This: {\n        return this.resolveThisExpression(\n          <ThisExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Super: {\n        return this.resolveSuperExpression(\n          <SuperExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.InstanceOf: {\n        return this.resolveInstanceOfExpression(\n          <InstanceOfExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Literal: {\n        return this.resolveLiteralExpression(\n          <LiteralExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.New: {\n        return this.resolveNewExpression(\n          <NewExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.PropertyAccess: {\n        return this.resolvePropertyAccessExpression(\n          <PropertyAccessExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Ternary: {\n        return this.resolveTernaryExpression(\n          <TernaryExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.UnaryPostfix: {\n        return this.resolveUnaryPostfixExpression(\n          <UnaryPostfixExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.UnaryPrefix: {\n        return this.resolveUnaryPrefixExpression(\n          <UnaryPrefixExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Looks up the program element the specified identifier expression refers to. */\n  lookupIdentifierExpression(\n    /** The expression to look up. */\n    node: IdentifierExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Element to search. */\n    ctxElement: Element = ctxFlow.sourceFunction, // differs for enums and namespaces\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    switch (node.kind) {\n      case NodeKind.True:\n      case NodeKind.False:\n      case NodeKind.Null: {\n        let type = this.resolveIdentifierExpression(node, ctxFlow, Type.auto, ctxElement, reportMode);\n        return type ? this.getElementOfType(type) : null;\n      }\n    }\n    let name = node.text;\n    let element: Element | null;\n    if (element = ctxFlow.lookup(name)) {\n      this.currentThisExpression = null;\n      this.currentElementExpression = null;\n      return element;\n    }\n    let outerFlow = ctxFlow.outer;\n    if (outerFlow) {\n      if (element = outerFlow.lookup(name)) {\n        this.currentThisExpression = null;\n        this.currentElementExpression = null;\n        return element;\n      }\n    }\n    if (element = ctxElement.lookup(name)) {\n      this.currentThisExpression = null;\n      this.currentElementExpression = null;\n      return element;\n    }\n    if (element = this.program.lookup(name)) {\n      this.currentThisExpression = null;\n      this.currentElementExpression = null;\n      return element;\n    }\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode.Cannot_find_name_0,\n        node.range, name\n      );\n    }\n    return null;\n  }\n\n  /** Resolves an identifier to its static type. */\n  private resolveIdentifierExpression(\n    /** The expression to resolve. */\n    node: IdentifierExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** Element to search. */\n    ctxElement: Element = ctxFlow.sourceFunction, // differs for enums and namespaces\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    switch (node.kind) {\n      case NodeKind.True:\n      case NodeKind.False: return Type.bool;\n      case NodeKind.Null: {\n        let classReference = ctxType.getClass();\n        if (classReference) {\n          return classReference.type.asNullable();\n        } else {\n          let signatureReference = ctxType.getSignature();\n          if (signatureReference) {\n            return signatureReference.type.asNullable();\n          } else if (ctxType.isExternalReference) {\n            return ctxType; // TODO: nullable?\n          }\n        }\n        return this.program.options.usizeType;\n      }\n    }\n    let element = this.lookupIdentifierExpression(node, ctxFlow, ctxElement, reportMode);\n    if (!element) return null;\n    if (element.kind == ElementKind.FunctionPrototype) {\n      let instance = this.resolveFunction(<FunctionPrototype>element, null, new Map(), reportMode);\n      if (!instance) return null;\n      element = instance;\n    }\n    let type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Resolves a lazily compiled global, i.e. a static class field or annotated `@lazy`. */\n  private ensureResolvedLazyGlobal(global: Global, reportMode: ReportMode = ReportMode.Report): bool {\n    if (global.is(CommonFlags.Resolved)) return true;\n    let typeNode = global.typeNode;\n    let type = typeNode\n      ? this.resolveType(typeNode, null, global.parent, null, reportMode)\n      : this.resolveExpression(\n          assert(global.initializerNode),\n          global.file.startFunction.flow,\n          Type.auto,\n          reportMode\n        );\n    if (!type) return false;\n    global.setType(type); // also sets resolved\n    return true;\n  }\n\n  /** Looks up the program element the specified property access expression refers to. */\n  private lookupPropertyAccessExpression(\n    /** The expression to look up. */\n    node: PropertyAccessExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let targetNode = node.expression;\n    let target = this.lookupExpression(targetNode, ctxFlow, ctxType, reportMode); // reports\n    if (!target) return null;\n    let propertyName = node.property.text;\n\n    // Resolve variable-likes to their class type first\n    switch (target.kind) {\n      case ElementKind.Global: if (!this.ensureResolvedLazyGlobal(<Global>target, reportMode)) return null;\n      case ElementKind.EnumValue:\n      case ElementKind.Local: { // someVar.prop\n        let variableLikeElement = <VariableLikeElement>target;\n        let type = variableLikeElement.type;\n        if (type == Type.void) return null; // errored earlier\n        let classReference = type.getClassOrWrapper(this.program);\n        if (!classReference) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Property_0_does_not_exist_on_type_1,\n              node.property.range, propertyName, variableLikeElement.type.toString()\n            );\n          }\n          return null;\n        }\n        target = classReference;\n        break;\n      }\n      case ElementKind.PropertyPrototype: { // SomeClass.prop\n        let propertyInstance = this.resolveProperty(<PropertyPrototype>target, reportMode);\n        if (!propertyInstance) return null;\n        target = propertyInstance;\n        // fall-through\n      }\n      case ElementKind.Property: { // someInstance.prop\n        let propertyInstance = <Property>target;\n        let getterInstance = propertyInstance.getterInstance;\n        if (!getterInstance) {\n          // In TS, getters without setters return `undefined`. Since AS doesn't have\n          // undefined, we instead diagnose it at compile time, but this isn't\n          // compatible with TS.\n          let setterInstance = assert(propertyInstance.setterInstance);\n          this.errorRelated(\n            DiagnosticCode.Property_0_only_has_a_setter_and_is_missing_a_getter,\n            targetNode.range, setterInstance.declaration.range, propertyInstance.name\n          );\n          return null;\n        }\n        let type = getterInstance.signature.returnType;\n        let classReference = type.getClassOrWrapper(this.program);\n        if (!classReference) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Property_0_does_not_exist_on_type_1,\n              node.property.range, propertyName, type.toString()\n            );\n          }\n          return null;\n        }\n        target = classReference;\n        break;\n      }\n      case ElementKind.IndexSignature: { // someInstance[x].prop\n        let indexSignature = <IndexSignature>target;\n        let parent = indexSignature.parent;\n        assert(parent.kind == ElementKind.Class);\n        let classInstance = <Class>parent;\n        let elementExpression = assert(this.currentElementExpression);\n        let indexedGet = classInstance.lookupOverload(OperatorKind.IndexedGet);\n        if (!indexedGet) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Index_signature_is_missing_in_type_0,\n              elementExpression.range, parent.internalName\n            );\n          }\n          return null;\n        }\n        let returnType = indexedGet.signature.returnType;\n        let classReference = returnType.getClassOrWrapper(this.program);\n        if (!classReference) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Property_0_does_not_exist_on_type_1,\n              node.property.range, propertyName, returnType.toString()\n            );\n          }\n          return null;\n        }\n        target = classReference;\n        break;\n      }\n      case ElementKind.FunctionPrototype: {\n        // Function with shadow type, i.e. function Symbol() + type Symbol = _Symbol\n        let shadowType = target.shadowType;\n        if (shadowType) {\n          if (!shadowType.is(CommonFlags.Resolved)) {\n            let resolvedType = this.resolveType(shadowType.typeNode, null, shadowType.parent, null, reportMode);\n            if (resolvedType) shadowType.setType(resolvedType);\n          }\n          let classReference = shadowType.type.classReference;\n          if (classReference) target = classReference.prototype;\n          break;\n        } else if (!target.is(CommonFlags.Generic)) {\n          // Inherit from 'Function' if not overridden, i.e. fn.call\n          let ownMember = target.getMember(propertyName);\n          if (!ownMember) {\n            let functionInstance = this.resolveFunction(<FunctionPrototype>target, null, new Map(), ReportMode.Swallow);\n            if (functionInstance) {\n              let wrapper = functionInstance.type.getClassOrWrapper(this.program);\n              if (wrapper) target = wrapper;\n            }\n          }\n        }\n        break;\n      }\n    }\n\n    // Look up the member within\n    switch (target.kind) {\n      case ElementKind.ClassPrototype:\n      case ElementKind.InterfacePrototype:\n      case ElementKind.Class:\n      case ElementKind.Interface: {\n        let classLikeTarget = target;\n        let findBase = false; \n        do {\n          let member = classLikeTarget.getMember(propertyName);\n          if (member) {\n            if (member.kind == ElementKind.PropertyPrototype) {\n              let propertyInstance = this.resolveProperty(<PropertyPrototype>member, reportMode);\n              if (!propertyInstance) return null;\n              member = propertyInstance;\n              if (propertyInstance.is(CommonFlags.Static)) {\n                this.currentThisExpression = null;\n              } else {\n                this.currentThisExpression = targetNode;\n              }\n            } else {\n              this.currentThisExpression = targetNode;\n            }\n            this.currentElementExpression = null;\n            return member; // instance FIELD, static GLOBAL, FUNCTION_PROTOTYPE, PROPERTY...\n          }\n          findBase = false;\n          switch (classLikeTarget.kind) {\n            case ElementKind.ClassPrototype:\n            case ElementKind.InterfacePrototype: {\n              // traverse inherited static members on the base prototype if target is a class prototype\n              let classPrototype = <ClassPrototype>classLikeTarget;\n              let basePrototype = classPrototype.basePrototype;\n              if (basePrototype) {\n                findBase = true;\n                classLikeTarget = basePrototype;\n              }\n              break;\n            }\n            case ElementKind.Class:\n            case ElementKind.Interface: {\n              // traverse inherited instance members on the base class if target is a class instance\n              let classInstance = <Class>classLikeTarget;\n              let baseInstance = classInstance.base;\n              if (baseInstance) {\n                findBase = true;\n                classLikeTarget = baseInstance;\n              }\n              break;\n            }\n          }\n        } while (findBase);\n        break;\n      }\n      default: { // enums or other namespace-like elements\n        let member = target.getMember(propertyName);\n        if (member) {\n          this.currentThisExpression = targetNode;\n          this.currentElementExpression = null;\n          return member; // static ENUMVALUE, static GLOBAL, static FUNCTION_PROTOTYPE...\n        }\n        break;\n      }\n    }\n\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode.Property_0_does_not_exist_on_type_1,\n        node.property.range, propertyName, target.internalName\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a property access expression to its static type. */\n  private resolvePropertyAccessExpression(\n    /** The expression to resolve. */\n    node: PropertyAccessExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let element = this.lookupPropertyAccessExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    let type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Looks up the program element the specified element access expression refers to. */\n  private lookupElementAccessExpression(\n    /** The expression to look up. */\n    node: ElementAccessExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let targetExpression = node.expression;\n    let targetType = this.resolveExpression(targetExpression, ctxFlow, ctxType, reportMode);\n    if (!targetType) return null;\n    let classReference = targetType.getClassOrWrapper(this.program);\n    if (classReference) {\n      do {\n        let indexSignature = classReference.indexSignature;\n        if (indexSignature) {\n          this.currentThisExpression = targetExpression;\n          this.currentElementExpression = node.elementExpression;\n          return indexSignature;\n        }\n        classReference = classReference.base;\n      } while(classReference);\n    }\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode.Index_signature_is_missing_in_type_0,\n        targetExpression.range, targetType.toString()\n      );\n    }\n    return null;\n  }\n\n  /** Resolves an element access expression to its static type. */\n  private resolveElementAccessExpression(\n    /** The expression to resolve. */\n    node: ElementAccessExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let element = this.lookupElementAccessExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    let type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Determines the final type of an integer literal given the specified contextual type. */\n  determineIntegerLiteralType(\n    /** Integer literal value. */\n    expr: IntegerLiteralExpression,\n    /** Has unary minus before literal. */\n    negate: bool,\n    /** Contextual type. */\n    ctxType: Type\n  ): Type {\n    let intValue = expr.value;\n    if (negate) {\n      // x + i64.min > 0   ->   underflow\n      if (i64_gt(i64_add(intValue, i64_minimum), i64_zero)) {\n        let range = expr.range;\n        this.error(\n          DiagnosticCode.Literal_0_does_not_fit_into_i64_or_u64_types,\n          range, range.source.text.substring(range.start - 1, range.end)\n        );\n      } else if (i64_eq(intValue, i64_zero)) {\n        // Special handling for -0\n        if (ctxType.isFloatValue) {\n          return ctxType.kind == TypeKind.F32\n            ? Type.f32\n            : Type.f64;\n        } else if (!ctxType.isIntegerValue) {\n          // If it's unknown just always assume this is f64\n          return Type.f64;\n        }\n      }\n      intValue = i64_neg(intValue);\n    }\n    if (ctxType.isValue) {\n      // compile to contextual type if matching\n      switch (ctxType.kind) {\n        case TypeKind.Bool: {\n          if (i64_is_bool(intValue)) return Type.bool;\n          break;\n        }\n        case TypeKind.I8: {\n          if (i64_is_i8(intValue)) return Type.i8;\n          break;\n        }\n        case TypeKind.U8: {\n          if (i64_is_u8(intValue)) return Type.u8;\n          break;\n        }\n        case TypeKind.I16: {\n          if (i64_is_i16(intValue)) return Type.i16;\n          break;\n        }\n        case TypeKind.U16: {\n          if (i64_is_u16(intValue)) return Type.u16;\n          break;\n        }\n        case TypeKind.I32: {\n          if (i64_is_i32(intValue)) return Type.i32;\n          break;\n        }\n        case TypeKind.U32: {\n          if (i64_is_u32(intValue)) return Type.u32;\n          break;\n        }\n        case TypeKind.Isize: {\n          if (!this.program.options.isWasm64) {\n            if (i64_is_i32(intValue)) return Type.isize32;\n            break;\n          }\n          return Type.isize64;\n        }\n        case TypeKind.Usize: {\n          if (!this.program.options.isWasm64) {\n            if (i64_is_u32(intValue)) return Type.usize32;\n            break;\n          }\n          return Type.usize64;\n        }\n        case TypeKind.I64: return Type.i64;\n        case TypeKind.U64: return Type.u64;\n        case TypeKind.F32: return Type.f32;\n        case TypeKind.F64: return Type.f64;\n      }\n    }\n    // otherwise compile to best fitting type\n    if (i64_is_i32(intValue)) return Type.i32;\n    if (i64_is_u32(intValue)) return Type.u32;\n    return Type.i64; // TODO: u64 if positive and larger than i64?\n  }\n\n  /** Looks up the program element the specified assertion expression refers to. */\n  private lookupAssertionExpression(\n    /** The expression to look up. */\n    node: AssertionExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    switch (node.assertionKind) {\n      case AssertionKind.As:\n      case AssertionKind.Prefix: {\n        let type = this.resolveType(\n          assert(node.toType), // must be set if not NONNULL\n          null,\n          ctxFlow.sourceFunction,\n          ctxFlow.contextualTypeArguments,\n          reportMode\n        );\n        if (!type) return null;\n        let element = this.getElementOfType(type);\n        if (element) return element;\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Type_0_is_illegal_in_this_context,\n            node.range, type.toString()\n          );\n        }\n        this.currentThisExpression = null;\n        this.currentElementExpression = null;\n        return null;\n      }\n      case AssertionKind.NonNull: {\n        return this.lookupExpression(node.expression, ctxFlow, ctxType, reportMode);\n      }\n      case AssertionKind.Const: {\n        // TODO: decide on the layout of ReadonlyArray first\n        // let element = this.lookupExpression(node.expression, ctxFlow, ctxType, reportMode);\n        // if (!element) return null;\n        // if (element.kind == ElementKind.Class && (<Class>element).extends(this.program.arrayPrototype)) {\n        //   let elementType = assert((<Class>element).getTypeArgumentsTo(this.program.arrayPrototype))[0];\n        //   return this.resolveClass(this.program.readonlyArrayPrototype, [ elementType ]);\n        // }\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          node.range,\n          \"Const assertion\"\n        );\n        return null;\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Resolves an assertion expression to its static type. */\n  private resolveAssertionExpression(\n    /** The expression to resolve. */\n    node: AssertionExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    switch (node.assertionKind) {\n      case AssertionKind.As:\n      case AssertionKind.Prefix: {\n        return this.resolveType(\n          assert(node.toType),\n          null,\n          ctxFlow.sourceFunction,\n          ctxFlow.contextualTypeArguments,\n          reportMode\n        );\n      }\n      case AssertionKind.NonNull: {\n        let type = this.resolveExpression(node.expression, ctxFlow, ctxType, reportMode);\n        return type ? type.nonNullableType : null;\n      }\n      case AssertionKind.Const: {\n        let element = this.lookupExpression(node, ctxFlow, ctxType, reportMode);\n        if (!element) return null;\n        let type = this.getTypeOfElement(element);\n        if (!type) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n              node.range\n            );\n          }\n        }\n        return type;\n      }\n      default: assert(false);\n    }\n    return null;\n  }\n\n  /** Looks up the program element the specified unary prefix expression refers to. */\n  private lookupUnaryPrefixExpression(\n    /** The expression to look up. */\n    node: UnaryPrefixExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let type = this.resolveUnaryPrefixExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    let element = this.getElementOfType(type);\n    if (!element) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n          node.range, operatorTokenToString(node.operator), type.toString()\n        );\n      }\n    }\n    return element;\n  }\n\n  /** Resolves an unary prefix expression to its static type. */\n  private resolveUnaryPrefixExpression(\n    /** The expression to resolve. */\n    node: UnaryPrefixExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let operand = node.operand;\n    let operator = node.operator;\n    switch (operator) {\n      case Token.Minus: {\n        // implicitly negate if an integer literal to distinguish between i32/u32/i64\n        if (operand.isLiteralKind(LiteralKind.Integer)) {\n          return this.determineIntegerLiteralType(\n            <IntegerLiteralExpression>operand,\n            true,\n            ctxType\n          );\n        }\n        // fall-through\n      }\n      case Token.Plus:\n      case Token.Plus_Plus:\n      case Token.Minus_Minus: {\n        let type = this.resolveExpression(operand, ctxFlow, ctxType, reportMode);\n        if (!type) return null;\n        let classReference = type.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromUnaryPrefixToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        if (!type.isNumericValue) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              node.range, operatorTokenToString(operator), type.toString()\n            );\n          }\n          return null;\n        }\n        return type;\n      }\n      case Token.Exclamation: {\n        let type = this.resolveExpression(operand, ctxFlow, ctxType, reportMode);\n        if (!type) return null;\n        let classReference = type.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Not);\n          if (overload) return overload.signature.returnType;\n        }\n        return Type.bool; // incl. references\n      }\n      case Token.Tilde: {\n        let type = this.resolveExpression(operand, ctxFlow, ctxType, reportMode);\n        if (!type) return null;\n        let classReference = type.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BitwiseNot);\n          if (overload) return overload.signature.returnType;\n        }\n        if (!type.isNumericValue) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              node.range, \"~\", type.toString()\n            );\n          }\n          return null;\n        }\n        return type.intType;\n      }\n      case Token.Dot_Dot_Dot: {\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Not_implemented_0,\n            node.range, \"Spread operator\"\n          );\n        }\n        return null;\n      }\n      case Token.TypeOf: {\n        return this.program.stringInstance.type;\n      }\n      default: assert(false);\n    }\n    return null;\n  }\n\n  /** Looks up the program element the specified unary postfix expression refers to. */\n  private lookupUnaryPostfixExpression(\n    /** The expression to resolve. */\n    node: UnaryPostfixExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let type = this.resolveUnaryPostfixExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    let element = this.getElementOfType(type);\n    if (!element) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n          node.range, operatorTokenToString(node.operator), type.toString()\n        );\n      }\n    }\n    return element;\n  }\n\n  /** Resolves an unary postfix expression to its static type. */\n  private resolveUnaryPostfixExpression(\n    /** The expression to resolve. */\n    node: UnaryPostfixExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let operator = node.operator;\n    switch (operator) {\n      case Token.Plus_Plus:\n      case Token.Minus_Minus: {\n        let type = this.resolveExpression(node.operand, ctxFlow, ctxType, reportMode);\n        if (!type) return null;\n        let classReference = type.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromUnaryPostfixToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        if (!type.isNumericValue) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              node.range, operatorTokenToString(operator), type.toString()\n            );\n          }\n          return null;\n        }\n        return type;\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Looks up the program element the specified binary expression refers to. */\n  private lookupBinaryExpression(\n    /** The expression to look up. */\n    node: BinaryExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let type = this.resolveBinaryExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    let element = this.getElementOfType(type);\n    if (element) return element; // otherwise void\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode.Type_0_is_illegal_in_this_context,\n        node.range, type.toString()\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a binary expression to its static type. */\n  private resolveBinaryExpression(\n    /** The expression to resolve. */\n    node: BinaryExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let left = node.left;\n    let right = node.right;\n    let operator = node.operator;\n\n    switch (operator) {\n\n      // assignment: result is the target's type\n\n      case Token.Equals:\n      case Token.Plus_Equals:\n      case Token.Minus_Equals:\n      case Token.Asterisk_Equals:\n      case Token.Asterisk_Asterisk_Equals:\n      case Token.Slash_Equals:\n      case Token.Percent_Equals:\n      case Token.LessThan_LessThan_Equals:\n      case Token.GreaterThan_GreaterThan_Equals:\n      case Token.GreaterThan_GreaterThan_GreaterThan_Equals:\n      case Token.Ampersand_Equals:\n      case Token.Bar_Equals:\n      case Token.Caret_Equals: {\n        return this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n      }\n\n      // comparison: result is Bool, preferring overloads, integer/float only\n\n      case Token.LessThan:\n      case Token.GreaterThan:\n      case Token.LessThan_Equals:\n      case Token.GreaterThan_Equals: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        if (!leftType.isNumericValue) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              node.range, operatorTokenToString(operator), leftType.toString()\n            );\n          }\n          return null;\n        }\n        return Type.bool;\n      }\n\n      // equality: result is Bool, preferring overloads, incl. references\n\n      case Token.Equals_Equals:\n      case Token.Exclamation_Equals: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        return Type.bool;\n      }\n\n      // identity: result is Bool, not supporting overloads\n\n      case Token.Equals_Equals_Equals:\n      case Token.Exclamation_Equals_Equals: {\n        return Type.bool;\n      }\n\n      // in operator\n\n      case Token.In: {\n        return Type.bool;\n      }\n\n      // arithmetics: result is common type of LHS and RHS, preferring overloads\n\n      case Token.Plus:\n      case Token.Minus:\n      case Token.Asterisk:\n      case Token.Slash:\n      case Token.Percent: // mod has special logic, but also behaves like this\n      case Token.Asterisk_Asterisk: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        let rightType = this.resolveExpression(right, ctxFlow, leftType, reportMode);\n        if (!rightType) return null;\n        let commonType = Type.commonType(leftType, rightType, ctxType);\n        if (!commonType) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              node.range, operatorTokenToString(operator), leftType.toString(), rightType.toString()\n            );\n          }\n        }\n        return commonType;\n      }\n\n      // shift: result is LHS (RHS is converted to LHS), preferring overloads\n\n      case Token.LessThan_LessThan:\n      case Token.GreaterThan_GreaterThan:\n      case Token.GreaterThan_GreaterThan_GreaterThan: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        if (!leftType.isIntegerValue) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              node.range, operatorTokenToString(operator), leftType.toString()\n            );\n          }\n          return null;\n        }\n        return leftType;\n      }\n\n      // bitwise: result is common type of LHS and RHS with floats not being supported, preferring overloads\n\n      case Token.Ampersand:\n      case Token.Bar:\n      case Token.Caret: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        let rightType = this.resolveExpression(right, ctxFlow, ctxType, reportMode);\n        if (!rightType) return null;\n        let commonType = Type.commonType(leftType, rightType, ctxType);\n        if (!commonType || !commonType.isIntegerValue) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              node.range, operatorTokenToString(operator), leftType.toString(), rightType.toString()\n            );\n          }\n        }\n        return commonType;\n      }\n\n      // logical\n\n      case Token.Ampersand_Ampersand: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let rightType = this.resolveExpression(right, ctxFlow, leftType, reportMode);\n        if (!rightType) return null;\n        let commonType = Type.commonType(leftType, rightType, ctxType);\n        if (!commonType) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              node.range, \"&&\", leftType.toString(), rightType.toString()\n            );\n          }\n        }\n        return commonType;\n      }\n      case Token.Bar_Bar: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let rightType = this.resolveExpression(right, ctxFlow, leftType, reportMode);\n        if (!rightType) return null;\n        let commonType = Type.commonType(leftType, rightType, ctxType);\n        if (!commonType) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              node.range, \"||\", leftType.toString(), rightType.toString()\n            );\n          }\n          return null;\n        }\n        // `LHS || RHS` can only be null if both LHS and RHS are null\n        return leftType.is(TypeFlags.Nullable) && rightType.is(TypeFlags.Nullable)\n          ? commonType\n          : commonType.nonNullableType;\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Looks up the program element the specified this expression refers to. */\n  private lookupThisExpression(\n    /** The expression to look up. */\n    node: ThisExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    if (ctxFlow.isInline) {\n      let thisLocal = ctxFlow.lookupLocal(CommonNames.this_);\n      if (thisLocal) {\n        this.currentThisExpression = null;\n        this.currentElementExpression = null;\n        return thisLocal;\n      }\n    }\n    let parent = ctxFlow.sourceFunction.parent;\n    if (parent) {\n      this.currentThisExpression = null;\n      this.currentElementExpression = null;\n      return parent;\n    }\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode._this_cannot_be_referenced_in_current_location,\n        node.range\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a this expression to its static type. */\n  private resolveThisExpression(\n    /** The expression to resolve. */\n    node: ThisExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let element = this.lookupThisExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    let type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Looks up the program element the specified super expression refers to. */\n  private lookupSuperExpression(\n    /** The expression to look up. */\n    node: SuperExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    if (ctxFlow.isInline) {\n      let superLocal = ctxFlow.lookupLocal(CommonNames.super_);\n      if (superLocal) {\n        this.currentThisExpression = null;\n        this.currentElementExpression = null;\n        return superLocal;\n      }\n    }\n    let parent: Element | null = ctxFlow.sourceFunction.parent;\n    if (parent && parent.kind == ElementKind.Class) {\n      let base = (<Class>parent).base;\n      if (base) {\n        this.currentThisExpression = null;\n        this.currentElementExpression = null;\n        return base;\n      }\n    }\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode._super_can_only_be_referenced_in_a_derived_class,\n        node.range\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a super expression to its static type. */\n  private resolveSuperExpression(\n    /** The expression to resolve. */\n    node: SuperExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let element = this.lookupSuperExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    let type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Looks up the program element the specified literal expression refers to. */\n  private lookupLiteralExpression(\n    /** The expression to look up. */\n    node: LiteralExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    this.currentThisExpression = node;\n    this.currentElementExpression = null;\n    switch (node.literalKind) {\n      case LiteralKind.Integer: {\n        let intType = this.determineIntegerLiteralType(\n          <IntegerLiteralExpression>node,\n          false,\n          ctxType\n        );\n        return assert(intType.getClassOrWrapper(this.program));\n      }\n      case LiteralKind.Float: {\n        let fltType = ctxType == Type.f32 ? Type.f32 : Type.f64;\n        return assert(fltType.getClassOrWrapper(this.program));\n      }\n      case LiteralKind.String:\n      case LiteralKind.Template: {\n        return this.program.stringInstance;\n      }\n      case LiteralKind.RegExp: {\n        return this.program.regexpInstance;\n      }\n      case LiteralKind.Array: {\n        let classReference = ctxType.getClass();\n        if (classReference && classReference.prototype == this.program.arrayPrototype) {\n          return this.getElementOfType(ctxType);\n        }\n        // otherwise infer, ignoring ctxType\n        let expressions = (<ArrayLiteralExpression>node).elementExpressions;\n        let length = expressions.length;\n        let elementType = Type.auto;\n        let numNullLiterals = 0;\n        for (let i = 0, k = length; i < k; ++i) {\n          let expression = expressions[i];\n          if (expression) {\n            if (expression.kind == NodeKind.Null && length > 1) {\n              ++numNullLiterals;\n            } else {\n              let currentType = this.resolveExpression(expression, ctxFlow, elementType);\n              if (!currentType) return null;\n              if (elementType == Type.auto) elementType = currentType;\n              else if (currentType != elementType) {\n                let commonType = Type.commonType(elementType, currentType, elementType);\n                if (commonType) elementType = commonType;\n                // otherwise triggers error on compilation\n              }\n            }\n          }\n        }\n        if (elementType /* still */ == Type.auto) {\n          if (numNullLiterals == length) { // all nulls infers as usize\n            elementType = this.program.options.usizeType;\n          } else {\n            if (reportMode == ReportMode.Report) {\n              this.error(\n                DiagnosticCode.The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly,\n                node.range, \"T\"\n              );\n            }\n            return null;\n          }\n        }\n        if (\n          numNullLiterals > 0 &&\n          elementType.isInternalReference\n        ) {\n          elementType = elementType.asNullable();\n        }\n        return assert(this.resolveClass(this.program.arrayPrototype, [ elementType ]));\n      }\n      case LiteralKind.Object: {\n        if (ctxType.isClass) return ctxType.classReference;\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n            node.range\n          );\n        }\n        return null;\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Resolves a literal expression to its static type. */\n  private resolveLiteralExpression(\n    /** The expression to resolve. */\n    node: LiteralExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let element = this.lookupLiteralExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    let type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Looks up the program element the specified call expression refers to. */\n  private lookupCallExpression(\n    /** The expression to look up. */\n    node: CallExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.void,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let type = this.resolveCallExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    let element = this.getElementOfType(type);\n    if (!element) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Type_0_is_illegal_in_this_context,\n          node.range, type.toString()\n        );\n      }\n    }\n    return element;\n  }\n\n  /** Resolves a call expression to its static type. */\n  private resolveCallExpression(\n    /** The expression to resolve. */\n    node: CallExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.void,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let targetExpression = node.expression;\n    let target = this.lookupExpression( // reports\n      targetExpression,\n      ctxFlow,\n      ctxType,\n      reportMode\n    );\n    if (!target) return null;\n    switch (target.kind) {\n      case ElementKind.FunctionPrototype: {\n        let functionPrototype = <FunctionPrototype>target;\n        // `unchecked` behaves like parenthesized\n        if (\n          functionPrototype.internalName == BuiltinNames.unchecked &&\n          node.args.length > 0\n        ) {\n          return this.resolveExpression(node.args[0], ctxFlow, ctxType, reportMode);\n        }\n        let functionInstance = this.maybeInferCall(node, functionPrototype, ctxFlow, reportMode);\n        if (!functionInstance) return null;\n        target = functionInstance;\n        // fall-through\n      }\n      case ElementKind.Function: {\n        return (<Function>target).signature.returnType;\n      }\n      case ElementKind.PropertyPrototype: {\n        let propertyInstance = this.resolveProperty(<PropertyPrototype>target, reportMode);\n        if (!propertyInstance) return null;\n        target = propertyInstance;\n        // fall-through\n      }\n      default: {\n        if (!isTypedElement(target.kind)) break;\n        let targetElement = this.getElementOfType((<TypedElement>target).type);\n        if (!targetElement || targetElement.kind != ElementKind.Class) break;\n        target = targetElement;\n        // fall-through\n      }\n      case ElementKind.Class: {\n        let typeArguments = (<Class>target).getTypeArgumentsTo(this.program.functionPrototype);\n        if (!(typeArguments && typeArguments.length)) break;\n        let signature = assert(typeArguments[0].getSignature());\n        return signature.returnType;\n      }\n    }\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\n        targetExpression.range, target.internalName\n      );\n    }\n    return null;\n  }\n\n  /** Looks up the program element the specified comma expression refers to. */\n  private lookupCommaExpression(\n    /** The expression to look up. */\n    node: CommaExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let expressions = node.expressions;\n    return this.lookupExpression(expressions[assert(expressions.length) - 1], ctxFlow, ctxType, reportMode);\n  }\n\n  /** Resolves a comma expression to its static type. */\n  private resolveCommaExpression(\n    /** The expression to resolve. */\n    node: CommaExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let expressions = node.expressions;\n    return this.resolveExpression(expressions[assert(expressions.length) - 1], ctxFlow, ctxType, reportMode);\n  }\n\n  /** Looks up the program element the specified instanceof expression refers to. */\n  private lookupInstanceOfExpression(\n    /** The expression to look up. */\n    node: InstanceOfExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    return assert(Type.bool.getClassOrWrapper(this.program));\n  }\n\n  /** Resolves an instanceof expression to its static type. */\n  private resolveInstanceOfExpression(\n    /** The expression to resolve. */\n    node: InstanceOfExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    return Type.bool;\n  }\n\n  /** Looks up the program element the specified ternary expression refers to. */\n  private lookupTernaryExpression(\n    /** The expression to look up. */\n    node: TernaryExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let type = this.resolveTernaryExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    let element = this.getElementOfType(type);\n    if (!element) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Type_0_is_illegal_in_this_context,\n          node.range, type.toString()\n        );\n      }\n    }\n    return element;\n  }\n\n  /** Resolves a ternary expression to its static type. */\n  private resolveTernaryExpression(\n    /** The expression to resolve. */\n    node: TernaryExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let thenType = this.resolveExpression(node.ifThen, ctxFlow, ctxType, reportMode);\n    if (!thenType) return null;\n    let elseType = this.resolveExpression(node.ifElse, ctxFlow, thenType, reportMode);\n    if (!elseType) return null;\n    let commonType = Type.commonType(thenType, elseType, ctxType);\n    if (!commonType) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n          node.range, \"?:\", thenType.toString(), elseType.toString()\n        );\n      }\n    }\n    return commonType;\n  }\n\n  /** Looks up the program element the specified new expression refers to. */\n  private lookupNewExpression(\n    /** The expression to look up. */\n    node: NewExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let element = this.resolveTypeName(node.typeName, ctxFlow, ctxFlow.sourceFunction, reportMode);\n    if (!element) return null;\n    if (element.kind == ElementKind.ClassPrototype) {\n      return this.resolveClassInclTypeArguments(\n        <ClassPrototype>element,\n        node.typeArguments,\n        ctxFlow,\n        ctxFlow.sourceFunction,\n        cloneMap(ctxFlow.contextualTypeArguments),\n        node,\n        reportMode\n      );\n    }\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode.This_expression_is_not_constructable,\n        node.range\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a new expression to its static type. */\n  private resolveNewExpression(\n    /** The expression to resolve. */\n    node: NewExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let element = this.lookupNewExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    let type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Looks up the program element the specified function expression refers to. */\n  private lookupFunctionExpression(\n    /** The expression to look up. */\n    node: FunctionExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let type = this.resolveFunctionExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    let element = this.getElementOfType(type);\n    if (!element) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Type_0_is_illegal_in_this_context,\n          node.range, type.toString()\n        );\n      }\n    }\n    return element;\n  }\n\n  /** Resolves a function expression to its static type. */\n  private resolveFunctionExpression(\n    /** The expression to resolve. */\n    node: FunctionExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    const declaration = node.declaration;\n    const signature = declaration.signature;\n    const body = declaration.body;\n    let functionType = this.resolveType(signature, null, ctxFlow.sourceFunction, ctxFlow.contextualTypeArguments, reportMode);\n    if (\n      functionType &&\n      declaration.arrowKind != ArrowKind.None &&\n      body && body.kind == NodeKind.Expression &&\n      isTypeOmitted(signature.returnType)\n    ) {\n      // (x) => ret, infer return type accordingt to `ret`\n      const expr = (<ExpressionStatement>body).expression;\n      let signatureReference = assert(functionType.getSignature());\n      // create a temp flow to resolve expression\n      let tempFlow = Flow.createDefault(ctxFlow.sourceFunction);\n      let parameters = signature.parameters;\n      // return type of resolveFunctionType should have same parameter length with signature\n      assert(signatureReference.parameterTypes.length == parameters.length);\n      for (let i = 0, k = parameters.length; i < k; i++) {\n        const parameter = parameters[i];\n        const type = signatureReference.parameterTypes[i];\n        tempFlow.addScopedDummyLocal(parameter.name.text, type, parameter);\n      }\n      const type = this.resolveExpression(expr, tempFlow, ctxType, reportMode);\n      if (type) {\n        functionType.signatureReference = Signature.create(\n          this.program,\n          signatureReference.parameterTypes,\n          type,\n          signatureReference.thisType,\n          signatureReference.requiredParameters,\n          signatureReference.hasRest,\n        );\n      }\n    }\n    return functionType;\n  }\n\n  // ==================================================== Elements =====================================================\n\n  /** Resolves a function prototype using the specified concrete type arguments. */\n  resolveFunction(\n    /** The prototype of the function. */\n    prototype: FunctionPrototype,\n    /** Type arguments provided. */\n    typeArguments: Type[] | null,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> = new Map(),\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Function | null {\n    let classInstance: Class | null = null; // if an instance method\n    let instanceKey = typeArguments ? typesToString(typeArguments) : \"\";\n\n    // Instance method prototypes are pre-bound to their concrete class as their parent\n    if (prototype.is(CommonFlags.Instance)) {\n      classInstance = assert(prototype.getBoundClassOrInterface());\n\n      // check if this exact concrete class and function combination is known already\n      let resolvedInstance = prototype.getResolvedInstance(instanceKey);\n      if (resolvedInstance) return resolvedInstance;\n\n      // inherit class specific type arguments\n      let classTypeArguments = classInstance.typeArguments;\n      if (classTypeArguments) {\n        let classTypeParameters = assert(classInstance.prototype.typeParameterNodes);\n        let numClassTypeArguments = classTypeParameters.length;\n        assert(numClassTypeArguments == classTypeParameters.length);\n        for (let i = 0; i < numClassTypeArguments; ++i) {\n          let classTypeParameterName = classTypeParameters[i].name.text;\n          // override contextual\n          ctxTypes.set(classTypeParameterName, classTypeArguments[i]);\n        }\n      }\n    } else {\n      assert(!prototype.isBound);\n      let resolvedInstance = prototype.getResolvedInstance(instanceKey);\n      if (resolvedInstance) return resolvedInstance;\n    }\n\n    // override whatever is contextual with actual function type arguments\n    let signatureNode = prototype.functionTypeNode;\n    let typeParameterNodes = prototype.typeParameterNodes;\n    let numFunctionTypeArguments: i32;\n    if (typeArguments && (numFunctionTypeArguments = typeArguments.length) > 0) {\n      assert(typeParameterNodes && numFunctionTypeArguments == typeParameterNodes.length);\n      for (let i = 0; i < numFunctionTypeArguments; ++i) {\n        ctxTypes.set(\n          (<TypeParameterNode[]>typeParameterNodes)[i].name.text,\n          typeArguments[i]\n        );\n      }\n    } else {\n      assert(!typeParameterNodes || typeParameterNodes.length == 0);\n    }\n\n    // resolve `this` type if applicable\n    let thisType: Type | null = null;\n    let explicitThisType = signatureNode.explicitThisType;\n    if (explicitThisType) {\n      thisType = this.resolveType(\n        explicitThisType,\n        null,\n        prototype.parent, // relative to function\n        ctxTypes,\n        reportMode\n      );\n      if (!thisType) return null;\n      ctxTypes.set(CommonNames.this_, thisType);\n    } else if (classInstance) {\n      thisType = classInstance.type;\n      ctxTypes.set(CommonNames.this_, thisType);\n    }\n\n    // resolve parameter types\n    let signatureParameters = signatureNode.parameters;\n    let numSignatureParameters = signatureParameters.length;\n    let parameterTypes = new Array<Type>(numSignatureParameters);\n    let requiredParameters = 0;\n    let hasRest = false;\n    for (let i = 0; i < numSignatureParameters; ++i) {\n      let parameterDeclaration = signatureParameters[i];\n      if (parameterDeclaration.parameterKind == ParameterKind.Default) {\n        requiredParameters = i + 1;\n      } else if (parameterDeclaration.parameterKind == ParameterKind.Rest) {\n        hasRest = true;\n      }\n      let typeNode = parameterDeclaration.type;\n      if (isTypeOmitted(typeNode)) {\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            typeNode.range\n          );\n        }\n        return null;\n      }\n      let parameterType = this.resolveType(\n        typeNode,\n        null,\n        prototype.parent, // relative to function\n        ctxTypes,\n        reportMode\n      );\n      if (!parameterType) return null;\n      if (parameterType == Type.void) {\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            typeNode.range\n          );\n        }\n        return null;\n      }\n      parameterTypes[i] = parameterType;\n    }\n\n    // resolve return type\n    let returnType: Type;\n    if (prototype.is(CommonFlags.Set)) {\n      returnType = Type.void; // not annotated\n    } else if (prototype.is(CommonFlags.Constructor)) {\n      returnType = classInstance!.type; // not annotated\n    } else {\n      let typeNode = signatureNode.returnType;\n      if (isTypeOmitted(typeNode)) {\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            typeNode.range\n          );\n        }\n        return null;\n      }\n      let type = this.resolveType(\n        typeNode,\n        null,\n        prototype.parent, // relative to function\n        ctxTypes,\n        reportMode\n      );\n      if (!type) return null;\n      returnType = type;\n    }\n\n    let signature = Signature.create(this.program, parameterTypes, returnType, thisType, requiredParameters, hasRest);\n\n    let nameInclTypeParameters = prototype.name;\n    if (instanceKey.length) nameInclTypeParameters += `<${instanceKey}>`;\n    let instance = new Function(\n      nameInclTypeParameters,\n      prototype,\n      typeArguments,\n      signature,\n      ctxTypes\n    );\n    prototype.setResolvedInstance(instanceKey, instance);\n\n    // check against overridden base member\n    if (classInstance) {\n      let methodOrPropertyName = instance.declaration.name.text;\n      let baseClass = classInstance.base;\n      if (baseClass) {\n        let baseMember = baseClass.getMember(methodOrPropertyName);\n        if (baseMember) {\n          // note override discovery (used by stub finalization)\n          this.discoveredOverride = true;\n          // verify that this is a compatible override\n          let incompatibleOverride = true;\n          if (instance.isAny(CommonFlags.Get | CommonFlags.Set)) {\n            if (baseMember.kind == ElementKind.PropertyPrototype) {\n              let baseProperty = this.resolveProperty(<PropertyPrototype>baseMember, reportMode);\n              if (baseProperty) {\n                if (instance.is(CommonFlags.Get)) {\n                  let baseGetter = baseProperty.getterInstance;\n                  if (baseGetter && instance.signature.isAssignableTo(baseGetter.signature, true)) {\n                    incompatibleOverride = false;\n                  }\n                } else {\n                  assert(instance.is(CommonFlags.Set));\n                  let baseSetter = baseProperty.setterInstance;\n                  if (baseSetter && instance.signature.isAssignableTo(baseSetter.signature, true)) {\n                    incompatibleOverride = false;\n                  }\n                }\n              }\n            }\n          } else if (instance.is(CommonFlags.Constructor)) {\n            incompatibleOverride = false;\n          } else {\n            if (baseMember.kind == ElementKind.FunctionPrototype) {\n              // Possibly generic. Resolve with same type arguments to obtain the correct one.\n              let basePrototype = <FunctionPrototype>baseMember;\n              let baseFunction = this.resolveFunction(basePrototype, typeArguments, new Map(), ReportMode.Swallow);\n              if (baseFunction && instance.signature.isAssignableTo(baseFunction.signature, true)) {\n                incompatibleOverride = false;\n              }\n            }\n          }\n          if (incompatibleOverride) {\n            this.errorRelated(\n              DiagnosticCode.This_overload_signature_is_not_compatible_with_its_implementation_signature,\n              instance.identifierAndSignatureRange, baseMember.identifierAndSignatureRange\n            );\n          }\n        }\n      }\n    }\n    return instance;\n  }\n\n  /** Resolves a function prototypeby first resolving the specified type arguments. */\n  resolveFunctionInclTypeArguments(\n    /** The prototype of the function. */\n    prototype: FunctionPrototype,\n    /** Type arguments provided to be resolved. */\n    typeArgumentNodes: TypeNode[] | null,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type>,\n    /** The node to use when reporting intermediate errors. */\n    reportNode: Node,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Function | null {\n    let resolvedTypeArguments: Type[] | null = null;\n\n    // Resolve type arguments if generic\n    if (prototype.is(CommonFlags.Generic)) {\n\n      // If this is an instance method, first apply the class's type arguments\n      if (prototype.is(CommonFlags.Instance)) {\n        let classInstance = assert(prototype.getBoundClassOrInterface());\n        let classTypeArguments = classInstance.typeArguments;\n        if (classTypeArguments) {\n          let typeParameterNodes = assert(classInstance.prototype.typeParameterNodes);\n          let numClassTypeArguments = classTypeArguments.length;\n          assert(numClassTypeArguments == typeParameterNodes.length);\n          for (let i = 0; i < numClassTypeArguments; ++i) {\n            ctxTypes.set(\n              typeParameterNodes[i].name.text,\n              classTypeArguments[i]\n            );\n          }\n        }\n      }\n\n      resolvedTypeArguments = this.resolveTypeArguments( // reports\n        assert(prototype.typeParameterNodes),\n        typeArgumentNodes,\n        null,\n        ctxElement,\n        ctxTypes, // update\n        reportNode,\n        reportMode\n      );\n      if (!resolvedTypeArguments) return null;\n\n    // Otherwise make sure that no type arguments have been specified\n    } else {\n      if (typeArgumentNodes && typeArgumentNodes.length > 0) {\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_generic,\n            reportNode.range, prototype.internalName\n          );\n        }\n        return null;\n      }\n    }\n\n    // Continue with concrete types\n    return this.resolveFunction(\n      prototype,\n      resolvedTypeArguments,\n      ctxTypes,\n      reportMode\n    );\n  }\n\n  /** Resolves reachable overrides of the given instance method. */\n  resolveOverrides(instance: Function): Function[] | null {\n    let overridePrototypes = instance.prototype.unboundOverrides;\n    if (!overridePrototypes) return null;\n\n    let parentClassInstance = assert(instance.getBoundClassOrInterface());\n    let overrides = new Set<Function>();\n\n    // A method's `overrides` property contains its unbound override prototypes\n    // so we first have to find the concrete classes it became bound to, obtain\n    // their bound prototypes and make sure these are resolved.\n    for (let _values = Set_values(overridePrototypes), i = 0, k = _values.length; i < k; ++i) {\n      let unboundOverridePrototype = _values[i];\n      assert(!unboundOverridePrototype.isBound);\n      let unboundOverrideParent = unboundOverridePrototype.parent;\n      let classInstances: Map<string,Class> | null;\n      assert(unboundOverrideParent.kind == ElementKind.ClassPrototype || unboundOverrideParent.kind == ElementKind.InterfacePrototype);\n      classInstances = (<ClassPrototype>unboundOverrideParent).instances;\n      if (!classInstances) continue;\n      for (let _values = Map_values(classInstances), j = 0, l = _values.length; j < l; ++j) {\n        let classInstance = _values[j];\n        // Check if the parent class is a subtype of instance's class\n        if (!classInstance.isAssignableTo(parentClassInstance)) continue;\n        let overrideInstance: Function | null = null;\n        if (instance.isAny(CommonFlags.Get | CommonFlags.Set)) {\n          let propertyName = instance.declaration.name.text;\n          let boundPropertyPrototype = assert(classInstance.getMember(propertyName));\n          assert(boundPropertyPrototype.kind == ElementKind.PropertyPrototype);\n          let boundPropertyInstance = this.resolveProperty(<PropertyPrototype>boundPropertyPrototype);\n          if (!boundPropertyInstance) continue;\n          if (instance.is(CommonFlags.Get)) {\n            overrideInstance = boundPropertyInstance.getterInstance;\n          } else {\n            assert(instance.is(CommonFlags.Set));\n            overrideInstance = boundPropertyInstance.setterInstance;\n          }\n        } else {\n          let boundPrototype = classInstance.getMember(unboundOverridePrototype.name);\n          if (boundPrototype) { // might have errored earlier and wasn't added\n            assert(boundPrototype.kind == ElementKind.FunctionPrototype);\n            overrideInstance = this.resolveFunction(<FunctionPrototype>boundPrototype, instance.typeArguments);\n          }\n        }\n        if (overrideInstance) overrides.add(overrideInstance);\n      }\n    }\n    return Set_values(overrides);\n  }\n\n  /** Currently resolving classes. */\n  private resolveClassPending: Set<Class> = new Set();\n\n  /** Resolves a class prototype using the specified concrete type arguments. */\n  resolveClass(\n    /** The prototype of the class. */\n    prototype: ClassPrototype,\n    /** Type arguments provided. */\n    typeArguments: Type[] | null,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> = new Map(),\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Class | null {\n    let instanceKey = typeArguments ? typesToString(typeArguments) : \"\";\n\n    // Do not attempt to resolve the same class twice. This can return a class\n    // that isn't fully resolved yet, but only on deeper levels of recursion.\n    let instance = prototype.getResolvedInstance(instanceKey);\n    if (instance) return instance;\n\n    // Otherwise create\n    let nameInclTypeParameters = prototype.name;\n    if (instanceKey.length) nameInclTypeParameters += `<${instanceKey}>`;\n    if (prototype.kind == ElementKind.InterfacePrototype) {\n      instance = new Interface(nameInclTypeParameters, <InterfacePrototype>prototype, typeArguments);\n    } else {\n      instance = new Class(nameInclTypeParameters, prototype, typeArguments);\n    }\n    prototype.setResolvedInstance(instanceKey, instance);\n    let pendingClasses = this.resolveClassPending;\n    pendingClasses.add(instance);\n\n    // Insert contextual type arguments for this operation. Internally, this method is always\n    // called with matching type parameter / argument counts.\n    if (typeArguments) {\n      let typeParameterNodes = assert(prototype.typeParameterNodes);\n      let numTypeParameters = typeParameterNodes.length;\n      let numTypeArguments = typeArguments.length;\n      assert(numTypeArguments == numTypeParameters);\n      for (let i = 0; i < numTypeArguments; ++i) {\n        ctxTypes.set(typeParameterNodes[i].name.text, typeArguments[i]);\n      }\n    } else {\n      let typeParameterNodes = prototype.typeParameterNodes;\n      assert(!(typeParameterNodes && typeParameterNodes.length > 0));\n    }\n    instance.contextualTypeArguments = ctxTypes;\n\n    let anyPending = false;\n\n    // Resolve base class if applicable\n    let basePrototype = prototype.basePrototype;\n    if (basePrototype) {\n      let current: ClassPrototype | null = basePrototype;\n      do {\n        if (current == prototype) {\n          this.error(\n            DiagnosticCode._0_is_referenced_directly_or_indirectly_in_its_own_base_expression,\n            prototype.identifierNode.range,\n            prototype.internalName\n          );\n          return null;\n        }\n        current = current.basePrototype;\n      } while (current);\n      let extendsNode = assert(prototype.extendsNode); // must be present if it has a base prototype\n      let base = this.resolveClassInclTypeArguments(\n        basePrototype,\n        extendsNode.typeArguments,\n        null,\n        prototype.parent, // relative to derived class\n        cloneMap(ctxTypes), // don't inherit\n        extendsNode,\n        reportMode\n      );\n      if (!base) return null;\n      instance.setBase(base);\n\n      // If the base class is still pending, yield here and instead resolve any\n      // derived classes once the base class's `finishResolveClass` is done.\n      // This is guaranteed to never happen at the entry of the recursion, i.e.\n      // where `resolveClass` is called from other code.\n      if (pendingClasses.has(base)) anyPending = true;\n\n    // Implicitly extend `Object` if a derived object\n    } else if (prototype.implicitlyExtendsObject) {\n      instance.setBase(this.program.objectInstance);\n    }\n\n    // Resolve interfaces if applicable\n    let interfacePrototypes = prototype.interfacePrototypes;\n    if (interfacePrototypes) {\n      for (let i = 0, k = interfacePrototypes.length; i < k; ++i) {\n        let interfacePrototype = interfacePrototypes[i];\n        let current: ClassPrototype | null = interfacePrototype;\n        do {\n          if (current == prototype) {\n            this.error(\n              DiagnosticCode._0_is_referenced_directly_or_indirectly_in_its_own_base_expression,\n              prototype.identifierNode.range,\n              prototype.internalName\n            );\n            return null;\n          }\n          current = current.basePrototype;\n        } while (current);\n        let implementsNode = assert(prototype.implementsNodes![i]);\n        let iface = this.resolveClassInclTypeArguments(\n          interfacePrototype,\n          implementsNode.typeArguments,\n          null,\n          prototype.parent,\n          cloneMap(ctxTypes),\n          implementsNode,\n          reportMode\n        );\n        if (!iface) return null;\n        assert(iface.kind == ElementKind.Interface);\n        instance.addInterface(<Interface>iface);\n\n        // Like above, if any implemented interface is still pending, yield\n        if (pendingClasses.has(iface)) anyPending = true;\n      }\n    }\n    if (anyPending) return instance;\n\n    // We only get here if the base class has been fully resolved already.\n    this.finishResolveClass(instance, reportMode);\n    return instance;\n  }\n\n  /** Checks whether an override's visibility is valid. */\n  private checkOverrideVisibility(\n    /** Name to report. */\n    name: string,\n    /** Overriding member. */\n    thisMember: DeclaredElement,\n    /** Overriding class. */\n    thisClass: Class,\n    /** Overridden member. */\n    baseMember: DeclaredElement,\n    /** Overridden class. */\n    baseClass: Class,\n    /** Report mode. */\n    reportMode: ReportMode\n  ): bool {\n    let hasErrors = false;\n    if (thisMember.is(CommonFlags.Constructor)) {\n      assert(baseMember.is(CommonFlags.Constructor));\n      if (baseMember.is(CommonFlags.Private)) {\n        if (reportMode == ReportMode.Report) {\n          this.errorRelated(\n            DiagnosticCode.Cannot_extend_a_class_0_Class_constructor_is_marked_as_private,\n            thisMember.identifierNode.range, baseMember.identifierNode.range,\n            baseClass.internalName\n          );\n        }\n        hasErrors = true;\n      }\n    } else if (thisMember.is(CommonFlags.Private)) {\n      if (baseMember.is(CommonFlags.Private)) {\n        if (reportMode == ReportMode.Report) {\n          this.errorRelated(\n            DiagnosticCode.Types_have_separate_declarations_of_a_private_property_0,\n            thisMember.identifierNode.range, baseMember.identifierNode.range,\n            name\n          );\n        }\n        hasErrors = true;\n      } else {\n        if (reportMode == ReportMode.Report) {\n          this.errorRelated(\n            DiagnosticCode.Property_0_is_private_in_type_1_but_not_in_type_2,\n            thisMember.identifierNode.range, baseMember.identifierNode.range,\n            name, thisClass.internalName, baseClass.internalName\n          );\n        }\n        hasErrors = true;\n      }\n    } else if (thisMember.is(CommonFlags.Protected)) {\n      if (baseMember.is(CommonFlags.Private)) {\n        if (reportMode == ReportMode.Report) {\n          this.errorRelated(\n            DiagnosticCode.Property_0_is_private_in_type_1_but_not_in_type_2,\n            thisMember.identifierNode.range, baseMember.identifierNode.range,\n            name, baseClass.internalName, thisClass.internalName\n          );\n        }\n        hasErrors = true;\n      } else if (baseMember.isPublic) {\n        if (reportMode == ReportMode.Report) {\n          this.errorRelated(\n            DiagnosticCode.Property_0_is_protected_in_type_1_but_public_in_type_2,\n            thisMember.identifierNode.range, baseMember.identifierNode.range,\n            name, thisClass.internalName, baseClass.internalName\n          );\n        }\n        hasErrors = true;\n      } else {\n        assert(baseMember.is(CommonFlags.Protected));\n      }\n    } else if (thisMember.isPublic) {\n      if (baseMember.is(CommonFlags.Private)) {\n        if (reportMode == ReportMode.Report) {\n          this.errorRelated(\n            DiagnosticCode.Property_0_is_private_in_type_1_but_not_in_type_2,\n            thisMember.identifierNode.range, baseMember.identifierNode.range,\n            name, baseClass.internalName, thisClass.internalName\n          );\n        }\n        hasErrors = true;\n      } else if (baseMember.is(CommonFlags.Protected)) {\n        if (reportMode == ReportMode.Report) {\n          this.errorRelated(\n            DiagnosticCode.Property_0_is_protected_in_type_1_but_public_in_type_2,\n            thisMember.identifierNode.range, baseMember.identifierNode.range,\n            name, baseClass.internalName, thisClass.internalName\n          );\n        }\n        hasErrors = true;\n      } else {\n        assert(baseMember.isPublic);\n      }\n    }\n    return !hasErrors;\n  }\n\n  /** Finishes resolving the specified class. */\n  private finishResolveClass(\n    /** Class to finish resolving. */\n    instance: Class,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode\n  ): void {\n    let members = instance.members;\n    if (!members) instance.members = members = new Map();\n\n    let pendingClasses = this.resolveClassPending;\n    let unimplemented = new Map<string,DeclaredElement>();\n    // Alias implemented interface members\n    let interfaces = instance.interfaces;\n    if (interfaces) {\n      for (let _values = Set_values(interfaces), i = 0, k = _values.length; i < k; ++i) {\n        let iface = _values[i];\n        assert(!pendingClasses.has(iface));\n        let ifaceMembers = iface.members;\n        if (ifaceMembers) {\n          for (let _keys = Map_keys(ifaceMembers), i = 0, k = _keys.length; i < k; ++i) {\n            let memberName = unchecked(_keys[i]);\n            let ifaceMember = assert(ifaceMembers.get(memberName));\n            let existingMember = instance.getMember(memberName);\n            if (existingMember && !this.checkOverrideVisibility(memberName, existingMember, instance, ifaceMember, iface, reportMode)) {\n              continue; // keep previous\n            }\n            members.set(memberName, ifaceMember);\n            unimplemented.set(memberName, ifaceMember);\n          }\n        }\n      }\n    }\n\n    // Alias base members\n    let memoryOffset: u32 = 0;\n    let base = instance.base;\n    if (base) {\n      let implicitlyExtendsObject = instance.prototype.implicitlyExtendsObject;\n      assert(!pendingClasses.has(base));\n      let baseMembers = base.members;\n      if (baseMembers) {\n        // TODO: for (let [baseMemberName, baseMember] of baseMembers) {\n        for (let _keys = Map_keys(baseMembers), i = 0, k = _keys.length; i < k; ++i) {\n          let memberName = unchecked(_keys[i]);\n          let baseMember = assert(baseMembers.get(memberName));\n          if (implicitlyExtendsObject && baseMember.is(CommonFlags.Static)) continue;\n          let existingMember = instance.getMember(memberName);\n          if (existingMember && !this.checkOverrideVisibility(memberName, existingMember, instance, baseMember, base, reportMode)) {\n            continue; // keep previous\n          }\n          members.set(memberName, baseMember);\n          if (baseMember.is(CommonFlags.Abstract)) {\n            unimplemented.set(memberName, baseMember);\n          } else {\n            unimplemented.delete(memberName);\n          }\n        }\n      }\n      memoryOffset = base.nextMemoryOffset;\n    }\n\n    // Resolve instance members\n    let prototype = instance.prototype;\n    let instanceMemberPrototypes = prototype.instanceMembers;\n    if (instanceMemberPrototypes) {\n      // TODO: for (let member of instanceMemberPrototypes.values()) {\n      for (let _values = Map_values(instanceMemberPrototypes), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        let memberName = member.name;\n        if (base) {\n          let baseMember = base.getMember(memberName);\n          if (baseMember) this.checkOverrideVisibility(memberName, member, instance, baseMember, base, reportMode);\n        }\n        switch (member.kind) {\n          case ElementKind.FunctionPrototype: {\n            let boundPrototype = (<FunctionPrototype>member).toBound(instance);\n            instance.add(boundPrototype.name, boundPrototype); // reports\n            break;\n          }\n          case ElementKind.PropertyPrototype: {\n            let boundPrototype = (<PropertyPrototype>member).toBound(instance);\n            if (boundPrototype.isField) { // resolve and lay out\n              let boundInstance = this.resolveProperty(boundPrototype, reportMode);\n              if (boundInstance) {\n                let fieldType = boundInstance.type;\n                if (fieldType == Type.void) break; // failed to resolve earlier\n                if (fieldType.isExternalReference) {\n                  this.error(\n                    DiagnosticCode.Not_implemented_0,\n                    assert(boundPrototype.typeNode).range,\n                    \"Reference typed fields\"\n                  );\n                  break;\n                }\n                let needsLayout = true;\n                if (base) {\n                  let existingMember = base.getMember(boundPrototype.name);\n                  if (existingMember && existingMember.kind == ElementKind.PropertyPrototype) {\n                    let existingPrototype = <PropertyPrototype>existingMember;\n                    let existingProperty = this.resolveProperty(existingPrototype, reportMode);\n                    if (existingProperty && existingProperty.isField) {\n                      if (existingProperty.type != boundInstance.type) {\n                        // make sure fields are invariant (Binaryen would otherwise error)\n                        this.errorRelated(\n                          DiagnosticCode.Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2,\n                          boundInstance.identifierNode.range, existingProperty.identifierNode.range,\n                          boundInstance.name, instance.internalName, base.internalName\n                        );\n                        break; // keep existing\n                      }\n                      boundInstance.memoryOffset = existingProperty.memoryOffset;\n                      needsLayout = false;\n                    }\n                  }\n                }\n                if (needsLayout) {\n                  let byteSize = fieldType.byteSize;\n                  assert(isPowerOf2(byteSize));\n                  let mask = byteSize - 1;\n                  if (memoryOffset & mask) memoryOffset = (memoryOffset | mask) + 1;\n                  boundInstance.memoryOffset = memoryOffset;\n                  memoryOffset += byteSize;\n                }\n                boundPrototype.instance = boundInstance;\n                instance.add(boundPrototype.name, boundPrototype); // reports\n                // field materializes here, so check for supported type early\n                // (other checks are performed once an element is compiled)\n                let typeNode = assert(boundPrototype.fieldDeclaration).type;\n                if (typeNode) this.program.checkTypeSupported(fieldType, typeNode);\n              }\n            } else {\n              instance.add(boundPrototype.name, boundPrototype); // reports\n            }\n            break;\n          }\n          default: assert(false);\n        }\n        if (!member.is(CommonFlags.Abstract)) {\n          unimplemented.delete(memberName);\n        }\n      }\n    }\n\n    if (instance.kind != ElementKind.Interface) {\n\n      // Check that all required members are implemented\n      if (!instance.is(CommonFlags.Abstract) && unimplemented.size > 0) {\n        for (let _keys = Map_keys(unimplemented), i = 0, k = _keys.length; i < k; ++i) {\n          let memberName = _keys[i];\n          let member = assert(unimplemented.get(memberName));\n          this.errorRelated(\n            DiagnosticCode.Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_2,\n            instance.identifierNode.range, member.identifierNode.range,\n            instance.internalName, memberName, member.parent.internalName\n          );\n        }\n      }\n\n      // Finalize memory offset\n      instance.nextMemoryOffset = memoryOffset;\n\n      // Link _own_ constructor if present\n      {\n        let ctorPrototype = instance.getMember(CommonNames.constructor);\n        if (ctorPrototype && ctorPrototype.parent == instance) {\n          assert(ctorPrototype.kind == ElementKind.FunctionPrototype);\n          let ctorInstance = this.resolveFunction(\n            <FunctionPrototype>ctorPrototype,\n            null,\n            assert(instance.contextualTypeArguments),\n            reportMode\n          );\n          if (ctorInstance) instance.constructorInstance = <Function>ctorInstance;\n        }\n      }\n    }\n\n    // Fully resolve operator overloads (don't have type parameters on their own)\n    let overloadPrototypes = prototype.operatorOverloadPrototypes;\n    // TODO: for (let [overloadKind, overloadPrototype] of overloadPrototypes) {\n    for (let _keys = Map_keys(overloadPrototypes), i = 0, k = _keys.length; i < k; ++i) {\n      let overloadKind = unchecked(_keys[i]);\n      let overloadPrototype = assert(overloadPrototypes.get(overloadKind));\n      assert(overloadKind != OperatorKind.Invalid);\n      if (overloadPrototype.is(CommonFlags.Generic)) {\n        // Already errored during initialization: AS212: Decorator '@operator' is not valid here\n        continue;\n      }\n      let operatorInstance: Function | null;\n      if (overloadPrototype.is(CommonFlags.Instance)) {\n        let boundPrototype = overloadPrototype.toBound(instance);\n        operatorInstance = this.resolveFunction(\n          boundPrototype,\n          null,\n          new Map(),\n          reportMode\n        );\n      } else {\n        operatorInstance = this.resolveFunction(\n          overloadPrototype,\n          null,\n          new Map(),\n          reportMode\n        );\n      }\n      if (!operatorInstance) continue;\n      let overloads = instance.operatorOverloads;\n      if (!overloads) instance.operatorOverloads = overloads = new Map();\n      // inc/dec are special in that an instance overload attempts to re-assign\n      // the corresponding value, thus requiring a matching return type, while a\n      // static overload works like any other overload.\n      if (operatorInstance.is(CommonFlags.Instance)) {\n        switch (overloadKind) {\n          case OperatorKind.PrefixInc:\n          case OperatorKind.PrefixDec:\n          case OperatorKind.PostfixInc:\n          case OperatorKind.PostfixDec: {\n            let returnType = operatorInstance.signature.returnType;\n            if (!returnType.isAssignableTo(instance.type)) {\n              if (reportMode == ReportMode.Report) {\n                this.error(\n                  DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n                  overloadPrototype.functionTypeNode.returnType.range, returnType.toString(), instance.type.toString()\n                );\n              }\n            }\n          }\n        }\n      }\n      if (!overloads.has(overloadKind)) {\n        overloads.set(overloadKind, operatorInstance);\n        if (overloadKind == OperatorKind.IndexedGet || overloadKind == OperatorKind.IndexedSet) {\n          let index = instance.indexSignature;\n          if (!index) instance.indexSignature = index = new IndexSignature(instance);\n          if (overloadKind == OperatorKind.IndexedGet) {\n            index.setType(operatorInstance.signature.returnType);\n          }\n        }\n      } else {\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Duplicate_decorator,\n            operatorInstance.declaration.range\n          );\n        }\n      }\n    }\n\n    // Remove this class from pending\n    assert(pendingClasses.has(instance)); // must be pending\n    pendingClasses.delete(instance);\n\n    // Finish derived classes that we postponed in `resolveClass` due to the\n    // base class still being pending, again triggering `finishResolveClass`\n    // of any classes derived from those classes, ultimately leading to all\n    // pending classes being resolved.\n    for (let _values = Set_values(pendingClasses), i = 0, k = _values.length; i < k; ++i) {\n      let pending = _values[i];\n      let dependsOnInstance = pending.base == instance;\n      let interfaces = pending.interfaces;\n      if (interfaces) {\n        let anyPending = false;\n        for (let _values2 = Set_values(interfaces), j = 0, l = _values2.length; j < l; ++j) {\n          let iface = _values2[j];\n          if (iface == instance) dependsOnInstance = true;\n          else if (pendingClasses.has(iface)) anyPending = true;\n        }\n        if (anyPending) continue;\n      }\n      if (dependsOnInstance) this.finishResolveClass(pending, reportMode);\n    }\n  }\n\n  /** Resolves a class prototype by first resolving the specified type arguments. */\n  resolveClassInclTypeArguments(\n    /** The prototype of the class. */\n    prototype: ClassPrototype,\n    /** Type arguments provided to be resolved. */\n    typeArgumentNodes: TypeNode[] | null,\n    /** Flow of {@link typeArgumentNodes} */\n    flow: Flow | null,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type>,\n    /** The node to use when reporting intermediate errors. */\n    reportNode: Node,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Class | null {\n    let resolvedTypeArguments: Type[] | null = null;\n\n    // Resolve type arguments if generic\n    if (prototype.is(CommonFlags.Generic)) {\n\n      // find the constructor prototype, which may be on a base class\n      let constructorPrototype: FunctionPrototype | null = null;\n      for (let p: ClassPrototype | null = prototype; p && !constructorPrototype; p = p.basePrototype) {\n        constructorPrototype = p.constructorPrototype;\n      }\n\n      // if no type arguments are provided, try to infer them from the constructor call\n      if (!typeArgumentNodes && constructorPrototype && flow && ctxTypes.size == 0) {\n        resolvedTypeArguments = this.inferGenericTypeArguments(\n          reportNode as NewExpression,\n          constructorPrototype,\n          prototype.typeParameterNodes,\n          flow,\n        );\n      } else {\n        // resolve them from the provided type argument nodes\n        resolvedTypeArguments = this.resolveTypeArguments( // reports\n          assert(prototype.typeParameterNodes), // must be present if generic\n          typeArgumentNodes,\n          flow,\n          ctxElement,\n          ctxTypes, // update\n          reportNode,\n          reportMode\n        );\n      }\n\n      if (!resolvedTypeArguments) return null;\n\n    // Otherwise make sure that no type arguments have been specified\n    } else {\n      if (typeArgumentNodes && typeArgumentNodes.length > 0) {\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_generic,\n            reportNode.range, prototype.internalName\n          );\n        }\n        return null;\n      }\n    }\n\n    // Continue with concrete types\n    return this.resolveClass(\n      prototype,\n      resolvedTypeArguments,\n      ctxTypes,\n      reportMode\n    );\n  }\n\n  /** Resolves a property prototype. */\n  resolveProperty(\n    /** The prototype of the property. */\n    prototype: PropertyPrototype,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Property | null {\n    let instance = prototype.instance;\n    if (instance) return instance;\n    prototype.instance = instance = new Property(\n      prototype,\n      prototype.parent // same level as prototype\n    );\n    let getterPrototype = prototype.getterPrototype;\n    if (getterPrototype) {\n      let getterInstance = this.resolveFunction(\n        getterPrototype,\n        null,\n        new Map(),\n        reportMode\n      );\n      if (getterInstance) {\n        instance.getterInstance = getterInstance;\n        instance.setType(getterInstance.signature.returnType);\n      }\n    }\n    let setterPrototype = prototype.setterPrototype;\n    if (setterPrototype) {\n      let setterInstance = this.resolveFunction(\n        setterPrototype,\n        null,\n        new Map(),\n        reportMode\n      );\n      if (setterInstance) {\n        instance.setterInstance = setterInstance;\n        if (!instance.is(CommonFlags.Resolved)) {\n          assert(setterInstance.signature.parameterTypes.length == 1);\n          instance.setType(setterInstance.signature.parameterTypes[0]);\n        }\n      }\n    }\n    instance.checkVisibility(this);\n    return instance;\n  }\n\n  private ensureOneTypeArgument(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): TypeNode | null {\n    let typeArgumentNodes = node.typeArguments;\n    let numTypeArguments = 0;\n    if (!typeArgumentNodes || (numTypeArguments = typeArgumentNodes.length) != 1) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Expected_0_type_arguments_but_got_1,\n          node.range, \"1\", numTypeArguments.toString()\n        );\n      }\n      return null;\n    }\n    return typeArgumentNodes[0];\n  }\n}\n", "/**\n * @fileoverview A TypeScript parser for the AssemblyScript subset.\n *\n * Takes the tokens produced by the `Tokenizer` and builds an abstract\n * syntax tree composed of `Node`s wrapped in a `Source` out of it.\n *\n * @license Apache-2.0\n */\n\nimport {\n  CommonFlags,\n  LIBRARY_PREFIX,\n  PATH_DELIMITER\n} from \"./common\";\n\nimport {\n  Tokenizer,\n  Token,\n  CommentHandler,\n  IdentifierHandling,\n  isIllegalVariableIdentifier\n} from \"./tokenizer\";\n\nimport {\n  Range,\n  DiagnosticCode,\n  DiagnosticEmitter,\n  DiagnosticMessage\n} from \"./diagnostics\";\n\nimport {\n  CharCode,\n  normalizePath\n} from \"./util\";\n\nimport {\n  Node,\n  NodeKind,\n  Source,\n  SourceKind,\n  TypeNode,\n  TypeName,\n  NamedTypeNode,\n  FunctionTypeNode,\n  ArrowKind,\n\n  Expression,\n  AssertionKind,\n  CallExpression,\n  ClassExpression,\n  FunctionExpression,\n  IdentifierExpression,\n  StringLiteralExpression,\n\n  Statement,\n  BlockStatement,\n  BreakStatement,\n  ClassDeclaration,\n  ContinueStatement,\n  DeclarationStatement,\n  DecoratorNode,\n  DoStatement,\n  EnumDeclaration,\n  EnumValueDeclaration,\n  ExportImportStatement,\n  ExportMember,\n  ExportStatement,\n  ExpressionStatement,\n  ForOfStatement,\n  FunctionDeclaration,\n  IfStatement,\n  ImportDeclaration,\n  ImportStatement,\n  IndexSignatureNode,\n  NamespaceDeclaration,\n  ParameterNode,\n  ParameterKind,\n  ReturnStatement,\n  SwitchCase,\n  SwitchStatement,\n  ThrowStatement,\n  TryStatement,\n  TypeDeclaration,\n  TypeParameterNode,\n  VariableStatement,\n  VariableDeclaration,\n  VoidStatement,\n  WhileStatement,\n  ModuleDeclaration,\n\n  mangleInternalPath\n} from \"./ast\";\n\n/** Represents a dependee. */\nclass Dependee {\n  constructor(\n    public source: Source,\n    public reportNode: Node\n  ) {}\n}\n\n/** Parser interface. */\nexport class Parser extends DiagnosticEmitter {\n\n  /** Source file names to be requested next. */\n  backlog: string[] = new Array();\n  /** Source file names already seen, that is processed or backlogged. */\n  seenlog: Set<string> = new Set();\n  /** Source file names already completely processed. */\n  donelog: Set<string> = new Set();\n  /** Optional handler to intercept comments while tokenizing. */\n  onComment: CommentHandler | null = null;\n  /** Current file being parsed. */\n  currentSource: Source | null = null;\n  /** Map of dependees being depended upon by a source, by path. */\n  dependees: Map<string, Dependee> = new Map();\n  /** An array of parsed sources. */\n  sources: Source[];\n  /** Current overridden module name. */\n  currentModuleName: string | null = null;\n\n  /** Constructs a new parser. */\n  constructor(\n    diagnostics: DiagnosticMessage[] | null = null,\n    sources: Source[] = []\n  ) {\n    super(diagnostics);\n    this.sources = sources;\n  }\n\n  /** Parses a file and adds its definitions to the program. */\n  parseFile(\n    /** Source text of the file, or `null` to indicate not found. */\n    text: string | null,\n    /** Normalized path of the file. */\n    path: string,\n    /** Whether this is an entry file. */\n    isEntry: bool\n  ): void {\n    // the frontend gives us paths with file extensions\n    let normalizedPath = normalizePath(path);\n    let internalPath = mangleInternalPath(normalizedPath);\n\n    // check if already processed\n    if (this.donelog.has(internalPath)) return;\n    this.donelog.add(internalPath); // do not parse again\n    this.seenlog.add(internalPath); // do not request again\n\n    // check if this is an error\n    if (text == null) {\n      let dependees = this.dependees;\n      let dependee: Dependee | null = null;\n      if (dependees.has(internalPath)) dependee = assert(dependees.get(internalPath));\n      this.error(\n        DiagnosticCode.File_0_not_found,\n        dependee\n          ? dependee.reportNode.range\n          : null,\n        path\n      );\n      return;\n    }\n\n    // create the source element\n    let source = new Source(\n      isEntry\n        ? SourceKind.UserEntry\n        : path.startsWith(LIBRARY_PREFIX)\n          ? path.indexOf(PATH_DELIMITER, LIBRARY_PREFIX.length) < 0\n            ? SourceKind.LibraryEntry\n            : SourceKind.Library\n          : SourceKind.User,\n      normalizedPath,\n      text\n    );\n\n    this.sources.push(source);\n    this.currentSource = source;\n    this.currentModuleName = null;\n\n    // tokenize and parse\n    let tn = new Tokenizer(source, this.diagnostics);\n    tn.onComment = this.onComment;\n    let statements = source.statements;\n    while (!tn.skip(Token.EndOfFile)) {\n      let statement = this.parseTopLevelStatement(tn, null);\n      if (statement) {\n        statements.push(statement);\n      } else {\n        this.skipStatement(tn);\n      }\n    }\n  }\n\n  /** Parses a top-level statement. */\n  parseTopLevelStatement(\n    tn: Tokenizer,\n    namespace: NamespaceDeclaration | null = null\n  ): Statement | null {\n    let flags = namespace ? namespace.flags & CommonFlags.Ambient : CommonFlags.None;\n    let startPos = -1;\n\n    // check decorators\n    let decorators: DecoratorNode[] | null = null;\n    while (tn.skip(Token.At)) {\n      if (startPos < 0) startPos = tn.tokenPos;\n      let decorator = this.parseDecorator(tn);\n      if (!decorator) {\n        this.skipStatement(tn);\n        continue;\n      }\n      if (!decorators) decorators = [decorator];\n      else decorators.push(decorator);\n    }\n\n    // check modifiers\n    let exportStart = 0;\n    let exportEnd = 0;\n    let defaultStart = 0;\n    let defaultEnd = 0;\n    if (tn.skip(Token.Export)) {\n      if (startPos < 0) startPos = tn.tokenPos;\n      flags |= CommonFlags.Export;\n      exportStart = tn.tokenPos;\n      exportEnd = tn.pos;\n      if (tn.skip(Token.Default)) {\n        defaultStart = tn.tokenPos;\n        defaultEnd = tn.pos;\n      }\n    }\n\n    let declareStart = 0;\n    let declareEnd = 0;\n    let contextIsAmbient = namespace != null && namespace.is(CommonFlags.Ambient);\n    if (tn.skip(Token.Declare)) {\n      if (contextIsAmbient) {\n        this.error(\n          DiagnosticCode.A_declare_modifier_cannot_be_used_in_an_already_ambient_context,\n          tn.range()\n        ); // recoverable\n      } else {\n        if (startPos < 0) startPos = tn.tokenPos;\n        declareStart = startPos;\n        declareEnd = tn.pos;\n        flags |= CommonFlags.Declare | CommonFlags.Ambient;\n      }\n    } else if (contextIsAmbient) {\n      flags |= CommonFlags.Ambient;\n    }\n\n    // parse the statement\n    let statement: Statement | null = null;\n\n    // handle declarations\n    let first = tn.peek();\n    if (startPos < 0) startPos = tn.nextTokenPos;\n    switch (first) {\n      case Token.Const: {\n        tn.next();\n        flags |= CommonFlags.Const;\n        if (tn.skip(Token.Enum)) {\n          statement = this.parseEnum(tn, flags, decorators, startPos);\n        } else {\n          statement = this.parseVariable(tn, flags, decorators, startPos);\n        }\n        decorators = null;\n        break;\n      }\n      case Token.Let: flags |= CommonFlags.Let;\n      case Token.Var: {\n        tn.next();\n        statement = this.parseVariable(tn, flags, decorators, startPos);\n        decorators = null;\n        break;\n      }\n      case Token.Enum: {\n        tn.next();\n        statement = this.parseEnum(tn, flags, decorators, startPos);\n        decorators = null;\n        break;\n      }\n      case Token.Function: {\n        tn.next();\n        statement = this.parseFunction(tn, flags, decorators, startPos);\n        decorators = null;\n        break;\n      }\n      case Token.Abstract: {\n        let state = tn.mark();\n        tn.next();\n        let abstractStart = tn.tokenPos;\n        let abstractEnd = tn.pos;\n        if (tn.peekOnNewLine()) {\n          tn.reset(state);\n          statement = this.parseStatement(tn, true);\n          break;\n        }\n        let next = tn.peek();\n        if (next != Token.Class) {\n          if (next == Token.Interface) {\n            this.error(\n              DiagnosticCode._abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration,\n              tn.range(abstractStart, abstractEnd)\n            );\n          }\n          tn.reset(state);\n          statement = this.parseStatement(tn, true);\n          break;\n        } else {\n          tn.discard(state);\n        }\n        flags |= CommonFlags.Abstract;\n        // fall through\n      }\n      case Token.Class:\n      case Token.Interface: {\n        tn.next();\n        statement = this.parseClassOrInterface(tn, flags, decorators, startPos);\n        decorators = null;\n        break;\n      }\n      case Token.Namespace: {\n        let state = tn.mark();\n        tn.next();\n        if (tn.peek(IdentifierHandling.Prefer) == Token.Identifier) {\n          tn.discard(state);\n          statement = this.parseNamespace(tn, flags, decorators, startPos);\n          decorators = null;\n        } else {\n          tn.reset(state);\n          statement = this.parseStatement(tn, true);\n        }\n        break;\n      }\n      case Token.Import: {\n        tn.next();\n        flags |= CommonFlags.Import;\n        if (flags & CommonFlags.Export) {\n          statement = this.parseExportImport(tn, startPos);\n        } else {\n          statement = this.parseImport(tn);\n        }\n        break;\n      }\n      case Token.Type: { // also identifier\n        let state = tn.mark();\n        tn.next();\n        if (tn.peek(IdentifierHandling.Prefer) == Token.Identifier) {\n          tn.discard(state);\n          statement = this.parseTypeDeclaration(tn, flags, decorators, startPos);\n          decorators = null;\n        } else {\n          tn.reset(state);\n          statement = this.parseStatement(tn, true);\n        }\n        break;\n      }\n      case Token.Module: { // also identifier\n        let state = tn.mark();\n        tn.next();\n        if (tn.peek() == Token.StringLiteral && !tn.peekOnNewLine()) {\n          tn.discard(state);\n          statement = this.parseModuleDeclaration(tn, flags);\n        } else {\n          tn.reset(state);\n          statement = this.parseStatement(tn, true);\n        }\n        break;\n      }\n      default: {\n\n        // handle plain exports\n        if (flags & CommonFlags.Export) {\n          if (defaultEnd && tn.skipIdentifier(IdentifierHandling.Prefer)) {\n            if (declareEnd) {\n              this.error(\n                DiagnosticCode.An_export_assignment_cannot_have_modifiers,\n                tn.range(declareStart, declareEnd)\n              );\n            }\n            statement = this.parseExportDefaultAlias(tn, startPos, defaultStart, defaultEnd);\n            defaultStart = defaultEnd = 0; // consume\n          } else {\n            statement = this.parseExport(tn, startPos, (flags & CommonFlags.Declare) != 0);\n          }\n\n        // handle non-declaration statements\n        } else {\n          if (exportEnd) {\n            this.error(\n              DiagnosticCode._0_modifier_cannot_be_used_here,\n              tn.range(exportStart, exportEnd), \"export\"\n            ); // recoverable\n          }\n          if (declareEnd) {\n            this.error(\n              DiagnosticCode._0_modifier_cannot_be_used_here,\n              tn.range(declareStart, declareEnd), \"declare\"\n            ); // recoverable\n          }\n          if (namespace) {\n            this.error(\n              DiagnosticCode.Namespace_can_only_have_declarations,\n              tn.range(startPos)\n            );\n          } else {\n            statement = this.parseStatement(tn, true);\n          }\n        }\n        break;\n      }\n    }\n\n    // check for decorators that weren't consumed\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.error(\n          DiagnosticCode.Decorators_are_not_valid_here,\n          decorators[i].range\n        );\n      }\n    }\n\n    // check if this an `export default` declaration\n    if (defaultEnd && statement != null) {\n      switch (statement.kind) {\n        case NodeKind.EnumDeclaration:\n        case NodeKind.FunctionDeclaration:\n        case NodeKind.ClassDeclaration:\n        case NodeKind.InterfaceDeclaration:\n        case NodeKind.NamespaceDeclaration: {\n          return Node.createExportDefaultStatement(<DeclarationStatement>statement, tn.range(startPos, tn.pos));\n        }\n        default: {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(defaultStart, defaultEnd), \"default\"\n          );\n        }\n      }\n    }\n    return statement;\n  }\n\n  /** Obtains the next file to parse. */\n  nextFile(): string | null {\n    let backlog = this.backlog;\n    return backlog.length ? assert(backlog.shift()) : null;\n  }\n\n  /** Obtains the path of the dependee of the given imported file. */\n  getDependee(dependent: string): string | null {\n    let dependees = this.dependees;\n    if (dependees.has(dependent)) {\n      let dependee = assert(dependees.get(dependent));\n      return dependee.source.internalPath;\n    }\n    return null;\n  }\n\n  /** Finishes parsing. */\n  finish(): void {\n    if (this.backlog.length) throw new Error(\"backlog is not empty\");\n    this.backlog = [];\n    this.seenlog.clear();\n    this.donelog.clear();\n    this.dependees.clear();\n  }\n\n  // types\n\n  /** Parses a type name. */\n  parseTypeName(\n    tn: Tokenizer\n  ): TypeName | null {\n\n    // at: Identifier ('.' Identifier)*\n\n    let first = Node.createSimpleTypeName(tn.readIdentifier(), tn.range());\n    let current = first;\n    while (tn.skip(Token.Dot)) {\n      if (tn.skip(Token.Identifier)) {\n        let next = Node.createSimpleTypeName(tn.readIdentifier(), tn.range());\n        current.next = next;\n        current = next;\n      } else {\n        this.error(\n          DiagnosticCode.Identifier_expected,\n          tn.range(tn.pos)\n        );\n        return null;\n      }\n    }\n    return first;\n  }\n\n  /** Parses a type. */\n  parseType(\n    tn: Tokenizer,\n    acceptParenthesized: bool = true,\n    suppressErrors: bool = false\n  ): TypeNode | null {\n\n    // before: Type\n\n    // NOTE: this parses our limited subset\n    let token = tn.next();\n    let startPos = tn.tokenPos;\n\n    let type: TypeNode;\n\n    // '(' ...\n    if (token == Token.OpenParen) {\n\n      // '(' FunctionSignature ')'\n      let isInnerParenthesized = tn.skip(Token.OpenParen);\n      // FunctionSignature?\n      let signature = this.tryParseFunctionType(tn);\n      if (signature) {\n        if (isInnerParenthesized) {\n          if (!tn.skip(Token.CloseParen)) {\n            if (!suppressErrors) {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \")\"\n              );\n            }\n            return null;\n          }\n        }\n        type = signature;\n      } else if (isInnerParenthesized || this.tryParseSignatureIsSignature) {\n        if (!suppressErrors) {\n          this.error(\n            DiagnosticCode.Unexpected_token,\n            tn.range()\n          );\n        }\n        return null;\n      // Type (',' Type)* ')'\n      } else if (acceptParenthesized) {\n        let innerType = this.parseType(tn, false, suppressErrors);\n        if (!innerType) return null;\n        if (!tn.skip(Token.CloseParen)) {\n          if (!suppressErrors) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(tn.pos), \")\"\n            );\n          }\n          return null;\n        }\n        type = innerType;\n        type.range.start = startPos;\n        type.range.end = tn.pos;\n      } else {\n        if (!suppressErrors) {\n          this.error(\n            DiagnosticCode.Unexpected_token,\n            tn.range()\n          );\n        }\n        return null;\n      }\n\n    // 'void'\n    } else if (token == Token.Void) {\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"void\", tn.range()), [], false, tn.range(startPos, tn.pos)\n      );\n\n    // 'this'\n    } else if (token == Token.This) {\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"this\", tn.range()), [], false, tn.range(startPos, tn.pos)\n      );\n\n    // 'true'\n    } else if (token == Token.True || token == Token.False) {\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"bool\", tn.range()), [], false, tn.range(startPos, tn.pos)\n      );\n\n    // 'null'\n    } else if (token == Token.Null) {\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"null\", tn.range()), [], false, tn.range(startPos, tn.pos)\n      );\n\n    // StringLiteral\n    } else if (token == Token.StringLiteral) {\n      tn.readString();\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"string\", tn.range()), [], false, tn.range(startPos, tn.pos)\n      );\n\n    // Identifier\n    } else if (token == Token.Identifier) {\n      let name = this.parseTypeName(tn);\n      if (!name) return null;\n      let parameters: TypeNode[] | null = null;\n\n      // Name<T>\n      if (tn.skip(Token.LessThan)) {\n        do {\n          let parameter = this.parseType(tn, true, suppressErrors);\n          if (!parameter) return null;\n          if (!parameters) parameters = [ parameter ];\n          else parameters.push(parameter);\n        } while (tn.skip(Token.Comma));\n        if (!tn.skip(Token.GreaterThan)) {\n          if (!suppressErrors) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(tn.pos), \">\"\n            );\n          }\n          return null;\n        }\n      }\n      if (!parameters) parameters = [];\n      type = Node.createNamedType(name, parameters, false, tn.range(startPos, tn.pos));\n    } else {\n      if (!suppressErrors) {\n        this.error(\n          DiagnosticCode.Type_expected,\n          tn.range()\n        );\n      }\n      return null;\n    }\n    // ... | type\n    while (tn.skip(Token.Bar)) {\n      let nextType = this.parseType(tn, true, false);\n      if (!nextType) return null;\n      let typeIsNull = type.kind == NodeKind.NamedType && (<NamedTypeNode>type).isNull;\n      let nextTypeIsNull = nextType.kind == NodeKind.NamedType && (<NamedTypeNode>nextType).isNull;\n      if (!typeIsNull && !nextTypeIsNull) {\n        if (!suppressErrors) {\n          this.error(\n            DiagnosticCode.Not_implemented_0, nextType.range, \"union types\"\n          );\n        }\n        return null;\n      } else if (nextTypeIsNull) {\n        type.isNullable = true;\n        type.range.end = nextType.range.end;\n      } else if (typeIsNull) {\n        nextType.range.start = type.range.start;\n        nextType.isNullable = true;\n        type = nextType;\n      } else {\n        // `null | null` still `null`\n        type.range.end = nextType.range.end;\n      }\n    }\n    // ... [][]\n    while (tn.skip(Token.OpenBracket)) {\n      let bracketStart = tn.tokenPos;\n      if (!tn.skip(Token.CloseBracket)) {\n        if (!suppressErrors) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"]\"\n          );\n        }\n        return null;\n      }\n      let bracketRange = tn.range(bracketStart, tn.pos);\n\n      // ...[] | null\n      let nullable = false;\n      if (tn.skip(Token.Bar)) {\n        if (tn.skip(Token.Null)) {\n          nullable = true;\n        } else {\n          if (!suppressErrors) {\n            this.error(\n              DiagnosticCode.Not_implemented_0,\n              tn.range(), \"union types\"\n            );\n          }\n          return null;\n        }\n      }\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"Array\", bracketRange),\n        [ type ],\n        nullable,\n        tn.range(startPos, tn.pos)\n      );\n      if (nullable) break;\n    }\n\n    return type;\n  }\n\n  // Indicates whether tryParseSignature determined that it is handling a Signature\n  private tryParseSignatureIsSignature: bool = false;\n\n  /** Parses a function type, as used in type declarations. */\n  tryParseFunctionType(\n    tn: Tokenizer\n  ): FunctionTypeNode | null {\n\n    // at '(': ('...'? Identifier '?'? ':' Type (','  '...'? Identifier '?'? ':' Type)* )? ')' '=>' Type\n\n    let state = tn.mark();\n    let startPos = tn.tokenPos;\n    let parameters: ParameterNode[] | null = null;\n    let thisType: NamedTypeNode | null = null;\n    let isSignature: bool = false;\n    let firstParamNameNoType: IdentifierExpression | null = null;\n    let firstParamKind: ParameterKind = ParameterKind.Default;\n\n    if (tn.skip(Token.CloseParen)) {\n      isSignature = true;\n      tn.discard(state);\n      parameters = [];\n\n    } else {\n      isSignature = false; // not yet known\n      do {\n        let paramStart = -1;\n        let kind = ParameterKind.Default;\n        if (tn.skip(Token.Dot_Dot_Dot)) {\n          paramStart = tn.tokenPos;\n          isSignature = true;\n          tn.discard(state);\n          kind = ParameterKind.Rest;\n        }\n        if (tn.skip(Token.This)) {\n          if (paramStart < 0) paramStart = tn.tokenPos;\n          if (tn.skip(Token.Colon)) {\n            isSignature = true;\n            tn.discard(state);\n            let type = this.parseType(tn, false);\n            if (!type) return null;\n            if (type.kind != NodeKind.NamedType) {\n              this.error(\n                DiagnosticCode.Identifier_expected,\n                type.range\n              );\n              this.tryParseSignatureIsSignature = true;\n              return null;\n            }\n            thisType = <NamedTypeNode>type;\n          } else {\n            tn.reset(state);\n            this.tryParseSignatureIsSignature = false;\n            return null;\n          }\n        } else if (tn.skipIdentifier()) {\n          if (paramStart < 0) paramStart = tn.tokenPos;\n          let name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range(tn.tokenPos, tn.pos));\n          if (tn.skip(Token.Question)) {\n            isSignature = true;\n            tn.discard(state);\n            if (kind == ParameterKind.Rest) {\n              this.error(\n                DiagnosticCode.A_rest_parameter_cannot_be_optional,\n                tn.range()\n              ); // recoverable\n            } else {\n              kind = ParameterKind.Optional;\n            }\n          }\n          if (tn.skip(Token.Colon)) {\n            isSignature = true;\n            tn.discard(state);\n            let type = this.parseType(tn); // not suppressing errors because known\n            if (!type) {\n              this.tryParseSignatureIsSignature = isSignature;\n              return null;\n            }\n            let param = Node.createParameter(kind, name, type, null, tn.range(paramStart, tn.pos));\n            if (!parameters) parameters = [ param ];\n            else parameters.push(param);\n          } else {\n            if (!isSignature) {\n              if (tn.peek() == Token.Comma) {\n                isSignature = true;\n                tn.discard(state);\n              }\n            }\n            if (isSignature) {\n              let param = Node.createParameter(kind, name, Node.createOmittedType(tn.range(tn.pos)), null, tn.range(paramStart, tn.pos));\n              if (!parameters) parameters = [ param ];\n              else parameters.push(param);\n              this.error(\n                DiagnosticCode.Type_expected,\n                param.type.range\n              ); // recoverable\n            } else if (!parameters) {\n              // on '(' Identifier ^',' we don't yet know whether this is a\n              // parenthesized or a function type, hence we have to delay the\n              // respective diagnostic until we know for sure.\n              firstParamNameNoType = name;\n              firstParamKind = kind;\n            }\n          }\n        } else {\n          if (isSignature) {\n            if (tn.peek() == Token.CloseParen) break; // allow trailing comma\n            this.error(\n              DiagnosticCode.Identifier_expected,\n              tn.range()\n            );\n          } else {\n            tn.reset(state);\n          }\n          this.tryParseSignatureIsSignature = isSignature;\n          return null;\n        }\n      } while (tn.skip(Token.Comma));\n      if (!tn.skip(Token.CloseParen)) {\n        if (isSignature) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n        } else {\n          tn.reset(state);\n        }\n        this.tryParseSignatureIsSignature = isSignature;\n        return null;\n      }\n    }\n\n    let returnType: TypeNode | null;\n    if (tn.skip(Token.Equals_GreaterThan)) {\n      if (!isSignature) {\n        isSignature = true;\n        tn.discard(state);\n        if (firstParamNameNoType) { // now we know\n          let param = Node.createParameter(\n            firstParamKind,\n            firstParamNameNoType,\n            Node.createOmittedType(firstParamNameNoType.range.atEnd),\n            null,\n            firstParamNameNoType.range\n          );\n          if (!parameters) parameters = [ param ];\n          else parameters.push(param);\n          this.error(\n            DiagnosticCode.Type_expected,\n            param.type.range\n          ); // recoverable\n        }\n      }\n      returnType = this.parseType(tn);\n      if (!returnType) {\n        this.tryParseSignatureIsSignature = isSignature;\n        return null;\n      }\n    } else {\n      if (isSignature) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"=>\"\n        );\n      } else {\n        tn.reset(state);\n      }\n      this.tryParseSignatureIsSignature = isSignature;\n      return null;\n    }\n    this.tryParseSignatureIsSignature = true;\n\n    if (!parameters) parameters = [];\n\n    return Node.createFunctionType(\n      parameters,\n      returnType,\n      thisType,\n      false,\n      tn.range(startPos, tn.pos)\n    );\n  }\n\n  // statements\n\n  parseDecorator(\n    tn: Tokenizer\n  ): DecoratorNode | null {\n\n    // at '@': Identifier ('.' Identifier)* '(' Arguments\n\n    let startPos = tn.tokenPos;\n    if (tn.skipIdentifier()) {\n      let name = tn.readIdentifier();\n      let expression: Expression = Node.createIdentifierExpression(name, tn.range(startPos, tn.pos));\n      while (tn.skip(Token.Dot)) {\n        if (tn.skipIdentifier(IdentifierHandling.Prefer)) {\n          name = tn.readIdentifier();\n          expression = Node.createPropertyAccessExpression(\n            expression,\n            Node.createIdentifierExpression(name, tn.range()),\n            tn.range(startPos, tn.pos)\n          );\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n      }\n      let args: Expression[] | null;\n      if (tn.skip(Token.OpenParen)) {\n        args = this.parseArguments(tn);\n        if (args) {\n          return Node.createDecorator(expression, args, tn.range(startPos, tn.pos));\n        }\n      } else {\n        return Node.createDecorator(expression, null, tn.range(startPos, tn.pos));\n      }\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseVariable(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32,\n    isFor: bool = false\n  ): VariableStatement | null {\n\n    // at ('const' | 'let' | 'var'): VariableDeclaration (',' VariableDeclaration)* ';'?\n\n    let declarations = new Array<VariableDeclaration>();\n    do {\n      let declaration = this.parseVariableDeclaration(tn, flags, decorators, isFor);\n      if (!declaration) return null;\n      declaration.overriddenModuleName = this.currentModuleName;\n      declarations.push(declaration);\n    } while (tn.skip(Token.Comma));\n\n    let ret = Node.createVariableStatement(decorators, declarations, tn.range(startPos, tn.pos));\n    if (!tn.skip(Token.Semicolon) && !isFor) this.checkASI(tn);\n    return ret;\n  }\n\n  parseVariableDeclaration(\n    tn: Tokenizer,\n    parentFlags: CommonFlags,\n    parentDecorators: DecoratorNode[] | null,\n    isFor: bool = false\n  ): VariableDeclaration | null {\n\n    // before: Identifier (':' Type)? ('=' Expression)?\n\n    if (!tn.skipIdentifier()) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n      return null;\n    }\n    let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    if (isIllegalVariableIdentifier(identifier.text)) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        identifier.range\n      );\n    }\n    let flags = parentFlags;\n    if (tn.skip(Token.Exclamation)) {\n      flags |= CommonFlags.DefinitelyAssigned;\n    }\n\n    let type: TypeNode | null = null;\n    if (tn.skip(Token.Colon)) {\n      type = this.parseType(tn, true);\n    }\n\n    let initializer: Expression | null = null;\n    if (tn.skip(Token.Equals)) {\n      if (flags & CommonFlags.Ambient) {\n        this.error(\n          DiagnosticCode.Initializers_are_not_allowed_in_ambient_contexts,\n          tn.range()\n        ); // recoverable\n      }\n      initializer = this.parseExpression(tn, Precedence.Comma + 1);\n      if (!initializer) return null;\n      if (flags & CommonFlags.DefinitelyAssigned) {\n        this.error(\n          DiagnosticCode.Declarations_with_initializers_cannot_also_have_definite_assignment_assertions,\n          initializer.range\n        );\n      }\n    } else if (!isFor) {\n      if (flags & CommonFlags.Const) {\n        if (!(flags & CommonFlags.Ambient)) {\n          this.error(\n            DiagnosticCode._const_declarations_must_be_initialized,\n            identifier.range\n          ); // recoverable\n        }\n      } else if (!type) { // neither type nor initializer\n        this.error(\n          DiagnosticCode.Type_expected,\n          tn.range(tn.pos)\n        ); // recoverable\n      }\n    }\n    let range = Range.join(identifier.range, tn.range());\n    if ((flags & CommonFlags.DefinitelyAssigned) != 0 && (flags & CommonFlags.Ambient) != 0) {\n      this.error(\n        DiagnosticCode.A_definite_assignment_assertion_is_not_permitted_in_this_context,\n        range\n      );\n    }\n    return Node.createVariableDeclaration(\n      identifier,\n      parentDecorators,\n      flags,\n      type,\n      initializer,\n      range\n    );\n  }\n\n  parseEnum(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32\n  ): EnumDeclaration | null {\n\n    // at 'enum': Identifier '{' (EnumValueDeclaration (',' EnumValueDeclaration )*)? '}' ';'?\n\n    if (tn.next() != Token.Identifier) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n      return null;\n    }\n    let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    if (tn.next() != Token.OpenBrace) {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"{\"\n      );\n      return null;\n    }\n    let members = new Array<EnumValueDeclaration>();\n    while (!tn.skip(Token.CloseBrace)) {\n      let member = this.parseEnumValue(tn, CommonFlags.None);\n      if (!member) return null;\n      members.push(member);\n      if (!tn.skip(Token.Comma)) {\n        if (tn.skip(Token.CloseBrace)) {\n          break;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"}\"\n          );\n          return null;\n        }\n      }\n    }\n    let ret = Node.createEnumDeclaration(\n      identifier,\n      decorators,\n      flags,\n      members,\n      tn.range(startPos, tn.pos)\n    );\n    ret.overriddenModuleName = this.currentModuleName;\n    tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseEnumValue(\n    tn: Tokenizer,\n    parentFlags: CommonFlags\n  ): EnumValueDeclaration | null {\n\n    // before: Identifier ('=' Expression)?\n\n    if (!tn.skipIdentifier()) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n      return null;\n    }\n    let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    let value: Expression | null = null;\n    if (tn.skip(Token.Equals)) {\n      value = this.parseExpression(tn, Precedence.Comma + 1);\n      if (!value) return null;\n    }\n    return Node.createEnumValueDeclaration(\n      identifier,\n      parentFlags,\n      value,\n      Range.join(identifier.range, tn.range())\n    );\n  }\n\n  parseReturn(\n    tn: Tokenizer\n  ): ReturnStatement | null {\n\n    // at 'return': Expression | (';' | '}' | ...'\\n')\n\n    let startPos = tn.tokenPos;\n    let expr: Expression | null = null;\n    let nextToken = tn.peek();\n    if (\n      nextToken != Token.Semicolon &&\n      nextToken != Token.CloseBrace &&\n      !tn.peekOnNewLine()\n    ) {\n      if (!(expr = this.parseExpression(tn))) return null;\n    }\n\n    let ret = Node.createReturnStatement(expr, tn.range(startPos, tn.pos));\n    if (!tn.skip(Token.Semicolon)) this.checkASI(tn);\n    return ret;\n  }\n\n  parseTypeParameters(\n    tn: Tokenizer\n  ): TypeParameterNode[] | null {\n\n    // at '<': TypeParameter (',' TypeParameter)* '>'\n\n    let typeParameters = new Array<TypeParameterNode>();\n    let seenOptional = false;\n    let start = tn.tokenPos;\n    while (!tn.skip(Token.GreaterThan)) {\n      let typeParameter = this.parseTypeParameter(tn);\n      if (!typeParameter) return null;\n      if (typeParameter.defaultType) {\n        seenOptional = true;\n      } else if (seenOptional) {\n        this.error(\n          DiagnosticCode.Required_type_parameters_may_not_follow_optional_type_parameters,\n          typeParameter.range\n        );\n        typeParameter.defaultType = null;\n      }\n      typeParameters.push(typeParameter);\n      if (!tn.skip(Token.Comma)) {\n        if (tn.skip(Token.GreaterThan)) {\n          break;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \">\"\n          );\n          return null;\n        }\n      }\n    }\n    if (!typeParameters.length) {\n      this.error(\n        DiagnosticCode.Type_parameter_list_cannot_be_empty,\n        tn.range(start, tn.pos)\n      ); // recoverable\n    }\n    return typeParameters;\n  }\n\n  parseTypeParameter(\n    tn: Tokenizer\n  ): TypeParameterNode | null {\n\n    // before: Identifier ('extends' Type)? ('=' Type)?\n\n    if (tn.next() == Token.Identifier) {\n      let identifier = Node.createIdentifierExpression(\n        tn.readIdentifier(),\n        tn.range()\n      );\n      let extendsType: NamedTypeNode | null = null;\n      if (tn.skip(Token.Extends)) {\n        let type = this.parseType(tn);\n        if (!type) return null;\n        if (type.kind != NodeKind.NamedType) {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            type.range\n          );\n          return null;\n        }\n        extendsType = <NamedTypeNode>type;\n      }\n      let defaultType: NamedTypeNode | null = null;\n      if (tn.skip(Token.Equals)) {\n        let type = this.parseType(tn);\n        if (!type) return null;\n        if (type.kind != NodeKind.NamedType) {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            type.range\n          );\n          return null;\n        }\n        defaultType = <NamedTypeNode>type;\n      }\n      return Node.createTypeParameter(\n        identifier,\n        extendsType,\n        defaultType,\n        Range.join(identifier.range, tn.range())\n      );\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  private parseParametersThis: NamedTypeNode | null = null;\n\n  parseParameters(\n    tn: Tokenizer,\n    isConstructor: bool = false\n  ): ParameterNode[] | null {\n\n    // at '(': (Parameter (',' Parameter)*)? ')'\n\n    let parameters = new Array<ParameterNode>();\n    let seenRest: ParameterNode | null = null;\n    let seenOptional = false;\n    let reportedRest = false;\n    let thisType: TypeNode | null = null;\n\n    // check if there is a leading `this` parameter\n    this.parseParametersThis = null;\n    if (tn.skip(Token.This)) {\n      if (tn.skip(Token.Colon)) {\n        thisType = this.parseType(tn); // reports\n        if (!thisType) return null;\n        if (thisType.kind == NodeKind.NamedType) {\n          this.parseParametersThis = <NamedTypeNode>thisType;\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            thisType.range\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \":\"\n        );\n        return null;\n      }\n      if (!tn.skip(Token.Comma)) {\n        if (tn.skip(Token.CloseParen)) {\n          return parameters;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n          return null;\n        }\n      }\n    }\n\n    while (!tn.skip(Token.CloseParen)) {\n      let param = this.parseParameter(tn, isConstructor); // reports\n      if (!param) return null;\n      if (seenRest && !reportedRest) {\n        this.error(\n          DiagnosticCode.A_rest_parameter_must_be_last_in_a_parameter_list,\n          seenRest.name.range\n        );\n        reportedRest = true;\n      }\n      switch (param.parameterKind) {\n        default: {\n          if (seenOptional) {\n            this.error(\n              DiagnosticCode.A_required_parameter_cannot_follow_an_optional_parameter,\n              param.name.range\n            );\n          }\n          break;\n        }\n        case ParameterKind.Optional: {\n          seenOptional = true;\n          break;\n        }\n        case ParameterKind.Rest: {\n          seenRest = param;\n          break;\n        }\n      }\n      parameters.push(param);\n      if (!tn.skip(Token.Comma)) {\n        if (tn.skip(Token.CloseParen)) {\n          break;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n          return null;\n        }\n      }\n    }\n    return parameters;\n  }\n\n  parseParameter(\n    tn: Tokenizer,\n    isConstructor: bool = false\n  ): ParameterNode | null {\n\n    // before: ('public' | 'private' | 'protected' | '...')? Identifier '?'? (':' Type)? ('=' Expression)?\n\n    let isRest = false;\n    let isOptional = false;\n    let startRange: Range | null = null;\n    let accessFlags: CommonFlags = CommonFlags.None;\n    if (isConstructor) {\n      if (tn.skip(Token.Public)) {\n        startRange = tn.range();\n        accessFlags |= CommonFlags.Public;\n      } else if (tn.skip(Token.Protected)) {\n        startRange = tn.range();\n        accessFlags |= CommonFlags.Protected;\n      } else if (tn.skip(Token.Private)) {\n        startRange = tn.range();\n        accessFlags |= CommonFlags.Private;\n      }\n      if (tn.peek() == Token.Readonly) {\n        let state = tn.mark();\n        tn.next();\n        if (tn.peek() != Token.Colon) { // modifier\n          tn.discard(state);\n          if (!startRange) startRange = tn.range();\n          accessFlags |= CommonFlags.Readonly;\n        } else { // identifier\n          tn.reset(state);\n        }\n      }\n    }\n    if (tn.skip(Token.Dot_Dot_Dot)) {\n      if (accessFlags) {\n        this.error(\n          DiagnosticCode.A_parameter_property_cannot_be_declared_using_a_rest_parameter,\n          tn.range()\n        );\n      } else {\n        startRange = tn.range();\n      }\n      isRest = true;\n    }\n    if (tn.skipIdentifier()) {\n      if (!isRest) startRange = tn.range();\n      let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      let type: TypeNode | null = null;\n      if (isOptional = tn.skip(Token.Question)) {\n        if (isRest) {\n          this.error(\n            DiagnosticCode.A_rest_parameter_cannot_be_optional,\n            identifier.range\n          );\n        }\n      }\n      if (tn.skip(Token.Colon)) {\n        type = this.parseType(tn);\n        if (!type) return null;\n      } else {\n        type = Node.createOmittedType(tn.range(tn.pos));\n      }\n      let initializer: Expression | null = null;\n      if (tn.skip(Token.Equals)) {\n        if (isRest) {\n          this.error(\n            DiagnosticCode.A_rest_parameter_cannot_have_an_initializer,\n            identifier.range\n          );\n        }\n        if (isOptional) {\n          this.error(\n            DiagnosticCode.Parameter_cannot_have_question_mark_and_initializer,\n            identifier.range\n          );\n        } else {\n          isOptional = true;\n        }\n        initializer = this.parseExpression(tn, Precedence.Comma + 1);\n        if (!initializer) return null;\n      }\n      let param = Node.createParameter(\n        isRest\n          ? ParameterKind.Rest\n          : isOptional\n            ? ParameterKind.Optional\n            : ParameterKind.Default,\n        identifier,\n        type,\n        initializer,\n        Range.join(assert(startRange), tn.range())\n      );\n      param.flags |= accessFlags;\n      return param;\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseFunction(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32\n  ): FunctionDeclaration | null {\n\n    // at 'function':\n    //  Identifier\n    //  ('<' TypeParameters)?\n    //  '(' Parameters (':' Type)?\n    //  '{' Statement* '}'\n    //  ';'?\n\n    if (!tn.skipIdentifier()) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range(tn.pos)\n      );\n      return null;\n    }\n\n    let name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    let signatureStart = -1;\n\n    let typeParameters: TypeParameterNode[] | null = null;\n    if (tn.skip(Token.LessThan)) {\n      signatureStart = tn.tokenPos;\n      typeParameters = this.parseTypeParameters(tn);\n      if (!typeParameters) return null;\n      flags |= CommonFlags.Generic;\n    }\n\n    if (!tn.skip(Token.OpenParen)) {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(tn.pos), \"(\"\n      );\n      return null;\n    }\n\n    if (signatureStart < 0) {\n      signatureStart = tn.tokenPos;\n    }\n\n    let parameters = this.parseParameters(tn);\n    if (!parameters) return null;\n    let thisType = this.parseParametersThis;\n\n    let isSetter = (flags & CommonFlags.Set) != 0;\n    if (isSetter) {\n      if (parameters.length != 1) {\n        this.error(\n          DiagnosticCode.A_set_accessor_must_have_exactly_one_parameter,\n          name.range\n        ); // recoverable\n      }\n      if (parameters.length > 0 && parameters[0].initializer) {\n        this.error(\n          DiagnosticCode.A_set_accessor_parameter_cannot_have_an_initializer,\n          name.range\n        ); // recoverable\n      }\n    }\n\n    if (flags & CommonFlags.Get) {\n      if (parameters.length) {\n        this.error(\n          DiagnosticCode.A_get_accessor_cannot_have_parameters,\n          name.range\n        ); // recoverable\n      }\n    }\n\n    let returnType: TypeNode | null = null;\n    if (tn.skip(Token.Colon)) {\n      returnType = this.parseType(tn, true, isSetter);\n      if (!returnType) return null;\n    }\n\n    if (!returnType) {\n      returnType = Node.createOmittedType(\n        tn.range(tn.pos)\n      );\n      if (!isSetter) {\n        this.error(\n          DiagnosticCode.Type_expected,\n          returnType.range\n        ); // recoverable\n      }\n    }\n\n    let signature = Node.createFunctionType(\n      parameters,\n      returnType,\n      thisType,\n      false,\n      tn.range(signatureStart, tn.pos)\n    );\n\n    let body: Statement | null = null;\n    if (tn.skip(Token.OpenBrace)) {\n      if (flags & CommonFlags.Ambient) {\n        this.error(\n          DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts,\n          tn.range()\n        ); // recoverable\n      }\n\n      body = this.parseBlockStatement(tn, false);\n      if (!body) return null;\n    } else if (!(flags & CommonFlags.Ambient)) {\n      this.error(\n        DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,\n        tn.range(tn.pos)\n      );\n    }\n\n    let ret = Node.createFunctionDeclaration(\n      name,\n      decorators,\n      flags,\n      typeParameters,\n      signature,\n      body,\n      ArrowKind.None,\n      tn.range(startPos, tn.pos)\n    );\n    ret.overriddenModuleName = this.currentModuleName;\n    tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseFunctionExpression(tn: Tokenizer): FunctionExpression | null {\n    let startPos = tn.tokenPos;\n    let name: IdentifierExpression;\n    let arrowKind = ArrowKind.None;\n\n    // either at 'function':\n    //  Identifier?\n    //  '(' Parameters (':' Type)?\n    //  Statement\n\n    if (tn.token == Token.Function) {\n      if (tn.skipIdentifier()) {\n        name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      } else { // empty name\n        name = Node.createEmptyIdentifierExpression(tn.range(tn.pos));\n      }\n      if (!tn.skip(Token.OpenParen)) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(tn.pos), \"(\"\n        );\n        return null;\n      }\n\n      // or at '(' of arrow function:\n      //  Parameters (':' Type)?\n      //  Statement\n\n    } else {\n      arrowKind = ArrowKind.Parenthesized;\n      assert(tn.token == Token.OpenParen);\n      name = Node.createEmptyIdentifierExpression(tn.range(tn.tokenPos));\n    }\n\n    // TODO: type parameters? doesn't seem worth it.\n\n    let signatureStart = tn.pos;\n    let parameters = this.parseParameters(tn);\n    if (!parameters) return null;\n\n    return this.parseFunctionExpressionCommon(tn, name, parameters, this.parseParametersThis, arrowKind, startPos, signatureStart);\n  }\n\n  private parseFunctionExpressionCommon(\n    tn: Tokenizer,\n    name: IdentifierExpression,\n    parameters: ParameterNode[],\n    explicitThis: NamedTypeNode | null,\n    arrowKind: ArrowKind,\n    startPos: i32 = -1,\n    signatureStart: i32 = -1\n  ): FunctionExpression | null {\n    if (startPos < 0) startPos = name.range.start;\n    if (signatureStart < 0) signatureStart = startPos;\n\n    let returnType: TypeNode | null = null;\n    if (arrowKind != ArrowKind.Single && tn.skip(Token.Colon)) {\n      returnType = this.parseType(tn);\n      if (!returnType) return null;\n    } else {\n      returnType = Node.createOmittedType(tn.range(tn.pos));\n    }\n\n    if (arrowKind) {\n      if (!tn.skip(Token.Equals_GreaterThan)) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(tn.pos), \"=>\"\n        );\n        return null;\n      }\n    }\n\n    let signature = Node.createFunctionType(\n      parameters,\n      returnType,\n      explicitThis,\n      false,\n      tn.range(signatureStart, tn.pos)\n    );\n\n    let body: Statement | null = null;\n    if (arrowKind) {\n      if (tn.skip(Token.OpenBrace)) {\n        body = this.parseBlockStatement(tn, false);\n      } else {\n        let bodyExpression = this.parseExpression(tn, Precedence.Comma + 1);\n        if (bodyExpression) body = Node.createExpressionStatement(bodyExpression);\n      }\n    } else {\n      if (!tn.skip(Token.OpenBrace)) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(tn.pos), \"{\"\n        );\n        return null;\n      }\n      body = this.parseBlockStatement(tn, false);\n    }\n    if (!body) return null;\n\n    let declaration = Node.createFunctionDeclaration(\n      name,\n      null,\n      CommonFlags.None,\n      null,\n      signature,\n      body,\n      arrowKind,\n      tn.range(startPos, tn.pos)\n    );\n    return Node.createFunctionExpression(declaration);\n  }\n\n  parseClassOrInterface(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32\n  ): ClassDeclaration | null {\n\n    // at ('class' | 'interface'):\n    //   Identifier\n    //   ('<' TypeParameters)?\n    //   ('extends' Type)?\n    //   ('implements' Type (',' Type)*)?\n    //   '{' ClassMember* '}'\n\n    let isInterface = tn.token == Token.Interface;\n\n    if (!tn.skipIdentifier()) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n      return null;\n    }\n\n    let identifier = Node.createIdentifierExpression(\n      tn.readIdentifier(),\n      tn.range()\n    );\n\n    let typeParameters: TypeParameterNode[] | null = null;\n    if (tn.skip(Token.LessThan)) {\n      typeParameters = this.parseTypeParameters(tn);\n      if (!typeParameters) return null;\n      flags |= CommonFlags.Generic;\n    }\n\n    let extendsType: NamedTypeNode | null = null;\n    if (tn.skip(Token.Extends)) {\n      let type = this.parseType(tn);\n      if (!type) return null;\n      if (type.kind != NodeKind.NamedType) {\n        this.error(\n          DiagnosticCode.Identifier_expected,\n          type.range\n        );\n        return null;\n      }\n      extendsType = <NamedTypeNode>type;\n    }\n\n    let implementsTypes: NamedTypeNode[] | null = null;\n    if (tn.skip(Token.Implements)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode.Interface_declaration_cannot_have_implements_clause,\n          tn.range()\n        ); // recoverable\n      }\n      do {\n        let type = this.parseType(tn);\n        if (!type) return null;\n        if (type.kind != NodeKind.NamedType) {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            type.range\n          );\n          return null;\n        }\n        if (!isInterface) {\n          if (!implementsTypes) implementsTypes = [];\n          implementsTypes.push(<NamedTypeNode>type);\n        }\n      } while (tn.skip(Token.Comma));\n    }\n\n    if (!tn.skip(Token.OpenBrace)) {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"{\"\n      );\n      return null;\n    }\n\n    let members = new Array<DeclarationStatement>();\n    let declaration: ClassDeclaration;\n    if (isInterface) {\n      assert(!implementsTypes);\n      declaration = Node.createInterfaceDeclaration(\n        identifier,\n        decorators,\n        flags,\n        typeParameters,\n        extendsType,\n        null,\n        members,\n        tn.range(startPos, tn.pos)\n      );\n    } else {\n      declaration = Node.createClassDeclaration(\n        identifier,\n        decorators,\n        flags,\n        typeParameters,\n        extendsType,\n        implementsTypes,\n        members,\n        tn.range(startPos, tn.pos)\n      );\n    }\n    if (!tn.skip(Token.CloseBrace)) {\n      do {\n        let member = this.parseClassMember(tn, declaration);\n        if (member) {\n          if (member.kind == NodeKind.IndexSignature) {\n            declaration.indexSignature = <IndexSignatureNode>member;\n          } else {\n            assert(member instanceof DeclarationStatement);\n            members.push(<DeclarationStatement>member);\n          }\n        } else {\n          this.skipStatement(tn);\n          if (tn.skip(Token.EndOfFile)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"}\"\n            );\n            return null;\n          }\n        }\n      } while (!tn.skip(Token.CloseBrace));\n    }\n    declaration.range.end = tn.pos;\n    declaration.overriddenModuleName = this.currentModuleName;\n    return declaration;\n  }\n\n  parseClassExpression(tn: Tokenizer): ClassExpression | null {\n\n    // at 'class': Identifier? '{' ... '}'\n\n    let startPos = tn.tokenPos;\n    let name: IdentifierExpression;\n\n    if (tn.skipIdentifier()) {\n      name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    } else {\n      name = Node.createEmptyIdentifierExpression(tn.range(tn.pos));\n    }\n\n    if (!tn.skip(Token.OpenBrace)) {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(tn.pos), \"{\"\n      );\n      return null;\n    }\n\n    let members = new Array<DeclarationStatement>();\n    let declaration = Node.createClassDeclaration(\n      name,\n      null,\n      CommonFlags.None,\n      null,\n      null,\n      null,\n      members,\n      tn.range(startPos, tn.pos)\n    );\n    if (!tn.skip(Token.CloseBrace)) {\n      do {\n        let member = this.parseClassMember(tn, declaration);\n        if (member) {\n          if (member.kind == NodeKind.IndexSignature) {\n            declaration.indexSignature = <IndexSignatureNode>member;\n          } else {\n            assert(declaration instanceof DeclarationStatement);\n            members.push(<DeclarationStatement>member);\n          }\n        } else {\n          this.skipStatement(tn);\n          if (tn.skip(Token.EndOfFile)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"}\"\n            );\n            return null;\n          }\n        }\n      } while (!tn.skip(Token.CloseBrace));\n    }\n    declaration.range.end = tn.pos;\n    return Node.createClassExpression(declaration);\n  }\n\n  parseClassMember(\n    tn: Tokenizer,\n    parent: ClassDeclaration\n  ): Node | null {\n\n    // before:\n    //   'declare'?\n    //   ('public' | 'private' | 'protected')?\n    //   ('static' | 'abstract')?\n    //   'override'?\n    //   'readonly'?\n    //   ('get' | 'set')?\n    //   Identifier ...\n\n    let isInterface = parent.kind == NodeKind.InterfaceDeclaration;\n    let startPos = 0;\n    let decorators: DecoratorNode[] | null = null;\n    if (tn.skip(Token.At)) {\n      startPos = tn.tokenPos;\n      do {\n        let decorator = this.parseDecorator(tn);\n        if (!decorator) break;\n        if (!decorators) decorators = new Array();\n        decorators.push(decorator);\n      } while (tn.skip(Token.At));\n      if (isInterface && decorators) {\n        this.error(\n          DiagnosticCode.Decorators_are_not_valid_here,\n          Range.join(decorators[0].range, decorators[decorators.length - 1].range)\n        );\n      }\n    }\n\n    // inherit ambient status\n    let flags = parent.flags & CommonFlags.Ambient;\n\n    // interface methods are always overridden if used\n    if (isInterface) flags |= CommonFlags.Overridden;\n\n    let declareStart = 0;\n    let declareEnd = 0;\n    let contextIsAmbient = parent.is(CommonFlags.Ambient);\n    if (tn.skip(Token.Declare)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"declare\"\n        );\n      } else {\n        if (contextIsAmbient) {\n          this.error(\n            DiagnosticCode.A_declare_modifier_cannot_be_used_in_an_already_ambient_context,\n            tn.range()\n          ); // recoverable\n        } else {\n          flags |= CommonFlags.Declare | CommonFlags.Ambient;\n          declareStart = tn.tokenPos;\n          declareEnd = tn.pos;\n        }\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    } else if (contextIsAmbient) {\n      flags |= CommonFlags.Ambient;\n    }\n\n    let accessStart = 0;\n    let accessEnd = 0;\n    if (tn.skip(Token.Public)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"public\"\n        );\n      } else {\n        flags |= CommonFlags.Public;\n        accessStart = tn.tokenPos;\n        accessEnd = tn.pos;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    } else if (tn.skip(Token.Private)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"private\"\n        );\n      } else {\n        flags |= CommonFlags.Private;\n        accessStart = tn.tokenPos;\n        accessEnd = tn.pos;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    } else if (tn.skip(Token.Protected)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"protected\"\n        );\n      } else {\n        flags |= CommonFlags.Protected;\n        accessStart = tn.tokenPos;\n        accessEnd = tn.pos;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    }\n\n    let staticStart = 0;\n    let staticEnd = 0;\n    let abstractStart = 0;\n    let abstractEnd = 0;\n    if (tn.skip(Token.Static)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"static\"\n        );\n      } else {\n        flags |= CommonFlags.Static;\n        staticStart = tn.tokenPos;\n        staticEnd = tn.pos;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    } else {\n      flags |= CommonFlags.Instance;\n      if (tn.skip(Token.Abstract)) {\n        if (isInterface || !parent.is(CommonFlags.Abstract)) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(), \"abstract\"\n          );\n        } else {\n          flags |= CommonFlags.Abstract;\n          abstractStart = tn.tokenPos;\n          abstractEnd = tn.pos;\n        }\n        if (!startPos) startPos = tn.tokenPos;\n      }\n      if (parent.flags & CommonFlags.Generic) flags |= CommonFlags.GenericContext;\n    }\n\n    let overrideStart = 0;\n    let overrideEnd = 0;\n    if (tn.skip(Token.Override)) {\n      if (isInterface || parent.extendsType == null) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"override\"\n        );\n      } else {\n        flags |= CommonFlags.Override;\n        overrideStart = tn.tokenPos;\n        overrideEnd = tn.pos;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    }\n\n    let readonlyStart = 0;\n    let readonlyEnd = 0;\n    if (tn.peek() == Token.Readonly) {\n      let state = tn.mark();\n      tn.next();\n      if (tn.peek() != Token.Colon) { // modifier\n        tn.discard(state);\n        flags |= CommonFlags.Readonly;\n        readonlyStart = tn.tokenPos;\n        readonlyEnd = tn.pos;\n        if (!startPos) startPos = readonlyStart;\n      } else { // identifier\n        tn.reset(state);\n      }\n    }\n\n    // check if accessor: ('get' | 'set') ^\\n Identifier\n    let state = tn.mark();\n    let isConstructor = false;\n    let isGetter = false;\n    let getStart = 0;\n    let getEnd = 0;\n    let isSetter = false;\n    let setStart = 0;\n    let setEnd = 0;\n    if (!isInterface) {\n      if (tn.skip(Token.Get)) {\n        if (tn.peek(IdentifierHandling.Prefer) == Token.Identifier && !tn.peekOnNewLine()) {\n          flags |= CommonFlags.Get;\n          isGetter = true;\n          getStart = tn.tokenPos;\n          getEnd = tn.pos;\n          if (!startPos) startPos = getStart;\n          if (flags & CommonFlags.Readonly) {\n            this.error(\n              DiagnosticCode._0_modifier_cannot_be_used_here,\n              tn.range(readonlyStart, readonlyEnd), \"readonly\"\n            ); // recoverable\n          }\n        } else {\n          tn.reset(state);\n        }\n      } else if (tn.skip(Token.Set)) {\n        if (tn.peek(IdentifierHandling.Prefer) == Token.Identifier && !tn.peekOnNewLine()) {\n          flags |= CommonFlags.Set;\n          isSetter = true;\n          setStart = tn.tokenPos;\n          setEnd = tn.pos;\n          if (!startPos) startPos = setStart;\n          if (flags & CommonFlags.Readonly) {\n            this.error(\n              DiagnosticCode._0_modifier_cannot_be_used_here,\n              tn.range(readonlyStart, readonlyEnd), \"readonly\"\n            ); // recoverable\n          }\n        } else {\n          tn.reset(state);\n        }\n      } else if (tn.skip(Token.Constructor)) {\n        flags |= CommonFlags.Constructor;\n        isConstructor = true;\n        if (!startPos) startPos = tn.tokenPos;\n        if (flags & CommonFlags.Static) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(staticStart, staticEnd), \"static\"\n          ); // recoverable\n        }\n        if (flags & CommonFlags.Abstract) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(abstractStart, abstractEnd), \"abstract\"\n          ); // recoverable\n        }\n        if (flags & CommonFlags.Readonly) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(readonlyStart, readonlyEnd), \"readonly\"\n          ); // recoverable\n        }\n      }\n    }\n\n    let isGetterOrSetter = isGetter || isSetter;\n    let name: IdentifierExpression;\n    if (isConstructor) {\n      name = Node.createConstructorExpression(tn.range());\n    } else {\n      if (!isGetterOrSetter && tn.skip(Token.OpenBracket)) {\n        if (!startPos) startPos = tn.tokenPos;\n        // TODO: also handle symbols, which might have some of these modifiers\n        if (flags & CommonFlags.Public) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(accessStart, accessEnd), \"public\"\n          ); // recoverable\n        } else if (flags & CommonFlags.Protected) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(accessStart, accessEnd), \"protected\"\n          ); // recoverable\n        } else if (flags & CommonFlags.Private) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(accessStart, accessEnd), \"private\"\n          ); // recoverable\n        }\n        if (flags & CommonFlags.Static) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(staticStart, staticEnd), \"static\"\n          ); // recoverable\n        }\n        if (flags & CommonFlags.Override) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(overrideStart, overrideEnd), \"override\"\n          );\n        }\n        if (flags & CommonFlags.Abstract) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(abstractStart, abstractEnd), \"abstract\"\n          ); // recoverable\n        }\n        let retIndex = this.parseIndexSignature(tn, flags, decorators);\n        if (!retIndex) {\n          if (flags & CommonFlags.Readonly) {\n            this.error(\n              DiagnosticCode._0_modifier_cannot_be_used_here,\n              tn.range(readonlyStart, readonlyEnd), \"readonly\"\n            ); // recoverable\n          }\n          return null;\n        }\n        tn.skip(Token.Semicolon);\n        return retIndex;\n      }\n      if (!tn.skipIdentifier(IdentifierHandling.Always)) {\n        this.error(\n          DiagnosticCode.Identifier_expected,\n          tn.range()\n        );\n        return null;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n      name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    }\n    let typeParameters: TypeParameterNode[] | null = null;\n    if (tn.skip(Token.LessThan)) {\n      let typeParametersStart = tn.tokenPos;\n      typeParameters = this.parseTypeParameters(tn);\n      if (!typeParameters) return null;\n      if (isConstructor) {\n        this.error(\n          DiagnosticCode.Type_parameters_cannot_appear_on_a_constructor_declaration,\n          tn.range(typeParametersStart, tn.pos)\n        ); // recoverable\n      } else if (isGetterOrSetter) {\n        this.error(\n          DiagnosticCode.An_accessor_cannot_have_type_parameters,\n          tn.range(typeParametersStart, tn.pos)\n        ); // recoverable\n      } else {\n        flags |= CommonFlags.Generic;\n      }\n    }\n\n    // method: '(' Parameters (':' Type)? '{' Statement* '}' ';'?\n    if (tn.skip(Token.OpenParen)) {\n      if (flags & CommonFlags.Declare) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_appear_on_class_elements_of_this_kind,\n          tn.range(declareStart, declareEnd), \"declare\"\n        ); // recoverable\n      }\n\n      let signatureStart = tn.tokenPos;\n      let parameters = this.parseParameters(tn, isConstructor);\n      if (!parameters) return null;\n      let thisType = this.parseParametersThis;\n      if (isConstructor) {\n        for (let i = 0, k = parameters.length; i < k; ++i) {\n          let parameter = parameters[i];\n          if (parameter.isAny(\n            CommonFlags.Public |\n            CommonFlags.Protected |\n            CommonFlags.Private |\n            CommonFlags.Readonly\n          )) {\n            let implicitFieldDeclaration = Node.createFieldDeclaration(\n              parameter.name,\n              null,\n              parameter.flags | CommonFlags.Instance,\n              parameter.type,\n              null, // initialized via parameter\n              parameter.range\n            );\n            implicitFieldDeclaration.parameterIndex = i;\n            parameter.implicitFieldDeclaration = implicitFieldDeclaration;\n            parent.members.push(implicitFieldDeclaration);\n          }\n        }\n      } else if (isGetter) {\n        if (parameters.length) {\n          this.error(\n            DiagnosticCode.A_get_accessor_cannot_have_parameters,\n            name.range\n          );\n        }\n      } else if (isSetter) {\n        if (parameters.length != 1) {\n          this.error(\n            DiagnosticCode.A_set_accessor_must_have_exactly_one_parameter,\n            name.range\n          );\n        }\n        if (parameters.length > 0 && parameters[0].initializer) {\n          this.error(\n            DiagnosticCode.A_set_accessor_parameter_cannot_have_an_initializer,\n            name.range\n          );\n        }\n      } else if (name.text == \"constructor\") {\n        this.error(\n          DiagnosticCode._0_keyword_cannot_be_used_here,\n          name.range, \"constructor\"\n        );\n      }\n\n      let returnType: TypeNode | null = null;\n      if (tn.skip(Token.Colon)) {\n        if (name.kind == NodeKind.Constructor) {\n          this.error(\n            DiagnosticCode.Type_annotation_cannot_appear_on_a_constructor_declaration,\n            tn.range()\n          );\n        } else if (isSetter) {\n          this.error(\n            DiagnosticCode.A_set_accessor_cannot_have_a_return_type_annotation,\n            tn.range()\n          );\n        }\n        returnType = this.parseType(tn, isSetter || name.kind == NodeKind.Constructor);\n        if (!returnType) return null;\n      } else {\n        returnType = Node.createOmittedType(tn.range(tn.pos));\n        if (!isSetter && name.kind != NodeKind.Constructor) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            returnType.range\n          ); // recoverable\n        }\n      }\n\n      let signature = Node.createFunctionType(\n        parameters,\n        returnType,\n        thisType,\n        false,\n        tn.range(signatureStart, tn.pos)\n      );\n\n      let body: Statement | null = null;\n      if (tn.skip(Token.OpenBrace)) {\n        if (flags & CommonFlags.Ambient) {\n          this.error(\n            DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts,\n            tn.range()\n          ); // recoverable\n        } else if (flags & CommonFlags.Abstract) {\n          this.error(\n            DiagnosticCode.Method_0_cannot_have_an_implementation_because_it_is_marked_abstract,\n            tn.range(), name.text\n          ); // recoverable\n        } else if (isInterface) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \";\"\n          ); // recoverable\n        }\n        body = this.parseBlockStatement(tn, false);\n        if (!body) return null;\n      } else if (!isInterface && !(flags & (CommonFlags.Ambient | CommonFlags.Abstract))) {\n        this.error(\n          DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,\n          tn.range()\n        ); // recoverable\n      }\n\n      let retMethod = Node.createMethodDeclaration(\n        name,\n        decorators,\n        flags,\n        typeParameters,\n        signature,\n        body,\n        tn.range(startPos, tn.pos)\n      );\n      if (!(isInterface && tn.skip(Token.Comma))) {\n        tn.skip(Token.Semicolon);\n      }\n      return retMethod;\n\n    } else if (isConstructor) {\n      this.error(\n        DiagnosticCode.Constructor_implementation_is_missing,\n        name.range\n      );\n\n    } else if (isGetterOrSetter) {\n      this.error(\n        DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,\n        name.range\n      );\n\n    // field: (':' Type)? ('=' Expression)? ';'?\n    } else {\n      if (flags & CommonFlags.Declare) {\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          tn.range(declareStart, declareEnd), \"Ambient fields\"\n        ); // recoverable\n      }\n\n      if (flags & CommonFlags.Abstract) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(abstractStart, abstractEnd), \"abstract\"\n        ); // recoverable\n      }\n\n      if (flags & CommonFlags.Get) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(getStart, getEnd), \"get\"\n        ); // recoverable\n      }\n\n      if (flags & CommonFlags.Set) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(setStart, setEnd), \"set\"\n        ); // recoverable\n      }\n\n      let type: TypeNode | null = null;\n      if (tn.skip(Token.Question)) {\n        this.error(\n          DiagnosticCode.Optional_properties_are_not_supported,\n          tn.range(startPos, tn.pos)\n        );\n      }\n      if (tn.skip(Token.Exclamation)) {\n        flags |= CommonFlags.DefinitelyAssigned;\n      }\n      if (tn.skip(Token.Colon)) {\n        type = this.parseType(tn);\n        if (!type) return null;\n      } else {\n        this.error(\n          DiagnosticCode.Type_expected,\n          tn.range()\n        ); // recoverable\n      }\n      let initializer: Expression | null = null;\n      if (tn.skip(Token.Equals)) {\n        if (flags & CommonFlags.Ambient) {\n          this.error(\n            DiagnosticCode.Initializers_are_not_allowed_in_ambient_contexts,\n            tn.range()\n          ); // recoverable\n        }\n        initializer = this.parseExpression(tn);\n        if (!initializer) return null;\n        if (flags & CommonFlags.DefinitelyAssigned) {\n          this.error(\n            DiagnosticCode.Declarations_with_initializers_cannot_also_have_definite_assignment_assertions,\n            name.range\n          );\n        }\n      }\n      let range = tn.range(startPos, tn.pos);\n      if ((flags & CommonFlags.DefinitelyAssigned) != 0 && (isInterface || (flags & CommonFlags.Ambient) != 0)) {\n        this.error(\n          DiagnosticCode.A_definite_assignment_assertion_is_not_permitted_in_this_context,\n          range\n        );\n      }\n      let retField = Node.createFieldDeclaration(\n        name,\n        decorators,\n        flags,\n        type,\n        initializer,\n        range\n      );\n      if (!(isInterface && tn.skip(Token.Comma))) {\n        tn.skip(Token.Semicolon);\n      }\n      return retField;\n    }\n    return null;\n  }\n\n  parseIndexSignature(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n  ): IndexSignatureNode | null {\n\n    // at: '[': 'key' ':' Type ']' ':' Type\n\n    if (decorators && decorators.length > 0) {\n      this.error(\n        DiagnosticCode.Decorators_are_not_valid_here,\n        Range.join(decorators[0].range, decorators[decorators.length - 1].range)\n      ); // recoverable\n    }\n\n    let start = tn.tokenPos;\n    if (tn.skipIdentifier()) {\n      let id = tn.readIdentifier();\n      if (id == \"key\") {\n        if (tn.skip(Token.Colon)) {\n          let keyType = this.parseType(tn);\n          if (!keyType) return null;\n          if (keyType.kind != NodeKind.NamedType) {\n            this.error(\n              DiagnosticCode.Type_expected,\n              tn.range()\n            );\n            return null;\n          }\n          if (tn.skip(Token.CloseBracket)) {\n            if (tn.skip(Token.Colon)) {\n              let valueType = this.parseType(tn);\n              if (!valueType) return null;\n              if (valueType.kind != NodeKind.NamedType) {\n                this.error(\n                  DiagnosticCode.Identifier_expected,\n                  valueType.range\n                );\n                return null;\n              }\n              return Node.createIndexSignature(<NamedTypeNode>keyType, valueType, flags, tn.range(start, tn.pos));\n            } else {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \":\"\n              );\n            }\n          } else {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"]\"\n            );\n          }\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \":\"\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"key\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseNamespace(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32\n  ): NamespaceDeclaration | null {\n\n    // at 'namespace': Identifier '{' (Variable | Function)* '}'\n\n    if (tn.skipIdentifier()) {\n      let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      if (tn.skip(Token.OpenBrace)) {\n        let members = new Array<Statement>();\n        let declaration = Node.createNamespaceDeclaration(\n          identifier,\n          decorators,\n          flags,\n          members,\n          tn.range(startPos, tn.pos)\n        );\n        while (!tn.skip(Token.CloseBrace)) {\n          let member = this.parseTopLevelStatement(tn, declaration);\n          if (member) {\n            if (member.kind == NodeKind.Export) {\n              this.error(\n                DiagnosticCode.A_default_export_can_only_be_used_in_a_module,\n                member.range,\n              );\n              return null;\n            }\n            members.push(member);\n          } else {\n            this.skipStatement(tn);\n            if (tn.skip(Token.EndOfFile)) {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \"}\"\n              );\n              return null;\n            }\n          }\n        }\n        declaration.range.end = tn.pos;\n        declaration.overriddenModuleName = this.currentModuleName;\n        tn.skip(Token.Semicolon);\n        return declaration;\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"{\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseExport(\n    tn: Tokenizer,\n    startPos: i32,\n    isDeclare: bool\n  ): ExportStatement | null {\n\n    // at 'export': '{' ExportMember (',' ExportMember)* }' ('from' StringLiteral)? ';'?\n\n    let path: StringLiteralExpression | null = null;\n    let currentSource = assert(this.currentSource);\n    if (tn.skip(Token.OpenBrace)) {\n      let members = new Array<ExportMember>();\n      while (!tn.skip(Token.CloseBrace)) {\n        let member = this.parseExportMember(tn);\n        if (!member) return null;\n        members.push(member);\n        if (!tn.skip(Token.Comma)) {\n          if (tn.skip(Token.CloseBrace)) {\n            break;\n          } else {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"}\"\n            );\n            return null;\n          }\n        }\n      }\n      if (tn.skip(Token.From)) {\n        if (tn.skip(Token.StringLiteral)) {\n          path = Node.createStringLiteralExpression(tn.readString(), tn.range());\n        } else {\n          this.error(\n            DiagnosticCode.String_literal_expected,\n            tn.range()\n          );\n          return null;\n        }\n      }\n      let ret = Node.createExportStatement(members, path, isDeclare, tn.range(startPos, tn.pos));\n      if (path) {\n        let internalPath = assert(ret.internalPath);\n        if (!this.seenlog.has(internalPath)) {\n          this.dependees.set(internalPath, new Dependee(currentSource, path));\n          this.backlog.push(internalPath);\n          this.seenlog.add(internalPath);\n        }\n      }\n      tn.skip(Token.Semicolon);\n      return ret;\n    } else if (tn.skip(Token.Asterisk)) {\n      if (tn.skip(Token.From)) {\n        if (tn.skip(Token.StringLiteral)) {\n          path = Node.createStringLiteralExpression(tn.readString(), tn.range());\n          let ret = Node.createExportStatement(null, path, isDeclare, tn.range(startPos, tn.pos));\n          let internalPath = assert(ret.internalPath);\n          let source = tn.source;\n          let exportPaths = source.exportPaths;\n          if (!exportPaths) source.exportPaths = [ internalPath ];\n          else if (!exportPaths.includes(internalPath)) exportPaths.push(internalPath);\n          if (!this.seenlog.has(internalPath)) {\n            this.dependees.set(internalPath, new Dependee(currentSource, path));\n            this.backlog.push(internalPath);\n          }\n          tn.skip(Token.Semicolon);\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode.String_literal_expected,\n            tn.range()\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"from\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"{\"\n      );\n    }\n    return null;\n  }\n\n  parseExportMember(\n    tn: Tokenizer\n  ): ExportMember | null {\n\n    // before: Identifier ('as' Identifier)?\n\n    if (tn.skipIdentifier(IdentifierHandling.Always)) {\n      let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      let asIdentifier: IdentifierExpression | null = null;\n      if (tn.skip(Token.As)) {\n        if (tn.skipIdentifier(IdentifierHandling.Always)) {\n          asIdentifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n      }\n      if (asIdentifier) {\n        return Node.createExportMember(\n          identifier,\n          asIdentifier,\n          Range.join(identifier.range, asIdentifier.range)\n        );\n      }\n      return Node.createExportMember(\n        identifier,\n        null,\n        identifier.range\n      );\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseExportDefaultAlias(\n    tn: Tokenizer,\n    startPos: i32,\n    defaultStart: i32,\n    defaultEnd: i32\n  ): ExportStatement {\n\n    // at 'export' 'default': [Known-To-Be-]Identifier\n\n    let name = tn.readIdentifier();\n    let range = tn.range();\n    let ret = Node.createExportStatement([\n      Node.createExportMember(\n        Node.createIdentifierExpression(name, range),\n        Node.createIdentifierExpression(\"default\", tn.range(defaultStart, defaultEnd)),\n        range\n      )\n    ], null, false, tn.range(startPos, tn.pos));\n    tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseImport(\n    tn: Tokenizer\n  ): ImportStatement | null {\n\n    // at 'import':\n    //  ('{' (ImportMember (',' ImportMember)* '}') | ('*' 'as' Identifier)?\n    //  'from' StringLiteral ';'?\n\n    let startPos = tn.tokenPos;\n    let members: ImportDeclaration[] | null = null;\n    let namespaceName: IdentifierExpression | null = null;\n    let skipFrom = false;\n    if (tn.skip(Token.OpenBrace)) { // import { ... } from \"file\"\n      members = new Array();\n      while (!tn.skip(Token.CloseBrace)) {\n        let member = this.parseImportDeclaration(tn);\n        if (!member) return null;\n        members.push(member);\n        if (!tn.skip(Token.Comma)) {\n          if (tn.skip(Token.CloseBrace)) {\n            break;\n          } else {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"}\"\n            );\n            return null;\n          }\n        }\n      }\n    } else if (tn.skip(Token.Asterisk)) { // import * from \"file\"\n      if (tn.skip(Token.As)) {\n        if (tn.skipIdentifier()) {\n          namespaceName = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"as\"\n        );\n        return null;\n      }\n    } else if (tn.skip(Token.Identifier, IdentifierHandling.Prefer)) { // import Name from \"file\"\n      let name = tn.readIdentifier();\n      let range = tn.range();\n      members = [\n        Node.createImportDeclaration(\n          Node.createIdentifierExpression(\"default\", range),\n          Node.createIdentifierExpression(name, range),\n          range\n        )\n      ];\n      if (tn.skip(Token.Comma)) {\n        // TODO: default + star, default + members\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          tn.range(),\n          \"Mixed default and named imports\"\n        );\n        return null;\n      }\n    } else { // import \"file\"\n      skipFrom = true;\n    }\n\n    if (skipFrom || tn.skip(Token.From)) {\n      if (tn.skip(Token.StringLiteral)) {\n        let path = Node.createStringLiteralExpression(tn.readString(), tn.range());\n        let ret: ImportStatement;\n        if (namespaceName) {\n          assert(!members);\n          ret = Node.createWildcardImportStatement(namespaceName, path, tn.range(startPos, tn.pos));\n        } else {\n          ret = Node.createImportStatement(members, path, tn.range(startPos, tn.pos));\n        }\n        let internalPath = ret.internalPath;\n        if (!this.seenlog.has(internalPath)) {\n          this.dependees.set(internalPath, new Dependee(assert(this.currentSource), path));\n          this.backlog.push(internalPath);\n        }\n        tn.skip(Token.Semicolon);\n        return ret;\n      } else {\n        this.error(\n          DiagnosticCode.String_literal_expected,\n          tn.range()\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"from\"\n      );\n    }\n    return null;\n  }\n\n  parseImportDeclaration(\n    tn: Tokenizer\n  ): ImportDeclaration | null {\n\n    // before: Identifier ('as' Identifier)?\n\n    if (tn.skipIdentifier(IdentifierHandling.Always)) {\n      let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      let asIdentifier: IdentifierExpression | null = null;\n      if (tn.skip(Token.As)) {\n        if (tn.skipIdentifier()) {\n          asIdentifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n      }\n      if (asIdentifier) {\n        return Node.createImportDeclaration(\n          identifier,\n          asIdentifier,\n          Range.join(identifier.range, asIdentifier.range)\n        );\n      }\n      return Node.createImportDeclaration(\n        identifier,\n        null,\n        identifier.range\n      );\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseExportImport(\n    tn: Tokenizer,\n    startPos: i32\n  ): ExportImportStatement | null {\n\n    // at 'export' 'import': Identifier ('=' Identifier)? ';'?\n\n    if (tn.skipIdentifier()) {\n      let asIdentifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      if (tn.skip(Token.Equals)) {\n        if (tn.skipIdentifier()) {\n          let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n          let ret = Node.createExportImportStatement(identifier, asIdentifier, tn.range(startPos, tn.pos));\n          tn.skip(Token.Semicolon);\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"=\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseStatement(\n    tn: Tokenizer,\n    topLevel: bool = false\n  ): Statement | null {\n\n    // at previous token\n\n    let state = tn.mark();\n    let token = tn.next();\n    let statement: Statement | null = null;\n    switch (token) {\n      case Token.Break: {\n        statement = this.parseBreak(tn);\n        break;\n      }\n      case Token.Const: {\n        statement = this.parseVariable(tn, CommonFlags.Const, null, tn.tokenPos);\n        break;\n      }\n      case Token.Continue: {\n        statement = this.parseContinue(tn);\n        break;\n      }\n      case Token.Do: {\n        statement = this.parseDoStatement(tn);\n        break;\n      }\n      case Token.For: {\n        statement = this.parseForStatement(tn);\n        break;\n      }\n      case Token.If: {\n        statement = this.parseIfStatement(tn);\n        break;\n      }\n      case Token.Let: {\n        statement = this.parseVariable(tn, CommonFlags.Let, null, tn.tokenPos);\n        break;\n      }\n      case Token.Var: {\n        statement = this.parseVariable(tn, CommonFlags.None, null, tn.tokenPos);\n        break;\n      }\n      case Token.OpenBrace: {\n        statement = this.parseBlockStatement(tn, topLevel);\n        break;\n      }\n      case Token.Return: {\n        if (topLevel) {\n          this.error(\n            DiagnosticCode.A_return_statement_can_only_be_used_within_a_function_body,\n            tn.range()\n          ); // recoverable\n        }\n        statement = this.parseReturn(tn);\n        break;\n      }\n      case Token.Semicolon: {\n        return Node.createEmptyStatement(tn.range(tn.tokenPos));\n      }\n      case Token.Switch: {\n        statement = this.parseSwitchStatement(tn);\n        break;\n      }\n      case Token.Throw: {\n        statement = this.parseThrowStatement(tn);\n        break;\n      }\n      case Token.Try: {\n        statement = this.parseTryStatement(tn);\n        break;\n      }\n      case Token.Void: {\n        statement = this.parseVoidStatement(tn);\n        break;\n      }\n      case Token.While: {\n        statement = this.parseWhileStatement(tn);\n        break;\n      }\n      case Token.Type: { // also identifier\n        if (tn.peek(IdentifierHandling.Prefer) == Token.Identifier) {\n          statement = this.parseTypeDeclaration(tn, CommonFlags.None, null, tn.tokenPos);\n          break;\n        }\n        // fall-through\n      }\n      default: {\n        tn.reset(state);\n        statement = this.parseExpressionStatement(tn);\n        break;\n      }\n    }\n    if (!statement) { // has been reported\n      tn.reset(state);\n      this.skipStatement(tn);\n    } else {\n      tn.discard(state);\n    }\n    return statement;\n  }\n\n  parseBlockStatement(\n    tn: Tokenizer,\n    topLevel: bool\n  ): BlockStatement | null {\n\n    // at '{': Statement* '}' ';'?\n\n    let startPos = tn.tokenPos;\n    let statements = new Array<Statement>();\n    while (!tn.skip(Token.CloseBrace)) {\n      let state = tn.mark();\n      let statement = this.parseStatement(tn, topLevel);\n      if (!statement) {\n        if (tn.token == Token.EndOfFile) return null;\n        tn.reset(state);\n        this.skipStatement(tn);\n      } else {\n        tn.discard(state);\n        statements.push(statement);\n      }\n    }\n    let ret = Node.createBlockStatement(statements, tn.range(startPos, tn.pos));\n    if (topLevel) tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseBreak(\n    tn: Tokenizer\n  ): BreakStatement | null {\n\n    // at 'break': Identifier? ';'?\n\n    let identifier: IdentifierExpression | null = null;\n    if (tn.peek() == Token.Identifier && !tn.peekOnNewLine()) {\n      tn.next(IdentifierHandling.Prefer);\n      identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    }\n    let ret = Node.createBreakStatement(identifier, tn.range());\n    tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseContinue(\n    tn: Tokenizer\n  ): ContinueStatement | null {\n\n    // at 'continue': Identifier? ';'?\n\n    let identifier: IdentifierExpression | null = null;\n    if (tn.peek() == Token.Identifier && !tn.peekOnNewLine()) {\n      tn.next(IdentifierHandling.Prefer);\n      identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    }\n    let ret = Node.createContinueStatement(identifier, tn.range());\n    tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseDoStatement(\n    tn: Tokenizer\n  ): DoStatement | null {\n\n    // at 'do': Statement 'while' '(' Expression ')' ';'?\n\n    let startPos = tn.tokenPos;\n    let statement = this.parseStatement(tn);\n    if (!statement) return null;\n\n    if (tn.skip(Token.While)) {\n\n      if (tn.skip(Token.OpenParen)) {\n        let condition = this.parseExpression(tn);\n        if (!condition) return null;\n\n        if (tn.skip(Token.CloseParen)) {\n          let ret = Node.createDoStatement(statement, condition, tn.range(startPos, tn.pos));\n          tn.skip(Token.Semicolon);\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"(\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"while\"\n      );\n    }\n    return null;\n  }\n\n  parseExpressionStatement(\n    tn: Tokenizer\n  ): ExpressionStatement | null {\n\n    // at previous token\n\n    let expr = this.parseExpression(tn);\n    if (!expr) return null;\n\n    let ret = Node.createExpressionStatement(expr);\n    tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseForStatement(\n    tn: Tokenizer\n  ): Statement | null {\n\n    // at 'for': '(' Statement? Expression? ';' Expression? ')' Statement\n\n    let startPos = tn.tokenPos;\n\n    if (tn.skip(Token.OpenParen)) {\n      let initializer: Statement | null = null;\n\n      if (tn.skip(Token.Const)) {\n        initializer = this.parseVariable(tn, CommonFlags.Const, null, tn.tokenPos, true);\n      } else if (tn.skip(Token.Let)) {\n        initializer = this.parseVariable(tn, CommonFlags.Let, null, tn.tokenPos, true);\n      } else if (tn.skip(Token.Var)) {\n        initializer = this.parseVariable(tn, CommonFlags.None, null, tn.tokenPos, true);\n\n      } else if (!tn.skip(Token.Semicolon)) {\n        initializer = this.parseExpressionStatement(tn);\n        if (!initializer) return null;\n      }\n\n      if (initializer) {\n        if (tn.skip(Token.Of)) {\n          // TODO: for (let [key, val] of ...)\n          if (initializer.kind == NodeKind.Expression) {\n            if ((<ExpressionStatement>initializer).expression.kind != NodeKind.Identifier) {\n              this.error(\n                DiagnosticCode.Identifier_expected,\n                initializer.range\n              );\n              return null;\n            }\n            return this.parseForOfStatement(tn, startPos, initializer);\n          }\n          if (initializer.kind == NodeKind.Variable) {\n            let declarations = (<VariableStatement>initializer).declarations;\n            for (let i = 0, k = declarations.length; i < k; ++i) {\n              let declaration = declarations[i];\n              let initializer = declaration.initializer;\n              if (initializer) {\n                this.error(\n                  DiagnosticCode.The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer,\n                  initializer.range\n                ); // recoverable\n              }\n            }\n            return this.parseForOfStatement(tn, startPos, initializer);\n          }\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            initializer.range\n          );\n          return null;\n        }\n        // non-for..of needs type or initializer\n        if (initializer.kind == NodeKind.Variable) {\n          let declarations = (<VariableStatement>initializer).declarations;\n          for (let i = 0, k = declarations.length; i < k; ++i) {\n            let declaration = declarations[i];\n            if (!declaration.initializer) {\n              if (declaration.flags & CommonFlags.Const) {\n                this.error(\n                  DiagnosticCode._const_declarations_must_be_initialized,\n                  declaration.name.range\n                );\n              } else if (!declaration.type) {\n                this.error(\n                  DiagnosticCode.Type_expected,\n                  declaration.name.range.atEnd\n                );\n              }\n            }\n          }\n        }\n      }\n\n      if (tn.token == Token.Semicolon) {\n        let condition: ExpressionStatement | null = null;\n        if (!tn.skip(Token.Semicolon)) {\n          condition = this.parseExpressionStatement(tn);\n          if (!condition) return null;\n        }\n\n        if (tn.token == Token.Semicolon) {\n          let incrementor: Expression | null = null;\n          if (!tn.skip(Token.CloseParen)) {\n            incrementor = this.parseExpression(tn);\n            if (!incrementor) return null;\n\n            if (!tn.skip(Token.CloseParen)) {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \")\"\n              );\n              return null;\n            }\n          }\n\n          let statement = this.parseStatement(tn);\n          if (!statement) return null;\n\n          return Node.createForStatement(\n            initializer,\n            condition\n              ? condition.expression\n              : null,\n            incrementor,\n            statement,\n            tn.range(startPos, tn.pos)\n          );\n\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \";\"\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \";\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"(\"\n      );\n    }\n    return null;\n  }\n\n  parseForOfStatement(\n    tn: Tokenizer,\n    startPos: i32,\n    variable: Statement,\n  ): ForOfStatement | null {\n\n    // at 'of': Expression ')' Statement\n\n    let iterable = this.parseExpression(tn);\n    if (!iterable) return null;\n\n    if (!tn.skip(Token.CloseParen)) {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \")\"\n      );\n      return null;\n    }\n\n    let statement = this.parseStatement(tn);\n    if (!statement) return null;\n\n    return Node.createForOfStatement(\n      variable,\n      iterable,\n      statement,\n      tn.range(startPos, tn.pos)\n    );\n  }\n\n  parseIfStatement(\n    tn: Tokenizer\n  ): IfStatement | null {\n\n    // at 'if': '(' Expression ')' Statement ('else' Statement)?\n\n    let startPos = tn.tokenPos;\n    if (tn.skip(Token.OpenParen)) {\n      let condition = this.parseExpression(tn);\n      if (!condition) return null;\n      if (tn.skip(Token.CloseParen)) {\n        let statement = this.parseStatement(tn);\n        if (!statement) return null;\n        let elseStatement: Statement | null = null;\n        if (tn.skip(Token.Else)) {\n          elseStatement = this.parseStatement(tn);\n          if (!elseStatement) return null;\n        }\n        return Node.createIfStatement(\n          condition,\n          statement,\n          elseStatement,\n          tn.range(startPos, tn.pos)\n        );\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \")\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"(\"\n      );\n    }\n    return null;\n  }\n\n  parseSwitchStatement(\n    tn: Tokenizer\n  ): SwitchStatement | null {\n\n    // at 'switch': '(' Expression ')' '{' SwitchCase* '}' ';'?\n\n    let startPos = tn.tokenPos;\n    if (tn.skip(Token.OpenParen)) {\n      let condition = this.parseExpression(tn);\n      if (!condition) return null;\n      if (tn.skip(Token.CloseParen)) {\n        if (tn.skip(Token.OpenBrace)) {\n          let switchCases = new Array<SwitchCase>();\n          while (!tn.skip(Token.CloseBrace)) {\n            let switchCase = this.parseSwitchCase(tn);\n            if (!switchCase) return null;\n            switchCases.push(switchCase);\n          }\n          let ret = Node.createSwitchStatement(condition, switchCases, tn.range(startPos, tn.pos));\n          tn.skip(Token.Semicolon);\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"{\"\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \")\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"(\"\n      );\n    }\n    return null;\n  }\n\n  parseSwitchCase(\n    tn: Tokenizer\n  ): SwitchCase | null {\n\n    let startPos = tn.tokenPos;\n    let statements: Statement[],\n        statement: Statement | null;\n\n    // 'case' Expression ':' Statement*\n\n    if (tn.skip(Token.Case)) {\n      let label = this.parseExpression(tn);\n      if (!label) return null;\n      if (tn.skip(Token.Colon)) {\n        statements = new Array<Statement>();\n        while (\n          tn.peek() != Token.Case &&\n          tn.nextToken != Token.Default &&\n          tn.nextToken != Token.CloseBrace\n        ) {\n          statement = this.parseStatement(tn);\n          if (!statement) return null;\n          statements.push(statement);\n        }\n        return Node.createSwitchCase(label, statements, tn.range(startPos, tn.pos));\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \":\"\n        );\n      }\n\n      // 'default' ':' Statement*\n\n    } else if (tn.skip(Token.Default)) {\n      if (tn.skip(Token.Colon)) {\n        statements = new Array<Statement>();\n        while (\n          tn.peek() != Token.Case &&\n          tn.nextToken != Token.Default &&\n          tn.nextToken != Token.CloseBrace\n        ) {\n          statement = this.parseStatement(tn);\n          if (!statement) return null;\n          statements.push(statement);\n        }\n        return Node.createSwitchCase(null, statements, tn.range(startPos, tn.pos));\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \":\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._case_or_default_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseThrowStatement(\n    tn: Tokenizer\n  ): ThrowStatement | null {\n\n    // at 'throw': Expression ';'?\n\n    let startPos = tn.tokenPos;\n    let expression = this.parseExpression(tn);\n    if (!expression) return null;\n    let ret = Node.createThrowStatement(expression, tn.range(startPos, tn.pos));\n    if (!tn.skip(Token.Semicolon)) this.checkASI(tn);\n    return ret;\n  }\n\n  parseTryStatement(\n    tn: Tokenizer\n  ): TryStatement | null {\n\n    // at 'try':\n    //   '{' Statement* '}'\n    //   ('catch' '(' VariableMember ')' '{' Statement* '}')?\n    //   ('finally' '{' Statement* '}'? ';'?\n\n    let startPos = tn.tokenPos;\n    let stmt: Statement | null;\n    if (tn.skip(Token.OpenBrace)) {\n      let bodyStatements = new Array<Statement>();\n      while (!tn.skip(Token.CloseBrace)) {\n        stmt = this.parseStatement(tn);\n        if (!stmt) return null;\n        bodyStatements.push(stmt);\n      }\n      let catchVariable: IdentifierExpression | null = null;\n      let catchStatements: Statement[] | null = null;\n      let finallyStatements: Statement[] | null = null;\n      if (tn.skip(Token.Catch)) {\n        if (!tn.skip(Token.OpenParen)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"(\"\n          );\n          return null;\n        }\n        if (!tn.skipIdentifier()) {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n        catchVariable = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n        if (!tn.skip(Token.CloseParen)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n          return null;\n        }\n        if (!tn.skip(Token.OpenBrace)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"{\"\n          );\n          return null;\n        }\n        catchStatements = [];\n        while (!tn.skip(Token.CloseBrace)) {\n          stmt = this.parseStatement(tn);\n          if (!stmt) return null;\n          catchStatements.push(stmt);\n        }\n      }\n      if (tn.skip(Token.Finally)) {\n        if (!tn.skip(Token.OpenBrace)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"{\"\n          );\n          return null;\n        }\n        finallyStatements = [];\n        while (!tn.skip(Token.CloseBrace)) {\n          stmt = this.parseStatement(tn);\n          if (!stmt) return null;\n          finallyStatements.push(stmt);\n        }\n      }\n      if (!(catchStatements || finallyStatements)) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"catch\"\n        );\n        return null;\n      }\n      let ret = Node.createTryStatement(\n        bodyStatements,\n        catchVariable,\n        catchStatements,\n        finallyStatements,\n        tn.range(startPos, tn.pos)\n      );\n      tn.skip(Token.Semicolon);\n      return ret;\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"{\"\n      );\n    }\n    return null;\n  }\n\n  parseTypeDeclaration(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32\n  ): TypeDeclaration | null {\n\n    // at 'type': Identifier ('<' TypeParameters '>')? '=' '|'? Type ';'?\n\n    if (tn.skipIdentifier()) {\n      let name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      let typeParameters: TypeParameterNode[] | null = null;\n      if (tn.skip(Token.LessThan)) {\n        typeParameters = this.parseTypeParameters(tn);\n        if (!typeParameters) return null;\n        flags |= CommonFlags.Generic;\n      }\n      if (tn.skip(Token.Equals)) {\n        tn.skip(Token.Bar);\n        let type = this.parseType(tn);\n        if (!type) return null;\n        if (isCircularTypeAlias(name.text, type)) {\n          this.error(\n            DiagnosticCode.Type_alias_0_circularly_references_itself,\n            name.range, name.text\n          );\n          return null;\n        }\n        let ret = Node.createTypeDeclaration(\n          name,\n          decorators,\n          flags,\n          typeParameters,\n          type,\n          tn.range(startPos, tn.pos)\n        );\n        tn.skip(Token.Semicolon);\n        ret.overriddenModuleName = this.currentModuleName;\n        return ret;\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"=\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseModuleDeclaration(\n    tn: Tokenizer,\n    flags: CommonFlags\n  ): ModuleDeclaration | null {\n\n    // at 'module': StringLiteral ';'?\n\n    let startPos = tn.tokenPos;\n    assert(tn.next() == Token.StringLiteral); // checked earlier\n    let moduleName = tn.readString();\n    let ret = Node.createModuleDeclaration(moduleName, flags, tn.range(startPos, tn.pos));\n    this.currentModuleName = moduleName;\n    tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseVoidStatement(\n    tn: Tokenizer\n  ): VoidStatement | null {\n\n    // at 'void': Expression ';'?\n\n    let startPos = tn.tokenPos;\n    let expression = this.parseExpression(tn, Precedence.Grouping);\n    if (!expression) return null;\n    let ret = Node.createVoidStatement(expression, tn.range(startPos, tn.pos));\n    tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseWhileStatement(\n    tn: Tokenizer\n  ): WhileStatement | null {\n\n    // at 'while': '(' Expression ')' Statement ';'?\n\n    let startPos = tn.tokenPos;\n    if (tn.skip(Token.OpenParen)) {\n      let expression = this.parseExpression(tn);\n      if (!expression) return null;\n      if (tn.skip(Token.CloseParen)) {\n        let statement = this.parseStatement(tn);\n        if (!statement) return null;\n        let ret = Node.createWhileStatement(expression, statement, tn.range(startPos, tn.pos));\n        tn.skip(Token.Semicolon);\n        return ret;\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \")\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"(\"\n      );\n    }\n    return null;\n  }\n\n  // expressions\n\n  parseExpressionStart(\n    tn: Tokenizer\n  ): Expression | null {\n    let token = tn.next(IdentifierHandling.Prefer);\n    let startPos = tn.tokenPos;\n    switch (token) {\n\n      // TODO: SpreadExpression, YieldExpression\n      case Token.Dot_Dot_Dot:\n      case Token.Yield: // fallthrough to unsupported UnaryPrefixExpression\n\n      // UnaryPrefixExpression\n      case Token.Exclamation:\n      case Token.Tilde:\n      case Token.Plus:\n      case Token.Minus:\n      case Token.TypeOf:\n      case Token.Void:\n      case Token.Delete: {\n        let operand = this.parseExpression(tn, Precedence.UnaryPrefix);\n        if (!operand) return null;\n        return Node.createUnaryPrefixExpression(token, operand, tn.range(startPos, tn.pos));\n      }\n      case Token.Plus_Plus:\n      case Token.Minus_Minus: {\n        let operand = this.parseExpression(tn, Precedence.UnaryPrefix);\n        if (!operand) return null;\n        switch (operand.kind) {\n          case NodeKind.Identifier:\n          case NodeKind.ElementAccess:\n          case NodeKind.PropertyAccess: break;\n          default: {\n            this.error(\n              DiagnosticCode.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access,\n              operand.range\n            );\n          }\n        }\n        return Node.createUnaryPrefixExpression(token, operand, tn.range(startPos, tn.pos));\n      }\n\n      // NewExpression\n      case Token.New: {\n        if (!tn.skipIdentifier()) {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n        let typeName = this.parseTypeName(tn);\n        if (!typeName) return null;\n        let typeArguments: TypeNode[] | null = null;\n        let arguments_: Expression[] | null = null;\n        if (\n          tn.skip(Token.OpenParen) ||\n          (typeArguments = this.tryParseTypeArgumentsBeforeArguments(tn))\n        ) {\n          arguments_ = this.parseArguments(tn);\n          if (!arguments_) return null;\n        } else {\n          arguments_ = []; // new Type;\n        }\n        return Node.createNewExpression(\n          typeName,\n          typeArguments,\n          arguments_,\n          tn.range(startPos, tn.pos)\n        );\n      }\n\n      // Special IdentifierExpression\n      case Token.Null: return Node.createNullExpression(tn.range());\n      case Token.True: return Node.createTrueExpression(tn.range());\n      case Token.False: return Node.createFalseExpression(tn.range());\n      case Token.This: return Node.createThisExpression(tn.range());\n      case Token.Constructor: return Node.createConstructorExpression(tn.range());\n\n      // ParenthesizedExpression or FunctionExpression\n      case Token.OpenParen: {\n\n        // determine whether this is a function expression\n        if (tn.skip(Token.CloseParen)) { // must be a function expression (fast route)\n          return this.parseFunctionExpressionCommon(\n            tn,\n            Node.createEmptyIdentifierExpression(tn.range(startPos)),\n            [],\n            null,\n            ArrowKind.Parenthesized\n          );\n        }\n        let state = tn.mark();\n        let again = true;\n        do {\n          switch (tn.next(IdentifierHandling.Prefer)) {\n\n            // function expression\n            case Token.Dot_Dot_Dot: {\n              tn.reset(state);\n              return this.parseFunctionExpression(tn);\n            }\n            // can be both\n            case Token.Identifier: {\n              tn.readIdentifier();\n              switch (tn.next()) {\n\n                // if we got here, check for arrow\n                case Token.CloseParen: {\n                  // `Identifier):Type =>` is function expression\n                  if (tn.skip(Token.Colon)) {\n                    let type = this.parseType(tn, true, true);\n                    if (type == null) {\n                      again = false;\n                      break;\n                    }\n                  }\n                  if (!tn.skip(Token.Equals_GreaterThan)) {\n                    again = false;\n                    break;\n                  }\n                  // fall-through\n                }\n                // function expression\n                case Token.Colon: {    // type annotation\n                  tn.reset(state);\n                  return this.parseFunctionExpression(tn);\n                }\n                // optional parameter or parenthesized\n                case Token.Question: {\n                  if (\n                    tn.skip(Token.Colon) ||   // optional parameter with type\n                    tn.skip(Token.Comma) ||   // optional parameter without type\n                    tn.skip(Token.CloseParen) // last optional parameter without type\n                  ) {\n                    tn.reset(state);\n                    return this.parseFunctionExpression(tn);\n                  }\n                  again = false; // parenthesized\n                  break;\n                }\n                case Token.Comma: {\n                  break; // continue\n                }\n                // parenthesized expression\n                // case Token.EQUALS:  // missing type annotation for simplicity\n                default: {\n                  again = false;\n                  break;\n                }\n              }\n              break;\n            }\n            // parenthesized expression\n            default: {\n              again = false;\n              break;\n            }\n          }\n        } while (again);\n        tn.reset(state);\n\n        // parse parenthesized\n        let inner = this.parseExpression(tn);\n        if (!inner) return null;\n        if (!tn.skip(Token.CloseParen)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n          return null;\n        }\n        inner = Node.createParenthesizedExpression(inner, tn.range(startPos, tn.pos));\n        return this.maybeParseCallExpression(tn, inner);\n      }\n      // ArrayLiteralExpression\n      case Token.OpenBracket: {\n        let elementExpressions = new Array<Expression>();\n        while (!tn.skip(Token.CloseBracket)) {\n          let expr: Expression | null;\n          if (tn.peek() == Token.Comma) {\n            expr = Node.createOmittedExpression(tn.range(tn.pos));\n          } else {\n            expr = this.parseExpression(tn, Precedence.Comma + 1);\n            if (!expr) return null;\n          }\n          elementExpressions.push(expr);\n          if (!tn.skip(Token.Comma)) {\n            if (tn.skip(Token.CloseBracket)) {\n              break;\n            } else {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \"]\"\n              );\n              return null;\n            }\n          }\n        }\n        return Node.createArrayLiteralExpression(elementExpressions, tn.range(startPos, tn.pos));\n      }\n      // ObjectLiteralExpression\n      case Token.OpenBrace: {\n        let startPos = tn.tokenPos;\n        let names = new Array<IdentifierExpression>();\n        let values = new Array<Expression>();\n        let name: IdentifierExpression;\n        while (!tn.skip(Token.CloseBrace)) {\n          if (!tn.skipIdentifier()) {\n            if (!tn.skip(Token.StringLiteral)) {\n              this.error(\n                DiagnosticCode.Identifier_expected,\n                tn.range(),\n              );\n              return null;\n            }\n            name = Node.createIdentifierExpression(tn.readString(), tn.range());\n            name.isQuoted = true;\n          } else {\n            name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n          }\n          names.push(name);\n          if (tn.skip(Token.Colon)) {\n            let value = this.parseExpression(tn, Precedence.Comma + 1);\n            if (!value) return null;\n            values.push(value);\n          } else if (!name.isQuoted) {\n            values.push(name);\n          } else {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \":\"\n            );\n            return null;\n          }\n          if (!tn.skip(Token.Comma)) {\n            if (tn.skip(Token.CloseBrace)) {\n              break;\n            } else {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \"}\"\n              );\n              return null;\n            }\n          }\n        }\n        return Node.createObjectLiteralExpression(names, values, tn.range(startPos, tn.pos));\n      }\n      // AssertionExpression (unary prefix)\n      case Token.LessThan: {\n        let toType = this.parseType(tn);\n        if (!toType) return null;\n        if (!tn.skip(Token.GreaterThan)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \">\"\n          );\n          return null;\n        }\n        let expr = this.parseExpression(tn, Precedence.Call);\n        if (!expr) return null;\n        return Node.createAssertionExpression(\n          AssertionKind.Prefix,\n          expr,\n          toType,\n          tn.range(startPos, tn.pos)\n        );\n      }\n      case Token.Identifier: {\n        let identifierText = tn.readIdentifier();\n        if (identifierText == \"null\") return Node.createNullExpression(tn.range()); // special\n        let identifier = Node.createIdentifierExpression(identifierText, tn.range(startPos, tn.pos));\n        if (tn.skip(Token.TemplateLiteral)) {\n          return this.parseTemplateLiteral(tn, identifier);\n        }\n        if (tn.peek() == Token.Equals_GreaterThan && !tn.peekOnNewLine()) {\n          return this.parseFunctionExpressionCommon(\n            tn,\n            Node.createEmptyIdentifierExpression(tn.range(startPos)),\n            [\n              Node.createParameter(\n                ParameterKind.Default,\n                identifier,\n                Node.createOmittedType(identifier.range.atEnd),\n                null,\n                identifier.range\n              )\n            ],\n            null,\n            ArrowKind.Single,\n            startPos\n          );\n        }\n        return this.maybeParseCallExpression(tn, identifier, true);\n      }\n      case Token.Super: {\n        if (tn.peek() != Token.Dot && tn.nextToken != Token.OpenParen) {\n          this.error(\n            DiagnosticCode._super_must_be_followed_by_an_argument_list_or_member_access,\n            tn.range()\n          );\n        }\n        let expr = Node.createSuperExpression(tn.range(startPos, tn.pos));\n        return this.maybeParseCallExpression(tn, expr);\n      }\n      case Token.StringLiteral: {\n        return Node.createStringLiteralExpression(tn.readString(), tn.range(startPos, tn.pos));\n      }\n      case Token.TemplateLiteral: {\n        return this.parseTemplateLiteral(tn);\n      }\n      case Token.IntegerLiteral: {\n        let value = tn.readInteger();\n        tn.checkForIdentifierStartAfterNumericLiteral();\n        return Node.createIntegerLiteralExpression(value, tn.range(startPos, tn.pos));\n      }\n      case Token.FloatLiteral: {\n        let value = tn.readFloat();\n        tn.checkForIdentifierStartAfterNumericLiteral();\n        return Node.createFloatLiteralExpression(value, tn.range(startPos, tn.pos));\n      }\n      // RegexpLiteralExpression\n      // note that this also continues on invalid ones so the surrounding AST remains intact\n      case Token.Slash: {\n        let regexpPattern = tn.readRegexpPattern(); // also reports\n        if (!tn.skip(Token.Slash)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"/\"\n          );\n          return null;\n        }\n        return Node.createRegexpLiteralExpression(\n          regexpPattern,\n          tn.readRegexpFlags(), // also reports\n          tn.range(startPos, tn.pos)\n        );\n      }\n      case Token.Function: {\n        let expr = this.parseFunctionExpression(tn);\n        if (!expr) return null;\n        return this.maybeParseCallExpression(tn, expr);\n      }\n      case Token.Class: {\n        return this.parseClassExpression(tn);\n      }\n      default: {\n        if (token == Token.EndOfFile) {\n          this.error(\n            DiagnosticCode.Unexpected_end_of_text,\n            tn.range(startPos)\n          );\n        } else {\n          this.error(\n            DiagnosticCode.Expression_expected,\n            tn.range()\n          );\n        }\n        return null;\n      }\n    }\n  }\n\n  tryParseTypeArgumentsBeforeArguments(\n    tn: Tokenizer\n  ): TypeNode[] | null {\n\n    // at '<': Type (',' Type)* '>' '('\n\n    let state = tn.mark();\n    if (!tn.skip(Token.LessThan)) return null;\n    let start = tn.tokenPos;\n    let typeArguments: TypeNode[] | null = null;\n    do {\n      if (tn.peek() == Token.GreaterThan) {\n        break;\n      }\n      let type = this.parseType(tn, true, true);\n      if (!type) {\n        tn.reset(state);\n        return null;\n      }\n      if (!typeArguments) typeArguments = [ type ];\n      else typeArguments.push(type);\n    } while (tn.skip(Token.Comma));\n    if (tn.skip(Token.GreaterThan)) {\n      let end = tn.pos;\n      if (tn.skip(Token.OpenParen)) {\n        if (!typeArguments) {\n          this.error(\n            DiagnosticCode.Type_argument_list_cannot_be_empty,\n            tn.range(start, end)\n          );\n        }\n        return typeArguments;\n      }\n    }\n    tn.reset(state);\n    return null;\n  }\n\n  parseArguments(\n    tn: Tokenizer\n  ): Expression[] | null {\n\n    // at '(': (Expression (',' Expression)*)? ')'\n\n    let args = new Array<Expression>();\n    while (!tn.skip(Token.CloseParen)) {\n      let expr = this.parseExpression(tn, Precedence.Comma + 1);\n      if (!expr) return null;\n      args.push(expr);\n      if (!tn.skip(Token.Comma)) {\n        if (tn.skip(Token.CloseParen)) {\n          break;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n          return null;\n        }\n      }\n    }\n    return args;\n  }\n\n  parseExpression(\n    tn: Tokenizer,\n    precedence: Precedence = Precedence.Comma\n  ): Expression | null {\n    assert(precedence != Precedence.None);\n    let expr = this.parseExpressionStart(tn);\n    if (!expr) return null;\n    let startPos = expr.range.start;\n\n    // precedence climbing\n    // see: http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm#climbing\n    let nextPrecedence: Precedence;\n    while (\n      (nextPrecedence = determinePrecedence(tn.peek())) >= precedence\n    ) {\n      let token = tn.next();\n      switch (token) {\n\n        // AssertionExpression\n        case Token.As: {\n          if (tn.skip(Token.Const)) {\n            expr = Node.createAssertionExpression(\n              AssertionKind.Const,\n              expr,\n              null,\n              tn.range(startPos, tn.pos)\n            );\n          } else {\n            let toType = this.parseType(tn); // reports\n            if (!toType) return null;\n            expr = Node.createAssertionExpression(\n              AssertionKind.As,\n              expr,\n              toType,\n              tn.range(startPos, tn.pos)\n            );\n          }\n          break;\n        }\n        case Token.Exclamation: {\n          expr = Node.createAssertionExpression(\n            AssertionKind.NonNull,\n            expr,\n            null,\n            tn.range(startPos, tn.pos)\n          );\n          expr = this.maybeParseCallExpression(tn, expr);\n          break;\n        }\n        // InstanceOfExpression\n        case Token.InstanceOf: {\n          let isType = this.parseType(tn); // reports\n          if (!isType) return null;\n          expr = Node.createInstanceOfExpression(\n            expr,\n            isType,\n            tn.range(startPos, tn.pos)\n          );\n          break;\n        }\n        // ElementAccessExpression\n        case Token.OpenBracket: {\n          let next = this.parseExpression(tn); // reports\n          if (!next) return null;\n          if (!tn.skip(Token.CloseBracket)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"]\"\n            );\n            return null;\n          }\n          expr = Node.createElementAccessExpression(\n            expr,\n            next,\n            tn.range(startPos, tn.pos)\n          );\n          expr = this.maybeParseCallExpression(tn, expr);\n          break;\n        }\n        // UnaryPostfixExpression\n        case Token.Plus_Plus:\n        case Token.Minus_Minus: {\n          if (\n            expr.kind != NodeKind.Identifier &&\n            expr.kind != NodeKind.ElementAccess &&\n            expr.kind != NodeKind.PropertyAccess\n          ) {\n            this.error(\n              DiagnosticCode.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access,\n              expr.range\n            );\n          }\n          expr = Node.createUnaryPostfixExpression(\n            token,\n            expr,\n            tn.range(startPos, tn.pos)\n          );\n          break;\n        }\n        // TernaryExpression\n        case Token.Question: {\n          let ifThen = this.parseExpression(tn);\n          if (!ifThen) return null;\n          if (!tn.skip(Token.Colon)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \":\"\n            );\n            return null;\n          }\n          let ifElse = this.parseExpression(tn, precedence > Precedence.Comma\n            ? Precedence.Comma + 1\n            : Precedence.Comma\n          );\n          if (!ifElse) return null;\n          expr = Node.createTernaryExpression(\n            expr,\n            ifThen,\n            ifElse,\n            tn.range(startPos, tn.pos)\n          );\n          break;\n        }\n        // CommaExpression\n        case Token.Comma: {\n          let commaExprs: Expression[] = [ expr ];\n          do {\n            expr = this.parseExpression(tn, Precedence.Comma + 1);\n            if (!expr) return null;\n            commaExprs.push(expr);\n          } while (tn.skip(Token.Comma));\n          expr = Node.createCommaExpression(commaExprs, tn.range(startPos, tn.pos));\n          break;\n        }\n        // PropertyAccessExpression\n        case Token.Dot: {\n          if (tn.skipIdentifier(IdentifierHandling.Always)) { // expr '.' Identifier\n            let next = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n            expr = Node.createPropertyAccessExpression(\n              expr,\n              next,\n              tn.range(startPos, tn.pos)\n            );\n          } else {\n            let next = this.parseExpression(tn, nextPrecedence + 1);\n            if (!next) return null;\n            if (next.kind == NodeKind.Call) { // expr '.' CallExpression\n              expr = this.joinPropertyCall(tn, startPos, expr, <CallExpression>next);\n              if (!expr) return null;\n            } else {\n              this.error(\n                DiagnosticCode.Identifier_expected,\n                next.range\n              );\n              return null;\n            }\n          }\n          if (tn.skip(Token.TemplateLiteral)) {\n            expr = this.parseTemplateLiteral(tn, expr);\n            if (!expr) return null;\n          } else {\n            expr = this.maybeParseCallExpression(tn, expr, true);\n          }\n          break;\n        }\n        // BinaryExpression (right associative)\n        case Token.Equals:\n        case Token.Plus_Equals:\n        case Token.Minus_Equals:\n        case Token.Asterisk_Asterisk_Equals:\n        case Token.Asterisk_Equals:\n        case Token.Slash_Equals:\n        case Token.Percent_Equals:\n        case Token.LessThan_LessThan_Equals:\n        case Token.GreaterThan_GreaterThan_Equals:\n        case Token.GreaterThan_GreaterThan_GreaterThan_Equals:\n        case Token.Ampersand_Equals:\n        case Token.Caret_Equals:\n        case Token.Bar_Equals:\n        case Token.Asterisk_Asterisk: {\n          let next = this.parseExpression(tn, nextPrecedence);\n          if (!next) return null;\n          expr = Node.createBinaryExpression(token, expr, next, tn.range(startPos, tn.pos));\n          break;\n        }\n        // BinaryExpression\n        case Token.LessThan:\n        case Token.GreaterThan:\n        case Token.LessThan_Equals:\n        case Token.GreaterThan_Equals:\n        case Token.Equals_Equals:\n        case Token.Equals_Equals_Equals:\n        case Token.Exclamation_Equals_Equals:\n        case Token.Exclamation_Equals:\n        case Token.Plus:\n        case Token.Minus:\n        case Token.Asterisk:\n        case Token.Slash:\n        case Token.Percent:\n        case Token.LessThan_LessThan:\n        case Token.GreaterThan_GreaterThan:\n        case Token.GreaterThan_GreaterThan_GreaterThan:\n        case Token.Ampersand:\n        case Token.Bar:\n        case Token.Caret:\n        case Token.Ampersand_Ampersand:\n        case Token.Bar_Bar:\n        case Token.In: {\n          let next = this.parseExpression(tn, nextPrecedence + 1);\n          if (!next) return null;\n          expr = Node.createBinaryExpression(token, expr, next, tn.range(startPos, tn.pos));\n          break;\n        }\n        default: assert(false); // filtered by determinePrecedence\n      }\n    }\n    return expr;\n  }\n\n  private parseTemplateLiteral(tn: Tokenizer, tag: Expression | null = null): Expression | null {\n    // at '`': ... '`'\n    let startPos = tag ? tag.range.start : tn.tokenPos;\n    let parts = new Array<string>();\n    let rawParts = new Array<string>();\n    let exprs = new Array<Expression>();\n    parts.push(tn.readString(0, tag != null));\n    rawParts.push(tn.source.text.substring(tn.readStringStart, tn.readStringEnd));\n    while (tn.readingTemplateString) {\n      let expr = this.parseExpression(tn);\n      if (!expr) return null;\n      exprs.push(expr);\n      if (!tn.skip(Token.CloseBrace)) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"}\"\n        );\n        return null;\n      }\n      parts.push(tn.readString(CharCode.Backtick, tag != null));\n      rawParts.push(tn.source.text.substring(tn.readStringStart, tn.readStringEnd));\n    }\n    return Node.createTemplateLiteralExpression(tag, parts, rawParts, exprs, tn.range(startPos, tn.pos));\n  }\n\n  private joinPropertyCall(\n    tn: Tokenizer,\n    startPos: i32,\n    expr: Expression,\n    call: CallExpression\n  ): Expression | null {\n    let callee = call.expression;\n    switch (callee.kind) {\n      case NodeKind.Identifier: { // join property access and use as call target\n        call.expression = Node.createPropertyAccessExpression(\n          expr,\n          <IdentifierExpression>callee,\n          tn.range(startPos, tn.pos)\n        );\n        break;\n      }\n      case NodeKind.Call: { // join call target und wrap the original call around it\n        let inner = this.joinPropertyCall(tn, startPos, expr, <CallExpression>callee);\n        if (!inner) return null;\n        call.expression = inner;\n        call.range = tn.range(startPos, tn.pos);\n        break;\n      }\n      default: {\n        this.error(\n          DiagnosticCode.Identifier_expected,\n          call.range\n        );\n        return null;\n      }\n    }\n    return call;\n  }\n\n  private maybeParseCallExpression(\n    tn: Tokenizer,\n    expr: Expression,\n    potentiallyGeneric: bool = false\n  ): Expression {\n    let typeArguments: TypeNode[] | null = null;\n    while (\n      tn.skip(Token.OpenParen) ||\n      potentiallyGeneric &&\n      (typeArguments = this.tryParseTypeArgumentsBeforeArguments(tn))\n    ) {\n      let args = this.parseArguments(tn);\n      if (!args) break;\n      expr = Node.createCallExpression( // is again callable\n        expr,\n        typeArguments,\n        args,\n        tn.range(expr.range.start, tn.pos)\n      );\n      potentiallyGeneric = false;\n    }\n    return expr;\n  }\n\n  private checkASI(\n    tn: Tokenizer\n  ): void {\n    // see: https://tc39.es/ecma262/#sec-automatic-semicolon-insertion\n    let nextToken = tn.peek();\n    if (nextToken == Token.EndOfFile || nextToken == Token.CloseBrace || tn.peekOnNewLine()) return;\n    this.error(\n      DiagnosticCode.Unexpected_token,\n      tn.range(tn.nextTokenPos)\n    );\n  }\n\n  /** Skips over a statement on errors in an attempt to reduce unnecessary diagnostic noise. */\n  skipStatement(tn: Tokenizer): void {\n    if (tn.peekOnNewLine()) tn.next(); // if reset() to the previous line\n    do {\n      let nextToken = tn.peek();\n      if (\n        nextToken == Token.EndOfFile ||   // next step should handle this\n        nextToken == Token.Semicolon      // end of the statement for sure\n      ) {\n        tn.next();\n        break;\n      }\n      if (tn.peekOnNewLine()) break;   // end of the statement maybe\n      switch (tn.next()) {\n        case Token.Identifier: {\n          tn.readIdentifier();\n          break;\n        }\n        case Token.StringLiteral:\n        case Token.TemplateLiteral: {\n          tn.readString();\n          break;\n        }\n        case Token.IntegerLiteral: {\n          tn.readInteger();\n          tn.checkForIdentifierStartAfterNumericLiteral();\n          break;\n        }\n        case Token.FloatLiteral: {\n          tn.readFloat();\n          tn.checkForIdentifierStartAfterNumericLiteral();\n          break;\n        }\n        case Token.OpenBrace: {\n          this.skipBlock(tn);\n          break;\n        }\n      }\n    } while (true);\n    tn.readingTemplateString = false;\n  }\n\n  /** Skips over a block on errors in an attempt to reduce unnecessary diagnostic noise. */\n  skipBlock(tn: Tokenizer): void {\n    // at '{': ... '}'\n    let depth = 1;\n    let again = true;\n    do {\n      switch (tn.next()) {\n        case Token.EndOfFile: {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"}\"\n          );\n          again = false;\n          break;\n        }\n        case Token.OpenBrace: {\n          ++depth;\n          break;\n        }\n        case Token.CloseBrace: {\n          --depth;\n          if (!depth) again = false;\n          break;\n        }\n        case Token.Identifier: {\n          tn.readIdentifier();\n          break;\n        }\n        case Token.StringLiteral:{\n          tn.readString();\n          break;\n        }\n        case Token.TemplateLiteral: {\n          tn.readString();\n          while(tn.readingTemplateString){\n            this.skipBlock(tn);\n            tn.readString(CharCode.Backtick);\n          }\n          break;\n        }\n        case Token.IntegerLiteral: {\n          tn.readInteger();\n          tn.checkForIdentifierStartAfterNumericLiteral();\n          break;\n        }\n        case Token.FloatLiteral: {\n          tn.readFloat();\n          tn.checkForIdentifierStartAfterNumericLiteral();\n          break;\n        }\n      }\n    } while (again);\n  }\n}\n\n/** Operator precedence from least to largest. */\nexport const enum Precedence {\n  None,\n  Comma,\n  Spread,\n  Yield,\n  Assignment,\n  Conditional,\n  LogicalOr,\n  LogicalAnd,\n  BitwiseOr,\n  BitwiseXor,\n  BitwiseAnd,\n  Equality,\n  Relational,\n  Shift,\n  Additive,\n  Multiplicative,\n  Exponentiated,\n  UnaryPrefix,\n  UnaryPostfix,\n  Call,\n  MemberAccess,\n  Grouping\n}\n\n/** Determines the precedence of a non-starting token. */\nfunction determinePrecedence(kind: Token): Precedence {\n  switch (kind) {\n    case Token.Comma: return Precedence.Comma;\n    case Token.Equals:\n    case Token.Plus_Equals:\n    case Token.Minus_Equals:\n    case Token.Asterisk_Asterisk_Equals:\n    case Token.Asterisk_Equals:\n    case Token.Slash_Equals:\n    case Token.Percent_Equals:\n    case Token.LessThan_LessThan_Equals:\n    case Token.GreaterThan_GreaterThan_Equals:\n    case Token.GreaterThan_GreaterThan_GreaterThan_Equals:\n    case Token.Ampersand_Equals:\n    case Token.Caret_Equals:\n    case Token.Bar_Equals: return Precedence.Assignment;\n    case Token.Question: return Precedence.Conditional;\n    case Token.Bar_Bar: return Precedence.LogicalOr;\n    case Token.Ampersand_Ampersand: return Precedence.LogicalAnd;\n    case Token.Bar: return Precedence.BitwiseOr;\n    case Token.Caret: return Precedence.BitwiseXor;\n    case Token.Ampersand: return Precedence.BitwiseAnd;\n    case Token.Equals_Equals:\n    case Token.Exclamation_Equals:\n    case Token.Equals_Equals_Equals:\n    case Token.Exclamation_Equals_Equals: return Precedence.Equality;\n    case Token.As:\n    case Token.In:\n    case Token.InstanceOf:\n    case Token.LessThan:\n    case Token.GreaterThan:\n    case Token.LessThan_Equals:\n    case Token.GreaterThan_Equals: return Precedence.Relational;\n    case Token.LessThan_LessThan:\n    case Token.GreaterThan_GreaterThan:\n    case Token.GreaterThan_GreaterThan_GreaterThan: return Precedence.Shift;\n    case Token.Plus:\n    case Token.Minus: return Precedence.Additive;\n    case Token.Asterisk:\n    case Token.Slash:\n    case Token.Percent: return Precedence.Multiplicative;\n    case Token.Asterisk_Asterisk: return Precedence.Exponentiated;\n    case Token.Plus_Plus:\n    case Token.Minus_Minus: return Precedence.UnaryPostfix;\n    case Token.Dot:\n    case Token.OpenBracket:\n    case Token.Exclamation: return Precedence.MemberAccess;\n  }\n  return Precedence.None;\n}\n\n/** Checks if the type alias of the given name and type is circular. */\nfunction isCircularTypeAlias(name: string, type: TypeNode): bool {\n  switch (type.kind) {\n    case NodeKind.NamedType: {\n      if ((<NamedTypeNode>type).name.identifier.text == name) {\n        return true;\n      }\n      let typeArguments = (<NamedTypeNode>type).typeArguments;\n      if (typeArguments) {\n        for (let i = 0, k = typeArguments.length; i < k; i++) {\n          if (isCircularTypeAlias(name, typeArguments[i])) return true;\n        }\n      }\n      break;\n    }\n    case NodeKind.FunctionType: {\n      let functionType = <FunctionTypeNode>type;\n      if (isCircularTypeAlias(name, functionType.returnType)) return true;\n      let parameters = functionType.parameters;\n      for (let i = 0, k = parameters.length; i < k; i++) {\n        if (isCircularTypeAlias(name, parameters[i].type)) return true;\n      }\n      break;\n    }\n    default: assert(false);\n  }\n  return false;\n}\n", "/**\n * @fileoverview AssemblyScript's intermediate representation.\n *\n * The compiler uses Binaryen IR, which is fairly low level, as its\n * primary intermediate representation, with the following structures\n * holding any higher level information that cannot be represented by\n * Binaryen IR alone, for example higher level types.\n *\n * Similar to the AST being composed of `Node`s in `Source`s, the IR is\n * composed of `Element`s in a `Program`. Each class or function is\n * represented by a \"prototype\" holding all the relevant information,\n * including each's concrete instances. If a class or function is not\n * generic, there is exactly one instance, otherwise there is one for\n * each concrete set of type arguments.\n *\n * @license Apache-2.0\n */\n\n// Element                    Base class of all elements\n// \u251C\u2500DeclaredElement          Base class of elements with a declaration\n// \u2502 \u251C\u2500TypedElement           Base class of elements resolving to a type\n// \u2502 \u2502 \u251C\u2500TypeDefinition       Type alias declaration\n// \u2502 \u2502 \u251C\u2500VariableLikeElement  Base class of all variable-like elements\n// \u2502 \u2502 \u2502 \u251C\u2500EnumValue          Enum value\n// \u2502 \u2502 \u2502 \u251C\u2500Global             File global\n// \u2502 \u2502 \u2502 \u251C\u2500Local              Function local\n// \u2502 \u2502 \u2502 \u2514\u2500Property           Class property (incl. instance fields)\n// \u2502 \u2502 \u251C\u2500IndexSignature       Class index signature\n// \u2502 \u2502 \u251C\u2500Function             Concrete function instance\n// \u2502 \u2502 \u2514\u2500Class                Concrete class instance\n// \u2502 \u251C\u2500Namespace              Namespace with static members\n// \u2502 \u251C\u2500FunctionPrototype      Prototype of concrete function instances\n// \u2502 \u251C\u2500PropertyPrototype      Prototype of concrete property instances\n// \u2502 \u2514\u2500ClassPrototype         Prototype of concrete class instances\n// \u2514\u2500File                     File, analogous to Source in the AST\n\nimport {\n  CommonFlags,\n  PATH_DELIMITER,\n  STATIC_DELIMITER,\n  INSTANCE_DELIMITER,\n  GETTER_PREFIX,\n  SETTER_PREFIX,\n  INNER_DELIMITER,\n  INDEX_SUFFIX,\n  STUB_DELIMITER,\n  CommonNames,\n  Feature,\n  Target,\n  featureToString\n} from \"./common\";\n\nimport {\n  Options\n} from \"./compiler\";\n\nimport {\n  Range,\n  DiagnosticCode,\n  DiagnosticMessage,\n  DiagnosticEmitter\n} from \"./diagnostics\";\n\nimport {\n  Type,\n  TypeKind,\n  Signature,\n  TypeFlags\n} from \"./types\";\n\nimport {\n  Token\n} from \"./tokenizer\";\n\nimport {\n  Node,\n  NodeKind,\n  Source,\n  SourceKind,\n  DecoratorNode,\n  DecoratorKind,\n  TypeParameterNode,\n  TypeNode,\n  NamedTypeNode,\n  FunctionTypeNode,\n  ArrowKind,\n\n  Expression,\n  IdentifierExpression,\n  LiteralKind,\n  StringLiteralExpression,\n\n  Statement,\n  ClassDeclaration,\n  DeclarationStatement,\n  EnumDeclaration,\n  EnumValueDeclaration,\n  ExportMember,\n  ExportDefaultStatement,\n  ExportStatement,\n  FieldDeclaration,\n  FunctionDeclaration,\n  ImportDeclaration,\n  ImportStatement,\n  InterfaceDeclaration,\n  MethodDeclaration,\n  NamespaceDeclaration,\n  TypeDeclaration,\n  VariableDeclaration,\n  VariableLikeDeclarationStatement,\n  VariableStatement,\n  ParameterKind,\n  ParameterNode,\n  TypeName\n} from \"./ast\";\n\nimport {\n  Module,\n  ExpressionRef,\n  FunctionRef,\n  MemorySegment,\n  getFunctionName\n} from \"./module\";\n\nimport {\n  CharCode,\n  writeI8,\n  writeI16,\n  writeI32,\n  writeF32,\n  writeF64,\n  writeI64,\n  writeI32AsI64,\n  writeI64AsI32\n} from \"./util\";\n\nimport {\n  Resolver\n} from \"./resolver\";\n\nimport {\n  Flow,\n  LocalFlags\n} from \"./flow\";\n\nimport {\n  Parser\n} from \"./parser\";\n\nimport {\n  BuiltinNames,\n  builtinFunctions,\n  builtinVariables_onAccess\n} from \"./builtins\";\n\n// Memory manager constants\nconst AL_SIZE = 16;\nconst AL_MASK = AL_SIZE - 1;\n\n/** Represents a yet unresolved `import`. */\nclass QueuedImport {\n  constructor(\n    /** File being imported into. */\n    public localFile: File,\n    /** Identifier within the local file. */\n    public localIdentifier: IdentifierExpression,\n    /** Identifier within the other file. Is an `import *` if not set. */\n    public foreignIdentifier: IdentifierExpression | null,\n    /** Path to the other file. */\n    public foreignPath: string,\n    /** Alternative path to the other file. */\n    public foreignPathAlt: string\n  ) {}\n}\n\n/** Represents a yet unresolved `export`. */\nclass QueuedExport {\n  constructor(\n    /** Identifier within the local file. */\n    public localIdentifier: IdentifierExpression,\n    /** Identifier within the other file. */\n    public foreignIdentifier: IdentifierExpression,\n    /** Path to the other file if a re-export. */\n    public foreignPath: string | null,\n    /** Alternative path to the other file if a re-export. */\n    public foreignPathAlt: string | null\n  ) {}\n}\n\n/** Represents a yet unresolved `export *`. */\nclass QueuedExportStar {\n  // stored in a map with localFile as the key\n  constructor(\n    /** Path to the other file. */\n    public foreignPath: string,\n    /** Alternative path to the other file. */\n    public foreignPathAlt: string,\n    /** Reference to the path literal for reporting. */\n    public pathLiteral: StringLiteralExpression\n  ) {}\n}\n\n/** Represents the kind of an operator overload. */\nexport enum OperatorKind {\n  Invalid,\n\n  // indexed access\n  IndexedGet,          // a[]\n  IndexedSet,          // a[]=b\n  UncheckedIndexedGet, // unchecked(a[])\n  UncheckedIndexedSet, // unchecked(a[]=b)\n\n  // binary\n  Add,                 // a + b\n  Sub,                 // a - b\n  Mul,                 // a * b\n  Div,                 // a / b\n  Rem,                 // a % b\n  Pow,                 // a ** b\n  BitwiseAnd,          // a & b\n  BitwiseOr,           // a | b\n  BitwiseXor,          // a ^ b\n  BitwiseShl,          // a << b\n  BitwiseShr,          // a >> b\n  BitwiseShrU,         // a >>> b\n  Eq,                  // a == b, a === b\n  Ne,                  // a != b, a !== b\n  Gt,                  // a > b\n  Ge,                  // a >= b\n  Lt,                  // a < b\n  Le,                  // a <= b\n\n  // unary prefix\n  Plus,                // +a\n  Minus,               // -a\n  Not,                 // !a\n  BitwiseNot,          // ~a\n  PrefixInc,           // ++a\n  PrefixDec,           // --a\n\n  // unary postfix\n  PostfixInc,          // a++\n  PostfixDec           // a--\n\n  // not overridable:\n  // LogicalAnd        // a && b\n  // LogicalOr         // a || b\n}\n\nexport namespace OperatorKind {\n\n  /** Returns the operator kind represented by the specified decorator and string argument. */\n  export function fromDecorator(decoratorKind: DecoratorKind, arg: string): OperatorKind {\n    assert(arg.length);\n    switch (decoratorKind) {\n      case DecoratorKind.Operator:\n      case DecoratorKind.OperatorBinary: {\n        switch (arg.charCodeAt(0)) {\n          case CharCode.OpenBracket: {\n            if (arg == \"[]\") return OperatorKind.IndexedGet;\n            if (arg == \"[]=\") return OperatorKind.IndexedSet;\n            break;\n          }\n          case CharCode.OpenBrace: {\n            if (arg == \"{}\") return OperatorKind.UncheckedIndexedGet;\n            if (arg == \"{}=\") return OperatorKind.UncheckedIndexedSet;\n            break;\n          }\n          case CharCode.Plus: {\n            if (arg == \"+\") return OperatorKind.Add;\n            break;\n          }\n          case CharCode.Minus: {\n            if (arg == \"-\") return OperatorKind.Sub;\n            break;\n          }\n          case CharCode.Asterisk: {\n            if (arg == \"*\") return OperatorKind.Mul;\n            if (arg == \"**\") return OperatorKind.Pow;\n            break;\n          }\n          case CharCode.Slash: {\n            if (arg == \"/\") return OperatorKind.Div;\n            break;\n          }\n          case CharCode.Percent: {\n            if (arg == \"%\") return OperatorKind.Rem;\n            break;\n          }\n          case CharCode.Ampersand: {\n            if (arg == \"&\") return OperatorKind.BitwiseAnd;\n            break;\n          }\n          case CharCode.Bar: {\n            if (arg == \"|\") return OperatorKind.BitwiseOr;\n            break;\n          }\n          case CharCode.Caret: {\n            if (arg == \"^\") return OperatorKind.BitwiseXor;\n            break;\n          }\n          case CharCode.Equals: {\n            if (arg == \"==\") return OperatorKind.Eq;\n            break;\n          }\n          case CharCode.Exclamation: {\n            if (arg == \"!=\") return OperatorKind.Ne;\n            break;\n          }\n          case CharCode.GreaterThan: {\n            if (arg == \">\") return OperatorKind.Gt;\n            if (arg == \">=\") return OperatorKind.Ge;\n            if (arg == \">>\") return OperatorKind.BitwiseShr;\n            if (arg == \">>>\") return OperatorKind.BitwiseShrU;\n            break;\n          }\n          case CharCode.LessThan: {\n            if (arg == \"<\") return OperatorKind.Lt;\n            if (arg == \"<=\") return OperatorKind.Le;\n            if (arg == \"<<\") return OperatorKind.BitwiseShl;\n            break;\n          }\n        }\n        break;\n      }\n      case DecoratorKind.OperatorPrefix: {\n        switch (arg.charCodeAt(0)) {\n          case CharCode.Plus: {\n            if (arg == \"+\") return OperatorKind.Plus;\n            if (arg == \"++\") return OperatorKind.PrefixInc;\n            break;\n          }\n          case CharCode.Minus: {\n            if (arg == \"-\") return OperatorKind.Minus;\n            if (arg == \"--\") return OperatorKind.PrefixDec;\n            break;\n          }\n          case CharCode.Exclamation: {\n            if (arg == \"!\") return OperatorKind.Not;\n            break;\n          }\n          case CharCode.Tilde: {\n            if (arg == \"~\") return OperatorKind.BitwiseNot;\n            break;\n          }\n        }\n        break;\n      }\n      case DecoratorKind.OperatorPostfix: {\n        switch (arg.charCodeAt(0)) {\n          case CharCode.Plus: {\n            if (arg == \"++\") return OperatorKind.PostfixInc;\n            break;\n          }\n          case CharCode.Minus: {\n            if (arg == \"--\") return OperatorKind.PostfixDec;\n            break;\n          }\n        }\n        break;\n      }\n    }\n    return OperatorKind.Invalid;\n  }\n\n  /** Converts a binary operator token to the respective operator kind. */\n  export function fromBinaryToken(token: Token): OperatorKind {\n    switch (token) {\n      case Token.Plus:\n      case Token.Plus_Equals: return OperatorKind.Add;\n      case Token.Minus:\n      case Token.Minus_Equals: return OperatorKind.Sub;\n      case Token.Asterisk:\n      case Token.Asterisk_Equals: return OperatorKind.Mul;\n      case Token.Slash:\n      case Token.Slash_Equals: return OperatorKind.Div;\n      case Token.Percent:\n      case Token.Percent_Equals: return OperatorKind.Rem;\n      case Token.Asterisk_Asterisk:\n      case Token.Asterisk_Asterisk_Equals: return OperatorKind.Pow;\n      case Token.Ampersand:\n      case Token.Ampersand_Equals: return OperatorKind.BitwiseAnd;\n      case Token.Bar:\n      case Token.Bar_Equals: return OperatorKind.BitwiseOr;\n      case Token.Caret:\n      case Token.Caret_Equals: return OperatorKind.BitwiseXor;\n      case Token.LessThan_LessThan:\n      case Token.LessThan_LessThan_Equals: return OperatorKind.BitwiseShl;\n      case Token.GreaterThan_GreaterThan:\n      case Token.GreaterThan_GreaterThan_Equals: return OperatorKind.BitwiseShr;\n      case Token.GreaterThan_GreaterThan_GreaterThan:\n      case Token.GreaterThan_GreaterThan_GreaterThan_Equals: return OperatorKind.BitwiseShrU;\n      case Token.Equals_Equals: \n      case Token.Equals_Equals_Equals: return OperatorKind.Eq;\n      case Token.Exclamation_Equals: \n      case Token.Exclamation_Equals_Equals: return OperatorKind.Ne;\n      case Token.GreaterThan: return OperatorKind.Gt;\n      case Token.GreaterThan_Equals: return OperatorKind.Ge;\n      case Token.LessThan: return OperatorKind.Lt;\n      case Token.LessThan_Equals: return OperatorKind.Le;\n    }\n    return OperatorKind.Invalid;\n  }\n\n  /** Converts a unary prefix operator token to the respective operator kind. */\n  export function fromUnaryPrefixToken(token: Token): OperatorKind {\n    switch (token) {\n      case Token.Plus: return OperatorKind.Plus;\n      case Token.Minus: return OperatorKind.Minus;\n      case Token.Exclamation: return OperatorKind.Not;\n      case Token.Tilde: return OperatorKind.BitwiseNot;\n      case Token.Plus_Plus: return OperatorKind.PrefixInc;\n      case Token.Minus_Minus: return OperatorKind.PrefixDec;\n    }\n    return OperatorKind.Invalid;\n  }\n\n  /** Converts a unary postfix operator token to the respective operator kind. */\n  export function fromUnaryPostfixToken(token: Token): OperatorKind {\n    switch (token) {\n      case Token.Plus_Plus: return OperatorKind.PostfixInc;\n      case Token.Minus_Minus: return OperatorKind.PostfixDec;\n    }\n    return OperatorKind.Invalid;\n  }\n}\n\n/** Represents an AssemblyScript program. */\nexport class Program extends DiagnosticEmitter {\n\n  /** Constructs a new program, optionally inheriting parser diagnostics. */\n  constructor(\n    /** Compiler options. */\n    public options: Options,\n    /** Shared array of diagnostic messages (emitted so far). */\n    diagnostics: DiagnosticMessage[] | null = null\n  ) {\n    super(diagnostics);\n    this.module = Module.create(options.stackSize > 0, options.sizeTypeRef);    \n    this.parser = new Parser(this.diagnostics, this.sources);\n    this.resolver = new Resolver(this);\n    let nativeFile = new File(this, Source.native);\n    this.nativeFile = nativeFile;\n    this.filesByName.set(nativeFile.internalName, nativeFile);\n  }\n\n  /** Module instance. */\n  module: Module;\n  /** Parser instance. */\n  parser!: Parser;\n  /** Resolver instance. */\n  resolver!: Resolver;\n  /** Array of sources. */\n  sources: Source[] = [];\n  /** Diagnostic offset used where successively obtaining the next diagnostic. */\n  diagnosticsOffset: i32 = 0;\n  /** Special native code file. */\n  nativeFile!: File;\n  /** Next class id. */\n  nextClassId: u32 = 0;\n  /** Next signature id. */\n  nextSignatureId: i32 = 0;\n  /** An indicator if the program has been initialized. */\n  initialized: bool = false;\n\n  // Lookup maps\n\n  /** Files by unique internal name. */\n  filesByName: Map<string,File> = new Map();\n  /** Elements by unique internal name in element space. */\n  elementsByName: Map<string,Element> = new Map();\n  /** Elements by declaration. */\n  elementsByDeclaration: Map<DeclarationStatement,DeclaredElement> = new Map();\n  /** Element instances by unique internal name. */\n  instancesByName: Map<string,Element> = new Map();\n  /** Classes wrapping basic types like `i32`. */\n  wrapperClasses: Map<Type,Class> = new Map();\n  /** Managed classes contained in the program, by id. */\n  managedClasses: Map<i32,Class> = new Map();\n  /** A set of unique function signatures contained in the program, by id. */\n  uniqueSignatures: Map<string, Signature> = new Map<string, Signature>();\n  /** Module imports. */\n  moduleImports: Map<string,Map<string,Element>> = new Map();\n\n  // Standard library\n\n  /** Gets the standard `ArrayBufferView` instance. */\n  get arrayBufferViewInstance(): Class {\n    let cached = this._arrayBufferViewInstance;\n    if (!cached) this._arrayBufferViewInstance = cached = this.requireClass(CommonNames.ArrayBufferView);\n    return cached;\n  }\n  private _arrayBufferViewInstance: Class | null = null;\n\n  /** Gets the standard `ArrayBuffer` instance. */\n  get arrayBufferInstance(): Class {\n    let cached = this._arrayBufferInstance;\n    if (!cached) this._arrayBufferInstance = cached = this.requireClass(CommonNames.ArrayBuffer);\n    return cached;\n  }\n  private _arrayBufferInstance: Class | null = null;\n\n  /** Gets the standard `Array` prototype. */\n  get arrayPrototype(): ClassPrototype {\n    let cached = this._arrayPrototype;\n    if (!cached) this._arrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _arrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `StaticArray` prototype. */\n  get staticArrayPrototype(): ClassPrototype {\n    let cached = this._staticArrayPrototype;\n    if (!cached) this._staticArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.StaticArray, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _staticArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Set` prototype. */\n  get setPrototype(): ClassPrototype {\n    let cached = this._setPrototype;\n    if (!cached) this._setPrototype = cached = <ClassPrototype>this.require(CommonNames.Set, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _setPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Map` prototype. */\n  get mapPrototype(): ClassPrototype {\n    let cached = this._mapPrototype;\n    if (!cached) this._mapPrototype = cached = <ClassPrototype>this.require(CommonNames.Map, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _mapPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Function` prototype. */\n  get functionPrototype(): ClassPrototype {\n    let cached = this._functionPrototype;\n    if (!cached) this._functionPrototype = cached = <ClassPrototype>this.require(CommonNames.Function, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _functionPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Int8Array` prototype. */\n  get int8ArrayPrototype(): ClassPrototype {\n    let cached = this._int8ArrayPrototype;\n    if (!cached) this._int8ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Int8Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _int8ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Int16Array` prototype. */\n  get int16ArrayPrototype(): ClassPrototype {\n    let cached = this._int16ArrayPrototype;\n    if (!cached) this._int16ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Int16Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _int16ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Int32Array` prototype. */\n  get int32ArrayPrototype(): ClassPrototype {\n    let cached = this._int32ArrayPrototype;\n    if (!cached) this._int32ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Int32Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _int32ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Int64Array` prototype. */\n  get int64ArrayPrototype(): ClassPrototype {\n    let cached = this._int64ArrayPrototype;\n    if (!cached) this._int64ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Int64Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _int64ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Uint8Array` prototype. */\n  get uint8ArrayPrototype(): ClassPrototype {\n    let cached = this._uint8ArrayPrototype;\n    if (!cached) this._uint8ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint8Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _uint8ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Uint8ClampedArray` prototype. */\n  get uint8ClampedArrayPrototype(): ClassPrototype {\n    let cached = this._uint8ClampedArrayPrototype;\n    if (!cached) this._uint8ClampedArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint8ClampedArray, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _uint8ClampedArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Uint16Array` prototype. */\n  get uint16ArrayPrototype(): ClassPrototype {\n    let cached = this._uint16ArrayPrototype;\n    if (!cached) this._uint16ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint16Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _uint16ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Uint32Array` prototype. */\n  get uint32ArrayPrototype(): ClassPrototype {\n    let cached = this._uint32ArrayPrototype;\n    if (!cached) this._uint32ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint32Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _uint32ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Uint64Array` prototype. */\n  get uint64ArrayPrototype(): ClassPrototype {\n    let cached = this._uint64ArrayPrototype;\n    if (!cached) this._uint64ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint64Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _uint64ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Float32Array` prototype. */\n  get float32ArrayPrototype(): ClassPrototype {\n    let cached = this._float32ArrayPrototype;\n    if (!cached) this._float32ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Float32Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _float32ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Float64Array` prototype. */\n  get float64ArrayPrototype(): ClassPrototype {\n    let cached = this._float64ArrayPrototype;\n    if (!cached) this._float64ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Float64Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _float64ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `String` instance. */\n  get stringInstance(): Class {\n    let cached = this._stringInstance;\n    if (!cached) this._stringInstance = cached = this.requireClass(CommonNames.String);\n    return cached;\n  }\n  private _stringInstance: Class | null = null;\n\n  /** Gets the standard `RegExp` instance. */\n  get regexpInstance(): Class {\n    let cached = this._regexpInstance;\n    if (!cached) this._regexpInstance = cached = this.requireClass(CommonNames.RegExp);\n    return cached;\n  }\n  private _regexpInstance: Class | null = null;\n\n  /** Gets the standard `Object` prototype. */\n  get objectPrototype(): ClassPrototype {\n    let cached = this._objectPrototype;\n    if (!cached) this._objectPrototype = cached = <ClassPrototype>this.require(CommonNames.Object, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _objectPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Object` instance. */\n  get objectInstance(): Class {\n    let cached = this._objectInstance;\n    if (!cached) this._objectInstance = cached = this.requireClass(CommonNames.Object);\n    return cached;\n  }\n  private _objectInstance: Class | null = null;\n\n  /** Gets the standard `TemplateStringsArray` instance. */\n  get templateStringsArrayInstance(): Class {\n    let cached = this._templateStringsArrayInstance;\n    if (!cached) this._templateStringsArrayInstance = cached = this.requireClass(CommonNames.TemplateStringsArray);\n    return cached;\n  }\n  private _templateStringsArrayInstance: Class | null = null;\n\n  /** Gets the standard `abort` instance, if not explicitly disabled. */\n  get abortInstance(): Function | null {\n    let prototype = this.lookup(CommonNames.abort);\n    if (!prototype || prototype.kind != ElementKind.FunctionPrototype) return null;\n    return this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n  }\n\n  // Runtime interface\n\n  /** Gets the runtime `__alloc(size: usize): usize` instance. */\n  get allocInstance(): Function {\n    let cached = this._allocInstance;\n    if (!cached) this._allocInstance = cached = this.requireFunction(CommonNames.alloc);\n    return cached;\n  }\n  private _allocInstance: Function | null = null;\n\n  /** Gets the runtime `__realloc(ptr: usize, newSize: usize): usize` instance. */\n  get reallocInstance(): Function {\n    let cached = this._reallocInstance;\n    if (!cached) this._reallocInstance = cached = this.requireFunction(CommonNames.realloc);\n    return cached;\n  }\n  private _reallocInstance: Function | null = null;\n\n  /** Gets the runtime `__free(ptr: usize): void` instance. */\n  get freeInstance(): Function {\n    let cached = this._freeInstance;\n    if (!cached) this._freeInstance = cached = this.requireFunction(CommonNames.free);\n    return cached;\n  }\n  private _freeInstance: Function | null = null;\n\n  /** Gets the runtime `__new(size: usize, id: u32): usize` instance. */\n  get newInstance(): Function {\n    let cached = this._newInstance;\n    if (!cached) this._newInstance = cached = this.requireFunction(CommonNames.new_);\n    return cached;\n  }\n  private _newInstance: Function | null = null;\n\n  /** Gets the runtime `__renew(ptr: usize, size: usize): usize` instance. */\n  get renewInstance(): Function {\n    let cached = this._renewInstance;\n    if (!cached) this._renewInstance = cached = this.requireFunction(CommonNames.renew);\n    return cached;\n  }\n  private _renewInstance: Function | null = null;\n\n  /** Gets the runtime `__link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void` instance. */\n  get linkInstance(): Function {\n    let cached = this._linkInstance;\n    if (!cached) this._linkInstance = cached = this.requireFunction(CommonNames.link);\n    return cached;\n  }\n  private _linkInstance: Function | null = null;\n\n  /** Gets the runtime `__collect(): void` instance. */\n  get collectInstance(): Function {\n    let cached = this._collectInstance;\n    if (!cached) this._collectInstance = cached = this.requireFunction(CommonNames.collect);\n    return cached;\n  }\n  private _collectInstance: Function | null = null;\n\n  /** Gets the runtime `__visit(ptr: usize, cookie: u32): void` instance. */\n  get visitInstance(): Function {\n    let cached = this._visitInstance;\n    if (!cached) this._visitInstance = cached = this.requireFunction(CommonNames.visit);\n    return cached;\n  }\n  private _visitInstance: Function | null = null;\n\n  /** Gets the runtime `__newBuffer(size: usize, id: u32, data: usize = 0): usize` instance. */\n  get newBufferInstance(): Function {\n    let cached = this._newBufferInstance;\n    if (!cached) this._newBufferInstance = cached = this.requireFunction(CommonNames.newBuffer);\n    return cached;\n  }\n  private _newBufferInstance: Function | null = null;\n\n  /** Gets the runtime `__newArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize` instance. */\n  get newArrayInstance(): Function {\n    let cached = this._newArrayInstance;\n    if (!cached) this._newArrayInstance = cached = this.requireFunction(CommonNames.newArray);\n    return cached;\n  }\n  private _newArrayInstance: Function | null = null;\n\n  /** Gets the runtime's internal `BLOCK` instance. */\n  get BLOCKInstance(): Class {\n    let cached = this._BLOCKInstance;\n    if (!cached) this._BLOCKInstance = cached = this.requireClass(CommonNames.BLOCK);\n    return cached;\n  }\n  private _BLOCKInstance: Class | null = null;\n\n  /** Gets the runtime's internal `OBJECT` instance. */\n  get OBJECTInstance(): Class {\n    let cached = this._OBJECTInstance;\n    if (!cached) this._OBJECTInstance = cached = this.requireClass(CommonNames.OBJECT);\n    return cached;\n  }\n  private _OBJECTInstance: Class | null = null;\n\n  // Utility\n\n  /** Obtains the source matching the specified internal path. */\n  getSource(internalPath: string): string | null {\n    let sources = this.sources;\n    for (let i = 0; i < sources.length; ++i) {\n      let source = sources[i];\n      if (source.internalPath == internalPath) return source.text;\n    }\n    return null;\n  }\n\n  /** Gets the overhead of a memory manager block. */\n  get blockOverhead(): i32 {\n    // BLOCK | data...\n    //       ^ 16b alignment\n    return this.BLOCKInstance.nextMemoryOffset;\n  }\n\n  /** Gets the overhead of a managed object, excl. block overhead, incl. alignment. */\n  get objectOverhead(): i32 {\n    // OBJECT+align | data...\n    //        \u2514 0 \u2518 ^ 16b alignment\n    return (this.OBJECTInstance.nextMemoryOffset - this.blockOverhead + AL_MASK) & ~AL_MASK;\n  }\n\n  /** Gets the total overhead of a managed object, incl. block overhead. */\n  get totalOverhead(): i32 {\n    // BLOCK | OBJECT+align | data...\n    // \u2514     = TOTAL      \u2518 ^ 16b alignment\n    return this.blockOverhead + this.objectOverhead;\n  }\n\n  searchFunctionByRef(ref: FunctionRef): Function | null {\n    const modifiedFunctionName = getFunctionName(ref);\n    if (modifiedFunctionName) {\n      const instancesByName = this.instancesByName;\n      if (instancesByName.has(modifiedFunctionName)) {\n        const element = assert(instancesByName.get(modifiedFunctionName));\n        if (element.kind == ElementKind.Function) {\n          return <Function>element;\n        }\n      }\n    }\n    return null;\n  }\n\n  /** Computes the next properly aligned offset of a memory manager block, given the current bump offset. */\n  computeBlockStart(currentOffset: i32): i32 {\n    let blockOverhead = this.blockOverhead;\n    return ((currentOffset + blockOverhead + AL_MASK) & ~AL_MASK) - blockOverhead;\n  }\n\n  /** Computes the next properly aligned offset of a memory manager block, given the current bump offset. */\n  computeBlockStart64(currentOffset: i64): i64 {\n    let blockOverhead = i64_new(this.blockOverhead);\n    return i64_sub(i64_align(i64_add(currentOffset, blockOverhead), AL_SIZE), blockOverhead);\n  }\n\n  /** Computes the size of a memory manager block, excl. block overhead. */\n  computeBlockSize(payloadSize: i32, isManaged: bool): i32 {\n    // see: std/rt/tlsf.ts, computeSize; becomes mmInfo\n    if (isManaged) payloadSize += this.objectOverhead;\n    // we know that payload must be aligned, and that block sizes must be chosen\n    // so that blocks are adjacent with the next payload aligned. hence, block\n    // size is payloadSize rounded up to where the next block would start:\n    let blockSize = this.computeBlockStart(payloadSize);\n    // make sure that block size is valid according to TLSF requirements\n    let blockOverhead = this.blockOverhead;\n    let blockMinsize = ((3 * this.options.usizeType.byteSize + blockOverhead + AL_MASK) & ~AL_MASK) - blockOverhead;\n    if (blockSize < blockMinsize) blockSize = blockMinsize;\n    const blockMaxsize = 1 << 30; // 1 << (FL_BITS + SB_BITS - 1), exclusive\n    const tagsMask = 3;\n    if (blockSize >= blockMaxsize || (blockSize & tagsMask) != 0) {\n      throw new Error(\"invalid block size\");\n    }\n    return blockSize;\n  }\n\n  /** Creates a native variable declaration. */\n  makeNativeVariableDeclaration(\n    /** The simple name of the variable */\n    name: string,\n    /** Flags indicating specific traits, e.g. `CONST`. */\n    flags: CommonFlags = CommonFlags.None\n  ): VariableDeclaration {\n    let range = Source.native.range;\n    return Node.createVariableDeclaration(\n      Node.createIdentifierExpression(name, range),\n      null, flags, null, null, range\n    );\n  }\n\n  /** Creates a native type declaration. */\n  makeNativeTypeDeclaration(\n    /** The simple name of the type. */\n    name: string,\n    /** Flags indicating specific traits, e.g. `GENERIC`. */\n    flags: CommonFlags = CommonFlags.None\n  ): TypeDeclaration {\n    let range = Source.native.range;\n    let identifier = Node.createIdentifierExpression(name, range);\n    return Node.createTypeDeclaration(\n      identifier,\n      null, flags, null,\n      Node.createOmittedType(range),\n      range\n    );\n  }\n\n  // a dummy signature for programmatically generated native functions\n  private nativeDummySignature: FunctionTypeNode | null = null;\n\n  /** Creates a native function declaration. */\n  makeNativeFunctionDeclaration(\n    /** The simple name of the function. */\n    name: string,\n    /** Flags indicating specific traits, e.g. `DECLARE`. */\n    flags: CommonFlags = CommonFlags.None\n  ): FunctionDeclaration {\n    let range = Source.native.range;\n    let signature = this.nativeDummySignature;\n    if (!signature) {\n      this.nativeDummySignature = signature = Node.createFunctionType([],\n        Node.createNamedType( // ^ AST signature doesn't really matter, is overridden anyway\n          Node.createSimpleTypeName(CommonNames.void_, range),\n          null, false, range\n        ),\n        null, false, range\n      );\n    }\n    return Node.createFunctionDeclaration(\n      Node.createIdentifierExpression(name, range),\n      null, flags, null, signature, null, ArrowKind.None, range\n    );\n  }\n\n  /** Creates a native namespace declaration. */\n  makeNativeNamespaceDeclaration(\n    /** The simple name of the namespace. */\n    name: string,\n    /** Flags indicating specific traits, e.g. `EXPORT`. */\n    flags: CommonFlags = CommonFlags.None\n  ): NamespaceDeclaration {\n    let range = Source.native.range;\n    return Node.createNamespaceDeclaration(\n      Node.createIdentifierExpression(name, range),\n      null, flags, [], range\n    );\n  }\n\n  /** Creates a native function. */\n  makeNativeFunction(\n    /** The simple name of the function. */\n    name: string,\n    /** Concrete function signature. */\n    signature: Signature,\n    /** Parent element, usually a file, class or namespace. */\n    parent: Element = this.nativeFile,\n    /** Flags indicating specific traits, e.g. `GENERIC`. */\n    flags: CommonFlags = CommonFlags.None,\n    /** Decorator flags representing built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.None\n  ): Function {\n    return new Function(\n      name,\n      new FunctionPrototype(\n        name,\n        parent,\n        this.makeNativeFunctionDeclaration(name, flags),\n        decoratorFlags\n      ),\n      null,\n      signature\n    );\n  }\n\n  /** Gets the (possibly merged) program element linked to the specified declaration. */\n  getElementByDeclaration(declaration: DeclarationStatement): DeclaredElement | null {\n    let elementsByDeclaration = this.elementsByDeclaration;\n    return elementsByDeclaration.has(declaration)\n      ? assert(elementsByDeclaration.get(declaration))\n      : null;\n  }\n\n  /** Initializes the program and its elements prior to compilation. */\n  initialize(): void {\n    if (this.initialized) return;\n    this.initialized = true;\n\n    let options = this.options;\n\n    // register native types\n    this.registerNativeType(CommonNames.i8, Type.i8);\n    this.registerNativeType(CommonNames.i16, Type.i16);\n    this.registerNativeType(CommonNames.i32, Type.i32);\n    this.registerNativeType(CommonNames.i64, Type.i64);\n    this.registerNativeType(CommonNames.isize, options.isizeType);\n    this.registerNativeType(CommonNames.u8, Type.u8);\n    this.registerNativeType(CommonNames.u16, Type.u16);\n    this.registerNativeType(CommonNames.u32, Type.u32);\n    this.registerNativeType(CommonNames.u64, Type.u64);\n    this.registerNativeType(CommonNames.usize, options.usizeType);\n    this.registerNativeType(CommonNames.bool, Type.bool);\n    this.registerNativeType(CommonNames.f32, Type.f32);\n    this.registerNativeType(CommonNames.f64, Type.f64);\n    this.registerNativeType(CommonNames.void_, Type.void);\n    this.registerNativeType(CommonNames.number, Type.f64); // alias\n    this.registerNativeType(CommonNames.boolean, Type.bool); // alias\n    this.nativeFile.add(CommonNames.native, new TypeDefinition(\n      CommonNames.native,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(CommonNames.native, CommonFlags.Export | CommonFlags.Generic),\n      DecoratorFlags.Builtin\n    ));\n    this.nativeFile.add(CommonNames.indexof, new TypeDefinition(\n      CommonNames.indexof,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(CommonNames.indexof, CommonFlags.Export | CommonFlags.Generic),\n      DecoratorFlags.Builtin\n    ));\n    this.nativeFile.add(CommonNames.valueof, new TypeDefinition(\n      CommonNames.valueof,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(CommonNames.valueof, CommonFlags.Export | CommonFlags.Generic),\n      DecoratorFlags.Builtin\n    ));\n    this.nativeFile.add(CommonNames.returnof, new TypeDefinition(\n      CommonNames.returnof,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(CommonNames.returnof, CommonFlags.Export | CommonFlags.Generic),\n      DecoratorFlags.Builtin\n    ));\n    this.nativeFile.add(CommonNames.nonnull, new TypeDefinition(\n      CommonNames.nonnull,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(CommonNames.nonnull, CommonFlags.Export | CommonFlags.Generic),\n      DecoratorFlags.Builtin\n    ));\n\n    // The following types might not be enabled by compiler options, so the\n    // compiler needs to check this condition whenever such a value is created\n    // respectively stored or loaded.\n    this.registerNativeType(CommonNames.v128, Type.v128);\n    this.registerNativeType(CommonNames.ref_func, Type.func);\n    this.registerNativeType(CommonNames.ref_extern, Type.extern);\n    this.registerNativeType(CommonNames.ref_any, Type.any);\n    this.registerNativeType(CommonNames.ref_eq, Type.eq);\n    this.registerNativeType(CommonNames.ref_struct, Type.struct);\n    this.registerNativeType(CommonNames.ref_array, Type.array);\n    this.registerNativeType(CommonNames.ref_i31, Type.i31);\n    this.registerNativeType(CommonNames.ref_string, Type.string);\n    this.registerNativeType(CommonNames.ref_stringview_wtf8, Type.stringview_wtf8);\n    this.registerNativeType(CommonNames.ref_stringview_wtf16, Type.stringview_wtf16);\n    this.registerNativeType(CommonNames.ref_stringview_iter, Type.stringview_iter);\n\n    // register compiler hints\n    this.registerConstantInteger(CommonNames.ASC_TARGET, Type.i32,\n      i64_new(options.isWasm64 ? Target.Wasm64 : Target.Wasm32));\n    this.registerConstantInteger(CommonNames.ASC_RUNTIME, Type.i32,\n      i64_new(options.runtime));\n    this.registerConstantInteger(CommonNames.ASC_NO_ASSERT, Type.bool,\n      i64_new(options.noAssert ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_MEMORY_BASE, Type.i32,\n      i64_new(options.memoryBase, 0));\n    this.registerConstantInteger(CommonNames.ASC_TABLE_BASE, Type.i32,\n      i64_new(options.tableBase, 0));\n    this.registerConstantInteger(CommonNames.ASC_OPTIMIZE_LEVEL, Type.i32,\n      i64_new(options.optimizeLevelHint, 0));\n    this.registerConstantInteger(CommonNames.ASC_SHRINK_LEVEL, Type.i32,\n      i64_new(options.shrinkLevelHint, 0));\n    this.registerConstantInteger(CommonNames.ASC_LOW_MEMORY_LIMIT, Type.i32,\n      i64_new(options.lowMemoryLimit, 0));\n    this.registerConstantInteger(CommonNames.ASC_EXPORT_RUNTIME, Type.bool,\n      i64_new(options.exportRuntime ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_VERSION_MAJOR, Type.i32,\n      i64_new(options.bundleMajorVersion));\n    this.registerConstantInteger(CommonNames.ASC_VERSION_MINOR, Type.i32,\n      i64_new(options.bundleMinorVersion));\n    this.registerConstantInteger(CommonNames.ASC_VERSION_PATCH, Type.i32,\n      i64_new(options.bundlePatchVersion));\n\n    // register feature hints\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_SIGN_EXTENSION, Type.bool,\n      i64_new(options.hasFeature(Feature.SignExtension) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_MUTABLE_GLOBALS, Type.bool,\n      i64_new(options.hasFeature(Feature.MutableGlobals) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_NONTRAPPING_F2I, Type.bool,\n      i64_new(options.hasFeature(Feature.NontrappingF2I) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_BULK_MEMORY, Type.bool,\n      i64_new(options.hasFeature(Feature.BulkMemory) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_SIMD, Type.bool,\n      i64_new(options.hasFeature(Feature.Simd) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_THREADS, Type.bool,\n      i64_new(options.hasFeature(Feature.Threads) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_EXCEPTION_HANDLING, Type.bool,\n      i64_new(options.hasFeature(Feature.ExceptionHandling) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_TAIL_CALLS, Type.bool,\n      i64_new(options.hasFeature(Feature.TailCalls) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_REFERENCE_TYPES, Type.bool,\n      i64_new(options.hasFeature(Feature.ReferenceTypes) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_MULTI_VALUE, Type.bool,\n      i64_new(options.hasFeature(Feature.MultiValue) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_GC, Type.bool,\n      i64_new(options.hasFeature(Feature.GC) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_MEMORY64, Type.bool,\n      i64_new(options.hasFeature(Feature.Memory64) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_RELAXED_SIMD, Type.bool,\n      i64_new(options.hasFeature(Feature.RelaxedSimd) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_EXTENDED_CONST, Type.bool,\n      i64_new(options.hasFeature(Feature.ExtendedConst) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_STRINGREF, Type.bool,\n      i64_new(options.hasFeature(Feature.Stringref) ? 1 : 0, 0));\n\n    // remember deferred elements\n    let queuedImports = new Array<QueuedImport>();\n    let queuedExports = new Map<File,Map<string,QueuedExport>>();\n    let queuedExportsStar = new Map<File,QueuedExportStar[]>();\n    let queuedExtends = new Array<ClassPrototype>();\n    let queuedImplements = new Array<ClassPrototype>();\n\n    // initialize relevant declaration-like statements of the entire program\n    for (let i = 0, k = this.sources.length; i < k; ++i) {\n      let source = this.sources[i];\n      let file = new File(this, source);\n      this.filesByName.set(file.internalName, file);\n      let statements = source.statements;\n      for (let j = 0, l = statements.length; j < l; ++j) {\n        let statement = statements[j];\n        switch (statement.kind) {\n          case NodeKind.Export: {\n            this.initializeExports(<ExportStatement>statement, file, queuedExports, queuedExportsStar);\n            break;\n          }\n          case NodeKind.ExportDefault: {\n            this.initializeExportDefault(<ExportDefaultStatement>statement, file, queuedExtends, queuedImplements);\n            break;\n          }\n          case NodeKind.Import: {\n            this.initializeImports(<ImportStatement>statement, file, queuedImports, queuedExports);\n            break;\n          }\n          case NodeKind.Variable: {\n            this.initializeVariables(<VariableStatement>statement, file);\n            break;\n          }\n          case NodeKind.ClassDeclaration: {\n            this.initializeClass(<ClassDeclaration>statement, file, queuedExtends, queuedImplements);\n            break;\n          }\n          case NodeKind.EnumDeclaration: {\n            this.initializeEnum(<EnumDeclaration>statement, file);\n            break;\n          }\n          case NodeKind.FunctionDeclaration: {\n            this.initializeFunction(<FunctionDeclaration>statement, file);\n            break;\n          }\n          case NodeKind.InterfaceDeclaration: {\n            this.initializeInterface(<InterfaceDeclaration>statement, file, queuedExtends);\n            break;\n          }\n          case NodeKind.NamespaceDeclaration: {\n            this.initializeNamespace(<NamespaceDeclaration>statement, file, queuedExtends, queuedImplements);\n            break;\n          }\n          case NodeKind.TypeDeclaration: {\n            this.initializeTypeDefinition(<TypeDeclaration>statement, file);\n            break;\n          }\n        }\n      }\n    }\n\n    // queued exports * should be linkable now that all files have been processed\n    // TODO: for (let [file, starExports] of queuedExportsStar) {\n    for (let _keys = Map_keys(queuedExportsStar), i = 0, k = _keys.length; i < k; ++i) {\n      let file = _keys[i];\n      let starExports = assert(queuedExportsStar.get(file));\n      for (let j = 0, l = starExports.length; j < l; ++j) {\n        let exportStar = unchecked(starExports[j]);\n        let foreignFile = this.lookupForeignFile(exportStar.foreignPath, exportStar.foreignPathAlt);\n        if (!foreignFile) {\n          this.error(\n            DiagnosticCode.File_0_not_found,\n            exportStar.pathLiteral.range, exportStar.pathLiteral.value\n          );\n          continue;\n        }\n        file.ensureExportStar(foreignFile);\n      }\n    }\n\n    // queued imports should be resolvable now through traversing exports and queued exports.\n    // note that imports may depend upon imports, so repeat until there's no more progress.\n    do {\n      let i = 0, madeProgress = false;\n      while (i < queuedImports.length) {\n        let queuedImport = queuedImports[i];\n        let localIdentifier = queuedImport.localIdentifier;\n        let foreignIdentifier = queuedImport.foreignIdentifier;\n        // File must be found here, as it would otherwise already have been reported by the parser\n        let foreignFile = assert(this.lookupForeignFile(queuedImport.foreignPath, queuedImport.foreignPathAlt));\n        if (foreignIdentifier) { // i.e. import { foo [as bar] } from \"./baz\"\n          let element = this.lookupForeign(\n            foreignIdentifier.text,\n            foreignFile,\n            queuedExports\n          );\n          if (element) {\n            queuedImport.localFile.add(\n              localIdentifier.text,\n              element,\n              localIdentifier // isImport\n            );\n            queuedImports.splice(i, 1);\n            madeProgress = true;\n          } else {\n            ++i;\n          }\n        } else { // i.e. import * as bar from \"./bar\"\n          let localFile = queuedImport.localFile;\n          let localName = localIdentifier.text;\n          localFile.add(\n            localName,\n            foreignFile.asAliasNamespace(\n              localName,\n              localFile,\n              localIdentifier\n            ),\n            localIdentifier // isImport\n          );\n          queuedImports.splice(i, 1);\n          madeProgress = true;\n        }\n      }\n      if (!madeProgress) {\n        // report queued imports we were unable to resolve\n        for (let j = 0, l = queuedImports.length; j < l; ++j) {\n          let queuedImport = queuedImports[j];\n          let foreignIdentifier = queuedImport.foreignIdentifier;\n          if (foreignIdentifier) {\n            this.error(\n              DiagnosticCode.Module_0_has_no_exported_member_1,\n              foreignIdentifier.range, queuedImport.foreignPath, foreignIdentifier.text\n            );\n          }\n        }\n        break;\n      }\n    } while (true);\n\n    // queued exports should be resolvable now that imports are finalized\n    // TODO: for (let [file, exports] of queuedExports) {\n    for (let _keys = Map_keys(queuedExports), i = 0, k = _keys.length; i < k; ++i) {\n      let file = unchecked(_keys[i]);\n      let exports = assert(queuedExports.get(file));\n      // TODO: for (let [exportName, queuedExport] of exports) {\n      for (let exportNames = Map_keys(exports), j = 0, l = exportNames.length; j < l; ++j) {\n        let exportName = unchecked(exportNames[j]);\n        let queuedExport = assert(exports.get(exportName));\n        let localName = queuedExport.localIdentifier.text;\n        let foreignPath = queuedExport.foreignPath;\n        if (foreignPath) { // i.e. export { foo [as bar] } from \"./baz\"\n          // File must be found here, as it would otherwise already have been reported by the parser\n          let foreignFile = assert(this.lookupForeignFile(foreignPath, assert(queuedExport.foreignPathAlt)));\n          let element = this.lookupForeign(localName, foreignFile, queuedExports);\n          if (element) {\n            file.ensureExport(exportName, element);\n          } else {\n            this.error(\n              DiagnosticCode.Module_0_has_no_exported_member_1,\n              queuedExport.localIdentifier.range,\n              foreignPath, localName\n            );\n          }\n        } else { // i.e. export { foo [as bar] }\n          let element = file.getMember(localName);\n          if (element) {\n            file.ensureExport(exportName, element);\n          } else {\n            let globalElement = this.lookup(localName);\n            if (globalElement && isDeclaredElement(globalElement.kind)) { // export { memory }\n              file.ensureExport(exportName, <DeclaredElement>globalElement);\n            } else {\n              this.error(\n                DiagnosticCode.Module_0_has_no_exported_member_1,\n                queuedExport.foreignIdentifier.range,\n                file.internalName, queuedExport.foreignIdentifier.text\n              );\n            }\n          }\n        }\n      }\n    }\n\n    // register foundational classes with fixed ids\n    assert(this.objectInstance.id == 0);\n    assert(this.arrayBufferInstance.id == 1);\n    assert(this.stringInstance.id == 2);\n    assert(this.arrayBufferViewInstance.id == 3);\n\n    // register classes backing basic types\n    this.registerWrapperClass(Type.i8, CommonNames.I8);\n    this.registerWrapperClass(Type.i16, CommonNames.I16);\n    this.registerWrapperClass(Type.i32, CommonNames.I32);\n    this.registerWrapperClass(Type.i64, CommonNames.I64);\n    this.registerWrapperClass(options.isizeType, CommonNames.Isize);\n    this.registerWrapperClass(Type.u8, CommonNames.U8);\n    this.registerWrapperClass(Type.u16, CommonNames.U16);\n    this.registerWrapperClass(Type.u32, CommonNames.U32);\n    this.registerWrapperClass(Type.u64, CommonNames.U64);\n    this.registerWrapperClass(options.usizeType, CommonNames.Usize);\n    this.registerWrapperClass(Type.bool, CommonNames.Bool);\n    this.registerWrapperClass(Type.f32, CommonNames.F32);\n    this.registerWrapperClass(Type.f64, CommonNames.F64);\n    if (options.hasFeature(Feature.Simd)) this.registerWrapperClass(Type.v128, CommonNames.V128);\n    if (options.hasFeature(Feature.ReferenceTypes)) {\n      this.registerWrapperClass(Type.func, CommonNames.RefFunc);\n      this.registerWrapperClass(Type.extern, CommonNames.RefExtern);\n      if (options.hasFeature(Feature.GC)) {\n        this.registerWrapperClass(Type.any, CommonNames.RefAny);\n        this.registerWrapperClass(Type.eq, CommonNames.RefEq);\n        this.registerWrapperClass(Type.struct, CommonNames.RefStruct);\n        this.registerWrapperClass(Type.array, CommonNames.RefArray);\n        this.registerWrapperClass(Type.i31, CommonNames.RefI31);\n      }\n      if (options.hasFeature(Feature.Stringref)) {\n        this.registerWrapperClass(Type.string, CommonNames.RefString);\n      }\n    }\n\n    // resolve prototypes of extended classes or interfaces\n    let resolver = this.resolver;\n    for (let i = 0, k = queuedExtends.length; i < k; ++i) {\n      let thisPrototype = queuedExtends[i];\n      let extendsNode = assert(thisPrototype.extendsNode); // must be present if in queuedExtends\n      let baseElement = resolver.resolveTypeName(extendsNode.name, null, thisPrototype.parent);\n      if (!baseElement) continue;\n      if (thisPrototype.kind == ElementKind.ClassPrototype) {\n        if (baseElement.kind == ElementKind.ClassPrototype) {\n          let basePrototype = <ClassPrototype>baseElement;\n          if (basePrototype.hasDecorator(DecoratorFlags.Final)) {\n            this.error(\n              DiagnosticCode.Class_0_is_final_and_cannot_be_extended,\n              extendsNode.range, basePrototype.identifierNode.text\n            );\n          }\n          if (\n            basePrototype.hasDecorator(DecoratorFlags.Unmanaged) !=\n            thisPrototype.hasDecorator(DecoratorFlags.Unmanaged)\n          ) {\n            this.error(\n              DiagnosticCode.Unmanaged_classes_cannot_extend_managed_classes_and_vice_versa,\n              Range.join(thisPrototype.identifierNode.range, extendsNode.range)\n            );\n          }\n          if (!thisPrototype.extends(basePrototype)) {\n            thisPrototype.basePrototype = basePrototype;\n          } else {\n            this.error(\n              DiagnosticCode._0_is_referenced_directly_or_indirectly_in_its_own_base_expression,\n              basePrototype.identifierNode.range,\n              basePrototype.identifierNode.text,\n            );\n          }\n        } else {\n          this.error(\n            DiagnosticCode.A_class_may_only_extend_another_class,\n            extendsNode.range\n          );\n        }\n      } else if (thisPrototype.kind == ElementKind.InterfacePrototype) {\n        if (baseElement.kind == ElementKind.InterfacePrototype) {\n          const basePrototype = <InterfacePrototype>baseElement;\n          if (!thisPrototype.extends(basePrototype)) {\n            thisPrototype.basePrototype = basePrototype;\n          } else {\n            this.error(\n              DiagnosticCode._0_is_referenced_directly_or_indirectly_in_its_own_base_expression,\n              basePrototype.identifierNode.range,\n              basePrototype.identifierNode.text,\n            );\n          }\n        } else {\n          this.error(\n            DiagnosticCode.An_interface_can_only_extend_an_interface,\n            extendsNode.range\n          );\n        }\n      }\n    }\n\n    // check override\n    for (let i = 0, k = queuedExtends.length; i < k; i++) {\n      let prototype = queuedExtends[i];\n      let instanesMembers = prototype.instanceMembers;\n      if (instanesMembers) {\n        let members = Map_values(instanesMembers);\n        for (let j = 0, k = members.length; j < k; j++) {\n          let member = members[j];\n          let declaration = member.declaration;\n          if (declaration.is(CommonFlags.Override)) {\n            let basePrototype = prototype.basePrototype;\n            let hasOverride = false;\n            while (basePrototype) {\n              let instanceMembers = basePrototype.instanceMembers;\n              if (instanceMembers) {\n                if (instanceMembers.has(member.name)) {\n                  hasOverride = true;\n                  break;\n                }\n              }\n              basePrototype = basePrototype.basePrototype;\n            }\n            if (!hasOverride) {\n              let basePrototype = assert(prototype.basePrototype);\n              this.error(\n                DiagnosticCode.This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0,\n                declaration.name.range,\n                basePrototype.name\n              );\n            }\n          }\n        }\n      }\n    }\n\n    // resolve prototypes of implemented interfaces\n    for (let i = 0, k = queuedImplements.length; i < k; ++i) {\n      let thisPrototype = queuedImplements[i];\n      let implementsNodes = assert(thisPrototype.implementsNodes); // must be present if in queuedImplements\n      for (let j = 0, l = implementsNodes.length; j < l; ++j) {\n        let implementsNode = implementsNodes[j];\n        let interfaceElement = resolver.resolveTypeName(implementsNode.name, null, thisPrototype.parent);\n        if (!interfaceElement) continue;\n        if (interfaceElement.kind == ElementKind.InterfacePrototype) {\n          let interfacePrototype = <InterfacePrototype>interfaceElement;\n          let interfacePrototypes = thisPrototype.interfacePrototypes;\n          if (!interfacePrototypes) thisPrototype.interfacePrototypes = interfacePrototypes = new Array();\n          interfacePrototypes.push(interfacePrototype);\n        } else {\n          this.error(\n            DiagnosticCode.A_class_can_only_implement_an_interface,\n            implementsNode.range\n          );\n        }\n      }\n    }\n\n    // process overrides in extended classes and implemented interfaces\n    for (let i = 0, k = queuedExtends.length; i < k; ++i) {\n      let thisPrototype = queuedExtends[i];\n      let basePrototype = thisPrototype.basePrototype;\n      if (basePrototype) {\n        this.processOverrides(thisPrototype, basePrototype);\n      }\n    }\n    for (let i = 0, k = queuedImplements.length; i < k; ++i) {\n      let thisPrototype = queuedImplements[i];\n      let basePrototype = thisPrototype.basePrototype;\n      let interfacePrototypes = thisPrototype.interfacePrototypes;\n      if (basePrototype) {\n        this.processOverrides(thisPrototype, basePrototype);\n      }\n      if (interfacePrototypes) {\n        for (let j = 0, l = interfacePrototypes.length; j < l; ++j) {\n          this.processOverrides(thisPrototype, interfacePrototypes[j]);\n        }\n      }\n    }\n\n    // set up global aliases\n    {\n      let globalAliases = options.globalAliases;\n      if (!globalAliases) globalAliases = new Map();\n      if (!globalAliases.has(CommonNames.abort)) {\n        globalAliases.set(CommonNames.abort, BuiltinNames.abort);\n      }\n      if (!globalAliases.has(CommonNames.trace)) {\n        globalAliases.set(CommonNames.trace, BuiltinNames.trace);\n      }\n      if (!globalAliases.has(CommonNames.seed)) {\n        globalAliases.set(CommonNames.seed, BuiltinNames.seed);\n      }\n      if (!globalAliases.has(CommonNames.Math)) {\n        globalAliases.set(CommonNames.Math, CommonNames.NativeMath);\n      }\n      if (!globalAliases.has(CommonNames.Mathf)) {\n        globalAliases.set(CommonNames.Mathf, CommonNames.NativeMathf);\n      }\n      // TODO: for (let [alias, name] of globalAliases) {\n      for (let _keys = Map_keys(globalAliases), i = 0, k = _keys.length; i < k; ++i) {\n        let alias = unchecked(_keys[i]);\n        let name = changetype<string>(globalAliases.get(alias));\n        assert(name != null);\n        if (!name.length) {\n          this.elementsByName.delete(alias);\n          continue;\n        }\n        let firstChar = name.charCodeAt(0);\n        if (firstChar >= CharCode._0 && firstChar <= CharCode._9) {\n          this.registerConstantInteger(alias, Type.i32, i64_new(<i32>parseInt(name, 10)));\n        } else {\n          let elementsByName = this.elementsByName;\n          if (elementsByName.has(name)) {\n            elementsByName.set(alias, assert(elementsByName.get(name)));\n          } else {\n            this.error(DiagnosticCode.Element_0_not_found, null, name);\n          }\n        }\n      }\n    }\n\n    // mark module exports, i.e. to apply proper wrapping behavior on the boundaries\n    // TODO: for (let file of this.filesByName.values()) {\n    for (let _values = Map_values(this.filesByName), i = 0, k = _values.length; i < k; ++i) {\n      let file = unchecked(_values[i]);\n      if (file.source.sourceKind == SourceKind.UserEntry) {\n        this.markModuleExports(file);\n      }\n    }\n  }\n\n  /** Processes overridden members by this class in a base class. */\n  private processOverrides(\n    thisPrototype: ClassPrototype,\n    basePrototype: ClassPrototype,\n  ): void {\n    // Note that we don't know concrete instances of class members, yet. Type\n    // checking of concrete (generic) instances happens upon resolve.\n    let thisInstanceMembers = thisPrototype.instanceMembers;\n    if (thisInstanceMembers) {\n      let thisMembers = Map_values(thisInstanceMembers);\n      let seen: Set<ClassPrototype> | null = null;\n      do {\n        let baseInstanceMembers = basePrototype.instanceMembers;\n        if (baseInstanceMembers) {\n          for (let j = 0, l = thisMembers.length; j < l; ++j) {\n            let thisMember = thisMembers[j];\n            if (baseInstanceMembers.has(thisMember.name)) {\n              let baseMember = assert(baseInstanceMembers.get(thisMember.name));\n              this.doProcessOverride(thisPrototype, thisMember, basePrototype, baseMember);\n            }\n          }\n        }\n        // A class can have a base class and multiple interfaces, but from the\n        // base member alone we only get one. Make sure we don't miss any.\n        let baseInterfacePrototypes = basePrototype.interfacePrototypes;\n        if (baseInterfacePrototypes) {\n          for (let i = 0, k = baseInterfacePrototypes.length; i < k; ++i) {\n            let baseInterfacePrototype = baseInterfacePrototypes[i];\n            if (baseInterfacePrototype != basePrototype) {\n              this.processOverrides(thisPrototype, baseInterfacePrototype);\n            }\n          }\n        }\n        let nextPrototype = basePrototype.basePrototype;\n        if (!nextPrototype) break;\n        // Break on circular inheritance. Is diagnosed later, when resolved.\n        if (!seen) seen = new Set();\n        seen.add(basePrototype);\n        if (seen.has(nextPrototype)) break;\n        // Otherwise traverse to next base prototype.\n        basePrototype = nextPrototype;\n      } while (true);\n    }\n  }\n\n  /** Processes a single overridden member by this class in a base class. */\n  private doProcessOverride(\n    thisClass: ClassPrototype,\n    thisMember: DeclaredElement,\n    baseClass: ClassPrototype,\n    baseMember: DeclaredElement\n  ): void {\n    // Constructors and private members do not override\n    if (thisMember.isAny(CommonFlags.Constructor | CommonFlags.Private)) return;\n    if (\n      thisMember.kind == ElementKind.FunctionPrototype &&\n      baseMember.kind == ElementKind.FunctionPrototype\n    ) {\n      let thisMethod = <FunctionPrototype>thisMember;\n      let baseMethod = <FunctionPrototype>baseMember;\n      if (!thisMethod.visibilityEquals(baseMethod)) {\n        this.errorRelated(\n          DiagnosticCode.Overload_signatures_must_all_be_public_private_or_protected,\n          thisMethod.identifierNode.range, baseMethod.identifierNode.range\n        );\n      }\n      baseMember.set(CommonFlags.Overridden);\n      let overrides = baseMethod.unboundOverrides;\n      if (!overrides) baseMethod.unboundOverrides = overrides = new Set();\n      overrides.add(<FunctionPrototype>thisMember);\n      let baseMethodInstances = baseMethod.instances;\n      if (baseMethodInstances) {\n        for (let _values = Map_values(baseMethodInstances), a = 0, b = _values.length; a < b; ++a) {\n          let baseMethodInstance = _values[a];\n          baseMethodInstance.set(CommonFlags.Overridden);\n        }\n      }\n    } else if (\n      thisMember.kind == ElementKind.PropertyPrototype &&\n      baseMember.kind == ElementKind.PropertyPrototype\n    ) {\n      let thisProperty = <PropertyPrototype>thisMember;\n      let baseProperty = <PropertyPrototype>baseMember;\n      if (!thisProperty.visibilityEquals(baseProperty)) {\n        this.errorRelated(\n          DiagnosticCode.Overload_signatures_must_all_be_public_private_or_protected,\n          thisProperty.identifierNode.range, baseProperty.identifierNode.range\n        );\n      }\n      if (baseProperty.parent.kind != ElementKind.InterfacePrototype) {\n        // Interface fields/properties can be implemented by either, but other\n        // members must match to retain compatiblity with TS/JS.\n        let thisIsField = thisProperty.isField;\n        if (thisIsField != baseProperty.isField) {\n          if (thisIsField) { // base is property\n            this.errorRelated(\n              DiagnosticCode._0_is_defined_as_an_accessor_in_class_1_but_is_overridden_here_in_2_as_an_instance_property,\n              thisProperty.identifierNode.range, baseProperty.identifierNode.range,\n              thisProperty.name, baseClass.internalName, thisClass.internalName\n            );\n          } else { // this is property, base is field\n            this.errorRelated(\n              DiagnosticCode._0_is_defined_as_a_property_in_class_1_but_is_overridden_here_in_2_as_an_accessor,\n              thisProperty.identifierNode.range, baseProperty.identifierNode.range,\n              thisProperty.name, baseClass.internalName, thisClass.internalName\n            );\n          }\n          return;\n        } else if (thisIsField) { // base is also field\n          // Fields don't override other fields and can only be redeclared\n          return;\n        }\n      }\n      baseProperty.set(CommonFlags.Overridden);\n      let baseGetter = baseProperty.getterPrototype;\n      if (baseGetter) {\n        baseGetter.set(CommonFlags.Overridden);\n        let thisGetter = thisProperty.getterPrototype;\n        if (thisGetter) {\n          let overrides = baseGetter.unboundOverrides;\n          if (!overrides) baseGetter.unboundOverrides = overrides = new Set();\n          overrides.add(thisGetter);\n        }\n        let baseGetterInstances = baseGetter.instances;\n        if (baseGetterInstances) {\n          for (let _values = Map_values(baseGetterInstances), a = 0, b = _values.length; a < b; ++a) {\n            let baseGetterInstance = _values[a];\n            baseGetterInstance.set(CommonFlags.Overridden);\n          }\n        }\n      }\n      let baseSetter = baseProperty.setterPrototype;\n      if (baseSetter && thisProperty.setterPrototype) {\n        baseSetter.set(CommonFlags.Overridden);\n        let thisSetter = thisProperty.setterPrototype;\n        if (thisSetter) {\n          let overrides = baseSetter.unboundOverrides;\n          if (!overrides) baseSetter.unboundOverrides = overrides = new Set();\n          overrides.add(thisSetter);\n        }\n        let baseSetterInstances = baseSetter.instances;\n        if (baseSetterInstances) {\n          for (let _values = Map_values(baseSetterInstances), a = 0, b = _values.length; a < b; ++a) {\n            let baseSetterInstance = _values[a];\n            baseSetterInstance.set(CommonFlags.Overridden);\n          }\n        }\n      }\n    } else {\n      this.errorRelated(\n        DiagnosticCode.Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2,\n        thisMember.identifierNode.range, baseMember.identifierNode.range,\n        thisMember.name, thisClass.internalName, baseClass.internalName\n      );\n    }\n  }\n\n  /** Looks up the element of the specified name in the global scope. */\n  lookup(name: string): Element | null {\n    let elements = this.elementsByName;\n    if (elements.has(name)) return assert(elements.get(name));\n    return null;\n  }\n\n  /** Requires that a global library element of the specified kind is present and returns it. */\n  private require(name: string, kind: ElementKind): Element {\n    let element = this.lookup(name);\n    if (!element) throw new Error(`Missing standard library component: ${name}`);\n    if (element.kind != kind) throw Error(`Invalid standard library component kind: ${name}`);\n    return element;\n  }\n\n  /** Requires that a global variable is present and returns it. */\n  requireGlobal(name: string): Global {\n    return <Global>this.require(name, ElementKind.Global);\n  }\n\n  /** Requires that a non-generic global class is present and returns it. */\n  requireClass(name: string): Class {\n    let prototype = this.require(name, ElementKind.ClassPrototype);\n    let resolved = this.resolver.resolveClass(<ClassPrototype>prototype, null);\n    if (!resolved) throw new Error(`Invalid standard library class: ${name}`);\n    return resolved;\n  }\n\n  /** Requires that a global function is present and returns it. */\n  requireFunction(name: string, typeArguments: Type[] | null = null): Function {\n    let prototype = <FunctionPrototype>this.require(name, ElementKind.FunctionPrototype);\n    let resolved = this.resolver.resolveFunction(prototype, typeArguments);\n    if (!resolved) throw new Error(`Invalid standard library function: ${name}`);\n    return resolved;\n  }\n\n  /** Marks all exports of the specified file as module exports. */\n  private markModuleExports(file: File): void {\n    let exports = file.exports;\n    if (exports) {\n      // TODO: for (let element of exports.values()) {\n      for (let _values = Map_values(exports), j = 0, l = _values.length; j < l; ++j) {\n        let element = unchecked(_values[j]);\n        this.markModuleExport(element);\n      }\n    }\n    let exportsStar = file.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        this.markModuleExports(exportsStar[i]);\n      }\n    }\n  }\n\n  /** Marks an element and its children as a module export. */\n  private markModuleExport(element: Element): void {\n    element.set(CommonFlags.ModuleExport);\n    switch (element.kind) {\n      case ElementKind.ClassPrototype: {\n        let instanceMembers = (<ClassPrototype>element).instanceMembers;\n        if (instanceMembers) {\n          // TODO: for (let member of instanceMembers.values()) {\n          for (let _values = Map_values(instanceMembers), i = 0, k = _values.length; i < k; ++i) {\n            let member = unchecked(_values[i]);\n            this.markModuleExport(member);\n          }\n        }\n        break;\n      }\n      case ElementKind.PropertyPrototype: {\n        let propertyPrototype = <PropertyPrototype>element;\n        let getterPrototype = propertyPrototype.getterPrototype;\n        if (getterPrototype) this.markModuleExport(getterPrototype);\n        let setterPrototype = propertyPrototype.setterPrototype;\n        if (setterPrototype) this.markModuleExport(setterPrototype);\n        break;\n      }\n      case ElementKind.Property:\n      case ElementKind.Function:\n      case ElementKind.Class: assert(false); // assumes that there are no instances yet\n    }\n    let staticMembers = element.members;\n    if (staticMembers) {\n      // TODO: for (let member of staticMembers.values()) {\n      for (let _values = Map_values(staticMembers), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        this.markModuleExport(member);\n      }\n    }\n  }\n\n  /** Marks an element as a module import. */\n  markModuleImport(moduleName: string, name: string, element: Element): void {\n    element.set(CommonFlags.ModuleImport);\n    let moduleImports = this.moduleImports;\n    let module: Map<string,Element>;\n    if (moduleImports.has(moduleName)) {\n      module = assert(moduleImports.get(moduleName));\n    } else {\n      module = new Map();\n      moduleImports.set(moduleName, module);\n    }\n    module.set(name, element);\n  }\n\n  /** Registers a native type with the program. */\n  private registerNativeType(name: string, type: Type): void {\n    let element = new TypeDefinition(\n      name,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(name, CommonFlags.Export),\n      DecoratorFlags.Builtin\n    );\n    element.setType(type);\n    this.nativeFile.add(name, element);\n  }\n\n  /** Registers the wrapper class of a non-class type. */\n  private registerWrapperClass(type: Type, className: string): void {\n    let wrapperClasses = this.wrapperClasses;\n    assert(!type.isInternalReference && !wrapperClasses.has(type));\n    let element = assert(this.lookup(className));\n    assert(element.kind == ElementKind.ClassPrototype);\n    let classElement = assert(this.resolver.resolveClass(<ClassPrototype>element, null));\n    classElement.wrappedType = type;\n    wrapperClasses.set(type, classElement);\n  }\n\n  /** Registers a constant integer value within the global scope. */\n  registerConstantInteger(name: string, type: Type, value: i64): void {\n    assert(type.isIntegerInclReference);\n    let global = new Global(\n      name,\n      this.nativeFile,\n      DecoratorFlags.Lazy,\n      this.makeNativeVariableDeclaration(name, CommonFlags.Const | CommonFlags.Export)\n    );\n    global.setConstantIntegerValue(value, type);\n    this.nativeFile.add(name, global);\n  }\n\n  /** Registers a constant float value within the global scope. */\n  private registerConstantFloat(name: string, type: Type, value: f64): void {\n    assert(type.isFloatValue);\n    let global = new Global(\n      name,\n      this.nativeFile,\n      DecoratorFlags.Lazy,\n      this.makeNativeVariableDeclaration(name, CommonFlags.Const | CommonFlags.Export)\n    );\n    global.setConstantFloatValue(value, type);\n    this.nativeFile.add(name, global);\n  }\n\n  /** Ensures that the given global element exists. Attempts to merge duplicates. */\n  ensureGlobal(name: string, element: DeclaredElement): DeclaredElement {\n    let elementsByName = this.elementsByName;\n    if (elementsByName.has(name)) {\n      let existing = assert(elementsByName.get(name));\n      // NOTE: this is effectively only performed when merging native types with\n      // their respective namespaces in std/builtins, but can also trigger when a\n      // user has multiple global elements of the same name in different files,\n      // which might result in unexpected shared symbols accross files. considering\n      // this a wonky feature for now that we might want to revisit later.\n      if (existing != element) {\n        let merged = tryMerge(existing, element);\n        if (!merged) {\n          if (isDeclaredElement(existing.kind)) {\n            this.errorRelated(\n              DiagnosticCode.Duplicate_identifier_0,\n              element.identifierNode.range,\n              (<DeclaredElement>existing).declaration.name.range,\n              name\n            );\n          } else {\n            this.error(\n              DiagnosticCode.Duplicate_identifier_0,\n              element.identifierNode.range, name\n            );\n          }\n          return element;\n        }\n        element = merged;\n      }\n    }\n    elementsByName.set(name, element);\n    return element;\n  }\n\n  /** Tries to locate a foreign file given its normalized path. */\n  private lookupForeignFile(\n    /** Normalized path to the other file. */\n    foreignPath: string,\n    /** Alternative normalized path to the other file. */\n    foreignPathAlt: string\n  ): File | null {\n    let filesByName = this.filesByName;\n    return filesByName.has(foreignPath)\n      ? assert(filesByName.get(foreignPath))\n      : filesByName.has(foreignPathAlt)\n        ? assert(filesByName.get(foreignPathAlt))\n        : null;\n  }\n\n  /** Tries to locate a foreign element by traversing exports and queued exports. */\n  private lookupForeign(\n    /** Identifier within the other file. */\n    foreignName: string,\n    /** The other file. */\n    foreignFile: File,\n    /** So far queued exports. */\n    queuedExports: Map<File,Map<string,QueuedExport>>\n  ): DeclaredElement | null {\n    do {\n      // check if already resolved\n      let element = foreignFile.lookupExport(foreignName);\n      if (element) return element;\n\n      // follow queued exports\n      if (queuedExports.has(foreignFile)) {\n        let fileQueuedExports = assert(queuedExports.get(foreignFile));\n        if (fileQueuedExports.has(foreignName)) {\n          let queuedExport = assert(fileQueuedExports.get(foreignName));\n          let queuedExportForeignPath = queuedExport.foreignPath;\n\n          // re-exported from another file\n          if (queuedExportForeignPath) {\n            let otherFile = this.lookupForeignFile(queuedExportForeignPath, assert(queuedExport.foreignPathAlt));\n            if (!otherFile) return null;\n            foreignName = queuedExport.localIdentifier.text;\n            foreignFile = otherFile;\n            continue;\n          }\n\n          // exported from this file\n          element = foreignFile.getMember(queuedExport.localIdentifier.text);\n          if (element) return element;\n        }\n      }\n      break;\n    } while (true);\n\n    // follow star exports\n    let exportsStar = foreignFile.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        let element = this.lookupForeign(foreignName, exportsStar[i], queuedExports);\n        if (element) return element;\n      }\n    }\n    return null;\n  }\n\n  /** Validates that only supported decorators are present. */\n  private checkDecorators(\n    /** Decorators present on an element. */\n    decorators: DecoratorNode[] | null,\n    /** Accepted decorator flags. Emits diagnostics if any other decorators are present. */\n    acceptedFlags: DecoratorFlags\n  ): DecoratorFlags {\n    let flags = DecoratorFlags.None;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        let decorator = decorators[i];\n        let kind = DecoratorKind.fromNode(decorator.name);\n        let flag = DecoratorFlags.fromKind(kind);\n        if (flag) {\n          if (!(acceptedFlags & flag)) {\n            this.error(\n              DiagnosticCode.Decorator_0_is_not_valid_here,\n              decorator.range, decorator.name.range.toString()\n            );\n          } else if (flags & flag) {\n            this.error(\n              DiagnosticCode.Duplicate_decorator,\n              decorator.range\n            );\n          } else {\n            flags |= flag;\n          }\n        }\n      }\n    }\n    return flags;\n  }\n\n  /** Checks whether a particular feature is enabled. */\n  checkFeatureEnabled(feature: Feature, reportNode: Node): bool {\n    if (!this.options.hasFeature(feature)) {\n      this.error(\n        DiagnosticCode.Feature_0_is_not_enabled,\n        reportNode.range, featureToString(feature)\n      );\n      return false;\n    }\n    return true;\n  }\n\n  /** Checks whether a particular type is supported. */\n  checkTypeSupported(type: Type, reportNode: Node): bool {\n    switch (type.kind) {\n      case TypeKind.V128: return this.checkFeatureEnabled(Feature.Simd, reportNode);\n      case TypeKind.Func:\n      case TypeKind.Extern:\n        // Non-nullability is introduced by typed function references (here part of GC)\n        if (!type.is(TypeFlags.Nullable)) return this.checkFeatureEnabled(Feature.GC, reportNode);\n        return this.checkFeatureEnabled(Feature.ReferenceTypes, reportNode);\n      case TypeKind.Any:\n      case TypeKind.Eq:\n      case TypeKind.Struct:\n      case TypeKind.Array:\n      case TypeKind.I31: {\n        return this.checkFeatureEnabled(Feature.ReferenceTypes, reportNode)\n            && this.checkFeatureEnabled(Feature.GC, reportNode);\n      }\n      case TypeKind.String:\n      case TypeKind.StringviewWTF8:\n      case TypeKind.StringviewWTF16:\n      case TypeKind.StringviewIter: {\n        return this.checkFeatureEnabled(Feature.ReferenceTypes, reportNode)\n            && this.checkFeatureEnabled(Feature.Stringref, reportNode);\n      }\n    }\n    let classReference = type.getClass();\n    if (classReference) {\n      do {\n        let typeArguments = classReference.typeArguments;\n        if (typeArguments) {\n          for (let i = 0, k = typeArguments.length; i < k; ++i) {\n            if (!this.checkTypeSupported(typeArguments[i], reportNode)) {\n              return false;\n            }\n          }\n        }\n        classReference = classReference.base;\n      } while (classReference);\n    } else {\n      let signatureReference = type.getSignature();\n      if (signatureReference) {\n        let thisType = signatureReference.thisType;\n        if (thisType) {\n          if (!this.checkTypeSupported(thisType, reportNode)) {\n            return false;\n          }\n        }\n        let parameterTypes = signatureReference.parameterTypes;\n        for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n          if (!this.checkTypeSupported(parameterTypes[i], reportNode)) {\n            return false;\n          }\n        }\n        let returnType = signatureReference.returnType;\n        if (!this.checkTypeSupported(returnType, reportNode)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  /** Initializes a class declaration. */\n  private initializeClass(\n    /** The declaration to initialize. */\n    declaration: ClassDeclaration,\n    /** Parent element, usually a file or namespace. */\n    parent: Element,\n    /** So far queued `extends` clauses. */\n    queuedExtends: ClassPrototype[],\n    /** So far queued `implements` clauses. */\n    queuedImplements: ClassPrototype[]\n  ): ClassPrototype | null {\n    let name = declaration.name.text;\n    let element = new ClassPrototype(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators,\n        DecoratorFlags.Global |\n        DecoratorFlags.Final |\n        DecoratorFlags.Unmanaged\n      )\n    );\n    if (!parent.add(name, element)) return null;\n\n    // remember classes that implement interfaces\n    let implementsTypes = declaration.implementsTypes;\n    if (implementsTypes) {\n      let numImplementsTypes = implementsTypes.length;\n      if (numImplementsTypes) {\n        // cannot implement interfaces when unmanaged\n        if (element.hasDecorator(DecoratorFlags.Unmanaged)) {\n          this.error(\n            DiagnosticCode.Unmanaged_classes_cannot_implement_interfaces,\n            Range.join(\n              declaration.name.range,\n              implementsTypes[numImplementsTypes - 1].range\n            )\n          );\n        } else {\n          queuedImplements.push(element);\n        }\n      }\n    }\n\n    // remember classes that extend another class\n    if (declaration.extendsType) {\n      queuedExtends.push(element);\n    } else if (\n      !element.hasDecorator(DecoratorFlags.Unmanaged) &&\n      element.internalName != BuiltinNames.Object\n    ) {\n      element.implicitlyExtendsObject = true;\n    }\n\n    // initialize members\n    let memberDeclarations = declaration.members;\n    for (let i = 0, k = memberDeclarations.length; i < k; ++i) {\n      let memberDeclaration = memberDeclarations[i];\n      switch (memberDeclaration.kind) {\n        case NodeKind.FieldDeclaration: {\n          this.initializeField(<FieldDeclaration>memberDeclaration, element);\n          break;\n        }\n        case NodeKind.MethodDeclaration: {\n          let methodDeclaration = <MethodDeclaration>memberDeclaration;\n          if (memberDeclaration.isAny(CommonFlags.Get | CommonFlags.Set)) {\n            this.initializeProperty(methodDeclaration, element);\n          } else {\n            let method = this.initializeMethod(methodDeclaration, element);\n            if (method && methodDeclaration.name.kind == NodeKind.Constructor) {\n              element.constructorPrototype = method;\n            }\n          }\n          break;\n        }\n        case NodeKind.IndexSignature: break; // ignored for now\n        default: assert(false); // class member expected\n      }\n    }\n    return element;\n  }\n\n  /** Initializes a field of a class or interface. */\n  private initializeField(\n    /** The declaration to initialize. */\n    declaration: FieldDeclaration,\n    /** Parent class. */\n    parent: ClassPrototype\n  ): void {\n    let name = declaration.name.text;\n    let decorators = declaration.decorators;\n    let element: DeclaredElement;\n    let acceptedFlags: DecoratorFlags = DecoratorFlags.Unsafe;\n    if (parent.is(CommonFlags.Ambient)) {\n      acceptedFlags |= DecoratorFlags.External;\n    }\n    if (declaration.is(CommonFlags.Static)) { // global variable\n      assert(parent.kind != ElementKind.InterfacePrototype);\n      acceptedFlags |= DecoratorFlags.Lazy;\n      if (declaration.is(CommonFlags.Readonly)) {\n        acceptedFlags |= DecoratorFlags.Inline;\n      }\n      element = new Global(\n        name,\n        parent,\n        this.checkDecorators(decorators, acceptedFlags),\n        declaration\n      );\n      if (!parent.add(name, element)) return;\n    } else { // actual instance field\n      assert(!declaration.isAny(CommonFlags.Abstract | CommonFlags.Get | CommonFlags.Set));\n      element = PropertyPrototype.forField(\n        name,\n        parent,\n        declaration,\n        this.checkDecorators(decorators, acceptedFlags)\n      );\n      if (!parent.addInstance(name, element)) return;\n    }\n  }\n\n  /** Initializes a method of a class or interface. */\n  private initializeMethod(\n    /** The declaration to initialize. */\n    declaration: MethodDeclaration,\n    /** Parent class. */\n    parent: ClassPrototype\n  ): FunctionPrototype | null {\n    let name = declaration.name.text;\n    let isStatic = declaration.is(CommonFlags.Static);\n    let acceptedFlags = DecoratorFlags.Inline | DecoratorFlags.Unsafe;\n    if (!declaration.is(CommonFlags.Generic)) {\n      acceptedFlags |= DecoratorFlags.OperatorBinary\n                    |  DecoratorFlags.OperatorPrefix\n                    |  DecoratorFlags.OperatorPostfix;\n    }\n    if (parent.is(CommonFlags.Ambient)) {\n      acceptedFlags |= DecoratorFlags.External;\n    }\n    if (declaration.range.source.isLibrary) {\n      acceptedFlags |= DecoratorFlags.Builtin;\n    }\n    let element = new FunctionPrototype(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators, acceptedFlags)\n    );\n    if (element.hasDecorator(DecoratorFlags.Builtin) && !builtinFunctions.has(element.internalName)) {\n      this.error(\n        DiagnosticCode.Not_implemented_0,\n        declaration.range, `Builtin '${element.internalName}'`\n      );\n    }\n    if (isStatic) { // global function\n      assert(declaration.name.kind != NodeKind.Constructor);\n      if (!parent.add(name, element)) return null;\n    } else { // actual instance method\n      if (!parent.addInstance(name, element)) return null;\n    }\n    this.checkOperatorOverloads(declaration.decorators, element, parent);\n    return element;\n  }\n\n  /** Checks that operator overloads are generally valid, if present. */\n  private checkOperatorOverloads(\n    /** Decorators to check. */\n    decorators: DecoratorNode[] | null,\n    /** Decorated method. */\n    prototype: FunctionPrototype,\n    /** Parent class. */\n    classPrototype: ClassPrototype\n  ): void {\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        let decorator: DecoratorNode = decorators[i]; // FIXME: why does tsc want a type here?\n        switch (decorator.decoratorKind) {\n          case DecoratorKind.Operator:\n          case DecoratorKind.OperatorBinary:\n          case DecoratorKind.OperatorPrefix:\n          case DecoratorKind.OperatorPostfix: {\n            let args = decorator.args;\n            let numArgs = args ? args.length : 0;\n            if (numArgs == 1) {\n              let firstArg = (<Expression[]>decorator.args)[0];\n              if (firstArg.isLiteralKind(LiteralKind.String)) {\n                let text = (<StringLiteralExpression>firstArg).value;\n                let kind = OperatorKind.fromDecorator(decorator.decoratorKind, text);\n                if (kind == OperatorKind.Invalid) {\n                  this.error(\n                    DiagnosticCode._0_is_not_a_valid_operator,\n                    firstArg.range, text\n                  );\n                } else {\n                  let overloads = classPrototype.operatorOverloadPrototypes;\n                  if (overloads.has(kind)) {\n                    this.error(\n                      DiagnosticCode.Duplicate_function_implementation,\n                      firstArg.range\n                    );\n                  } else {\n                    prototype.operatorKind = kind;\n                    overloads.set(kind, prototype);\n                  }\n                }\n              } else {\n                this.error(\n                  DiagnosticCode.String_literal_expected,\n                  firstArg.range\n                );\n              }\n            } else {\n              this.error(\n                DiagnosticCode.Expected_0_arguments_but_got_1,\n                decorator.range, \"1\", numArgs.toString()\n              );\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /** Ensures that the property introduced by the specified getter or setter exists.*/\n  private ensureProperty(\n    /** The declaration of the getter or setter introducing the property. */\n    declaration: MethodDeclaration,\n    /** Parent class. */\n    parent: ClassPrototype\n  ): PropertyPrototype | null {\n    let name = declaration.name.text;\n    if (declaration.is(CommonFlags.Static)) {\n      let parentMembers = parent.members;\n      if (parentMembers && parentMembers.has(name)) {\n        let element = assert(parentMembers.get(name));\n        if (element.kind == ElementKind.PropertyPrototype) return <PropertyPrototype>element;\n      } else {\n        let element = new PropertyPrototype(name, parent, declaration);\n        if (!parent.add(name, element)) return null;\n        return element;\n      }\n    } else {\n      let parentMembers = parent.instanceMembers;\n      if (parentMembers && parentMembers.has(name)) {\n        let element = assert(parentMembers.get(name));\n        if (element.kind == ElementKind.PropertyPrototype) return <PropertyPrototype>element;\n      } else {\n        let element = new PropertyPrototype(name, parent, declaration);\n        if (!parent.addInstance(name, element)) return null;\n        return element;\n      }\n    }\n    this.error(\n      DiagnosticCode.Duplicate_property_0,\n      declaration.name.range, name\n    );\n    return null;\n  }\n\n  /** Initializes a property of a class. */\n  private initializeProperty(\n    /** The declaration of the getter or setter. */\n    declaration: MethodDeclaration,\n    /** Parent class. */\n    parent: ClassPrototype\n  ): void {\n    let property = this.ensureProperty(declaration, parent);\n    if (!property) return;\n    let name = declaration.name.text;\n    let isGetter = declaration.is(CommonFlags.Get);\n    if (isGetter) {\n      if (property.getterPrototype) {\n        this.error(\n          DiagnosticCode.Duplicate_property_0,\n          declaration.name.range, name\n        );\n        return;\n      }\n    } else {\n      if (property.setterPrototype) {\n        this.error(\n          DiagnosticCode.Duplicate_property_0,\n          declaration.name.range, name\n        );\n        return;\n      }\n    }\n    let element = new FunctionPrototype(\n      (isGetter ? GETTER_PREFIX : SETTER_PREFIX) + name,\n      property.parent, // same level as property\n      declaration,\n      this.checkDecorators(declaration.decorators,\n        DecoratorFlags.Inline | DecoratorFlags.Unsafe\n      )\n    );\n    if (isGetter) {\n      property.getterPrototype = element;\n    } else {\n      property.setterPrototype = element;\n    }\n  }\n\n  /** Initializes an enum. */\n  private initializeEnum(\n    /** The declaration to initialize. */\n    declaration: EnumDeclaration,\n    /** Parent element, usually a file or namespace. */\n    parent: Element\n  ): Enum | null {\n    let name = declaration.name.text;\n    let element = new Enum(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators,\n        DecoratorFlags.Global |\n        DecoratorFlags.Inline |\n        DecoratorFlags.Lazy\n      )\n    );\n    if (!parent.add(name, element)) return null;\n    let values = declaration.values;\n    for (let i = 0, k = values.length; i < k; ++i) {\n      this.initializeEnumValue(values[i], element);\n    }\n    return element;\n  }\n\n  /** Initializes an enum value. */\n  private initializeEnumValue(\n    /** The declaration to initialize. */\n    declaration: EnumValueDeclaration,\n    /** Parent enum. */\n    parent: Enum\n  ): void {\n    let name = declaration.name.text;\n    let element = new EnumValue(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators,\n        DecoratorFlags.None\n      )\n    );\n    if (!parent.add(name, element)) return;\n  }\n\n  /** Initializes an `export` statement. */\n  private initializeExports(\n    /** The statement to initialize. */\n    statement: ExportStatement,\n    /** Parent file. */\n    parent: File,\n    /** So far queued `export`s. */\n    queuedExports: Map<File,Map<string,QueuedExport>>,\n    /** So far queued `export *`s. */\n    queuedExportsStar: Map<File,QueuedExportStar[]>\n  ): void {\n    let members = statement.members;\n    if (members) { // export { foo, bar } [from \"./baz\"]\n      for (let i = 0, k = members.length; i < k; ++i) {\n        this.initializeExport(members[i], parent, statement.internalPath, queuedExports);\n      }\n    } else { // export * from \"./baz\"\n      let queued: QueuedExportStar[];\n      if (queuedExportsStar.has(parent)) queued = assert(queuedExportsStar.get(parent));\n      else queuedExportsStar.set(parent, queued = []);\n      let foreignPath = statement.internalPath!; // must be set for export *\n      queued.push(new QueuedExportStar(\n        foreignPath,\n        foreignPath.endsWith(INDEX_SUFFIX) // strip or add index depending on what's already present\n          ? foreignPath.substring(0, foreignPath.length - INDEX_SUFFIX.length)\n          : foreignPath + INDEX_SUFFIX,\n        assert(statement.path)\n      ));\n    }\n  }\n\n  /** Initializes a single `export` member. Does not handle `export *`. */\n  private initializeExport(\n    /** The member to initialize. */\n    member: ExportMember,\n    /** Local file. */\n    localFile: File,\n    /** Path to the other file, if present. */\n    foreignPath: string | null,\n    /** So far queued `export`s. */\n    queuedExports: Map<File,Map<string,QueuedExport>>\n  ): void {\n    let localName = member.localName.text;\n    let foreignName = member.exportedName.text;\n\n    // check for duplicates\n    let element = localFile.lookupExport(foreignName);\n    if (element) {\n      this.error(\n        DiagnosticCode.Export_declaration_conflicts_with_exported_declaration_of_0,\n        member.exportedName.range, foreignName\n      );\n      return;\n    }\n    // local element, i.e. export { foo [as bar] }\n    if (foreignPath == null) {\n\n      // resolve right away if the local element already exists\n      if (element = localFile.getMember(localName)) {\n        localFile.ensureExport(foreignName, element);\n\n      // otherwise queue it\n      } else {\n        let queued: Map<string,QueuedExport>;\n        if (queuedExports.has(localFile)) queued = assert(queuedExports.get(localFile));\n        else queuedExports.set(localFile, queued = new Map());\n        queued.set(foreignName, new QueuedExport(\n          member.localName,\n          member.exportedName,\n          null, null\n        ));\n      }\n\n    // foreign element, i.e. export { foo } from \"./bar\"\n    } else {\n      let queued: Map<string,QueuedExport>;\n      if (queuedExports.has(localFile)) queued = assert(queuedExports.get(localFile));\n      else queuedExports.set(localFile, queued = new Map());\n      queued.set(foreignName, new QueuedExport(\n        member.localName,\n        member.exportedName,\n        foreignPath,\n        foreignPath.endsWith(INDEX_SUFFIX) // strip or add index depending on what's already present\n          ? foreignPath.substring(0, foreignPath.length - INDEX_SUFFIX.length)\n          : foreignPath + INDEX_SUFFIX\n      ));\n    }\n  }\n\n  private initializeExportDefault(\n    /** The statement to initialize. */\n    statement: ExportDefaultStatement,\n    /** Parent file. */\n    parent: File,\n    /** So far queued `extends` clauses. */\n    queuedExtends: Array<ClassPrototype>,\n    /** So far queued `implements` clauses. */\n    queuedImplements: ClassPrototype[]\n  ): void {\n    let declaration = statement.declaration;\n    let element: DeclaredElement | null = null;\n    switch (declaration.kind) {\n      case NodeKind.EnumDeclaration: {\n        element = this.initializeEnum(<EnumDeclaration>declaration, parent);\n        break;\n      }\n      case NodeKind.FunctionDeclaration: {\n        element = this.initializeFunction(<FunctionDeclaration>declaration, parent);\n        break;\n      }\n      case NodeKind.ClassDeclaration: {\n        element = this.initializeClass(<ClassDeclaration>declaration, parent, queuedExtends, queuedImplements);\n        break;\n      }\n      case NodeKind.InterfaceDeclaration: {\n        element = this.initializeInterface(<InterfaceDeclaration>declaration, parent, queuedExtends);\n        break;\n      }\n      case NodeKind.NamespaceDeclaration: {\n        element = this.initializeNamespace(<NamespaceDeclaration>declaration, parent, queuedExtends, queuedImplements);\n        break;\n      }\n      default: assert(false);\n    }\n    if (element) {\n      let exports = parent.exports;\n      if (!exports) parent.exports = exports = new Map();\n      else {\n        if (exports.has(\"default\")) {\n          let existing = assert(exports.get(\"default\"));\n          this.errorRelated(\n            DiagnosticCode.Duplicate_identifier_0,\n            declaration.name.range,\n            existing.declaration.name.range,\n            \"default\"\n          );\n          return;\n        }\n      }\n      exports.set(\"default\", element);\n    }\n  }\n\n  /** Initializes an `import` statement. */\n  private initializeImports(\n    /** The statement to initialize. */\n    statement: ImportStatement,\n    /** Parent file. */\n    parent: File,\n    /** So far queued `import`s. */\n    queuedImports: QueuedImport[],\n    /** So far queued `export`s. */\n    queuedExports: Map<File,Map<string,QueuedExport>>\n  ): void {\n    let declarations = statement.declarations;\n    if (declarations) { // import { foo [as bar] } from \"./baz\"\n      for (let i = 0, k = declarations.length; i < k; ++i) {\n        this.initializeImport(\n          declarations[i],\n          parent,\n          statement.internalPath,\n          queuedImports,\n          queuedExports\n        );\n      }\n    } else {\n      let namespaceName = statement.namespaceName;\n      if (namespaceName) { // import * as foo from \"./bar\"\n        queuedImports.push(new QueuedImport(\n          parent,\n          namespaceName,\n          null, // indicates import *\n          statement.internalPath,\n          statement.internalPath + INDEX_SUFFIX\n        ));\n      } else {\n        // import \"./foo\"\n      }\n    }\n  }\n\n  /** Initializes a single `import` declaration. Does not handle `import *`. */\n  private initializeImport( // { foo [as bar] }\n    /** The declaration to initialize. */\n    declaration: ImportDeclaration,\n    /** Parent file. */\n    parent: File,\n    /** Path to the other file. */\n    foreignPath: string,\n    /** So far queued `import`s. */\n    queuedImports: QueuedImport[],\n    /** So far queued `export`s. */\n    queuedExports: Map<File,Map<string,QueuedExport>>\n  ): void {\n    let foreignPathAlt = foreignPath.endsWith(INDEX_SUFFIX) // strip or add index depending on what's already present\n      ? foreignPath.substring(0, foreignPath.length - INDEX_SUFFIX.length)\n      : foreignPath + INDEX_SUFFIX;\n\n    // resolve right away if the element exists\n    let foreignFile = this.lookupForeignFile(foreignPath, foreignPathAlt);\n    if (foreignFile) {\n      let element = this.lookupForeign(declaration.foreignName.text, foreignFile, queuedExports);\n      if (element) {\n        parent.add(declaration.name.text, element, declaration.name /* isImport */);\n        return;\n      }\n    }\n\n    // otherwise queue it\n    queuedImports.push(new QueuedImport(\n      parent,\n      declaration.name,\n      declaration.foreignName,\n      foreignPath,\n      foreignPathAlt\n    ));\n  }\n\n  /** Initializes a function. Does not handle methods. */\n  private initializeFunction(\n    /** The declaration to initialize. */\n    declaration: FunctionDeclaration,\n    /** Parent element, usually a file or namespace. */\n    parent: Element\n  ): FunctionPrototype | null {\n    let name = declaration.name.text;\n    let validDecorators = DecoratorFlags.Unsafe;\n    if (declaration.is(CommonFlags.Ambient)) {\n      validDecorators |= DecoratorFlags.External | DecoratorFlags.ExternalJs;\n    } else {\n      validDecorators |= DecoratorFlags.Inline;\n      if (declaration.range.source.isLibrary || declaration.is(CommonFlags.Export)) {\n        validDecorators |= DecoratorFlags.Lazy;\n      }\n    }\n    if (!declaration.is(CommonFlags.Instance)) {\n      if (parent.kind != ElementKind.ClassPrototype) {\n        validDecorators |= DecoratorFlags.Global;\n      }\n    }\n    if (declaration.range.source.isLibrary) {\n      validDecorators |= DecoratorFlags.Builtin;\n    }\n    let element = new FunctionPrototype(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators, validDecorators)\n    );\n    if (element.hasDecorator(DecoratorFlags.Builtin) && !builtinFunctions.has(element.internalName)) {\n      this.error(\n        DiagnosticCode.Not_implemented_0,\n        declaration.range, `Builtin '${element.internalName}'`\n      );\n    }\n    if (!parent.add(name, element)) return null;\n    return element;\n  }\n\n  /** Initializes an interface. */\n  private initializeInterface(\n    /** The declaration to initialize. */\n    declaration: InterfaceDeclaration,\n    /** Parent element, usually a file or namespace. */\n    parent: Element,\n    /** So far queued `extends` clauses. */\n    queuedExtends: ClassPrototype[],\n  ): InterfacePrototype | null {\n    let name = declaration.name.text;\n    let element = new InterfacePrototype(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators,\n        DecoratorFlags.Global\n      )\n    );\n    if (!parent.add(name, element)) return null;\n\n    // remember interfaces that extend another interface\n    if (declaration.extendsType) queuedExtends.push(element);\n\n    let memberDeclarations = declaration.members;\n    for (let i = 0, k = memberDeclarations.length; i < k; ++i) {\n      let memberDeclaration = memberDeclarations[i];\n      switch (memberDeclaration.kind) {\n        case NodeKind.FieldDeclaration: {\n          this.initializeFieldAsProperty(<FieldDeclaration>memberDeclaration, element);\n          break;\n        }\n        case NodeKind.MethodDeclaration: {\n          let methodDeclaration = <MethodDeclaration>memberDeclaration;\n          if (memberDeclaration.isAny(CommonFlags.Get | CommonFlags.Set)) {\n            this.initializeProperty(methodDeclaration, element);\n          } else {\n            this.initializeMethod(methodDeclaration, element);\n          }\n          break;\n        }\n        default: assert(false); // interface member expected\n      }\n    }\n    return element;\n  }\n\n  /** Initializes a field of an interface, as a property. */\n  private initializeFieldAsProperty(\n    /** Field declaration. */\n    declaration: FieldDeclaration,\n    /** Parent interface. */\n    parent: InterfacePrototype\n  ): void {\n    let initializer = declaration.initializer;\n    if (initializer) {\n      this.error(DiagnosticCode.An_interface_property_cannot_have_an_initializer, initializer.range);\n    }\n    let typeNode = declaration.type;\n    if (!typeNode) typeNode = Node.createOmittedType(declaration.name.range.atEnd);\n    this.initializeProperty(\n      Node.createMethodDeclaration(\n        declaration.name,\n        declaration.decorators,\n        declaration.flags | CommonFlags.Get,\n        null,\n        Node.createFunctionType(\n          [],\n          typeNode,\n          null,\n          false,\n          declaration.range\n        ),\n        null,\n        declaration.range\n      ),\n      parent\n    );\n    if (!declaration.is(CommonFlags.Readonly)) {\n      this.initializeProperty(\n        Node.createMethodDeclaration(\n          declaration.name,\n          declaration.decorators,\n          declaration.flags | CommonFlags.Set,\n          null,\n          Node.createFunctionType(\n            [\n              Node.createParameter(\n                ParameterKind.Default,\n                declaration.name,\n                typeNode,\n                null,\n                declaration.name.range\n              )\n            ],\n            Node.createOmittedType(declaration.name.range.atEnd),\n            null,\n            false,\n            declaration.range\n          ),\n          null,\n          declaration.range\n        ),\n        parent\n      );\n    }\n  }\n\n  /** Initializes a namespace. */\n  private initializeNamespace(\n    /** The declaration to initialize. */\n    declaration: NamespaceDeclaration,\n    /** Parent element, usually a file or another namespace. */\n    parent: Element,\n    /** So far queued `extends` clauses. */\n    queuedExtends: ClassPrototype[],\n    /** So far queued `implements` clauses. */\n    queuedImplements: ClassPrototype[]\n  ): DeclaredElement | null {\n    let name = declaration.name.text;\n    let original = new Namespace(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators, DecoratorFlags.Global)\n    );\n    if (!parent.add(name, original)) return null;\n    let element = assert(parent.getMember(name)); // possibly merged\n    let members = declaration.members;\n    for (let i = 0, k = members.length; i < k; ++i) {\n      let member = members[i];\n      switch (member.kind) {\n        case NodeKind.ClassDeclaration: {\n          this.initializeClass(<ClassDeclaration>member, original, queuedExtends, queuedImplements);\n          break;\n        }\n        case NodeKind.EnumDeclaration: {\n          this.initializeEnum(<EnumDeclaration>member, original);\n          break;\n        }\n        case NodeKind.FunctionDeclaration: {\n          this.initializeFunction(<FunctionDeclaration>member, original);\n          break;\n        }\n        case NodeKind.InterfaceDeclaration: {\n          this.initializeInterface(<InterfaceDeclaration>member, original, queuedExtends);\n          break;\n        }\n        case NodeKind.NamespaceDeclaration: {\n          this.initializeNamespace(<NamespaceDeclaration>member, original, queuedExtends, queuedImplements);\n          break;\n        }\n        case NodeKind.TypeDeclaration: {\n          this.initializeTypeDefinition(<TypeDeclaration>member, original);\n          break;\n        }\n        case NodeKind.Variable: {\n          this.initializeVariables(<VariableStatement>member, original);\n          break;\n        }\n        default: assert(false); // namespace member expected\n      }\n    }\n    if (original != element) copyMembers(original, element); // keep original parent\n    return element;\n  }\n\n  /** Initializes a `type` definition. */\n  private initializeTypeDefinition(\n    /** The declaration to initialize. */\n    declaration: TypeDeclaration,\n    /** Parent element, usually a file or namespace. */\n    parent: Element\n  ): void {\n    let name = declaration.name.text;\n    let element = new TypeDefinition(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators, DecoratorFlags.None)\n    );\n    parent.add(name, element); // reports\n  }\n\n  /** Initializes a variable statement. */\n  private initializeVariables(\n    /** The statement to initialize. */\n    statement: VariableStatement,\n    /** Parent element, usually a file or namespace. */\n    parent: Element\n  ): void {\n    let declarations = statement.declarations;\n    for (let i = 0, k = declarations.length; i < k; ++i) {\n      let declaration = declarations[i];\n      let name = declaration.name.text;\n      let acceptedFlags = DecoratorFlags.Global | DecoratorFlags.Lazy;\n      if (declaration.is(CommonFlags.Ambient)) {\n        acceptedFlags |= DecoratorFlags.External;\n      }\n      if (declaration.is(CommonFlags.Const)) {\n        acceptedFlags |= DecoratorFlags.Inline;\n      }\n      if (declaration.range.source.isLibrary) {\n        acceptedFlags |= DecoratorFlags.Builtin;\n      }\n      let element = new Global(\n        name,\n        parent,\n        this.checkDecorators(declaration.decorators, acceptedFlags),\n        declaration\n      );\n      if (element.hasDecorator(DecoratorFlags.Builtin) && !builtinVariables_onAccess.has(element.internalName)) {\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          declaration.range, `Builtin '${element.internalName}'`\n        );\n      }\n      if (!parent.add(name, element)) continue; // reports\n    }\n  }\n\n  /** Determines the element type of a built-in array. */\n  // determineBuiltinArrayType(target: Class): Type | null {\n  //   switch (target.internalName) {\n  //     case BuiltinSymbols.Int8Array: return Type.i8;\n  //     case BuiltinSymbols.Uint8ClampedArray:\n  //     case BuiltinSymbols.Uint8Array: return Type.u8;\n  //     case BuiltinSymbols.Int16Array: return Type.i16;\n  //     case BuiltinSymbols.Uint16Array: return Type.u16;\n  //     case BuiltinSymbols.Int32Array: return Type.i32;\n  //     case BuiltinSymbols.Uint32Array: return Type.u32;\n  //     case BuiltinSymbols.Int64Array: return Type.i64;\n  //     case BuiltinSymbols.Uint64Array: return Type.u64;\n  //     case BuiltinSymbols.Float32Array: return Type.f32;\n  //     case BuiltinSymbols.Float64Array: return Type.f64;\n  //   }\n  //   let current: Class | null = target;\n  //   let arrayPrototype = this.arrayPrototype;\n  //   do {\n  //     if (current.prototype == arrayPrototype) { // Array<T>\n  //       let typeArguments = assert(current.typeArguments);\n  //       assert(typeArguments.length == 1);\n  //       return typeArguments[0];\n  //     }\n  //   } while (current = current.base);\n  //   return null;\n  // }\n}\n\n/** Indicates the specific kind of an {@link Element}. */\nexport const enum ElementKind {\n  /** A {@link Global}. */\n  Global,\n  /** A {@link Local}. */\n  Local,\n  /** An {@link Enum}. */\n  Enum,\n  /** An {@link EnumValue}. */\n  EnumValue,\n  /** A {@link FunctionPrototype}. */\n  FunctionPrototype,\n  /** A {@link Function}. */\n  Function,\n  /** A {@link ClassPrototype}. */\n  ClassPrototype,\n  /** A {@link Class}. */\n  Class,\n  /** An {@link InterfacePrototype}. */\n  InterfacePrototype,\n  /** An {@link Interface}. */\n  Interface,\n  /** A {@link PropertyPrototype}.  */\n  PropertyPrototype,\n  /** A {@link Property}. */\n  Property,\n  /** A {@link Namespace}. */\n  Namespace,\n  /** A {@link File}. */\n  File,\n  /** A {@link TypeDefinition}.  */\n  TypeDefinition,\n  /** An {@link IndexSignature}. */\n  IndexSignature\n}\n\n/** Indicates built-in decorators that are present. */\nexport enum DecoratorFlags {\n  /** No flags set. */\n  None = 0,\n  /** Is a program global. */\n  Global = 1 << 0,\n  /** Is a binary operator overload. */\n  OperatorBinary = 1 << 1,\n  /** Is a unary prefix operator overload. */\n  OperatorPrefix = 1 << 2,\n  /** Is a unary postfix operator overload. */\n  OperatorPostfix = 1 << 3,\n  /** Is an unmanaged class. */\n  Unmanaged = 1 << 4,\n  /** Is a final class. */\n  Final = 1 << 5,\n  /** Is always inlined. */\n  Inline = 1 << 6,\n  /** Is using a different external name. */\n  External = 1 << 7,\n  /** Has external JavaScript code. */\n  ExternalJs = 1 << 8,\n  /** Is a builtin. */\n  Builtin = 1 << 9,\n  /** Is compiled lazily. */\n  Lazy = 1 << 10,\n  /** Is considered unsafe code. */\n  Unsafe = 1 << 11\n}\n\nexport namespace DecoratorFlags {\n\n  /** Translates a decorator kind to the respective decorator flag. */\n  export function fromKind(kind: DecoratorKind): DecoratorFlags {\n    switch (kind) {\n      case DecoratorKind.Global: return DecoratorFlags.Global;\n      case DecoratorKind.Operator:\n      case DecoratorKind.OperatorBinary: return DecoratorFlags.OperatorBinary;\n      case DecoratorKind.OperatorPrefix: return DecoratorFlags.OperatorPrefix;\n      case DecoratorKind.OperatorPostfix: return DecoratorFlags.OperatorPostfix;\n      case DecoratorKind.Unmanaged: return DecoratorFlags.Unmanaged;\n      case DecoratorKind.Final: return DecoratorFlags.Final;\n      case DecoratorKind.Inline: return DecoratorFlags.Inline;\n      case DecoratorKind.External: return DecoratorFlags.External;\n      case DecoratorKind.ExternalJs: return DecoratorFlags.ExternalJs;\n      case DecoratorKind.Builtin: return DecoratorFlags.Builtin;\n      case DecoratorKind.Lazy: return DecoratorFlags.Lazy;\n      case DecoratorKind.Unsafe: return DecoratorFlags.Unsafe;\n      default: return DecoratorFlags.None;\n    }\n  }\n}\n\n/** Base class of all program elements. */\nexport abstract class Element {\n\n  /** Parent element. */\n  parent!: Element;\n  /** Common flags indicating specific traits. */\n  flags: CommonFlags = CommonFlags.None;\n  /** Decorator flags indicating annotated traits. */\n  decoratorFlags: DecoratorFlags = DecoratorFlags.None;\n  /** Member elements. */\n  members: Map<string,DeclaredElement> | null = null;\n  /** Shadowing type in type space, if any. */\n  shadowType: TypeDefinition | null = null;\n\n  /** Constructs a new program element. */\n  protected constructor(\n    /** Specific element kind. */\n    public kind: ElementKind,\n    /** Simple name. */\n    public name: string,\n    /** Internal name referring to this element. */\n    public internalName: string,\n    /** Containing {@link Program}. */\n    public program: Program,\n    /** Parent element. */\n    parent: Element | null\n  ) {\n    this.program = program;\n    this.name = name;\n    this.internalName = internalName;\n    if (parent) {\n      this.parent = parent;\n    } else {\n      assert(this.kind == ElementKind.File);\n      this.parent = this; // special case to keep this.parent non-nullable\n    }\n  }\n\n  /** Gets the enclosing file. */\n  get file(): File {\n    let current: Element = this;\n    do {\n      current = current.parent;\n      if (current.kind == ElementKind.File) return <File>current;\n    } while (true);\n  }\n\n  /** Tests if this element has a specific flag or flags. */\n  is(flag: CommonFlags): bool { return (this.flags & flag) == flag; }\n  /** Tests if this element has any of the specified flags. */\n  isAny(flags: CommonFlags): bool { return (this.flags & flags) != 0; }\n  /** Sets a specific flag or flags. */\n  set(flag: CommonFlags): void { this.flags |= flag; }\n  /** Unsets the specific flag or flags. */\n  unset(flag: CommonFlags): void {this.flags &= ~flag; }\n  /** Tests if this element has a specific decorator flag or flags. */\n  hasDecorator(flag: DecoratorFlags): bool { return (this.decoratorFlags & flag) == flag; }\n  /** Tests if this element has any of the specified decorator flags. */\n  hasAnyDecorator(flags: DecoratorFlags): bool { return (this.decoratorFlags & flags) != 0; }\n\n  /** Get the member with the specified name, if any. */\n  getMember(name: string): DeclaredElement | null {\n    let members = this.members;\n    if (members && members.has(name)) return assert(members.get(name));\n    return null;\n  }\n\n  /** Looks up the element with the specified name relative to this element. */\n  lookup(name: string, isType: bool = false): Element | null {\n    return this.parent.lookup(name, isType);\n  }\n\n  /** Adds an element as a member of this one. Reports and returns `false` if a duplicate. */\n  add(name: string, element: DeclaredElement, localIdentifierIfImport: IdentifierExpression | null = null): bool {\n    let originalDeclaration = element.declaration;\n    let members = this.members;\n    if (!members) this.members = members = new Map();\n    else if (members.has(name)) {\n      let existing = assert(members.get(name));\n      if (existing.parent != this) {\n        // override non-own element\n      } else {\n        let merged = tryMerge(existing, element);\n        if (merged) {\n          element = merged; // use merged element\n        } else {\n          let reportedIdentifier = localIdentifierIfImport\n            ? localIdentifierIfImport\n            : element.identifierNode;\n          if (isDeclaredElement(existing.kind)) {\n            this.program.errorRelated(\n              DiagnosticCode.Duplicate_identifier_0,\n              reportedIdentifier.range,\n              (<DeclaredElement>existing).identifierNode.range,\n              reportedIdentifier.text\n            );\n          } else {\n            this.program.error(\n              DiagnosticCode.Duplicate_identifier_0,\n              reportedIdentifier.range, reportedIdentifier.text\n            );\n          }\n          return false;\n        }\n      }\n    }\n    members.set(name, element);\n    let program = this.program;\n    if (element.kind != ElementKind.FunctionPrototype || !(<FunctionPrototype>element).isBound) {\n      // prefer unbound prototypes in global lookup maps\n      program.elementsByName.set(element.internalName, element);\n      program.elementsByDeclaration.set(originalDeclaration, element);\n    }\n    return true;\n  }\n\n  /** Checks if this element is public, explicitly or implicitly. */\n  get isPublic(): bool {\n    return !this.isAny(CommonFlags.Private | CommonFlags.Protected);\n  }\n\n  /** Checks if this element is implicitly public, i.e. not explicitly declared to be. */\n  get isImplicitlyPublic(): bool {\n    return this.isPublic && !this.is(CommonFlags.Public);\n  }\n\n  /** Checks if the visibility of this element equals the specified. */\n  visibilityEquals(other: Element): bool {\n    if (this.isPublic == other.isPublic) return true;\n    const vis = CommonFlags.Private | CommonFlags.Protected;\n    return (this.flags & vis) == (other.flags & vis);\n  }\n\n  visibilityNoLessThan(other: Element): bool {\n    if (this.isPublic) return true; // public is a most frequent case\n    if (this.is(CommonFlags.Private)) return other.is(CommonFlags.Private);\n    if (this.is(CommonFlags.Protected)) return other.isAny(CommonFlags.Private | CommonFlags.Protected);\n    return assert(false);\n  }\n\n  /** Tests if this element is bound to a class. */\n  get isBound(): bool {\n    let parent = this.parent;\n    switch (parent.kind) {\n      case ElementKind.Class:\n      case ElementKind.Interface: return true;\n    }\n    return false;\n  }\n\n  /** Gets the class or interface this element is bound to, if any. */\n  getBoundClassOrInterface(): Class | null {\n    let parent = this.parent;\n    switch (parent.kind) {\n      case ElementKind.Class:\n      case ElementKind.Interface: return <Class>parent;\n    }\n    return null;\n  }\n\n  /** Returns a string representation of this element. */\n  toString(): string {\n    return `${this.internalName}, kind=${this.kind}`;\n  }\n}\n\n// Kinds of all declared elements\nlet declaredElements = new Set<ElementKind>();\n\n/** Tests if the specified element kind indicates a declared element. */\nexport function isDeclaredElement(kind: ElementKind): bool {\n  return declaredElements.has(kind);\n}\n\n/** Base class of elements with an associated declaration statement. */\nexport abstract class DeclaredElement extends Element {\n\n  /** Constructs a new declared program element. */\n  protected constructor(\n    /** Specific element kind. */\n    kind: ElementKind,\n    /** Simple name. */\n    name: string,\n    /** Internal name referring to this element. */\n    internalName: string,\n    /** Containing {@link Program}. */\n    program: Program,\n    /** Parent element. */\n    parent: Element | null,\n    /** Declaration reference. */\n    public declaration: DeclarationStatement\n  ) {\n    super(kind, name, internalName, program, parent);\n    declaredElements.add(kind);\n    // It is necessary to have access to identifiers of all members and exports\n    // for reporting purposes and this is the lowest common denominator. Comes\n    // at the expense of not having more specific type information in derived\n    // classes, though. Instead, derived classes implement getters for other\n    // important AST nodes directly through manual casting, allowing the resolver\n    // etc. to not worry about actual declarations.\n    this.declaration = declaration;\n    this.flags = declaration.flags; // inherit\n  }\n\n  /** Tests if this element is a library element. */\n  get isDeclaredInLibrary(): bool {\n    return this.declaration.range.source.isLibrary;\n  }\n\n  /** Gets the associated identifier node. */\n  get identifierNode(): IdentifierExpression {\n    return this.declaration.name;\n  }\n\n  /** Gets the signature node, if applicable, along the identifier node. */\n  get identifierAndSignatureRange(): Range {\n    let declaration = this.declaration;\n    let identifierNode = declaration.name;\n    if (declaration.kind == NodeKind.FunctionDeclaration || declaration.kind == NodeKind.MethodDeclaration) {\n      let signatureNode = (<FunctionDeclaration>declaration).signature;\n      if (identifierNode.range.source == signatureNode.range.source) {\n        return Range.join(identifierNode.range, signatureNode.range);\n      }\n    }\n    return identifierNode.range;\n  }\n\n  /** Gets the assiciated decorator nodes. */\n  get decoratorNodes(): DecoratorNode[] | null {\n    return this.declaration.decorators;\n  }\n}\n\n// Kinds of all typed elements\nlet typedElements = new Set<ElementKind>();\n\n/** Checks if the specified element kind indicates a typed element. */\nexport function isTypedElement(kind: ElementKind): bool {\n  return typedElements.has(kind);\n}\n\n/** Base class of elements that can be resolved to a concrete type. */\nexport abstract class TypedElement extends DeclaredElement {\n\n  /** Resolved type. Set once `is(RESOLVED)`, otherwise void. */\n  type: Type = Type.void;\n\n  constructor(\n    /** Specific element kind. */\n    kind: ElementKind,\n    /** Simple name. */\n    name: string,\n    /** Internal name referring to this element. */\n    internalName: string,\n    /** Containing {@link Program}. */\n    program: Program,\n    /** Parent element. */\n    parent: Element | null,\n    /** Declaration reference. */\n    declaration: DeclarationStatement\n  ) {\n    super(kind, name, internalName, program, parent, declaration);\n    typedElements.add(kind);\n  }\n\n  /** Sets the resolved type of this element. */\n  setType(type: Type): void {\n    assert(!this.is(CommonFlags.Resolved));\n    this.type = type;\n    this.set(CommonFlags.Resolved);\n  }\n}\n\n/** A file representing the implicit top-level namespace of a source. */\nexport class File extends Element {\n\n  /** File exports. */\n  exports: Map<string,DeclaredElement> | null = null;\n  /** File re-exports. */\n  exportsStar: File[] | null = null;\n  /** Top-level start function of this file. */\n  startFunction!: Function;\n  /** Array of `import * as X` alias namespaces of this file. */\n  aliasNamespaces: Array<Namespace> = new Array<Namespace>();\n\n  /** Constructs a new file. */\n  constructor(\n    /** Program this file belongs to. */\n    program: Program,\n    /** Source of this file. */\n    public source: Source\n  ) {\n    super(\n      ElementKind.File,\n      source.normalizedPath,\n      source.internalPath,\n      program,\n      null // special case for files\n    );\n    this.source = source;\n    assert(!program.filesByName.has(this.internalName));\n    program.filesByName.set(this.internalName, this);\n    let startFunction = this.program.makeNativeFunction(\n      `start:${this.internalName}`,\n      Signature.create(program, [], Type.void),\n      this\n    );\n    startFunction.internalName = startFunction.name;\n    this.startFunction = startFunction;\n  }\n\n  /* @override */\n  add(name: string, element: DeclaredElement, localIdentifierIfImport: IdentifierExpression | null = null): bool {\n    if (element.hasDecorator(DecoratorFlags.Global)) {\n      element = this.program.ensureGlobal(name, element); // possibly merged globally\n    }\n    if (!super.add(name, element, localIdentifierIfImport)) return false;\n    element = assert(this.getMember(name)); // possibly merged locally\n    if (element.is(CommonFlags.Export) && !localIdentifierIfImport) {\n      this.ensureExport(\n        element.name,\n        element\n      );\n    }\n    return true;\n  }\n\n  /* @override */\n  getMember(name: string): DeclaredElement | null {\n    let element = super.getMember(name);\n    if (element) return element;\n    let exportsStar = this.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        if (element = exportsStar[i].getMember(name)) return element;\n      }\n    }\n    return null;\n  }\n\n  /* @override */\n  lookup(name: string, isType: bool = false): Element | null {\n    let element = this.getMember(name);\n    if (element) return element;\n    return this.program.lookup(name); // has no meaningful parent\n  }\n\n  /** Ensures that an element is an export of this file. */\n  ensureExport(name: string, element: DeclaredElement): void {\n    let exports = this.exports;\n    if (!exports) this.exports = exports = new Map();\n    exports.set(name, element);\n    if (this.source.sourceKind == SourceKind.LibraryEntry) this.program.ensureGlobal(name, element);\n\n    // Also, add to the namespaces that capture our exports\n    for(let i = 0; i < this.aliasNamespaces.length; i++) {\n      let ns = this.aliasNamespaces[i];\n      ns.add(name, element);\n    }\n  }\n\n  /** Ensures that another file is a re-export of this file. */\n  ensureExportStar(file: File): void {\n    let exportsStar = this.exportsStar;\n    if (!exportsStar) this.exportsStar = exportsStar = [];\n    else if (exportsStar.includes(file)) return;\n    exportsStar.push(file);\n  }\n\n  /** Looks up the export of the specified name. */\n  lookupExport(name: string): DeclaredElement | null {\n    let exports = this.exports;\n    if (exports && exports.has(name)) return assert(exports.get(name));\n    let exportsStar = this.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        let element = exportsStar[i].lookupExport(name);\n        if (element) return element;\n      }\n    }\n    return null;\n  }\n\n  /** Creates an imported namespace from this file. */\n  asAliasNamespace(\n    name: string,\n    parent: Element,\n    localIdentifier: IdentifierExpression\n  ): Namespace {\n    let declaration = this.program.makeNativeNamespaceDeclaration(name);\n    declaration.name = localIdentifier;\n    let ns = new Namespace(name, parent, declaration);\n    ns.set(CommonFlags.Scoped);\n    this.copyExportsToNamespace(ns);\n    // NOTE: Some exports are still queued, and can't yet be added here,\n    // so we remember all the alias namespaces and add to them as well\n    // when adding an element to the file.\n    this.aliasNamespaces.push(ns);\n    return ns;\n  }\n\n  /** Recursively copies the exports of this file to the specified namespace. */\n  private copyExportsToNamespace(ns: Namespace): void {\n    let exports = this.exports;\n    if (exports) {\n      // TODO: for (let [memberName, member] of exports) {\n      for (let _keys = Map_keys(exports), i = 0, k = _keys.length; i < k; ++i) {\n        let memberName = unchecked(_keys[i]);\n        let member = assert(exports.get(memberName));\n        ns.add(memberName, member);\n      }\n    }\n    let exportsStar = this.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        exportsStar[i].copyExportsToNamespace(ns);\n      }\n    }\n  }\n}\n\n/** A type definition. */\nexport class TypeDefinition extends TypedElement {\n\n  /** Constructs a new type definition. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element. */\n    parent: Element,\n    /** Declaration reference. */\n    declaration: TypeDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.None\n  ) {\n    super(\n      ElementKind.TypeDefinition,\n      name,\n      mangleInternalName(name, parent, false),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n\n  /** Gets the associated type parameter nodes. */\n  get typeParameterNodes(): TypeParameterNode[] | null {\n    return (<TypeDeclaration>this.declaration).typeParameters;\n  }\n\n  /** Gets the associated type node. */\n  get typeNode(): TypeNode {\n    return (<TypeDeclaration>this.declaration).type;\n  }\n}\n\n/** A namespace that differs from a file in being user-declared with a name. */\nexport class Namespace extends DeclaredElement {\n\n  /** Constructs a new namespace. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file or another namespace. */\n    parent: Element,\n    /** Declaration reference. */\n    declaration: NamespaceDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.None\n  ) {\n    super(\n      ElementKind.Namespace,\n      name,\n      mangleInternalName(name, parent, false),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n\n  /* @override */\n  lookup(name: string, isType: bool = false): Element | null {\n    let member = this.getMember(name);\n    if (member) return member;\n    return super.lookup(name, isType);\n  }\n}\n\n/** An enum. */\nexport class Enum extends TypedElement {\n\n  /** Constructs a new enum. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file or namespace. */\n    parent: Element,\n    /** Declaration reference. */\n    declaration: EnumDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.None\n  ) {\n    super(\n      ElementKind.Enum,\n      name,\n      mangleInternalName(name, parent, false),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n    this.setType(Type.i32);\n  }\n\n  /* @override */\n  lookup(name: string, isType: bool = false): Element | null {\n    let member = this.getMember(name);\n    if (member) return member;\n    return super.lookup(name, isType);\n  }\n}\n\n/** Indicates the kind of an inlined constant value. */\nexport const enum ConstantValueKind {\n  /** No constant value. */\n  None,\n  /** Constant integer value. */\n  Integer,\n  /** Constant float value. */\n  Float\n}\n\n/** Base class of all variable-like program elements. */\nexport abstract class VariableLikeElement extends TypedElement {\n\n  /** Constant value kind. */\n  constantValueKind: ConstantValueKind = ConstantValueKind.None;\n  /** Constant integer value, if applicable. */\n  constantIntegerValue: i64 = i64_zero;\n  /** Constant float value, if applicable. */\n  constantFloatValue: f64 = 0;\n\n  /** Constructs a new variable-like element. */\n  protected constructor(\n    /** Specific element kind. */\n    kind: ElementKind,\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file, namespace or class. */\n    parent: Element,\n    /** Declaration reference. Creates a native declaration if omitted. */\n    declaration: VariableLikeDeclarationStatement = parent.program.makeNativeVariableDeclaration(name)\n  ) {\n    super(\n      kind,\n      name,\n      mangleInternalName(name, parent, declaration.is(CommonFlags.Instance)),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.flags = declaration.flags;\n  }\n\n  /** Gets the associated type node.s */\n  get typeNode(): TypeNode | null {\n    return (<VariableLikeDeclarationStatement>this.declaration).type;\n  }\n\n  /** Gets the associated initializer node. */\n  get initializerNode(): Expression | null {\n    return (<VariableLikeDeclarationStatement>this.declaration).initializer;\n  }\n\n  /** Applies a constant integer value to this element. */\n  setConstantIntegerValue(value: i64, type: Type): void {\n    assert(type.isIntegerInclReference);\n    this.type = type;\n    this.constantValueKind = ConstantValueKind.Integer;\n    this.constantIntegerValue = value;\n    this.set(CommonFlags.Const | CommonFlags.Inlined | CommonFlags.Resolved);\n  }\n\n  /** Applies a constant float value to this element. */\n  setConstantFloatValue(value: f64, type: Type): void {\n    assert(type.isFloatValue);\n    this.type = type;\n    this.constantValueKind = ConstantValueKind.Float;\n    this.constantFloatValue = value;\n    this.set(CommonFlags.Const | CommonFlags.Inlined | CommonFlags.Resolved);\n  }\n}\n\n/** An enum value. */\nexport class EnumValue extends VariableLikeElement {\n\n  /** Constructs a new enum value. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent enum. */\n    parent: Enum,\n    /** Declaration reference. */\n    declaration: EnumValueDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.None\n  ) {\n    super(\n      ElementKind.EnumValue,\n      name,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n    this.setType(Type.i32);\n  }\n\n  /** Whether this enum value is immutable. */\n  isImmutable: bool = false;\n\n  /** Gets the associated value node. */\n  get valueNode(): Expression | null {\n    return (<EnumValueDeclaration>this.declaration).initializer;\n  }\n}\n\n/** A global variable. */\nexport class Global extends VariableLikeElement {\n\n  /** Constructs a new global variable. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file, namespace or static class. */\n    parent: Element,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags,\n    /** Declaration reference. Creates a native declaration if omitted. */\n    declaration: VariableLikeDeclarationStatement = parent.program.makeNativeVariableDeclaration(name)\n  ) {\n    super(\n      ElementKind.Global,\n      name,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n}\n\n/** A function parameter. */\nexport class Parameter {\n  /** Constructs a new function parameter. */\n  constructor(\n    /** Parameter name. */\n    public name: string,\n    /** Parameter type. */\n    public type: Type,\n    /** Parameter initializer, if present. */\n    public initializer: Expression | null = null\n  ) {}\n}\n\n/** A local variable. */\nexport class Local extends VariableLikeElement {\n\n  /** Original name of the (temporary) local. */\n  private originalName: string;\n\n  /** Constructs a new local variable. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Zero-based index within the enclosing function. `-1` indicates a dummy local. */\n    public index: i32,\n    /** Resolved type. */\n    type: Type,\n    /** Parent function. */\n    parent: Function,\n    /** Declaration reference. */\n    declaration: VariableLikeDeclarationStatement = parent.program.makeNativeVariableDeclaration(name)\n  ) {\n    super(\n      ElementKind.Local,\n      name,\n      parent,\n      declaration\n    );\n    this.originalName = name;\n    this.index = index;\n    assert(type != Type.void);\n    this.setType(type);\n  }\n\n  declaredByFlow(flow: Flow): bool {\n    return this.parent == flow.targetFunction;\n  }\n}\n\n/** A yet unresolved function prototype. */\nexport class FunctionPrototype extends DeclaredElement {\n\n  /** Operator kind, if an overload. */\n  operatorKind: OperatorKind = OperatorKind.Invalid;\n  /** Already resolved instances. */\n  instances: Map<string,Function> | null = null;\n  /** Methods overriding this one, if any. These are unbound. */\n  unboundOverrides: Set<FunctionPrototype> | null = null;\n\n  /** Clones of this prototype that are bound to specific classes. */\n  private boundPrototypes: Map<Class,FunctionPrototype> | null = null;\n\n  /** Constructs a new function prototype. */\n  constructor(\n    /** Simple name */\n    name: string,\n    /** Parent element, usually a file, namespace or class (if a method). */\n    parent: Element,\n    /** Declaration reference. */\n    declaration: FunctionDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.None\n  ) {\n    super(\n      ElementKind.FunctionPrototype,\n      name,\n      mangleInternalName(name, parent, declaration.is(CommonFlags.Instance)),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n\n  /** Gets the associated type parameter nodes. */\n  get typeParameterNodes(): TypeParameterNode[] | null {\n    return (<FunctionDeclaration>this.declaration).typeParameters;\n  }\n\n  /** Gets the associated function type node. */\n  get functionTypeNode(): FunctionTypeNode {\n    return (<FunctionDeclaration>this.declaration).signature;\n  }\n\n  /** Gets the associated body node. */\n  get bodyNode(): Statement | null {\n    return (<FunctionDeclaration>this.declaration).body;\n  }\n\n  /** Gets the arrow function kind. */\n  get arrowKind(): ArrowKind {\n    return (<FunctionDeclaration>this.declaration).arrowKind;\n  }\n\n  /** Creates a clone of this prototype that is bound to a concrete class instead. */\n  toBound(classInstance: Class): FunctionPrototype {\n    assert(this.is(CommonFlags.Instance));\n    assert(!this.isBound);\n    let boundPrototypes = this.boundPrototypes;\n    if (!boundPrototypes) this.boundPrototypes = boundPrototypes = new Map();\n    else if (boundPrototypes.has(classInstance)) return assert(boundPrototypes.get(classInstance));\n    let declaration = this.declaration;\n    assert(declaration.kind == NodeKind.MethodDeclaration);\n    let bound = new FunctionPrototype(\n      this.name,\n      classInstance, // now bound\n      <MethodDeclaration>declaration,\n      this.decoratorFlags\n    );\n    bound.flags = this.flags;\n    bound.operatorKind = this.operatorKind;\n    bound.unboundOverrides = this.unboundOverrides;\n    // NOTE: this.instances holds instances per bound class / unbound\n    boundPrototypes.set(classInstance, bound);\n    return bound;\n  }\n\n  /** Gets the resolved instance for the specified instance key, if already resolved. */\n  getResolvedInstance(instanceKey: string): Function | null {\n    let instances = this.instances;\n    if (instances && instances.has(instanceKey)) return assert(instances.get(instanceKey));\n    return null;\n  }\n\n  /** Sets the resolved instance for the specified instance key. */\n  setResolvedInstance(instanceKey: string, instance: Function): void {\n    let instances = this.instances;\n    if (!instances) this.instances = instances = new Map();\n    else assert(!instances.has(instanceKey));\n    instances.set(instanceKey, instance);\n  }\n}\n\n/** A resolved function. */\nexport class Function extends TypedElement {\n\n  /** Function prototype. */\n  prototype: FunctionPrototype;\n  /** Function signature. */\n  signature: Signature;\n  /** Array of locals by index. */\n  localsByIndex: Local[] = [];\n  /** Concrete type arguments. */\n  typeArguments: Type[] | null;\n  /** Contextual type arguments. */\n  contextualTypeArguments: Map<string,Type> | null;\n  /** Default control flow. */\n  flow!: Flow;\n  /** Ordered debug locations by Binaryen expression reference. */\n  debugLocations: Map<ExpressionRef, Range> = new Map();\n  /** Function reference, if compiled. */\n  ref: FunctionRef = 0;\n  /** Varargs stub for calling with omitted arguments. */\n  varargsStub: Function | null = null;\n  /** Stub for calling overrides. */\n  overrideStub: Function | null = null;\n  /** Runtime memory segment, if created. */\n  memorySegment: MemorySegment | null = null;\n  /** Original function, if a stub. Otherwise `this`. */\n  original!: Function;\n\n  /** Counting id of inline operations involving this function. */\n  nextInlineId: i32 = 0;\n  /** Counting id of anonymous inner functions. */\n  nextAnonymousId: i32 = 0;\n\n  /** Constructs a new concrete function. */\n  constructor(\n    /** Name incl. type parameters, i.e. `foo<i32>`. */\n    nameInclTypeParameters: string,\n    /** Respective function prototype. */\n    prototype: FunctionPrototype,\n    /** Concrete type arguments. */\n    typeArguments: Type[] | null,\n    /** Concrete signature. */\n    signature: Signature, // pre-resolved\n    /** Contextual type arguments inherited from its parent class, if any. */\n    contextualTypeArguments: Map<string,Type> | null = null\n  ) {\n    super(\n      ElementKind.Function,\n      nameInclTypeParameters,\n      mangleInternalName(nameInclTypeParameters, prototype.parent, prototype.is(CommonFlags.Instance)),\n      prototype.program,\n      prototype.parent,\n      prototype.declaration\n    );\n    this.prototype = prototype;\n    this.typeArguments = typeArguments;\n    this.signature = signature;\n    this.flags = prototype.flags | CommonFlags.Resolved;\n    this.decoratorFlags = prototype.decoratorFlags;\n    this.contextualTypeArguments = contextualTypeArguments;\n    this.original = this;\n    let program = prototype.program;\n    this.type = signature.type;\n    let flow = Flow.createDefault(this);\n    this.flow = flow;\n    if (!prototype.is(CommonFlags.Ambient)) {\n      let localIndex = 0;\n      let thisType = signature.thisType;\n      if (thisType) {\n        let local = new Local(\n          CommonNames.this_,\n          localIndex++,\n          thisType,\n          this\n        );\n        let scopedLocals = this.flow.scopedLocals;\n        if (!scopedLocals) this.flow.scopedLocals = scopedLocals = new Map();\n        scopedLocals.set(CommonNames.this_, local);\n        this.localsByIndex[local.index] = local;\n        flow.setLocalFlag(local.index, LocalFlags.Initialized);\n      }\n      let parameterTypes = signature.parameterTypes;\n      for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n        let parameterType = parameterTypes[i];\n        let parameterName = this.getParameterName(i);\n        let local = new Local(\n          parameterName,\n          localIndex++,\n          parameterType,\n          this\n        );\n        let scopedLocals = this.flow.scopedLocals;\n        if (!scopedLocals) this.flow.scopedLocals = scopedLocals = new Map();\n        scopedLocals.set(parameterName, local);\n        this.localsByIndex[local.index] = local;\n        flow.setLocalFlag(local.index, LocalFlags.Initialized);\n      }\n    }\n    registerConcreteElement(program, this);\n  }\n\n  /** Gets the types of additional locals that are not parameters. */\n  getNonParameterLocalTypes(): Type[] {\n    let localsByIndex = this.localsByIndex;\n    let signature = this.signature;\n    let numTotal = localsByIndex.length;\n    let numFixed = signature.parameterTypes.length;\n    if (signature.thisType) ++numFixed;\n    let numAdditional = numTotal - numFixed;\n    let types = new Array<Type>(numAdditional);\n    for (let i = 0; i < numAdditional; ++i) {\n      types[i] = localsByIndex[numFixed + i].type;\n    }\n    return types;\n  }\n\n  /** Gets the name of the parameter at the specified index. */\n  getParameterName(index: i32): string {\n    let parameters = (<FunctionDeclaration>this.declaration).signature.parameters;\n    return parameters.length > index\n      ? parameters[index].name.text\n      : getDefaultParameterName(index);\n  }\n\n  /** Creates a stub for use with this function, i.e. for varargs or override calls. */\n  newStub(postfix: string, requiredParameters: i32 = this.signature.requiredParameters): Function {\n    let stub = new Function(\n      this.original.name + STUB_DELIMITER + postfix,\n      this.prototype,\n      this.typeArguments,\n      this.signature.clone(requiredParameters),\n      this.contextualTypeArguments\n    );\n    stub.original = this.original;\n    stub.set(this.flags & ~CommonFlags.Compiled | CommonFlags.Stub);\n    return stub;\n  }\n\n  /** Adds a local of the specified type, with an optional name. */\n  addLocal(type: Type, name: string | null = null, declaration: VariableDeclaration | null = null): Local {\n    // if it has a name, check previously as this method will throw otherwise\n    let localsByIndex = this.localsByIndex;\n    let localIndex = localsByIndex.length;\n    let localName = name != null ? name : localIndex.toString();\n    if (!declaration) declaration = this.program.makeNativeVariableDeclaration(localName);\n    let local = new Local(localName, localIndex, type, this, declaration);\n    if (name) {\n      let defaultFlow = this.flow;\n      let scopedLocals = defaultFlow.scopedLocals;\n      if (!scopedLocals) defaultFlow.scopedLocals = scopedLocals = new Map();\n      if (scopedLocals.has(name)) throw new Error(\"duplicate local name\");\n      scopedLocals.set(name, local);\n    }\n    localsByIndex[localIndex] = local;\n    return local;\n  }\n\n  /* @override */\n  lookup(name: string, isType: bool = false): Element | null {\n    if (!isType) {\n      let scopedLocals = this.flow.scopedLocals;\n      if (scopedLocals && scopedLocals.has(name)) {\n        return assert(scopedLocals.get(name));\n      }\n    }\n    return super.lookup(name, isType);\n  }\n\n  // used by flows to keep track of break labels\n  nextBreakId: i32 = 0;\n  breakStack: i32[] | null = null;\n\n  /** Finalizes the function once compiled, releasing no longer needed resources. */\n  finalize(module: Module, ref: FunctionRef): void {\n    this.ref = ref;\n    let breakStack = this.breakStack;\n    assert(!breakStack || !breakStack.length); // should be empty\n    this.breakStack = null;\n    this.addDebugInfo(module, ref);\n  }\n\n  addDebugInfo(module: Module, ref: FunctionRef): void {\n    if (this.program.options.sourceMap) {\n      let debugLocations = this.debugLocations;\n      for (let _keys = Map_keys(debugLocations), i = 0, k = _keys.length; i < k; ++i) {\n        let expressionRef = _keys[i];\n        let range = assert(debugLocations.get(expressionRef));\n        let source = range.source;\n        module.setDebugLocation(\n          ref,\n          expressionRef,\n          source.debugInfoIndex,\n          source.lineAt(range.start),\n          source.columnAt() - 1 // source maps are 0-based\n        );\n      }\n    }\n    if (this.program.options.debugInfo) {\n      let localNameMap = new Set<string>();\n      let localsByIndex = this.localsByIndex;\n      for (let i = 0, k = localsByIndex.length; i < k; i++) {\n        let localName = localsByIndex[i].name;\n        if (localNameMap.has(localName)) {\n          localName = `${localName}|${i}`;\n        }\n        localNameMap.add(localName);\n        module.setLocalName(ref, i, localName);\n      }\n    }\n  }\n}\n\n/** A property comprised of a getter and a setter function. */\nexport class PropertyPrototype extends DeclaredElement {\n\n  /** Field declaration, if a field. */\n  fieldDeclaration: FieldDeclaration | null = null;\n  /** Getter prototype. */\n  getterPrototype: FunctionPrototype | null = null;\n  /** Setter prototype. */\n  setterPrototype: FunctionPrototype | null = null;\n  /** Property instance, if resolved. */\n  instance: Property | null = null;\n\n  /** Clones of this prototype that are bound to specific classes. */\n  private boundPrototypes: Map<Class,PropertyPrototype> | null = null;\n\n  /** Creates a property prototype representing a field. */\n  static forField(\n    /** Simple name. */\n    name: string,\n    /** Parent element. Always a class prototype. */\n    parent: ClassPrototype,\n    /** Declaration of the field. */\n    fieldDeclaration: FieldDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags,\n  ): PropertyPrototype {\n    // A field is a property with an attached memory offset. Unlike normal\n    // properties, accessors for fields are not explicitly declared, so we\n    // declare them implicitly here and compile them as built-ins when used.\n    // As a result, explicit and implicit accessors can override each other,\n    // which is useful when implementing interfaces declaring \"fields\". Such\n    // fields are satisfied by either a field or a normal property, so the\n    // override stub at the interface needs to handle both interchangeably.\n    let nativeRange = Source.native.range;\n    let typeNode = fieldDeclaration.type;\n    if (!typeNode) typeNode = Node.createOmittedType(fieldDeclaration.name.range.atEnd);\n    let getterDeclaration = new MethodDeclaration( // get name(): type\n      fieldDeclaration.name,\n      fieldDeclaration.decorators,\n      fieldDeclaration.flags | CommonFlags.Instance | CommonFlags.Get,\n      null,\n      new FunctionTypeNode([], typeNode, null, false, nativeRange),\n      null,\n      nativeRange\n    );\n    let setterDeclaration = new MethodDeclaration( // set name(name: type)\n      fieldDeclaration.name,\n      fieldDeclaration.decorators,\n      fieldDeclaration.flags | CommonFlags.Instance | CommonFlags.Set,\n      null,\n      new FunctionTypeNode(\n        [\n          new ParameterNode(\n            ParameterKind.Default,\n            fieldDeclaration.name,\n            typeNode, null, nativeRange\n          )\n        ],\n        new NamedTypeNode(\n          new TypeName(\n            new IdentifierExpression(\"\", false, nativeRange),\n            null, nativeRange\n          ),\n          null, false, nativeRange\n        ),\n        null, false, nativeRange\n      ),\n      null, nativeRange\n    );\n    let prototype = new PropertyPrototype(name, parent, getterDeclaration);\n    prototype.fieldDeclaration = fieldDeclaration;\n    prototype.decoratorFlags = decoratorFlags;\n    prototype.getterPrototype = new FunctionPrototype(GETTER_PREFIX + name, parent, getterDeclaration, decoratorFlags);\n    prototype.setterPrototype = new FunctionPrototype(SETTER_PREFIX + name, parent, setterDeclaration, decoratorFlags);\n    return prototype;\n  }\n\n  /** Constructs a new property prototype. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element. Either a class prototype or instance. */\n    parent: Element,\n    /** Declaration of the getter or setter introducing the property. */\n    firstDeclaration: FunctionDeclaration\n  ) {\n    super(\n      ElementKind.PropertyPrototype,\n      name,\n      mangleInternalName(name, parent, firstDeclaration.is(CommonFlags.Instance)),\n      parent.program,\n      parent,\n      firstDeclaration\n    );\n    this.flags &= ~(CommonFlags.Get | CommonFlags.Set);\n  }\n\n  /** Tests if this property prototype represents a field. */\n  get isField(): bool {\n    return this.fieldDeclaration != null;\n  }\n\n  /** Gets the associated type node. */\n  get typeNode(): TypeNode | null {\n    let fieldDeclaration = this.fieldDeclaration;\n    if (fieldDeclaration) return fieldDeclaration.type;\n    let getterPrototype = this.getterPrototype;\n    if (getterPrototype) {\n      let getterDeclaration = getterPrototype.declaration;\n      if (getterDeclaration.kind == NodeKind.FunctionDeclaration) {\n        return (<FunctionDeclaration>getterDeclaration).signature.returnType;\n      }\n    }\n    let setterPrototype = this.setterPrototype;\n    if (setterPrototype) {\n      let setterDeclaration = setterPrototype.declaration;\n      if (setterDeclaration.kind == NodeKind.FunctionDeclaration) {\n        let setterParameters = (<FunctionDeclaration>setterDeclaration).signature.parameters;\n        if (setterParameters.length) return setterParameters[0].type;\n      }\n    }\n    return null;\n  }\n\n  /** Gets the associated initializer node. */\n  get initializerNode(): Expression | null {\n    let fieldDeclaration = this.fieldDeclaration;\n    if (fieldDeclaration) return fieldDeclaration.initializer;\n    return null;\n  }\n\n  /** Gets the associated parameter index. Set if declared as a constructor parameter, otherwise `-1`. */\n  get parameterIndex(): i32 {\n    let fieldDeclaration = this.fieldDeclaration;\n    if (fieldDeclaration) return fieldDeclaration.parameterIndex;\n    return -1;\n  }\n\n  /** Gets the respective `this` type. */\n  get thisType(): Type {\n    let parent = this.parent;\n    assert(parent.kind == ElementKind.Class);\n    return (<Class>parent).type;\n  }\n\n  /** Creates a clone of this property prototype that is bound to a concrete class. */\n  toBound(classInstance: Class): PropertyPrototype {\n    assert(this.is(CommonFlags.Instance));\n    assert(!this.isBound);\n    let boundPrototypes = this.boundPrototypes;\n    if (!boundPrototypes) this.boundPrototypes = boundPrototypes = new Map();\n    else if (boundPrototypes.has(classInstance)) return assert(boundPrototypes.get(classInstance));\n    let firstDeclaration = this.declaration;\n    assert(firstDeclaration.kind == NodeKind.MethodDeclaration);\n    let bound = new PropertyPrototype(\n      this.name,\n      classInstance, // now bound\n      <MethodDeclaration>firstDeclaration\n    );\n    bound.flags = this.flags;\n    bound.fieldDeclaration = this.fieldDeclaration;\n    let getterPrototype = this.getterPrototype;\n    if (getterPrototype) {\n      bound.getterPrototype = getterPrototype.toBound(classInstance);\n    }\n    let setterPrototype = this.setterPrototype;\n    if (setterPrototype) {\n      bound.setterPrototype = setterPrototype.toBound(classInstance);\n    }\n    boundPrototypes.set(classInstance, bound);\n    return bound;\n  }\n}\n\n/** A resolved property. */\nexport class Property extends VariableLikeElement {\n\n  /** Prototype reference. */\n  prototype: PropertyPrototype;\n  /** Getter instance. */\n  getterInstance: Function | null = null;\n  /** Setter instance. */\n  setterInstance: Function | null = null;\n  /** Field memory offset, if a (layed out) instance field. */\n  memoryOffset: i32 = -1;\n\n  /** Constructs a new property prototype. */\n  constructor(\n    /** Respective property prototype. */\n    prototype: PropertyPrototype,\n    /** Parent element, usually a static class prototype or class instance. */\n    parent: Element\n  ) {\n    super(\n      ElementKind.Property,\n      prototype.name,\n      parent,\n      prototype.isField\n        ? <VariableLikeDeclarationStatement>assert(prototype.fieldDeclaration)\n        : Node.createVariableDeclaration(\n            prototype.identifierNode,\n            null,\n            prototype.flags & CommonFlags.Instance,\n            null, null,\n            prototype.identifierNode.range\n          )\n    );\n    this.prototype = prototype;\n    this.flags = prototype.flags;\n    this.decoratorFlags = prototype.decoratorFlags;\n    if (this.is(CommonFlags.Instance)) {\n      registerConcreteElement(this.program, this);\n    }\n  }\n\n  /** Tests if this property represents a field. */\n  get isField(): bool {\n    return this.prototype.isField;\n  }\n\n  checkVisibility(diag: DiagnosticEmitter): void {\n    let propertyGetter = this.getterInstance;\n    let propertySetter = this.setterInstance;\n    if (propertyGetter && propertySetter && !propertyGetter.visibilityNoLessThan(propertySetter)) {\n      diag.errorRelated(\n        DiagnosticCode.Get_accessor_0_must_be_at_least_as_accessible_as_the_setter,\n        propertyGetter.identifierNode.range, propertySetter.identifierNode.range, propertyGetter.identifierNode.text\n      );\n    }\n  }\n}\n\n/** A resolved index signature. */\nexport class IndexSignature extends TypedElement {\n\n  /** Constructs a new index prototype. */\n  constructor(\n    /** Parent class. */\n    parent: Class\n  ) {\n    super(\n      ElementKind.IndexSignature,\n      \"[]\",\n      parent.internalName + \"[]\",\n      parent.program,\n      parent,\n      parent.program.makeNativeVariableDeclaration(\"[]\") // is fine\n    );\n  }\n\n  /** Obtains the getter instance. */\n  getGetterInstance(isUnchecked: bool): Function | null {\n    return (<Class>this.parent).lookupOverload(OperatorKind.IndexedGet, isUnchecked);\n  }\n\n  /** Obtains the setter instance. */\n  getSetterInstance(isUnchecked: bool): Function | null {\n    return (<Class>this.parent).lookupOverload(OperatorKind.IndexedSet, isUnchecked);\n  }\n}\n\n/** A yet unresolved class prototype. */\nexport class ClassPrototype extends DeclaredElement {\n\n  /** Instance member prototypes. */\n  instanceMembers: Map<string,DeclaredElement> | null = null;\n  /** Base class prototype, if applicable. */\n  basePrototype: ClassPrototype | null = null;\n  /** Interface prototypes, if applicable. */\n  interfacePrototypes: InterfacePrototype[] | null = null;\n  /** Constructor prototype. */\n  constructorPrototype: FunctionPrototype | null = null;\n  /** Operator overload prototypes. */\n  operatorOverloadPrototypes: Map<OperatorKind, FunctionPrototype> = new Map();\n  /** Already resolved instances. */\n  instances: Map<string,Class> | null = null;\n  /** Classes extending this class. */\n  extenders: Set<ClassPrototype> = new Set();\n  /** Whether this class implicitly extends `Object`. */\n  implicitlyExtendsObject: bool = false;\n\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file or namespace. */\n    parent: Element,\n    /** Declaration reference. */\n    declaration: ClassDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.None,\n    _isInterface: bool = false // FIXME\n  ) {\n    super(\n      _isInterface ? ElementKind.InterfacePrototype : ElementKind.ClassPrototype,\n      name,\n      mangleInternalName(name, parent, declaration.is(CommonFlags.Instance)),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n\n  /** Gets the associated type parameter nodes. */\n  get typeParameterNodes(): TypeParameterNode[] | null {\n    return (<ClassDeclaration>this.declaration).typeParameters;\n  }\n  /** Gets the associated extends node. */\n  get extendsNode(): NamedTypeNode | null {\n    return (<ClassDeclaration>this.declaration).extendsType;\n  }\n  /** Gets the associated implements nodes. */\n  get implementsNodes(): NamedTypeNode[] | null {\n    return (<ClassDeclaration>this.declaration).implementsTypes;\n  }\n\n  /** Tests if this prototype is of a builtin array type (Array/TypedArray). */\n  get isBuiltinArray(): bool {\n    let arrayBufferViewInstance = this.program.arrayBufferViewInstance;\n    return arrayBufferViewInstance && this.extends(arrayBufferViewInstance.prototype);\n  }\n\n  /** Tests if this prototype extends the specified. */\n  extends(basePtototype: ClassPrototype | null): bool {\n    let current: ClassPrototype | null = this;\n    let seen = new Set<ClassPrototype>();\n    do {\n      // cannot directly or indirectly extend itself\n      if (seen.has(current)) break;\n      seen.add(current);\n      if (current == basePtototype) return true;\n      current = current.basePrototype;\n    } while (current);\n    return false;\n  }\n\n  /** Adds an element as an instance member of this one. Returns the previous element if a duplicate. */\n  addInstance(name: string, element: DeclaredElement): bool {\n    let originalDeclaration = element.declaration;\n    let instanceMembers = this.instanceMembers;\n    if (!instanceMembers) this.instanceMembers = instanceMembers = new Map();\n    else if (instanceMembers.has(name)) {\n      let existing = assert(instanceMembers.get(name));\n      let merged = tryMerge(existing, element);\n      if (!merged) {\n        if (isDeclaredElement(existing.kind)) {\n          this.program.errorRelated(\n            DiagnosticCode.Duplicate_identifier_0,\n            element.identifierNode.range,\n            (<DeclaredElement>existing).declaration.name.range,\n            element.identifierNode.text\n          );\n        } else {\n          this.program.error(\n            DiagnosticCode.Duplicate_identifier_0,\n            element.identifierNode.range, element.identifierNode.text\n          );\n        }\n        return false;\n      }\n      element = merged;\n    }\n    instanceMembers.set(name, element);\n    if (element.is(CommonFlags.Export) && this.is(CommonFlags.ModuleExport)) {\n      element.set(CommonFlags.ModuleExport); // propagate\n    }\n    this.program.elementsByDeclaration.set(originalDeclaration, element);\n    return true;\n  }\n\n  /** Gets the resolved instance for the specified instance key, if already resolved. */\n  getResolvedInstance(instanceKey: string): Class | null {\n    let instances = this.instances;\n    if (instances && instances.has(instanceKey)) return <Class>instances.get(instanceKey);\n    return null;\n  }\n\n  /** Sets the resolved instance for the specified instance key. */\n  setResolvedInstance(instanceKey: string, instance: Class): void {\n    let instances = this.instances;\n    if (!instances) this.instances = instances = new Map();\n    else assert(!instances.has(instanceKey));\n    instances.set(instanceKey, instance);\n  }\n}\n\n/** A resolved class. */\nexport class Class extends TypedElement {\n\n  /** Class prototype. */\n  prototype: ClassPrototype;\n  /** Resolved type arguments. */\n  typeArguments: Type[] | null;\n  /** Base class, if any. */\n  base: Class | null = null;\n  /** Directly implemented interfaces, if any. */\n  interfaces: Set<Interface> | null = null;\n  /** Contextual type arguments for fields and methods. */\n  contextualTypeArguments: Map<string,Type> | null = null;\n  /** Current member memory offset. */\n  nextMemoryOffset: u32 = 0;\n  /** Constructor instance. */\n  constructorInstance: Function | null = null;\n  /** Operator overloads. */\n  operatorOverloads: Map<OperatorKind,Function> | null = null;\n  /** Index signature, if present. */\n  indexSignature: IndexSignature | null = null;\n  /** Unique class id. */\n  private _id: u32 = 0;\n  /** Runtime type information flags. */\n  rttiFlags: u32 = 0;\n  /** Wrapped type, if a wrapper for a basic type. */\n  wrappedType: Type | null = null;\n  /** Classes directly or indirectly extending this class, if any. */\n  extenders: Set<Class> | null = null;\n  /** Classes directly or indirectly implementing this interface, if any. */\n  implementers: Set<Class> | null = null;\n  /** Whether the field initialization check has already been performed. */\n  didCheckFieldInitialization: bool = false;\n  /** Runtime visitor function reference. */\n  visitRef: FunctionRef = 0;\n\n  /** Gets the unique runtime id of this class. */\n  get id(): u32 {\n    return this._id; // unmanaged remains 0 (=ArrayBuffer)\n  }\n\n  /** Tests if this class is of a builtin array type (Array/TypedArray). */\n  get isBuiltinArray(): bool {\n    return this.prototype.isBuiltinArray;\n  }\n\n  /** Tests if this class is array-like. */\n  get isArrayLike(): bool {\n    if (this.isBuiltinArray) return true;\n    let lengthField = this.getMember(\"length\");\n    if (!lengthField) return false;\n    return (\n      (\n        lengthField.kind == ElementKind.Property &&\n        (<Property>lengthField).getterInstance != null\n      ) || (\n        lengthField.kind == ElementKind.PropertyPrototype &&\n        (<PropertyPrototype>lengthField).getterPrototype != null // TODO: resolve & check type?\n      )\n    ) && (\n      this.lookupOverload(OperatorKind.IndexedGet) != null ||\n      this.lookupOverload(OperatorKind.UncheckedIndexedGet) != null\n    );\n  }\n\n  /** Tests if this is an interface. */\n  get isInterface(): bool {\n    return this.kind == ElementKind.Interface;\n  }\n\n  /** Constructs a new class. */\n  constructor(\n    /** Name incl. type parameters, i.e. `Foo<i32>`. */\n    nameInclTypeParameters: string,\n    /** The respective class prototype. */\n    prototype: ClassPrototype,\n    /** Concrete type arguments, if any. */\n    typeArguments: Type[] | null = null,\n    _isInterface: bool = false // FIXME\n  ) {\n    super(\n      _isInterface ? ElementKind.Interface : ElementKind.Class,\n      nameInclTypeParameters,\n      mangleInternalName(nameInclTypeParameters, prototype.parent, prototype.is(CommonFlags.Instance)),\n      prototype.program,\n      prototype.parent,\n      prototype.declaration\n    );\n    this.prototype = prototype;\n    this.flags = prototype.flags;\n    this.decoratorFlags = prototype.decoratorFlags;\n    this.typeArguments = typeArguments;\n    let program = this.program;\n    let usizeType = program.options.usizeType;\n    let type = new Type(usizeType.kind, usizeType.flags & ~TypeFlags.Value | TypeFlags.Reference, usizeType.size);\n    type.classReference = this;\n    this.setType(type);\n\n    if (!this.hasDecorator(DecoratorFlags.Unmanaged)) {\n      let id = program.nextClassId++;\n      this._id = id;\n      program.managedClasses.set(id, this);\n    }\n\n    // apply pre-checked instance-specific contextual type arguments\n    let typeParameters = prototype.typeParameterNodes;\n    if (typeArguments) {\n      let numTypeArguments = typeArguments.length;\n      if (!typeParameters || numTypeArguments != typeParameters.length) {\n        throw new Error(\"type argument count mismatch\");\n      }\n      if (numTypeArguments) {\n        let contextualTypeArguments = this.contextualTypeArguments;\n        if (!contextualTypeArguments) this.contextualTypeArguments = contextualTypeArguments = new Map();\n        for (let i = 0; i < numTypeArguments; ++i) {\n          contextualTypeArguments.set(typeParameters[i].name.text, typeArguments[i]);\n        }\n      }\n    } else if (typeParameters && typeParameters.length > 0) {\n      throw new Error(\"type argument count mismatch\");\n    }\n    registerConcreteElement(program, this);\n  }\n\n  /** Computes the least upper bound of two class types. */\n  static leastUpperBound(a: Class, b: Class): Class | null {\n    if (a == b) return a;\n    let candidates = new Set<Class>();\n    candidates.add(a);\n    candidates.add(b);\n    while (true) {\n      let aBase = a.base;\n      let bBase = b.base;\n      if (!aBase && !bBase) return null; // none\n      if (aBase) {\n        if (candidates.has(aBase)) return aBase;\n        candidates.add(a = aBase);\n      }\n      if (bBase) {\n        if (candidates.has(bBase)) return bBase;\n        candidates.add(b = bBase);\n      }\n    }\n  }\n\n  /** Sets the base class. */\n  setBase(base: Class): void {\n    assert(!this.base);\n    this.base = base;\n\n    // Inherit contextual type arguments from base class\n    let inheritedTypeArguments = base.contextualTypeArguments;\n    if (inheritedTypeArguments) {\n      let contextualTypeArguments = this.contextualTypeArguments;\n      // TODO: for (let [baseName, baseType] of inheritedTypeArguments) {\n      for (let _keys = Map_keys(inheritedTypeArguments), i = 0, k = _keys.length; i < k; ++i) {\n        let baseName = unchecked(_keys[i]);\n        let baseType = assert(inheritedTypeArguments.get(baseName));\n        if (!contextualTypeArguments) {\n          this.contextualTypeArguments = contextualTypeArguments = new Map();\n          contextualTypeArguments.set(baseName, baseType);\n        } else if (!contextualTypeArguments.has(baseName)) {\n          contextualTypeArguments.set(baseName, baseType);\n        }\n      }\n    }\n\n    // This class and its extenders now extend each direct or indirect base class\n    base.propagateExtenderUp(this);\n    let extenders = this.extenders;\n    if (extenders) {\n      for (let _values = Set_values(extenders), i = 0, k = _values.length; i < k; ++i) {\n        let extender = _values[i];\n        base.propagateExtenderUp(extender);\n      }\n    }\n\n    // Direct or indirect base interfaces are now implemented by this class and its extenders\n    let nextBase: Class | null = base;\n    do {\n      let baseInterfaces = nextBase.interfaces;\n      if (baseInterfaces) {\n        for (let _values = Set_values(baseInterfaces), i = 0, k = _values.length; i < k; ++i) {\n          let baseInterface = _values[i];\n          this.propagateInterfaceDown(baseInterface);\n        }\n      }\n      nextBase = nextBase.base;\n    } while (nextBase);\n  }\n\n  /** Propagates an extender to this class and its base classes. */\n  private propagateExtenderUp(extender: Class): void {\n    // Start with this class, adding the extender to it. Repeat for the class's\n    // bases that are indirectly extended by the extender.\n    let nextBase: Class | null = this;\n    do {\n      let extenders = nextBase.extenders;\n      if (!extenders) nextBase.extenders = extenders = new Set();\n      extenders.add(extender);\n      nextBase = nextBase.base;\n    } while (nextBase);\n  }\n\n  /** Propagates an interface and its base interfaces to this class and its extenders. */\n  private propagateInterfaceDown(iface: Interface): void {\n    // Start with the interface itself, adding this class and its extenders to\n    // its implementers. Repeat for the interface's bases that are indirectly\n    // implemented by means of being extended by the interface.\n    let nextIface: Interface | null = iface;\n    let extenders = this.extenders;\n    do {\n      let implementers = nextIface.implementers;\n      if (!implementers) nextIface.implementers = implementers = new Set();\n      implementers.add(this);\n      if (extenders) {\n        for (let _values = Set_values(extenders), i = 0, k = _values.length; i < k; ++i) {\n          let extender = _values[i];\n          implementers.add(extender);\n        }\n      }\n      nextIface = <Interface | null>nextIface.base;\n    } while (nextIface);\n  }\n\n  /** Adds an interface. */\n  addInterface(iface: Interface): void {\n    let interfaces = this.interfaces;\n    if (!interfaces) this.interfaces = interfaces = new Set();\n    interfaces.add(iface);\n\n    // This class and its extenders now implement the interface and its bases\n    this.propagateInterfaceDown(iface);\n  }\n\n  /** Tests if a value of this class type is assignable to a target of the specified class type. */\n  isAssignableTo(target: Class): bool {\n    // Q: When does the assignment in the comment below succeed?\n    if (target.isInterface) {\n      if (this.isInterface) {\n        // targetInterface = thisInterface\n        return this == target || this.extends(target);\n      } else {\n        // targetInterface = thisClass\n        return this.implements(<Interface>target);\n      }\n    } else {\n      if (this.isInterface) {\n        // targetClass = thisInterface\n        return target == this.program.objectInstance;\n      } else {\n        // targetClass = thisClass\n        return this == target || this.extends(target);\n      }\n    }\n  }\n\n  /** Tests if any subclass of this class is assignable to a target of the specified class type. */\n  hasSubclassAssignableTo(target: Class): bool {\n    // Q: When can the cast in the comment below succeed? (while an assignment would not)\n    if (target.isInterface) {\n      if (this.isInterface) {\n        // <TargetInterface>thisInterface\n        return this.hasImplementerImplementing(<Interface>target);\n      } else {\n        // <TargetInterface>thisClass\n        return this.hasExtenderImplementing(<Interface>target);\n      }\n    } else {\n      if (this.isInterface) {\n        // <TargetClass>thisInterface\n        return this.hasImplementer(target);\n      } else {\n        // <TargetClass>thisClass\n        return this.hasExtender(target);\n      }\n    }\n  }\n\n  /** Looks up the operator overload of the specified kind. */\n  lookupOverload(kind: OperatorKind, unchecked: bool = false): Function | null {\n    if (unchecked) {\n      switch (kind) {\n        case OperatorKind.IndexedGet: {\n          let uncheckedOverload = this.lookupOverload(OperatorKind.UncheckedIndexedGet);\n          if (uncheckedOverload) return uncheckedOverload;\n          break;\n        }\n        case OperatorKind.IndexedSet: {\n          let uncheckedOverload = this.lookupOverload(OperatorKind.UncheckedIndexedSet);\n          if (uncheckedOverload) return uncheckedOverload;\n          break;\n        }\n        default: assert(false);\n      }\n    }\n    let instance: Class | null = this;\n    do {\n      let overloads = instance.operatorOverloads;\n      if (overloads != null && overloads.has(kind)) {\n        return assert(overloads.get(kind));\n      }\n      instance = instance.base;\n    } while (instance);\n    return null;\n  }\n\n  /** Gets the method of the specified name, resolved with the given type arguments. */\n  getMethod(name: string, typeArguments: Type[] | null = null): Function | null {\n    let member = this.getMember(name);\n    if (member && member.kind == ElementKind.FunctionPrototype) {\n      return this.program.resolver.resolveFunction(<FunctionPrototype>member, typeArguments);\n    }\n    return null;\n  }\n\n  /** Calculates the memory offset of the specified field. */\n  offsetof(fieldName: string): u32 {\n    let member = assert(this.getMember(fieldName));\n    assert(member.kind == ElementKind.PropertyPrototype);\n    let prototype = <PropertyPrototype>member;\n    let property = prototype.instance;\n    if (property) { // would have failed before\n      assert(property.isField && property.memoryOffset >= 0);\n      return property.memoryOffset;\n    }\n    return 0;\n  }\n\n  /** Creates a buffer suitable to hold a runtime instance of this class. */\n  createBuffer(overhead: i32 = 0): Uint8Array {\n    let program = this.program;\n    let payloadSize = this.nextMemoryOffset + overhead;\n    let blockSize = program.computeBlockSize(payloadSize, true); // excl. overhead\n    let buffer = new Uint8Array(program.blockOverhead + blockSize);\n    let OBJECT = program.OBJECTInstance;\n    OBJECT.writeField(\"mmInfo\", blockSize, buffer, 0);\n    OBJECT.writeField(\"gcInfo\", 0, buffer, 0);\n    OBJECT.writeField(\"gcInfo2\", 0, buffer, 0);\n    OBJECT.writeField(\"rtId\", this.id, buffer, 0);\n    OBJECT.writeField(\"rtSize\", payloadSize, buffer, 0);\n    return buffer;\n  }\n\n  /** Writes a field value to a buffer and returns the number of bytes written. */\n  writeField<T>(name: string, value: T, buffer: Uint8Array, baseOffset: i32 = this.program.totalOverhead): i32 {\n    let member = this.getMember(name);\n    if (member && member.kind == ElementKind.PropertyPrototype) {\n      let prototype = <PropertyPrototype>member;\n      let property = prototype.instance; // resolved during class finalization\n      if (!property) return 0; // failed before\n      assert(property.isField && property.memoryOffset >= 0);\n      let offset = baseOffset + property.memoryOffset;\n      let typeKind = property.type.kind;\n      switch (typeKind) {\n        case TypeKind.I8:\n        case TypeKind.U8: {\n          assert(!i64_is(value));\n          writeI8(i32(value), buffer, offset);\n          return 1;\n        }\n        case TypeKind.I16:\n        case TypeKind.U16: {\n          assert(!i64_is(value));\n          writeI16(i32(value), buffer, offset);\n          return 2;\n        }\n        case TypeKind.I32:\n        case TypeKind.U32: {\n          assert(!i64_is(value));\n          writeI32(i32(value), buffer, offset);\n          return 4;\n        }\n        case TypeKind.Isize:\n        case TypeKind.Usize: {\n          if (this.program.options.isWasm64) {\n            if (i64_is(value)) {\n              writeI64(value, buffer, offset);\n            } else {\n              writeI32AsI64(i32(value), buffer, offset, typeKind == TypeKind.Usize);\n            }\n            return 8;\n          } else {\n            if (i64_is(value)) {\n              writeI64AsI32(value, buffer, offset, typeKind == TypeKind.Usize);\n            } else {\n              writeI32(i32(value), buffer, offset);\n            }\n            return 4;\n          }\n        }\n        case TypeKind.I64:\n        case TypeKind.U64: {\n          if (i64_is(value)) {\n            writeI64(value, buffer, offset);\n          } else {\n            writeI32AsI64(i32(value), buffer, offset, typeKind == TypeKind.U64);\n          }\n          return 8;\n        }\n        case TypeKind.F32: {\n          assert(!i64_is(value));\n          writeF32(f32(value), buffer, offset);\n          return 4;\n        }\n        case TypeKind.F64: {\n          assert(!i64_is(value));\n          writeF64(f64(value), buffer, offset);\n          return 8;\n        }\n      }\n    }\n    assert(false);\n    return 0;\n  }\n\n  /** Tests if this class extends the specified prototype. */\n  extendsPrototype(prototype: ClassPrototype): bool {\n    return this.prototype.extends(prototype);\n  }\n\n  /** Gets the concrete type arguments to the specified extendend prototype. */\n  getTypeArgumentsTo(extendedPrototype: ClassPrototype): Type[] | null {\n    let current: Class | null = this;\n    do {\n      if (current.prototype == extendedPrototype) return current.typeArguments;\n      current = current.base;\n    } while (current);\n    return null;\n  }\n\n  /** Gets the value type of an array. Must be an array. */\n  getArrayValueType(): Type {\n    let current: Class = this;\n    let program = this.program;\n    let arrayPrototype = program.arrayPrototype;\n    if (this.extendsPrototype(arrayPrototype)) {\n      return this.getTypeArgumentsTo(arrayPrototype)![0];\n    }\n    let staticArrayPrototype = program.staticArrayPrototype;\n    if (this.extendsPrototype(staticArrayPrototype)) {\n      return this.getTypeArgumentsTo(staticArrayPrototype)![0];\n    }\n    let abvInstance = program.arrayBufferViewInstance;\n    while (current.base != abvInstance) {\n      current = assert(current.base);\n    }\n    let prototype = current.prototype;\n    switch (prototype.name.charCodeAt(0)) {\n      case CharCode.F: {\n        if (prototype == program.float32ArrayPrototype) return Type.f32;\n        if (prototype == program.float64ArrayPrototype) return Type.f64;\n        break;\n      }\n      case CharCode.I: {\n        if (prototype == program.int8ArrayPrototype) return Type.i8;\n        if (prototype == program.int16ArrayPrototype) return Type.i16;\n        if (prototype == program.int32ArrayPrototype) return Type.i32;\n        if (prototype == program.int64ArrayPrototype) return Type.i64;\n        break;\n      }\n      case CharCode.U: {\n        if (prototype == program.uint8ArrayPrototype) return Type.u8;\n        if (prototype == program.uint8ClampedArrayPrototype) return Type.u8;\n        if (prototype == program.uint16ArrayPrototype) return Type.u16;\n        if (prototype == program.uint32ArrayPrototype) return Type.u32;\n        if (prototype == program.uint64ArrayPrototype) return Type.u64;\n        break;\n      }\n    }\n    assert(false);\n    return Type.void;\n  }\n\n  /** Tests if this class is pointerfree. Useful to know for the GC. */\n  get isPointerfree(): bool {\n    let program = this.program;\n\n    let instanceMembers = this.members;\n    if (instanceMembers) {\n\n      // Check that there are no managed instance fields\n      for (let _values = Map_values(instanceMembers), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        if (member.kind == ElementKind.PropertyPrototype) {\n          let prototype = <PropertyPrototype>member;\n          let property = prototype.instance; // resolved during class finalization\n          if (!property) continue; // failed earlier\n          if (property.isField && property.type.isManaged) return false;\n        }\n      }\n\n      // Check that this isn't a managed collection\n      if (instanceMembers.has(CommonNames.visit)) {\n        let prototype = this.prototype;\n        if (\n          prototype == program.arrayPrototype ||\n          prototype == program.staticArrayPrototype ||\n          prototype == program.setPrototype ||\n          prototype == program.mapPrototype\n        ) {\n          // Note that we cannot know for sure anymore as soon as the collection\n          // is extended, because user code may implement a custom visitor.\n          let typeArguments = assert(this.getTypeArgumentsTo(prototype));\n          for (let i = 0, k = typeArguments.length; i < k; ++i) {\n            if (typeArguments[i].isManaged) return false;\n          }\n          return true;\n        }\n        return false; // has a custom __visit\n      }\n    }\n    return true;\n  }\n\n  /** Tests if this class or interface extends the given class or interface. */\n  extends(other: Class): bool {\n    return other.hasExtender(this);\n  }\n\n  /** Tests if this class has a direct or indirect extender matching the given class. */\n  hasExtender(other: Class): bool {\n    let extenders = this.extenders;\n    return extenders != null && extenders.has(other);\n  }\n\n  /** Tests if this class has a direct or indirect extender that implements the given interface. */\n  hasExtenderImplementing(other: Interface): bool {\n    let extenders = this.extenders;\n    if (extenders) {\n      for (let _values = Set_values(extenders), i = 0, k = _values.length; i < k; ++i) {\n        let extender = _values[i];\n        if (extender.implements(other)) return true;\n      }\n    }\n    return false;\n  }\n\n  /** Tests if this class directly or indirectly implements the given interface. */\n  implements(other: Interface): bool {\n    return other.hasImplementer(this);\n  }\n\n  /** Tests if this interface has a direct or indirect implementer matching the given class. */\n  hasImplementer(other: Class): bool {\n    let implementers = this.implementers;\n    return implementers != null && implementers.has(other);\n  }\n\n  /** Tests if this interface has an implementer implementing the given interface. */\n  hasImplementerImplementing(other: Interface): bool {\n    let implementers = this.implementers;\n    if (implementers) {\n      for (let _values = Set_values(implementers), i = 0, k = _values.length; i < k; ++i) {\n        let implementer = _values[i];\n        if (implementer.implements(other)) return true;\n      }\n    }\n    return false;\n  }\n}\n\n/** A yet unresolved interface. */\nexport class InterfacePrototype extends ClassPrototype {\n\n  /** Constructs a new interface prototype. */\n  constructor(\n    name: string,\n    parent: Element,\n    declaration: InterfaceDeclaration,\n    decoratorFlags: DecoratorFlags\n  ) {\n    super(\n      name,\n      parent,\n      declaration,\n      decoratorFlags,\n      true\n    );\n  }\n}\n\n/** A resolved interface. */\nexport class Interface extends Class { // FIXME\n\n  /** Constructs a new interface. */\n  constructor(\n    /** Name incl. type parameters, i.e. `Foo<i32>`. */\n    nameInclTypeParameters: string,\n    /** The respective class prototype. */\n    prototype: InterfacePrototype,\n    /** Concrete type arguments, if any. */\n    typeArguments: Type[] | null = null,\n  ) {\n    super(\n      nameInclTypeParameters,\n      prototype,\n      typeArguments,\n      true\n    );\n  }\n}\n\n/** Registers a concrete element with a program. */\nfunction registerConcreteElement(program: Program, element: Element): void {\n  assert(!program.instancesByName.has(element.internalName));\n  program.instancesByName.set(element.internalName, element);\n}\n\n/** Attempts to merge two elements. Returns the merged element on success. */\nfunction tryMerge(older: Element, newer: Element): DeclaredElement | null {\n  // NOTE: some of the following cases are not supported by TS, not sure why exactly.\n  // suggesting to just merge what seems to be possible for now and revisit later.\n  assert(older.program == newer.program);\n  if (newer.members) return null;\n  let merged: DeclaredElement | null = null;\n  switch (older.kind) {\n    case ElementKind.FunctionPrototype: {\n      switch (newer.kind) {\n        case ElementKind.Namespace: {\n          copyMembers(newer, older);\n          merged = <DeclaredElement>older;\n          break;\n        }\n        case ElementKind.TypeDefinition: {\n          if (!older.shadowType) {\n            older.shadowType = <TypeDefinition>newer;\n            copyMembers(newer, older);\n            merged = <DeclaredElement>older;\n          }\n          break;\n        }\n      }\n      break;\n    }\n    case ElementKind.ClassPrototype:\n    case ElementKind.Enum: {\n      if (newer.kind == ElementKind.Namespace) {\n        copyMembers(newer, older);\n        merged = <DeclaredElement>older;\n        break;\n      }\n      break;\n    }\n    case ElementKind.Namespace: {\n      switch (newer.kind) {\n        case ElementKind.Enum:\n        case ElementKind.ClassPrototype:      // TS2434\n        case ElementKind.FunctionPrototype: { // TS2434\n          copyMembers(older, newer);\n          merged = <DeclaredElement>newer;\n          break;\n        }\n        case ElementKind.Namespace: {\n          copyMembers(newer, older);\n          merged = <DeclaredElement>older;\n          break;\n        }\n        case ElementKind.TypeDefinition: {\n          if (!older.shadowType) {\n            older.shadowType = <TypeDefinition>newer;\n            copyMembers(newer, older);\n            merged = <DeclaredElement>older;\n          }\n          break;\n        }\n      }\n      break;\n    }\n    case ElementKind.Global: {\n      if (newer.kind == ElementKind.TypeDefinition) {\n        if (!older.shadowType) {\n          older.shadowType = <TypeDefinition>newer;\n          copyMembers(newer, older);\n          merged = <DeclaredElement>older;\n        }\n      }\n      break;\n    }\n    case ElementKind.TypeDefinition: {\n      switch (newer.kind) {\n        case ElementKind.Global:\n        case ElementKind.FunctionPrototype:\n        case ElementKind.Namespace: {\n          if (!newer.shadowType) {\n            newer.shadowType = <TypeDefinition>older;\n            copyMembers(older, newer);\n            merged = <DeclaredElement>newer;\n          }\n          break;\n        }\n      }\n      break;\n    }\n  }\n  if (merged) {\n    let olderIsExport = older.is(CommonFlags.Export) || older.hasDecorator(DecoratorFlags.Global);\n    let newerIsExport = newer.is(CommonFlags.Export) || newer.hasDecorator(DecoratorFlags.Global);\n    if (olderIsExport != newerIsExport) {\n      older.program.error(\n        DiagnosticCode.Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local,\n        merged.identifierNode.range, merged.identifierNode.text\n      );\n    }\n  }\n  return merged;\n}\n\n/** Copies the members of `src` to `dest`. */\nfunction copyMembers(src: Element, dest: Element): void {\n  let srcMembers = src.members;\n  if (srcMembers) {\n    let destMembers = dest.members;\n    if (!destMembers) dest.members = destMembers = new Map();\n    // TODO: for (let [memberName, member] of srcMembers) {\n    for (let _keys = Map_keys(srcMembers), i = 0, k = _keys.length; i < k; ++i) {\n      let memberName = unchecked(_keys[i]);\n      let member = assert(srcMembers.get(memberName));\n      destMembers.set(memberName, member);\n    }\n  }\n}\n\n/** Mangles the internal name of an element with the specified name that is a child of the given parent. */\nexport function mangleInternalName(\n  name: string,\n  parent: Element,\n  isInstance: bool,\n  asGlobal: bool = false\n): string {\n  switch (parent.kind) {\n    case ElementKind.File: {\n      if (asGlobal) return name;\n      return parent.internalName + PATH_DELIMITER + name;\n    }\n    case ElementKind.Function: {\n      if (asGlobal) return name;\n      assert(!isInstance);\n      return parent.internalName + INNER_DELIMITER + name;\n    }\n    case ElementKind.PropertyPrototype: // properties are just containers\n    case ElementKind.Property: {         //\n      parent = parent.parent;\n      // fall-through\n    }\n    default: {\n      return (\n        mangleInternalName(parent.name, parent.parent, parent.is(CommonFlags.Instance), asGlobal) +\n        (isInstance ? INSTANCE_DELIMITER : STATIC_DELIMITER) + name\n      );\n    }\n  }\n}\n\n// Cached default parameter names used where names are unknown.\nlet cachedDefaultParameterNames: string[] = [];\n\n/** Gets the cached default parameter name for the specified index. */\nexport function getDefaultParameterName(index: i32): string {\n  for (let i = cachedDefaultParameterNames.length; i <= index; ++i) {\n    cachedDefaultParameterNames.push(`$${i}`);\n  }\n  return cachedDefaultParameterNames[index];\n}\n", "/**\n * @fileoverview Mappings from AssemblyScript types to WebAssembly types.\n * @license Apache-2.0\n */\n\nimport {\n  CommonNames\n} from \"./common\";\n\nimport {\n  Class,\n  Program,\n  DecoratorFlags,\n  OperatorKind,\n  Function\n} from \"./program\";\n\nimport {\n  TypeRef,\n  createType,\n  HeapTypeRef,\n  ensureType\n} from \"./module\";\n\nimport * as binaryen from \"./glue/binaryen\";\n\n/** Indicates the kind of a type. */\nexport const enum TypeKind {\n  /** A 1-bit unsigned integer. */\n  Bool,\n\n  // signed integers\n\n  /** An 8-bit signed integer. */\n  I8,\n  /** A 16-bit signed integer. */\n  I16,\n  /** A 32-bit signed integer. */\n  I32,\n  /** A 64-bit signed integer. */\n  I64,\n  /** A 32-bit/64-bit signed integer, depending on the target. */\n  Isize,\n\n  // unsigned integers\n\n  /** An 8-bit unsigned integer. */\n  U8,\n  /** A 16-bit unsigned integer. */\n  U16,\n  /** A 32-bit unsigned integer. Also the base of function types. */\n  U32,\n  /** A 64-bit unsigned integer. */\n  U64,\n  /** A 32-bit/64-bit unsigned integer, depending on the target. Also the base of class types. */\n  Usize,\n\n  // floats\n\n  /** A 32-bit float. */\n  F32,\n  /** A 64-bit double. */\n  F64,\n\n  // vectors\n\n  /** A 128-bit vector. */\n  V128,\n\n  // references (keep in same order as in Binaryen)\n\n  /** External reference. */\n  Extern,\n  /** Function reference. */\n  Func,\n  /** Any reference. */\n  Any,\n  /** Equatable reference. */\n  Eq,\n  /** Struct reference. */\n  Struct,\n  /** Array reference. */\n  Array,\n  /** 31-bit integer reference. */\n  I31,\n  /** String reference. */\n  String,\n  /** WTF8 string view. */\n  StringviewWTF8,\n  /** WTF16 string view. */\n  StringviewWTF16,\n  /** String iterator. */\n  StringviewIter,\n\n  // other\n\n  /** No return type. */\n  Void\n}\n\n/** Indicates capabilities of a type. */\nexport const enum TypeFlags {\n  None = 0,\n  /** Is a signed type that can represent negative values. */\n  Signed = 1 << 0,\n  /** Is an unsigned type that cannot represent negative values. */\n  Unsigned = 1 << 1,\n  /** Is an integer type. */\n  Integer = 1 << 2,\n  /** Is a floating point type. */\n  Float = 1 << 3,\n  /** Is a varying (in size) type. */\n  Varying = 1 << 4,\n  /** Is smaller than 32-bits. */\n  Short = 1 << 5,\n  /** Is larger than 32-bits. */\n  Long = 1 << 6,\n  /** Is a value type. */\n  Value = 1 << 7,\n  /** Is a reference type (either a class or a function type). */\n  Reference = 1 << 8,\n  /** Is a nullable type. */\n  Nullable = 1 << 9,\n  /** Is a vector type. */\n  Vector = 1 << 10,\n  /** Is an external type. */\n  External = 1 << 11,\n  /** Is a class. */\n  Class = 1 << 12,\n  /** Is a function. */\n  Function = 1 << 13\n}\n\n/** Represents a resolved type. */\nexport class Type {\n\n  /** Type kind. */\n  kind: TypeKind;\n  /** Type flags. */\n  flags: TypeFlags;\n  /** Size in bits. */\n  size: i32;\n  /** Underlying class reference, if a class type. */\n  classReference: Class | null = null;\n  /** Underlying signature reference, if a function type. */\n  signatureReference: Signature | null = null;\n  /** Respective non-nullable type, if nullable. */\n  private _nonNullableType: Type | null = null;\n  /** Respective nullable type, if non-nullable. */\n  private _nullableType: Type | null = null;\n  /** Cached Binaryen type reference. */\n  ref: TypeRef = 0;\n\n  /** Constructs a new resolved type. */\n  constructor(kind: TypeKind, flags: TypeFlags, size: u32) {\n    this.kind = kind;\n    this.flags = flags;\n    this.size = size;\n    if (!(flags & TypeFlags.Nullable)) {\n      this._nonNullableType = this;\n    } else {\n      this._nullableType = this;\n    }\n  }\n\n  /** Returns the closest int type representing this type. */\n  get intType(): Type {\n    if (this == Type.auto) return this; // keep auto as a hint\n    switch (this.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I32:\n      case TypeKind.F32:   return Type.i32;\n      case TypeKind.I8:    return Type.i8;\n      case TypeKind.I16:   return Type.i16;\n      case TypeKind.F64:\n      case TypeKind.I64:   return Type.i64;\n      case TypeKind.Isize: return this.size == 64 ? Type.isize64 : Type.isize32;\n      case TypeKind.U8:    return Type.u8;\n      case TypeKind.U16:   return Type.u16;\n      case TypeKind.U32:   return Type.u32;\n      case TypeKind.U64:   return Type.u64;\n      case TypeKind.Usize: return this.size == 64 ? Type.usize64 : Type.usize32;\n      default: return Type.i32;\n    }\n  }\n\n  /** Substitutes this type with the auto type if this type is void. */\n  get exceptVoid(): Type {\n    return this.kind == TypeKind.Void ? Type.auto : this;\n  }\n\n  /** Size in bytes. */\n  get byteSize(): i32 {\n    // ceiled div by 8\n    return this.size + 7 >>> 3;\n  }\n\n  /** Gets this type's logarithmic alignment in memory. */\n  get alignLog2(): i32 {\n    return 31 - clz<i32>(this.byteSize);\n  }\n\n  /** Tests if this type represents a basic value. */\n  get isValue(): bool {\n    return this.is(TypeFlags.Value);\n  }\n\n  /** Tests if this type represents an integer value. */\n  get isIntegerValue(): bool {\n    return this.is(TypeFlags.Integer | TypeFlags.Value);\n  }\n\n  /** Tests if this type represents a small (< 32 bits) integer value. */\n  get isShortIntegerValue(): bool {\n    return this.is(TypeFlags.Short | TypeFlags.Integer | TypeFlags.Value);\n  }\n\n  /** Tests if this type represents a long (> 32 bits) integer value. */\n  get isLongIntegerValue(): bool {\n    return this.is(TypeFlags.Long | TypeFlags.Integer | TypeFlags.Value);\n  }\n\n  /** Tests if this type represents a signed integer value. */\n  get isSignedIntegerValue(): bool {\n    return this.is(TypeFlags.Signed | TypeFlags.Integer | TypeFlags.Value);\n  }\n\n  /** Tests if this type represents an unsigned integer value. */\n  get isUnsignedIntegerValue(): bool {\n    return this.is(TypeFlags.Unsigned | TypeFlags.Integer | TypeFlags.Value);\n  }\n\n  /** Tests if this type represents a varying (in size) integer value. */\n  get isVaryingIntegerValue(): bool {\n    return this.is(TypeFlags.Varying | TypeFlags.Integer | TypeFlags.Value);\n  }\n\n  /** Tests if this type represents an integer, including references.  */\n  get isIntegerInclReference(): bool {\n    return this.is(TypeFlags.Integer);\n  }\n\n  /** Tests if this type represents a floating point value. */\n  get isFloatValue(): bool {\n    return this.is(TypeFlags.Float | TypeFlags.Value);\n  }\n\n  /** Tests if this type represents a numeric (integer or floating point) value. */\n  get isNumericValue(): bool {\n    return this.isIntegerValue || this.isFloatValue;\n  }\n\n  /** Tests if this type represents a boolean value. */\n  get isBooleanValue(): bool {\n    return this == Type.bool;\n  }\n\n  /** Tests if this type represents a vector value. */\n  get isVectorValue(): bool {\n    return this.is(TypeFlags.Vector | TypeFlags.Value);\n  }\n\n  /** Tests if this type represents an internal or external reference. */\n  get isReference(): bool {\n    return this.is(TypeFlags.Reference);\n  }\n\n  /** Tests if this type represents a nullable internal or external reference. */\n  get isNullableReference(): bool {\n    return this.is(TypeFlags.Nullable | TypeFlags.Reference);\n  }\n\n  /** Tests if this type represents an internal object. */\n  get isInternalReference(): bool {\n    return this.is(TypeFlags.Integer | TypeFlags.Reference);\n  }\n\n  /** Tests if this type represents an external object. */\n  get isExternalReference(): bool {\n    return this.is(TypeFlags.External | TypeFlags.Reference);\n  }\n\n  /** Tests if this type represents a nullable external object. */\n  get isNullableExternalReference(): bool {\n    return this.is(TypeFlags.Nullable | TypeFlags.External | TypeFlags.Reference);\n  }\n\n  /** Gets the underlying class of this type, if any. */\n  getClass(): Class | null {\n    return this.isInternalReference\n      ? this.classReference\n      : null;\n  }\n\n  /** Tests if this type represents a class. */\n  get isClass(): bool {\n    return this.getClass() != null;\n  }\n\n  /** Gets the underlying class or wrapper class of this type, if any. */\n  getClassOrWrapper(program: Program): Class | null {\n    let classReference = this.getClass();\n    if (classReference) {\n      // typical class\n      return classReference;\n    } else {\n      let signatureReference = this.getSignature();\n      if (signatureReference) {\n        // function wrapper\n        let type = signatureReference.type;\n        let wrapper = assert(program.resolver.resolveClass(program.functionPrototype, [ type ]));\n        wrapper.wrappedType = type;\n        return wrapper;\n      } else {\n        let wrapperClasses = program.wrapperClasses;\n        if (wrapperClasses.has(this)) {\n          // value wrapper\n          return assert(wrapperClasses.get(this));\n        }\n      }\n    }\n    return null;\n  }\n\n  lookupOverload(kind: OperatorKind, program: Program): Function | null {\n    let classReference = this.getClassOrWrapper(program);\n    if (classReference) {\n      return classReference.lookupOverload(kind);\n    }\n    return null;\n  }\n\n  /** Gets the underlying function signature of this type, if any. */\n  getSignature(): Signature | null {\n    return this.isInternalReference\n      ? this.signatureReference\n      : null;\n  }\n\n  /** Tests if this type represents a function. */\n  get isFunction(): bool {\n    return this.getSignature() != null;\n  }\n\n  /** Tests if this is a managed type that needs GC hooks. */\n  get isManaged(): bool {\n    if (this.isInternalReference) {\n      let classReference = this.classReference;\n      if (classReference) return !classReference.hasDecorator(DecoratorFlags.Unmanaged);\n      return this.signatureReference != null; // function references are managed\n    }\n    return false;\n  }\n\n  /** Tests if this is a class type explicitly annotated as unmanaged. */\n  get isUnmanaged(): bool {\n    let classReference = this.classReference;\n    return classReference != null && classReference.hasDecorator(DecoratorFlags.Unmanaged);\n  }\n\n  get isMemory(): bool {\n    switch (this.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.Isize:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.Usize:\n      case TypeKind.F32:\n      case TypeKind.F64:\n      case TypeKind.V128: return true;\n    }\n    return false;\n  }\n\n  /** Gets the corresponding non-nullable type. */\n  get nonNullableType(): Type {\n    // Every type has a corresponding non-nullable type\n    return assert(this._nonNullableType);\n  }\n\n  /** Gets the corresponding nullable type, if applicable. */\n  get nullableType(): Type | null {\n    return this.isReference\n      ? this.asNullable() // Every reference type has a corresponding nullable type\n      : null;             // Other types do not have a nullable type\n  }\n\n  /** Computes the sign-extending shift in the target type. */\n  computeSmallIntegerShift(targetType: Type): i32 {\n    return targetType.size - this.size;\n  }\n\n  /** Computes the truncating mask in the target type. */\n  computeSmallIntegerMask(targetType: Type): i32 {\n    let size = this.size;\n    if (!this.is(TypeFlags.Unsigned)) size -= 1;\n    return ~0 >>> (targetType.size - size);\n  }\n\n  /** Tests if this type has (all of) the specified flags. */\n  is(flags: TypeFlags): bool { return (this.flags & flags) == flags; }\n  /** Tests if this type has any of the specified flags. */\n  isAny(flags: TypeFlags): bool { return (this.flags & flags) != 0; }\n\n  /** Composes the respective nullable type of this type. */\n  asNullable(): Type {\n    assert(this.isReference);\n    let nullableType = this._nullableType;\n    if (!nullableType) {\n      assert(!this.isNullableReference);\n      this._nullableType = nullableType = new Type(this.kind, this.flags | TypeFlags.Nullable, this.size);\n      nullableType.classReference = this.classReference;\n      nullableType.signatureReference = this.signatureReference;\n      nullableType._nonNullableType = this;\n    }\n    return nullableType;\n  }\n\n  /** Use unsigned type for according size if possible. */\n  toUnsigned(): Type {\n    switch (this.kind) {\n      case TypeKind.I8:    return Type.u8;\n      case TypeKind.I16:   return Type.u16;\n      case TypeKind.I32:   return Type.u32;\n      case TypeKind.I64:   return Type.u64;\n      case TypeKind.Isize: return this.size == 64 ? Type.usize64 : Type.usize32;\n    }\n    return this;\n  }\n\n  /** Tests if this type equals the specified. */\n  equals(other: Type): bool {\n    if (this.kind != other.kind) {\n      return false;\n    }\n    if (this.isReference) {\n      let selfSignatureReference = this.signatureReference;\n      let otherSignatureReference = other.signatureReference;\n\n      return (\n        this.classReference == other.classReference\n        && selfSignatureReference == otherSignatureReference\n        && this.isNullableReference == other.isNullableReference\n      );\n    }\n    return true;\n  }\n\n  /** Tests if a value of this type is assignable to the target type incl. implicit conversion. */\n  isAssignableTo(target: Type, signednessIsRelevant: bool = false): bool {\n    let currentClass: Class | null;\n    let targetClass: Class | null;\n    let currentFunction: Signature | null;\n    let targetFunction: Signature | null;\n    if (this.isReference) {\n      if (target.isReference) {\n        if (!this.isNullableReference || target.isNullableReference) {\n          if (currentClass = this.getClass()) {\n            if (targetClass = target.getClass()) {\n              return currentClass.isAssignableTo(targetClass);\n            }\n          } else if (currentFunction = this.getSignature()) {\n            if (targetFunction = target.getSignature()) {\n              return currentFunction.isAssignableTo(targetFunction);\n            }\n          } else if (this.isExternalReference) {\n            if (\n              this.kind == target.kind ||\n              (target.kind == TypeKind.Any && this.kind != TypeKind.Extern)\n            ) {\n              return true;\n            }\n          }\n        }\n      }\n    } else if (!target.isReference) {\n      if (this.isIntegerValue) {\n        if (target.isIntegerValue) {\n          if (\n            !signednessIsRelevant ||\n            this.isBooleanValue || // a bool (0 or 1) can be safely assigned to all sorts of integers\n            this.isSignedIntegerValue == target.isSignedIntegerValue\n          ) {\n            return this.size <= target.size;\n          }\n        } else if (target.kind == TypeKind.F32) {\n          return this.size <= 23; // mantissa bits\n        } else if (target.kind == TypeKind.F64) {\n          return this.size <= 52; // ^\n        }\n      } else if (this.isFloatValue) {\n        if (target.isFloatValue) {\n          return this.size <= target.size;\n        }\n      } else if (this.isVectorValue) {\n        if (target.isVectorValue) {\n          return this.size == target.size;\n        }\n      }\n    }\n    return false;\n  }\n\n  /** Tests if a value of this type is assignable to the target type excl. implicit conversion. */\n  isStrictlyAssignableTo(target: Type, signednessIsRelevant: bool = false): bool {\n    if (this.isReference) return this.isAssignableTo(target);\n    else if (target.isReference) return false;\n    // not dealing with references from here on\n    if (this.isIntegerValue) {\n      return target.isIntegerValue && target.size == this.size && (\n        !signednessIsRelevant ||\n        this.isSignedIntegerValue == target.isSignedIntegerValue\n      );\n    }\n    return this.kind == target.kind;\n  }\n\n  /** Tests if this type has a subtype assignable to the target type. */\n  hasSubtypeAssignableTo(target: Type): bool {\n    let thisClass = this.getClass();\n    let targetClass = target.getClass();\n    if (!thisClass || !targetClass) return false; // TODO: what about basic types?\n    return thisClass.hasSubclassAssignableTo(targetClass);\n  }\n\n  /** Tests if a value of this type can be changed to the target type using `changetype`. */\n  isChangeableTo(target: Type): bool {\n    // special in that it allows integer references as well\n    if (this.is(TypeFlags.Integer) && target.is(TypeFlags.Integer)) {\n      let size = this.size;\n      return size == target.size && (\n        size >= 32 ||\n        this.is(TypeFlags.Signed) == target.is(TypeFlags.Signed)\n      );\n    }\n    return this.kind == target.kind;\n  }\n\n  /** Tests if this type can extend or implement the given type. */\n  canExtendOrImplement(base: Type): bool {\n    // Both must be class types\n    let thisClass = this.getClass();\n    let baseClass = base.getClass();\n    if (!thisClass || !baseClass) return false;\n    // Both types must be either managed or unmanaged\n    if (this.isManaged != base.isManaged) return false;\n    // Both types must be either internal or external references\n    if (this.isInternalReference) {\n      if (!base.isInternalReference) return false;\n    } else if (this.isExternalReference) {\n      if (!base.isExternalReference) return false;\n    } else {\n      return false;\n    }\n    return true;\n  }\n\n  /** Computes the common type of a binary-like expression, if any. */\n  static commonType(\n    /** LHS type. */\n    left: Type,\n    /** RHS type. */\n    right: Type,\n    /** Contextual type, if any. */\n    contextualType: Type = Type.auto,\n    /** Whether signedness is relevant. */\n    signednessIsRelevant: bool = false\n  ): Type | null {\n    // Compute LUB of internal reference types (classes)\n    if (left.isInternalReference) {\n      if (!right.isInternalReference) return null;\n      // Prefer contextual type if meaningful\n      if (contextualType != Type.void && left.isAssignableTo(contextualType) && right.isAssignableTo(contextualType)) {\n        return contextualType;\n      }\n      let leftClass = left.getClass();\n      let rightClass = right.getClass();\n      if (leftClass && rightClass) {\n        let lubClass = Class.leastUpperBound(leftClass, rightClass);\n        if (lubClass) {\n          let ret = left.is(TypeFlags.Nullable) || right.is(TypeFlags.Nullable) ? lubClass.type.asNullable() : lubClass.type;\n          return ret;\n        }\n      }\n    } else if (right.isInternalReference) {\n      return null;\n    }\n    // TODO: External reference types (needs nullability)\n    // Otherwise do a trivial check\n    if (right.isAssignableTo(left, signednessIsRelevant)) return left;\n    else if (left.isAssignableTo(right, signednessIsRelevant)) return right;\n    return null;\n  }\n\n  /** Converts this type's kind to a string. */\n  kindToString(): string {\n    switch (this.kind) {\n      case TypeKind.Bool: return CommonNames.bool;\n      case TypeKind.I8: return CommonNames.i8;\n      case TypeKind.I16: return CommonNames.i16;\n      case TypeKind.I32: return CommonNames.i32;\n      case TypeKind.I64: return CommonNames.i64;\n      case TypeKind.Isize: return CommonNames.isize;\n      case TypeKind.U8: return CommonNames.u8;\n      case TypeKind.U16: return CommonNames.u16;\n      case TypeKind.U32: return CommonNames.u32;\n      case TypeKind.U64: return CommonNames.u64;\n      case TypeKind.Usize: return CommonNames.usize;\n      case TypeKind.F32: return CommonNames.f32;\n      case TypeKind.F64: return CommonNames.f64;\n      case TypeKind.V128: return CommonNames.v128;\n      case TypeKind.Func: return CommonNames.ref_func;\n      case TypeKind.Extern: return CommonNames.ref_extern;\n      case TypeKind.Any: return CommonNames.ref_any;\n      case TypeKind.Eq: return CommonNames.ref_eq;\n      case TypeKind.Struct: return CommonNames.ref_struct;\n      case TypeKind.Array: return CommonNames.ref_array;\n      case TypeKind.I31: return CommonNames.ref_i31;\n      case TypeKind.String: return CommonNames.ref_string;\n      case TypeKind.StringviewWTF8: return CommonNames.ref_stringview_wtf8;\n      case TypeKind.StringviewWTF16: return CommonNames.ref_stringview_wtf16;\n      case TypeKind.StringviewIter: return CommonNames.ref_stringview_iter;\n      default: assert(false);\n      case TypeKind.Void: return CommonNames.void_;\n    }\n  }\n\n  /** Converts this type to a string. */\n  toString(validWat: bool = false): string {\n    const nullablePostfix = validWat ? \"|null\" : \" | null\";\n    if (this.isReference) {\n      let classReference = this.getClass();\n      if (classReference) {\n        return this.isNullableReference\n          ? classReference.internalName + nullablePostfix\n          : classReference.internalName;\n      } else {\n        let signatureReference = this.getSignature();\n        if (signatureReference) {\n          return this.isNullableReference\n            ? `(${signatureReference.toString(validWat)})${nullablePostfix}`\n            : signatureReference.toString(validWat);\n        } else {\n          return this.isNullableReference\n            ? `${this.kindToString()}${nullablePostfix}`\n            : this.kindToString();\n        }\n      }\n    }\n    if (this == Type.auto) {\n      return \"auto\";\n    }\n    return this.kindToString();\n  }\n\n  // Binaryen specific\n\n  /** Converts this type to its respective type reference. */\n  toRef(): TypeRef {\n    switch (this.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32: return TypeRef.I32;\n      case TypeKind.Isize:\n      case TypeKind.Usize: if (this.size != 64) return TypeRef.I32;\n      case TypeKind.I64:\n      case TypeKind.U64:  return TypeRef.I64;\n      case TypeKind.F32:  return TypeRef.F32;\n      case TypeKind.F64:  return TypeRef.F64;\n      case TypeKind.V128: return TypeRef.V128;\n      case TypeKind.Func: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Func, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.Extern: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Extern, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.Any: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Any, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.Eq: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Eq, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.Struct: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Struct, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.Array: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Array, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.I31: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.I31, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.String: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.String, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.Void: return TypeRef.None;\n    }\n    // TODO: not used yet\n    assert(false);\n    return ensureType(this);\n  }\n\n  // Types\n\n  /** An 8-bit signed integer. */\n  static readonly i8: Type  = new Type(TypeKind.I8,\n    TypeFlags.Signed   |\n    TypeFlags.Short    |\n    TypeFlags.Integer  |\n    TypeFlags.Value,   8\n  );\n\n  /** A 16-bit signed integer. */\n  static readonly i16: Type = new Type(TypeKind.I16,\n    TypeFlags.Signed   |\n    TypeFlags.Short    |\n    TypeFlags.Integer  |\n    TypeFlags.Value,  16\n  );\n\n  /** A 32-bit signed integer. */\n  static readonly i32: Type = new Type(TypeKind.I32,\n    TypeFlags.Signed   |\n    TypeFlags.Integer  |\n    TypeFlags.Value,  32\n  );\n\n  /** A 64-bit signed integer. */\n  static readonly i64: Type = new Type(TypeKind.I64,\n    TypeFlags.Signed   |\n    TypeFlags.Long     |\n    TypeFlags.Integer  |\n    TypeFlags.Value,  64\n  );\n\n  /** A 32-bit signed size. WASM32 only. */\n  static readonly isize32: Type = new Type(TypeKind.Isize,\n    TypeFlags.Signed   |\n    TypeFlags.Integer  |\n    TypeFlags.Varying  |\n    TypeFlags.Value,  32\n  );\n\n  /** A 64-bit signed size. WASM64 only. */\n  static readonly isize64: Type = new Type(TypeKind.Isize,\n    TypeFlags.Signed   |\n    TypeFlags.Long     |\n    TypeFlags.Integer  |\n    TypeFlags.Varying  |\n    TypeFlags.Value,  64\n  );\n\n  /** An 8-bit unsigned integer. */\n  static readonly u8: Type = new Type(TypeKind.U8,\n    TypeFlags.Unsigned |\n    TypeFlags.Short    |\n    TypeFlags.Integer  |\n    TypeFlags.Value,   8\n  );\n\n  /** A 16-bit unsigned integer. */\n  static readonly u16: Type = new Type(TypeKind.U16,\n    TypeFlags.Unsigned |\n    TypeFlags.Short    |\n    TypeFlags.Integer  |\n    TypeFlags.Value,  16\n  );\n\n  /** A 32-bit unsigned integer. */\n  static readonly u32: Type = new Type(TypeKind.U32,\n    TypeFlags.Unsigned |\n    TypeFlags.Integer  |\n    TypeFlags.Value,  32\n  );\n\n  /** A 64-bit unsigned integer. */\n  static readonly u64: Type = new Type(TypeKind.U64,\n    TypeFlags.Unsigned |\n    TypeFlags.Long     |\n    TypeFlags.Integer  |\n    TypeFlags.Value,  64\n  );\n\n  /** A 32-bit unsigned size. WASM32 only. */\n  static readonly usize32: Type = new Type(TypeKind.Usize,\n    TypeFlags.Unsigned |\n    TypeFlags.Integer  |\n    TypeFlags.Varying  |\n    TypeFlags.Value,  32\n  );\n\n  /** A 64-bit unsigned size. WASM64 only. */\n  static readonly usize64: Type = new Type(TypeKind.Usize,\n    TypeFlags.Unsigned |\n    TypeFlags.Long     |\n    TypeFlags.Integer  |\n    TypeFlags.Varying  |\n    TypeFlags.Value,  64\n  );\n\n  /** A 1-bit unsigned integer. */\n  static readonly bool: Type = new Type(TypeKind.Bool,\n    TypeFlags.Unsigned |\n    TypeFlags.Short    |\n    TypeFlags.Integer  |\n    TypeFlags.Value,   1\n  );\n\n  /** A 32-bit float. */\n  static readonly f32: Type = new Type(TypeKind.F32,\n    TypeFlags.Signed   |\n    TypeFlags.Float    |\n    TypeFlags.Value,  32\n  );\n\n  /** A 64-bit float. */\n  static readonly f64: Type = new Type(TypeKind.F64,\n    TypeFlags.Signed   |\n    TypeFlags.Long     |\n    TypeFlags.Float    |\n    TypeFlags.Value,  64\n  );\n\n  /** A 128-bit vector. */\n  static readonly v128: Type = new Type(TypeKind.V128,\n    TypeFlags.Vector   |\n    TypeFlags.Value, 128\n  );\n\n  /** Non-nullable function reference (`ref func`). */\n  static readonly func: Type = new Type(TypeKind.Func,\n    TypeFlags.External   |\n    TypeFlags.Reference, 0\n  );\n\n  /** Non-nullable external reference (`ref extern`). */\n  static readonly extern: Type = new Type(TypeKind.Extern,\n    TypeFlags.External   |\n    TypeFlags.Reference, 0\n  );\n\n  /** Non-nullable any reference (`ref any`). */\n  static readonly any: Type = new Type(TypeKind.Any,\n    TypeFlags.External   |\n    TypeFlags.Reference, 0\n  );\n\n  /** Non-nullable equatable reference (`ref eq`). */\n  static readonly eq: Type = new Type(TypeKind.Eq,\n    TypeFlags.External   |\n    TypeFlags.Reference, 0\n  );\n\n  /** Non-nullable struct reference (`ref struct`). */\n  static readonly struct: Type = new Type(TypeKind.Struct,\n    TypeFlags.External   |\n    TypeFlags.Reference, 0\n  );\n\n  /** Non-nullable array reference (`ref array`). */\n  static readonly array: Type = new Type(TypeKind.Array,\n    TypeFlags.External   |\n    TypeFlags.Reference, 0\n  );\n\n  /** Non-nullable 31-bit integer reference (`ref i31`). */\n  static readonly i31: Type = new Type(TypeKind.I31,\n    TypeFlags.External   |\n    TypeFlags.Reference, 0\n  );\n\n  /** Non-nullable string reference (`ref string`). */\n  static readonly string: Type = new Type(TypeKind.String,\n    TypeFlags.External   |\n    TypeFlags.Reference, 0\n  );\n\n  /** Non-nullable WTF8 string view reference (`ref stringview_wtf8`). */\n  static readonly stringview_wtf8: Type = new Type(TypeKind.StringviewWTF8,\n    TypeFlags.External   |\n    TypeFlags.Reference, 0\n  );\n\n  /** Non-nullable WTF16 string view reference (`ref stringview_wtf16`). */\n  static readonly stringview_wtf16: Type = new Type(TypeKind.StringviewWTF16,\n    TypeFlags.External   |\n    TypeFlags.Reference, 0\n  );\n\n  /** Non-nullable string iterator reference (`ref stringview_iter`). */\n  static readonly stringview_iter: Type = new Type(TypeKind.StringviewIter,\n    TypeFlags.External   |\n    TypeFlags.Reference, 0\n  );\n\n  /** No return type. */\n  static readonly void: Type = new Type(TypeKind.Void, TypeFlags.None, 0);\n\n  /** Alias of i32 indicating type inference of locals and globals with just an initializer. */\n  static readonly auto: Type = new Type(Type.i32.kind, Type.i32.flags, Type.i32.size);\n}\n\n/** Converts an array of types to an array of type references. */\nexport function typesToRefs(types: Type[]): TypeRef[] {\n  let numTypes = types.length;\n  let ret = new Array<TypeRef>(numTypes);\n  for (let i = 0; i < numTypes; ++i) {\n    unchecked(ret[i] = types[i].toRef());\n  }\n  return ret;\n}\n\n/** Converts an array of types to its combined string representation. */\nexport function typesToString(types: Type[]): string {\n  let numTypes = types.length;\n  if (!numTypes) return \"\";\n  let sb = new Array<string>(numTypes);\n  for (let i = 0; i < numTypes; ++i) {\n    unchecked(sb[i] = types[i].toString(true));\n  }\n  return sb.join(\",\");\n}\n\n/** Represents a fully resolved function signature. */\nexport class Signature {\n  /** Construct a new signature. */\n  public static create(\n    /** The program that created this signature. */\n    program: Program,\n    /** Parameter types, if any, excluding `this`. */\n    parameterTypes: Type[] = [],\n    /** Return type. */\n    returnType: Type = Type.void,\n    /** This type, if an instance signature. */\n    thisType: Type | null = null,\n    /** Number of required parameters excluding `this`. Other parameters are considered optional. */\n    requiredParameters: i32 = parameterTypes ? parameterTypes.length : 0,\n    /** Whether the last parameter is a rest parameter. */\n    hasRest: bool = false,\n  ): Signature {\n    // get the usize type, and the type of the signature\n    let usizeType = program.options.usizeType;\n    let type = new Type(\n      usizeType.kind,\n      usizeType.flags & ~TypeFlags.Value | TypeFlags.Reference,\n      usizeType.size\n    );\n\n    // calculate the properties\n    let signatureTypes = program.uniqueSignatures;\n    let nextId = program.nextSignatureId;\n    \n    // construct the signature and calculate it's unique key\n    let signature = new Signature(program, parameterTypes, returnType, thisType, requiredParameters, hasRest, nextId, type);\n    let uniqueKey = signature.toString();\n\n    // check if it exists, and return it\n    if (signatureTypes.has(uniqueKey)) {\n      let existing = assert(signatureTypes.get(uniqueKey));\n      assert(signature.equals(existing));\n      return existing;\n    }\n\n    // otherwise increment the program's signature id, set the signature reference of the type, and memoize the signature\n    program.nextSignatureId = nextId + 1;\n    type.signatureReference = signature;\n    signatureTypes.set(uniqueKey, signature);\n    return signature;\n  }\n\n  /** Constructs a new signature. */\n  private constructor(\n    /** The program that created this signature. */\n    public readonly program: Program,\n    /** Parameter types, if any, excluding `this`. */\n    public readonly parameterTypes: Type[],\n    /** Return type. */\n    public readonly returnType: Type,\n    /** This type, if an instance signature. */\n    public readonly thisType: Type | null,\n    /** Number of required parameters excluding `this`. Other parameters are considered optional. */\n    public readonly requiredParameters: i32,\n    /** Whether the last parameter is a rest parameter. */\n    public readonly hasRest: bool,\n    /** Unique id representing this signature. */\n    public readonly id: u32,\n    /** Respective function type. */\n    public readonly type: Type,\n  ) {}\n\n  get paramRefs(): TypeRef {\n    let thisType = this.thisType;\n    let parameterTypes = this.parameterTypes;\n    let numParameterTypes = parameterTypes.length;\n    if (!numParameterTypes) {\n      return thisType ? thisType.toRef() : TypeRef.None;\n    }\n    if (thisType) {\n      let typeRefs = new Array<TypeRef>(1 + numParameterTypes);\n      unchecked(typeRefs[0] = thisType.toRef());\n      for (let i = 0; i < numParameterTypes; ++i) {\n        unchecked(typeRefs[i + 1] = parameterTypes[i].toRef());\n      }\n      return createType(typeRefs);\n    }\n    return createType(typesToRefs(parameterTypes));\n  }\n\n  get resultRefs(): TypeRef {\n    return this.returnType.toRef();\n  }\n\n  /** Tests if this signature equals the specified. */\n  equals(other: Signature): bool {\n\n    // check `this` type\n    let thisThisType = this.thisType;\n    let otherThisType = other.thisType;\n    if (thisThisType) {\n      if (!otherThisType || !thisThisType.equals(otherThisType)) return false;\n    } else if (otherThisType) {\n      return false;\n    }\n\n    // check rest parameter\n    if (this.hasRest != other.hasRest) return false;\n\n    // check return type\n    if (!this.returnType.equals(other.returnType)) return false;\n\n    // check parameter types\n    let selfParameterTypes = this.parameterTypes;\n    let otherParameterTypes = other.parameterTypes;\n    let numParameters = selfParameterTypes.length;\n    if (numParameters != otherParameterTypes.length)  return false;\n\n    for (let i = 0; i < numParameters; ++i) {\n      let selfParameterType = unchecked(selfParameterTypes[i]);\n      let otherParameterType = unchecked(otherParameterTypes[i]);\n      if (!selfParameterType.equals(otherParameterType)) return false;\n    }\n    return true;\n  }\n\n  /** Tests if a value of this function type is assignable to a target of the specified function type. */\n  isAssignableTo(target: Signature, checkCompatibleOverride: bool = false): bool {\n    let thisThisType = this.thisType;\n    let targetThisType = target.thisType;\n\n    if (thisThisType && targetThisType) {\n      const compatibleThisType = checkCompatibleOverride \n        ? thisThisType.canExtendOrImplement(targetThisType)\n        : targetThisType.isAssignableTo(thisThisType);\n      if (!compatibleThisType) return false; \n    } else if (thisThisType || targetThisType) {\n      return false;\n    }\n\n    // check rest parameter\n    if (this.hasRest != target.hasRest) return false; // TODO\n\n    // check return type (covariant)\n    let thisReturnType = this.returnType;\n    let targetReturnType = target.returnType;\n    if (!(thisReturnType == targetReturnType || thisReturnType.isAssignableTo(targetReturnType))) {\n      return false;\n    }\n    // check parameter types (invariant)\n    let thisParameterTypes = this.parameterTypes;\n    let targetParameterTypes = target.parameterTypes;\n    let numParameters = thisParameterTypes.length;\n    if (numParameters != targetParameterTypes.length) return false; // TODO\n\n    for (let i = 0; i < numParameters; ++i) {\n      let thisParameterType = unchecked(thisParameterTypes[i]);\n      let targetParameterType = unchecked(targetParameterTypes[i]);\n      if (thisParameterType != targetParameterType) return false;\n    }\n    return true;\n  }\n\n  /** Tests if this signature has at least one managed operand. */\n  get hasManagedOperands(): bool {\n    let thisType = this.thisType;\n    if (thisType && thisType.isManaged) {\n      return true;\n    }\n    let parameterTypes = this.parameterTypes;\n    for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n      if (unchecked(parameterTypes[i]).isManaged) return true;\n    }\n    return false;\n  }\n\n  /** Gets the indices of all managed operands. */\n  getManagedOperandIndices(): i32[] {\n    let indices = new Array<i32>();\n    let index = 0;\n    let thisType = this.thisType;\n    if (thisType) {\n      if (thisType.isManaged) indices.push(index);\n      ++index;\n    }\n    let parameterTypes = this.parameterTypes;\n    for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n      if (unchecked(parameterTypes[i]).isManaged) {\n        indices.push(index);\n      }\n      ++index;\n    }\n    return indices;\n  }\n\n  /** Tests if this signature has at least one v128 operand. */\n  get hasVectorValueOperands(): bool {\n    let thisType = this.thisType;\n    if (thisType && thisType.isVectorValue) {\n      return true;\n    }\n    let parameterTypes = this.parameterTypes;\n    for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n      if (unchecked(parameterTypes[i]).isVectorValue) return true;\n    }\n    return false;\n  }\n\n  /** Gets the indices of all v128 operands. */\n  getVectorValueOperandIndices(): i32[] {\n    let indices = new Array<i32>();\n    let index = 0;\n    let thisType = this.thisType;\n    if (thisType) {\n      if (thisType.isVectorValue) indices.push(index);\n      ++index;\n    }\n    let parameterTypes = this.parameterTypes;\n    for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n      if (unchecked(parameterTypes[i]).isVectorValue) {\n        indices.push(index);\n      }\n      ++index;\n    }\n    return indices;\n  }\n\n  /** Converts this signature to a string. */\n  toString(validWat: bool = false): string {\n    let sb = new Array<string>();\n    sb.push(validWat ? \"%28\" : \"(\");\n    let index = 0;\n    let thisType = this.thisType;\n    if (thisType) {\n      sb.push(validWat ? \"this:\" : \"this: \");\n      sb.push(thisType.toString(validWat));\n      index = 1;\n    }\n    let parameters = this.parameterTypes;\n    let numParameters = parameters.length;\n    if (numParameters) {\n      let optionalStart = this.requiredParameters;\n      let restIndex = this.hasRest ? numParameters - 1 : -1;\n      for (let i = 0; i < numParameters; ++i, ++index) {\n        if (index) sb.push(validWat ? \"%2C\" : \", \");\n        if (i == restIndex) sb.push(\"...\");\n        sb.push(parameters[i].toString(validWat));\n        if (i >= optionalStart && i != restIndex) sb.push(\"?\");\n      }\n    }\n    sb.push(validWat ? \"%29=>\" : \") => \");\n    sb.push(this.returnType.toString(validWat));\n    return sb.join(\"\");\n  }\n\n  /** Creates a clone of this signature that is safe to modify. */\n  clone(requiredParameters: i32 = this.requiredParameters, hasRest: bool = this.hasRest): Signature {\n    let parameterTypes = this.parameterTypes;\n    let numParameterTypes = parameterTypes.length;\n    let cloneParameterTypes = new Array<Type>(numParameterTypes);\n    for (let i = 0; i < numParameterTypes; ++i) {\n      unchecked(cloneParameterTypes[i] = parameterTypes[i]);\n    }\n    return Signature.create(\n      this.program,\n      cloneParameterTypes,\n      this.returnType,\n      this.thisType,\n      requiredParameters,\n      hasRest\n    );\n  }\n}\n", "/**\n * @fileoverview Built-in elements providing core WebAssembly functionality.\n *\n * Each builtin is linked to its definition in std/assembly/builtins.ts.\n * When its prototype is called, the compiler recognizes the `@builtin`\n * decorator, looks up the respective handler in the global builtins map\n * and executes it, with the handler directly emitting WebAssembly code\n * according to context.\n *\n * Builtins can be categorized into core builtins that typically are generic\n * and emit code directly and aliases calling core builtins with overridden\n * contexts. The latter is used by inline assembler aliases of WebAssembly\n * instructions, like `i64.load8_u` deferring to `<i64>load<u8>`.\n *\n * The `contextIsExact` modifier is used to force a specific instruction\n * family. A `i32.store8` deferring to `<i32>store<i8>` for example is\n * ambiguous in that the input can still be an i32 or an i64, leading to\n * either an `i32.store8` or an `i64.store8`, so `i32` is forced there.\n * This behavior is indicated by `from i32/i64` in the comments below.\n *\n * @license Apache-2.0\n */\n\n// TODO: Add builtins for `i32.add` etc. that do not have a core builtin.\n\nimport {\n  Compiler,\n  Constraints,\n  RuntimeFeatures,\n  UncheckedBehavior\n} from \"./compiler\";\n\nimport {\n  DiagnosticCode,\n  DiagnosticCategory\n} from \"./diagnostics\";\n\nimport {\n  Expression,\n  LiteralKind,\n  StringLiteralExpression,\n  CallExpression,\n  NodeKind,\n  LiteralExpression,\n  ArrayLiteralExpression,\n  IdentifierExpression\n} from \"./ast\";\n\nimport {\n  Type,\n  TypeKind,\n  TypeFlags\n} from \"./types\";\n\nimport {\n  BinaryOp,\n  UnaryOp,\n  AtomicRMWOp,\n  SIMDExtractOp,\n  SIMDReplaceOp,\n  SIMDShiftOp,\n  SIMDTernaryOp,\n  SIMDLoadOp,\n  SIMDLoadStoreLaneOp,\n  TypeRef,\n  ExpressionRef,\n  ExpressionId,\n  getExpressionId,\n  getExpressionType,\n  getConstValueI64High,\n  getConstValueI64Low,\n  getConstValueI32,\n  getConstValueF32,\n  getConstValueF64,\n  getLocalGetIndex,\n  createType,\n  ExpressionRunnerFlags,\n  mustPreserveSideEffects\n} from \"./module\";\n\nimport {\n  ElementKind,\n  FunctionPrototype,\n  Global,\n  DecoratorFlags,\n  Class,\n  PropertyPrototype,\n  VariableLikeElement\n} from \"./program\";\n\nimport {\n  FlowFlags,\n  LocalFlags\n} from \"./flow\";\n\nimport {\n  ReportMode\n} from \"./resolver\";\n\nimport {\n  CommonFlags,\n  Feature,\n  featureToString,\n  TypeinfoFlags\n} from \"./common\";\n\nimport {\n  writeI8,\n  writeI16,\n  writeI32,\n  writeF32,\n  writeF64,\n  isPowerOf2\n} from \"./util\";\n\n/** Internal names of various compiler built-ins. */\nexport namespace BuiltinNames {\n\n  // compiler-generated\n  export const start = \"~start\";\n  export const started = \"~started\";\n  export const argumentsLength = \"~argumentsLength\";\n  export const setArgumentsLength = \"~setArgumentsLength\";\n\n  // std/builtins.ts\n  export const abort = \"~lib/builtins/abort\";\n  export const trace = \"~lib/builtins/trace\";\n  export const seed = \"~lib/builtins/seed\";\n\n  export const isBoolean = \"~lib/builtins/isBoolean\";\n  export const isInteger = \"~lib/builtins/isInteger\";\n  export const isSigned = \"~lib/builtins/isSigned\";\n  export const isFloat = \"~lib/builtins/isFloat\";\n  export const isVector = \"~lib/builtins/isVector\";\n  export const isReference = \"~lib/builtins/isReference\";\n  export const isString = \"~lib/builtins/isString\";\n  export const isArray = \"~lib/builtins/isArray\";\n  export const isArrayLike = \"~lib/builtins/isArrayLike\";\n  export const isFunction = \"~lib/builtins/isFunction\";\n  export const isNullable = \"~lib/builtins/isNullable\";\n  export const isDefined = \"~lib/builtins/isDefined\";\n  export const isConstant = \"~lib/builtins/isConstant\";\n  export const isManaged = \"~lib/builtins/isManaged\";\n  export const isVoid = \"~lib/builtins/isVoid\";\n\n  export const add = \"~lib/builtins/add\";\n  export const sub = \"~lib/builtins/sub\";\n  export const mul = \"~lib/builtins/mul\";\n  export const div = \"~lib/builtins/div\";\n  export const clz = \"~lib/builtins/clz\";\n  export const ctz = \"~lib/builtins/ctz\";\n  export const popcnt = \"~lib/builtins/popcnt\";\n  export const rotl = \"~lib/builtins/rotl\";\n  export const rotr = \"~lib/builtins/rotr\";\n  export const abs = \"~lib/builtins/abs\";\n  export const max = \"~lib/builtins/max\";\n  export const min = \"~lib/builtins/min\";\n  export const ceil = \"~lib/builtins/ceil\";\n  export const floor = \"~lib/builtins/floor\";\n  export const copysign = \"~lib/builtins/copysign\";\n  export const nearest = \"~lib/builtins/nearest\";\n  export const reinterpret = \"~lib/builtins/reinterpret\";\n  export const sqrt = \"~lib/builtins/sqrt\";\n  export const trunc = \"~lib/builtins/trunc\";\n  export const eq = \"~lib/builtins/eq\";\n  export const ne = \"~lib/builtins/ne\";\n  export const rem = \"~lib/builtins/rem\";\n  export const load = \"~lib/builtins/load\";\n  export const store = \"~lib/builtins/store\";\n  export const atomic_load = \"~lib/builtins/atomic.load\";\n  export const atomic_store = \"~lib/builtins/atomic.store\";\n  export const atomic_add = \"~lib/builtins/atomic.add\";\n  export const atomic_sub = \"~lib/builtins/atomic.sub\";\n  export const atomic_and = \"~lib/builtins/atomic.and\";\n  export const atomic_or = \"~lib/builtins/atomic.or\";\n  export const atomic_xor = \"~lib/builtins/atomic.xor\";\n  export const atomic_xchg = \"~lib/builtins/atomic.xchg\";\n  export const atomic_cmpxchg = \"~lib/builtins/atomic.cmpxchg\";\n  export const atomic_wait = \"~lib/builtins/atomic.wait\";\n  export const atomic_notify = \"~lib/builtins/atomic.notify\";\n  export const atomic_fence = \"~lib/builtins/atomic.fence\";\n\n  export const sizeof = \"~lib/builtins/sizeof\";\n  export const alignof = \"~lib/builtins/alignof\";\n  export const offsetof = \"~lib/builtins/offsetof\";\n  export const nameof = \"~lib/builtins/nameof\";\n  export const lengthof = \"~lib/builtins/lengthof\";\n  export const select = \"~lib/builtins/select\";\n  export const unreachable = \"~lib/builtins/unreachable\";\n  export const changetype = \"~lib/builtins/changetype\";\n  export const assert = \"~lib/builtins/assert\";\n  export const call_indirect = \"~lib/builtins/call_indirect\";\n  export const unchecked = \"~lib/builtins/unchecked\";\n  export const inline_always = \"~lib/builtins/inline.always\";\n  export const instantiate = \"~lib/builtins/instantiate\";\n  export const idof = \"~lib/builtins/idof\";\n\n  export const i8 = \"~lib/builtins/i8\";\n  export const i16 = \"~lib/builtins/i16\";\n  export const i32 = \"~lib/builtins/i32\";\n  export const i64 = \"~lib/builtins/i64\";\n  export const isize = \"~lib/builtins/isize\";\n  export const u8 = \"~lib/builtins/u8\";\n  export const u16 = \"~lib/builtins/u16\";\n  export const u32 = \"~lib/builtins/u32\";\n  export const u64 = \"~lib/builtins/u64\";\n  export const usize = \"~lib/builtins/usize\";\n  export const bool = \"~lib/builtins/bool\";\n  export const f32 = \"~lib/builtins/f32\";\n  export const f64 = \"~lib/builtins/f64\";\n  export const v128 = \"~lib/builtins/v128\";\n\n  export const i32_clz = \"~lib/builtins/i32.clz\";\n  export const i64_clz = \"~lib/builtins/i64.clz\";\n  export const i32_ctz = \"~lib/builtins/i32.ctz\";\n  export const i64_ctz = \"~lib/builtins/i64.ctz\";\n  export const i32_popcnt = \"~lib/builtins/i32.popcnt\";\n  export const i64_popcnt = \"~lib/builtins/i64.popcnt\";\n  export const i32_rotl = \"~lib/builtins/i32.rotl\";\n  export const i64_rotl = \"~lib/builtins/i64.rotl\";\n  export const i32_rotr = \"~lib/builtins/i32.rotr\";\n  export const i64_rotr = \"~lib/builtins/i64.rotr\";\n\n  export const f32_abs = \"~lib/builtins/f32.abs\";\n  export const f64_abs = \"~lib/builtins/f64.abs\";\n  export const f32_max = \"~lib/builtins/f32.max\";\n  export const f64_max = \"~lib/builtins/f64.max\";\n  export const f32_min = \"~lib/builtins/f32.min\";\n  export const f64_min = \"~lib/builtins/f64.min\";\n  export const f32_ceil = \"~lib/builtins/f32.ceil\";\n  export const f64_ceil = \"~lib/builtins/f64.ceil\";\n  export const f32_floor = \"~lib/builtins/f32.floor\";\n  export const f64_floor = \"~lib/builtins/f64.floor\";\n  export const f32_copysign = \"~lib/builtins/f32.copysign\";\n  export const f64_copysign = \"~lib/builtins/f64.copysign\";\n  export const f32_nearest = \"~lib/builtins/f32.nearest\";\n  export const f64_nearest = \"~lib/builtins/f64.nearest\";\n  export const i32_reinterpret_f32 = \"~lib/builtins/i32.reinterpret_f32\";\n  export const i64_reinterpret_f64 = \"~lib/builtins/i64.reinterpret_f64\";\n  export const f32_reinterpret_i32 = \"~lib/builtins/f32.reinterpret_i32\";\n  export const f64_reinterpret_i64 = \"~lib/builtins/f64.reinterpret_i64\";\n  export const f32_sqrt = \"~lib/builtins/f32.sqrt\";\n  export const f64_sqrt = \"~lib/builtins/f64.sqrt\";\n  export const f32_trunc = \"~lib/builtins/f32.trunc\";\n  export const f64_trunc = \"~lib/builtins/f64.trunc\";\n\n  export const i32_add = \"~lib/builtins/i32.add\";\n  export const i64_add = \"~lib/builtins/i64.add\";\n  export const f32_add = \"~lib/builtins/f32.add\";\n  export const f64_add = \"~lib/builtins/f64.add\";\n  export const i32_sub = \"~lib/builtins/i32.sub\";\n  export const i64_sub = \"~lib/builtins/i64.sub\";\n  export const f32_sub = \"~lib/builtins/f32.sub\";\n  export const f64_sub = \"~lib/builtins/f64.sub\";\n  export const i32_mul = \"~lib/builtins/i32.mul\";\n  export const i64_mul = \"~lib/builtins/i64.mul\";\n  export const f32_mul = \"~lib/builtins/f32.mul\";\n  export const f64_mul = \"~lib/builtins/f64.mul\";\n  export const i32_div_s = \"~lib/builtins/i32.div_s\";\n  export const i32_div_u = \"~lib/builtins/i32.div_u\";\n  export const i64_div_s = \"~lib/builtins/i64.div_s\";\n  export const i64_div_u = \"~lib/builtins/i64.div_u\";\n  export const f32_div = \"~lib/builtins/f32.div\";\n  export const f64_div = \"~lib/builtins/f64.div\";\n\n  export const i32_eq = \"~lib/builtins/i32.eq\";\n  export const i64_eq = \"~lib/builtins/i64.eq\";\n  export const f32_eq = \"~lib/builtins/f32.eq\";\n  export const f64_eq = \"~lib/builtins/f64.eq\";\n  export const i32_ne = \"~lib/builtins/i32.ne\";\n  export const i64_ne = \"~lib/builtins/i64.ne\";\n  export const f32_ne = \"~lib/builtins/f32.ne\";\n  export const f64_ne = \"~lib/builtins/f64.ne\";\n\n  export const i32_rem_s = \"~lib/builtins/i32.rem_s\";\n  export const i32_rem_u = \"~lib/builtins/i32.rem_u\";\n  export const i64_rem_s = \"~lib/builtins/i64.rem_s\";\n  export const i64_rem_u = \"~lib/builtins/i64.rem_u\";\n\n  export const i32_load8_s = \"~lib/builtins/i32.load8_s\";\n  export const i32_load8_u = \"~lib/builtins/i32.load8_u\";\n  export const i32_load16_s = \"~lib/builtins/i32.load16_s\";\n  export const i32_load16_u = \"~lib/builtins/i32.load16_u\";\n  export const i32_load = \"~lib/builtins/i32.load\";\n  export const i64_load8_s = \"~lib/builtins/i64.load8_s\";\n  export const i64_load8_u = \"~lib/builtins/i64.load8_u\";\n  export const i64_load16_s = \"~lib/builtins/i64.load16_s\";\n  export const i64_load16_u = \"~lib/builtins/i64.load16_u\";\n  export const i64_load32_s = \"~lib/builtins/i64.load32_s\";\n  export const i64_load32_u = \"~lib/builtins/i64.load32_u\";\n  export const i64_load = \"~lib/builtins/i64.load\";\n  export const f32_load = \"~lib/builtins/f32.load\";\n  export const f64_load = \"~lib/builtins/f64.load\";\n  export const i32_store8 = \"~lib/builtins/i32.store8\";\n  export const i32_store16 = \"~lib/builtins/i32.store16\";\n  export const i32_store = \"~lib/builtins/i32.store\";\n  export const i64_store8 = \"~lib/builtins/i64.store8\";\n  export const i64_store16 = \"~lib/builtins/i64.store16\";\n  export const i64_store32 = \"~lib/builtins/i64.store32\";\n  export const i64_store = \"~lib/builtins/i64.store\";\n  export const f32_store = \"~lib/builtins/f32.store\";\n  export const f64_store = \"~lib/builtins/f64.store\";\n\n  export const i32_atomic_load8_u = \"~lib/builtins/i32.atomic.load8_u\";\n  export const i32_atomic_load16_u = \"~lib/builtins/i32.atomic.load16_u\";\n  export const i32_atomic_load = \"~lib/builtins/i32.atomic.load\";\n  export const i64_atomic_load8_u = \"~lib/builtins/i64.atomic.load8_u\";\n  export const i64_atomic_load16_u = \"~lib/builtins/i64.atomic.load16_u\";\n  export const i64_atomic_load32_u = \"~lib/builtins/i64.atomic.load32_u\";\n  export const i64_atomic_load = \"~lib/builtins/i64.atomic.load\";\n  export const i32_atomic_store8 = \"~lib/builtins/i32.atomic.store8\";\n  export const i32_atomic_store16 = \"~lib/builtins/i32.atomic.store16\";\n  export const i32_atomic_store = \"~lib/builtins/i32.atomic.store\";\n  export const i64_atomic_store8 = \"~lib/builtins/i64.atomic.store8\";\n  export const i64_atomic_store16 = \"~lib/builtins/i64.atomic.store16\";\n  export const i64_atomic_store32 = \"~lib/builtins/i64.atomic.store32\";\n  export const i64_atomic_store = \"~lib/builtins/i64.atomic.store\";\n  export const i32_atomic_rmw8_add_u = \"~lib/builtins/i32.atomic.rmw8.add_u\";\n  export const i32_atomic_rmw16_add_u = \"~lib/builtins/i32.atomic.rmw16.add_u\";\n  export const i32_atomic_rmw_add = \"~lib/builtins/i32.atomic.rmw.add\";\n  export const i64_atomic_rmw8_add_u = \"~lib/builtins/i64.atomic.rmw8.add_u\";\n  export const i64_atomic_rmw16_add_u = \"~lib/builtins/i64.atomic.rmw16.add_u\";\n  export const i64_atomic_rmw32_add_u = \"~lib/builtins/i64.atomic.rmw32.add_u\";\n  export const i64_atomic_rmw_add = \"~lib/builtins/i64.atomic.rmw.add\";\n  export const i32_atomic_rmw8_sub_u = \"~lib/builtins/i32.atomic.rmw8.sub_u\";\n  export const i32_atomic_rmw16_sub_u = \"~lib/builtins/i32.atomic.rmw16.sub_u\";\n  export const i32_atomic_rmw_sub = \"~lib/builtins/i32.atomic.rmw.sub\";\n  export const i64_atomic_rmw8_sub_u = \"~lib/builtins/i64.atomic.rmw8.sub_u\";\n  export const i64_atomic_rmw16_sub_u = \"~lib/builtins/i64.atomic.rmw16.sub_u\";\n  export const i64_atomic_rmw32_sub_u = \"~lib/builtins/i64.atomic.rmw32.sub_u\";\n  export const i64_atomic_rmw_sub = \"~lib/builtins/i64.atomic.rmw.sub\";\n  export const i32_atomic_rmw8_and_u = \"~lib/builtins/i32.atomic.rmw8.and_u\";\n  export const i32_atomic_rmw16_and_u = \"~lib/builtins/i32.atomic.rmw16.and_u\";\n  export const i32_atomic_rmw_and = \"~lib/builtins/i32.atomic.rmw.and\";\n  export const i64_atomic_rmw8_and_u = \"~lib/builtins/i64.atomic.rmw8.and_u\";\n  export const i64_atomic_rmw16_and_u = \"~lib/builtins/i64.atomic.rmw16.and_u\";\n  export const i64_atomic_rmw32_and_u = \"~lib/builtins/i64.atomic.rmw32.and_u\";\n  export const i64_atomic_rmw_and = \"~lib/builtins/i64.atomic.rmw.and\";\n  export const i32_atomic_rmw8_or_u = \"~lib/builtins/i32.atomic.rmw8.or_u\";\n  export const i32_atomic_rmw16_or_u = \"~lib/builtins/i32.atomic.rmw16.or_u\";\n  export const i32_atomic_rmw_or = \"~lib/builtins/i32.atomic.rmw.or\";\n  export const i64_atomic_rmw8_or_u = \"~lib/builtins/i64.atomic.rmw8.or_u\";\n  export const i64_atomic_rmw16_or_u = \"~lib/builtins/i64.atomic.rmw16.or_u\";\n  export const i64_atomic_rmw32_or_u = \"~lib/builtins/i64.atomic.rmw32.or_u\";\n  export const i64_atomic_rmw_or = \"~lib/builtins/i64.atomic.rmw.or\";\n  export const i32_atomic_rmw8_xor_u = \"~lib/builtins/i32.atomic.rmw8.xor_u\";\n  export const i32_atomic_rmw16_xor_u = \"~lib/builtins/i32.atomic.rmw16.xor_u\";\n  export const i32_atomic_rmw_xor = \"~lib/builtins/i32.atomic.rmw.xor\";\n  export const i64_atomic_rmw8_xor_u = \"~lib/builtins/i64.atomic.rmw8.xor_u\";\n  export const i64_atomic_rmw16_xor_u = \"~lib/builtins/i64.atomic.rmw16.xor_u\";\n  export const i64_atomic_rmw32_xor_u = \"~lib/builtins/i64.atomic.rmw32.xor_u\";\n  export const i64_atomic_rmw_xor = \"~lib/builtins/i64.atomic.rmw.xor\";\n  export const i32_atomic_rmw8_xchg_u = \"~lib/builtins/i32.atomic.rmw8.xchg_u\";\n  export const i32_atomic_rmw16_xchg_u = \"~lib/builtins/i32.atomic.rmw16.xchg_u\";\n  export const i32_atomic_rmw_xchg = \"~lib/builtins/i32.atomic.rmw.xchg\";\n  export const i64_atomic_rmw8_xchg_u = \"~lib/builtins/i64.atomic.rmw8.xchg_u\";\n  export const i64_atomic_rmw16_xchg_u = \"~lib/builtins/i64.atomic.rmw16.xchg_u\";\n  export const i64_atomic_rmw32_xchg_u = \"~lib/builtins/i64.atomic.rmw32.xchg_u\";\n  export const i64_atomic_rmw_xchg = \"~lib/builtins/i64.atomic.rmw.xchg\";\n  export const i32_atomic_rmw8_cmpxchg_u = \"~lib/builtins/i32.atomic.rmw8.cmpxchg_u\";\n  export const i32_atomic_rmw16_cmpxchg_u = \"~lib/builtins/i32.atomic.rmw16.cmpxchg_u\";\n  export const i32_atomic_rmw_cmpxchg = \"~lib/builtins/i32.atomic.rmw.cmpxchg\";\n  export const i64_atomic_rmw8_cmpxchg_u = \"~lib/builtins/i64.atomic.rmw8.cmpxchg_u\";\n  export const i64_atomic_rmw16_cmpxchg_u = \"~lib/builtins/i64.atomic.rmw16.cmpxchg_u\";\n  export const i64_atomic_rmw32_cmpxchg_u = \"~lib/builtins/i64.atomic.rmw32.cmpxchg_u\";\n  export const i64_atomic_rmw_cmpxchg = \"~lib/builtins/i64.atomic.rmw.cmpxchg\";\n  export const memory_atomic_wait32 = \"~lib/memory/memory.atomic.wait32\";\n  export const memory_atomic_wait64 = \"~lib/memory/memory.atomic.wait64\";\n\n  export const v128_splat = \"~lib/builtins/v128.splat\";\n  export const v128_extract_lane = \"~lib/builtins/v128.extract_lane\";\n  export const v128_replace_lane = \"~lib/builtins/v128.replace_lane\";\n  export const v128_shuffle = \"~lib/builtins/v128.shuffle\";\n  export const v128_swizzle = \"~lib/builtins/v128.swizzle\";\n  export const v128_load_splat = \"~lib/builtins/v128.load_splat\";\n  export const v128_load_ext = \"~lib/builtins/v128.load_ext\";\n  export const v128_load_zero = \"~lib/builtins/v128.load_zero\";\n  export const v128_load_lane = \"~lib/builtins/v128.load_lane\";\n  export const v128_store_lane = \"~lib/builtins/v128.store_lane\";\n  export const v128_load = \"~lib/builtins/v128.load\";\n  export const v128_load8x8_s = \"~lib/builtins/v128.load8x8_s\";\n  export const v128_load8x8_u = \"~lib/builtins/v128.load8x8_u\";\n  export const v128_load16x4_s = \"~lib/builtins/v128.load16x4_s\";\n  export const v128_load16x4_u = \"~lib/builtins/v128.load16x4_u\";\n  export const v128_load32x2_s = \"~lib/builtins/v128.load32x2_s\";\n  export const v128_load32x2_u = \"~lib/builtins/v128.load32x2_u\";\n  export const v128_load8_splat = \"~lib/builtins/v128.load8_splat\";\n  export const v128_load16_splat = \"~lib/builtins/v128.load16_splat\";\n  export const v128_load32_splat = \"~lib/builtins/v128.load32_splat\";\n  export const v128_load64_splat = \"~lib/builtins/v128.load64_splat\";\n  export const v128_load32_zero = \"~lib/builtins/v128.load32_zero\";\n  export const v128_load64_zero = \"~lib/builtins/v128.load64_zero\";\n  export const v128_load8_lane = \"~lib/builtins/v128.load8_lane\";\n  export const v128_load16_lane = \"~lib/builtins/v128.load16_lane\";\n  export const v128_load32_lane = \"~lib/builtins/v128.load32_lane\";\n  export const v128_load64_lane = \"~lib/builtins/v128.load64_lane\";\n  export const v128_store8_lane = \"~lib/builtins/v128.store8_lane\";\n  export const v128_store16_lane = \"~lib/builtins/v128.store16_lane\";\n  export const v128_store32_lane = \"~lib/builtins/v128.store32_lane\";\n  export const v128_store64_lane = \"~lib/builtins/v128.store64_lane\";\n  export const v128_store = \"~lib/builtins/v128.store\";\n  export const v128_add = \"~lib/builtins/v128.add\";\n  export const v128_sub = \"~lib/builtins/v128.sub\";\n  export const v128_mul = \"~lib/builtins/v128.mul\";\n  export const v128_div = \"~lib/builtins/v128.div\";\n  export const v128_neg = \"~lib/builtins/v128.neg\";\n  export const v128_add_sat = \"~lib/builtins/v128.add_sat\";\n  export const v128_sub_sat = \"~lib/builtins/v128.sub_sat\";\n  export const v128_shl = \"~lib/builtins/v128.shl\";\n  export const v128_shr = \"~lib/builtins/v128.shr\";\n  export const v128_and = \"~lib/builtins/v128.and\";\n  export const v128_or = \"~lib/builtins/v128.or\";\n  export const v128_xor = \"~lib/builtins/v128.xor\";\n  export const v128_andnot = \"~lib/builtins/v128.andnot\";\n  export const v128_not = \"~lib/builtins/v128.not\";\n  export const v128_bitselect = \"~lib/builtins/v128.bitselect\";\n  export const v128_any_true = \"~lib/builtins/v128.any_true\";\n  export const v128_all_true = \"~lib/builtins/v128.all_true\";\n  export const v128_bitmask = \"~lib/builtins/v128.bitmask\";\n  export const v128_popcnt = \"~lib/builtins/v128.popcnt\";\n  export const v128_min = \"~lib/builtins/v128.min\";\n  export const v128_max = \"~lib/builtins/v128.max\";\n  export const v128_pmin = \"~lib/builtins/v128.pmin\";\n  export const v128_pmax = \"~lib/builtins/v128.pmax\";\n  export const v128_dot = \"~lib/builtins/v128.dot\";\n  export const v128_avgr = \"~lib/builtins/v128.avgr\";\n  export const v128_abs = \"~lib/builtins/v128.abs\";\n  export const v128_sqrt = \"~lib/builtins/v128.sqrt\";\n  export const v128_ceil = \"~lib/builtins/v128.ceil\";\n  export const v128_floor = \"~lib/builtins/v128.floor\";\n  export const v128_trunc = \"~lib/builtins/v128.trunc\";\n  export const v128_nearest = \"~lib/builtins/v128.nearest\";\n  export const v128_eq = \"~lib/builtins/v128.eq\";\n  export const v128_ne = \"~lib/builtins/v128.ne\";\n  export const v128_lt = \"~lib/builtins/v128.lt\";\n  export const v128_le = \"~lib/builtins/v128.le\";\n  export const v128_gt = \"~lib/builtins/v128.gt\";\n  export const v128_ge = \"~lib/builtins/v128.ge\";\n  export const v128_convert = \"~lib/builtins/v128.convert\";\n  export const v128_convert_low = \"~lib/builtins/v128.convert_low\";\n  export const v128_trunc_sat = \"~lib/builtins/v128.trunc_sat\";\n  export const v128_trunc_sat_zero = \"~lib/builtins/v128.trunc_sat_zero\";\n  export const v128_narrow = \"~lib/builtins/v128.narrow\";\n  export const v128_extend_low = \"~lib/builtins/v128.extend_low\";\n  export const v128_extend_high = \"~lib/builtins/v128.extend_high\";\n  export const v128_extadd_pairwise = \"~lib/builtins/v128.extadd_pairwise\";\n  export const v128_demote_zero = \"~lib/builtins/v128.demote_zero\";\n  export const v128_promote_low = \"~lib/builtins/v128.promote_low\";\n  export const v128_q15mulr_sat = \"~lib/builtins/v128.q15mulr_sat\";\n  export const v128_extmul_low = \"~lib/builtins/v128.extmul_low\";\n  export const v128_extmul_high = \"~lib/builtins/v128.extmul_high\";\n  export const v128_relaxed_swizzle = \"~lib/builtins/v128.relaxed_swizzle\";\n  export const v128_relaxed_trunc = \"~lib/builtins/v128.relaxed_trunc\";\n  export const v128_relaxed_trunc_zero = \"~lib/builtins/v128.relaxed_trunc_zero\";\n  export const v128_relaxed_madd = \"~lib/builtins/v128.relaxed_madd\";\n  export const v128_relaxed_nmadd = \"~lib/builtins/v128.relaxed_nmadd\";\n  export const v128_relaxed_laneselect = \"~lib/builtins/v128.relaxed_laneselect\";\n  export const v128_relaxed_min = \"~lib/builtins/v128.relaxed_min\";\n  export const v128_relaxed_max = \"~lib/builtins/v128.relaxed_max\";\n  export const v128_relaxed_q15mulr = \"~lib/builtins/v128.relaxed_q15mulr\";\n  export const v128_relaxed_dot = \"~lib/builtins/v128.relaxed_dot\";\n  export const v128_relaxed_dot_add = \"~lib/builtins/v128.relaxed_dot_add\";\n\n  export const i8x16 = \"~lib/builtins/i8x16\";\n  export const i16x8 = \"~lib/builtins/i16x8\";\n  export const i32x4 = \"~lib/builtins/i32x4\";\n  export const i64x2 = \"~lib/builtins/i64x2\";\n  export const f32x4 = \"~lib/builtins/f32x4\";\n  export const f64x2 = \"~lib/builtins/f64x2\";\n\n  export const i8x16_splat = \"~lib/builtins/i8x16.splat\";\n  export const i8x16_extract_lane_s = \"~lib/builtins/i8x16.extract_lane_s\";\n  export const i8x16_extract_lane_u = \"~lib/builtins/i8x16.extract_lane_u\";\n  export const i8x16_replace_lane = \"~lib/builtins/i8x16.replace_lane\";\n  export const i8x16_add = \"~lib/builtins/i8x16.add\";\n  export const i8x16_sub = \"~lib/builtins/i8x16.sub\";\n  export const i8x16_mul = \"~lib/builtins/i8x16.mul\";\n  export const i8x16_min_s = \"~lib/builtins/i8x16.min_s\";\n  export const i8x16_min_u = \"~lib/builtins/i8x16.min_u\";\n  export const i8x16_max_s = \"~lib/builtins/i8x16.max_s\";\n  export const i8x16_max_u = \"~lib/builtins/i8x16.max_u\";\n  export const i8x16_avgr_u = \"~lib/builtins/i8x16.avgr_u\";\n  export const i8x16_abs = \"~lib/builtins/i8x16.abs\";\n  export const i8x16_neg = \"~lib/builtins/i8x16.neg\";\n  export const i8x16_add_sat_s = \"~lib/builtins/i8x16.add_sat_s\";\n  export const i8x16_add_sat_u = \"~lib/builtins/i8x16.add_sat_u\";\n  export const i8x16_sub_sat_s = \"~lib/builtins/i8x16.sub_sat_s\";\n  export const i8x16_sub_sat_u = \"~lib/builtins/i8x16.sub_sat_u\";\n  export const i8x16_shl = \"~lib/builtins/i8x16.shl\";\n  export const i8x16_shr_s = \"~lib/builtins/i8x16.shr_s\";\n  export const i8x16_shr_u = \"~lib/builtins/i8x16.shr_u\";\n  export const i8x16_all_true = \"~lib/builtins/i8x16.all_true\";\n  export const i8x16_bitmask = \"~lib/builtins/i8x16.bitmask\";\n  export const i8x16_popcnt = \"~lib/builtins/i8x16.popcnt\";\n  export const i8x16_eq = \"~lib/builtins/i8x16.eq\";\n  export const i8x16_ne = \"~lib/builtins/i8x16.ne\";\n  export const i8x16_lt_s = \"~lib/builtins/i8x16.lt_s\";\n  export const i8x16_lt_u = \"~lib/builtins/i8x16.lt_u\";\n  export const i8x16_le_s = \"~lib/builtins/i8x16.le_s\";\n  export const i8x16_le_u = \"~lib/builtins/i8x16.le_u\";\n  export const i8x16_gt_s = \"~lib/builtins/i8x16.gt_s\";\n  export const i8x16_gt_u = \"~lib/builtins/i8x16.gt_u\";\n  export const i8x16_ge_s = \"~lib/builtins/i8x16.ge_s\";\n  export const i8x16_ge_u = \"~lib/builtins/i8x16.ge_u\";\n  export const i8x16_narrow_i16x8_s = \"~lib/builtins/i8x16.narrow_i16x8_s\";\n  export const i8x16_narrow_i16x8_u = \"~lib/builtins/i8x16.narrow_i16x8_u\";\n  export const i8x16_shuffle = \"~lib/builtins/i8x16.shuffle\";\n  export const i8x16_swizzle = \"~lib/builtins/i8x16.swizzle\";\n\n  export const i16x8_splat = \"~lib/builtins/i16x8.splat\";\n  export const i16x8_extract_lane_s = \"~lib/builtins/i16x8.extract_lane_s\";\n  export const i16x8_extract_lane_u = \"~lib/builtins/i16x8.extract_lane_u\";\n  export const i16x8_replace_lane = \"~lib/builtins/i16x8.replace_lane\";\n  export const i16x8_add = \"~lib/builtins/i16x8.add\";\n  export const i16x8_sub = \"~lib/builtins/i16x8.sub\";\n  export const i16x8_mul = \"~lib/builtins/i16x8.mul\";\n  export const i16x8_min_s = \"~lib/builtins/i16x8.min_s\";\n  export const i16x8_min_u = \"~lib/builtins/i16x8.min_u\";\n  export const i16x8_max_s = \"~lib/builtins/i16x8.max_s\";\n  export const i16x8_max_u = \"~lib/builtins/i16x8.max_u\";\n  export const i16x8_avgr_u = \"~lib/builtins/i16x8.avgr_u\";\n  export const i16x8_abs = \"~lib/builtins/i16x8.abs\";\n  export const i16x8_neg = \"~lib/builtins/i16x8.neg\";\n  export const i16x8_add_sat_s = \"~lib/builtins/i16x8.add_sat_s\";\n  export const i16x8_add_sat_u = \"~lib/builtins/i16x8.add_sat_u\";\n  export const i16x8_sub_sat_s = \"~lib/builtins/i16x8.sub_sat_s\";\n  export const i16x8_sub_sat_u = \"~lib/builtins/i16x8.sub_sat_u\";\n  export const i16x8_shl = \"~lib/builtins/i16x8.shl\";\n  export const i16x8_shr_s = \"~lib/builtins/i16x8.shr_s\";\n  export const i16x8_shr_u = \"~lib/builtins/i16x8.shr_u\";\n  export const i16x8_all_true = \"~lib/builtins/i16x8.all_true\";\n  export const i16x8_bitmask = \"~lib/builtins/i16x8.bitmask\";\n  export const i16x8_eq = \"~lib/builtins/i16x8.eq\";\n  export const i16x8_ne = \"~lib/builtins/i16x8.ne\";\n  export const i16x8_lt_s = \"~lib/builtins/i16x8.lt_s\";\n  export const i16x8_lt_u = \"~lib/builtins/i16x8.lt_u\";\n  export const i16x8_le_s = \"~lib/builtins/i16x8.le_s\";\n  export const i16x8_le_u = \"~lib/builtins/i16x8.le_u\";\n  export const i16x8_gt_s = \"~lib/builtins/i16x8.gt_s\";\n  export const i16x8_gt_u = \"~lib/builtins/i16x8.gt_u\";\n  export const i16x8_ge_s = \"~lib/builtins/i16x8.ge_s\";\n  export const i16x8_ge_u = \"~lib/builtins/i16x8.ge_u\";\n  export const i16x8_narrow_i32x4_s = \"~lib/builtins/i16x8.narrow_i32x4_s\";\n  export const i16x8_narrow_i32x4_u = \"~lib/builtins/i16x8.narrow_i32x4_u\";\n  export const i16x8_extend_low_i8x16_s = \"~lib/builtins/i16x8.extend_low_i8x16_s\";\n  export const i16x8_extend_low_i8x16_u = \"~lib/builtins/i16x8.extend_low_i8x16_u\";\n  export const i16x8_extend_high_i8x16_s = \"~lib/builtins/i16x8.extend_high_i8x16_s\";\n  export const i16x8_extend_high_i8x16_u = \"~lib/builtins/i16x8.extend_high_i8x16_u\";\n  export const i16x8_extadd_pairwise_i8x16_s = \"~lib/builtins/i16x8.extadd_pairwise_i8x16_s\";\n  export const i16x8_extadd_pairwise_i8x16_u = \"~lib/builtins/i16x8.extadd_pairwise_i8x16_u\";\n  export const i16x8_q15mulr_sat_s = \"~lib/builtins/i16x8.q15mulr_sat_s\";\n  export const i16x8_extmul_low_i8x16_s = \"~lib/builtins/i16x8.extmul_low_i8x16_s\";\n  export const i16x8_extmul_low_i8x16_u = \"~lib/builtins/i16x8.extmul_low_i8x16_u\";\n  export const i16x8_extmul_high_i8x16_s = \"~lib/builtins/i16x8.extmul_high_i8x16_s\";\n  export const i16x8_extmul_high_i8x16_u = \"~lib/builtins/i16x8.extmul_high_i8x16_u\";\n  export const i16x8_shuffle = \"~lib/builtins/i16x8.shuffle\";\n\n  export const i32x4_splat = \"~lib/builtins/i32x4.splat\";\n  export const i32x4_extract_lane = \"~lib/builtins/i32x4.extract_lane\";\n  export const i32x4_replace_lane = \"~lib/builtins/i32x4.replace_lane\";\n  export const i32x4_add = \"~lib/builtins/i32x4.add\";\n  export const i32x4_sub = \"~lib/builtins/i32x4.sub\";\n  export const i32x4_mul = \"~lib/builtins/i32x4.mul\";\n  export const i32x4_min_s = \"~lib/builtins/i32x4.min_s\";\n  export const i32x4_min_u = \"~lib/builtins/i32x4.min_u\";\n  export const i32x4_max_s = \"~lib/builtins/i32x4.max_s\";\n  export const i32x4_max_u = \"~lib/builtins/i32x4.max_u\";\n  export const i32x4_dot_i16x8_s = \"~lib/builtins/i32x4.dot_i16x8_s\";\n  export const i32x4_abs = \"~lib/builtins/i32x4.abs\";\n  export const i32x4_neg = \"~lib/builtins/i32x4.neg\";\n  export const i32x4_shl = \"~lib/builtins/i32x4.shl\";\n  export const i32x4_shr_s = \"~lib/builtins/i32x4.shr_s\";\n  export const i32x4_shr_u = \"~lib/builtins/i32x4.shr_u\";\n  export const i32x4_all_true = \"~lib/builtins/i32x4.all_true\";\n  export const i32x4_bitmask = \"~lib/builtins/i32x4.bitmask\";\n  export const i32x4_eq = \"~lib/builtins/i32x4.eq\";\n  export const i32x4_ne = \"~lib/builtins/i32x4.ne\";\n  export const i32x4_lt_s = \"~lib/builtins/i32x4.lt_s\";\n  export const i32x4_lt_u = \"~lib/builtins/i32x4.lt_u\";\n  export const i32x4_le_s = \"~lib/builtins/i32x4.le_s\";\n  export const i32x4_le_u = \"~lib/builtins/i32x4.le_u\";\n  export const i32x4_gt_s = \"~lib/builtins/i32x4.gt_s\";\n  export const i32x4_gt_u = \"~lib/builtins/i32x4.gt_u\";\n  export const i32x4_ge_s = \"~lib/builtins/i32x4.ge_s\";\n  export const i32x4_ge_u = \"~lib/builtins/i32x4.ge_u\";\n  export const i32x4_trunc_sat_f32x4_s = \"~lib/builtins/i32x4.trunc_sat_f32x4_s\";\n  export const i32x4_trunc_sat_f32x4_u = \"~lib/builtins/i32x4.trunc_sat_f32x4_u\";\n  export const i32x4_trunc_sat_f64x2_s_zero = \"~lib/builtins/i32x4.trunc_sat_f64x2_s_zero\";\n  export const i32x4_trunc_sat_f64x2_u_zero = \"~lib/builtins/i32x4.trunc_sat_f64x2_u_zero\";\n  export const i32x4_extend_low_i16x8_s = \"~lib/builtins/i32x4.extend_low_i16x8_s\";\n  export const i32x4_extend_low_i16x8_u = \"~lib/builtins/i32x4.extend_low_i16x8_u\";\n  export const i32x4_extend_high_i16x8_s = \"~lib/builtins/i32x4.extend_high_i16x8_s\";\n  export const i32x4_extend_high_i16x8_u = \"~lib/builtins/i32x4.extend_high_i16x8_u\";\n  export const i32x4_extadd_pairwise_i16x8_s = \"~lib/builtins/i32x4.extadd_pairwise_i16x8_s\";\n  export const i32x4_extadd_pairwise_i16x8_u = \"~lib/builtins/i32x4.extadd_pairwise_i16x8_u\";\n  export const i32x4_extmul_low_i16x8_s = \"~lib/builtins/i32x4.extmul_low_i16x8_s\";\n  export const i32x4_extmul_low_i16x8_u = \"~lib/builtins/i32x4.extmul_low_i16x8_u\";\n  export const i32x4_extmul_high_i16x8_s = \"~lib/builtins/i32x4.extmul_high_i16x8_s\";\n  export const i32x4_extmul_high_i16x8_u = \"~lib/builtins/i32x4.extmul_high_i16x8_u\";\n  export const i32x4_shuffle = \"~lib/builtins/i32x4.shuffle\";\n\n  export const i64x2_splat = \"~lib/builtins/i64x2.splat\";\n  export const i64x2_extract_lane = \"~lib/builtins/i64x2.extract_lane\";\n  export const i64x2_replace_lane = \"~lib/builtins/i64x2.replace_lane\";\n  export const i64x2_add = \"~lib/builtins/i64x2.add\";\n  export const i64x2_sub = \"~lib/builtins/i64x2.sub\";\n  export const i64x2_mul = \"~lib/builtins/i64x2.mul\";\n  export const i64x2_abs = \"~lib/builtins/i64x2.abs\";\n  export const i64x2_neg = \"~lib/builtins/i64x2.neg\";\n  export const i64x2_shl = \"~lib/builtins/i64x2.shl\";\n  export const i64x2_shr_s = \"~lib/builtins/i64x2.shr_s\";\n  export const i64x2_shr_u = \"~lib/builtins/i64x2.shr_u\";\n  export const i64x2_all_true = \"~lib/builtins/i64x2.all_true\";\n  export const i64x2_bitmask = \"~lib/builtins/i64x2.bitmask\";\n  export const i64x2_eq = \"~lib/builtins/i64x2.eq\";\n  export const i64x2_ne = \"~lib/builtins/i64x2.ne\";\n  export const i64x2_lt_s = \"~lib/builtins/i64x2.lt_s\";\n  export const i64x2_lt_u = \"~lib/builtins/i64x2.lt_u\";\n  export const i64x2_le_s = \"~lib/builtins/i64x2.le_s\";\n  export const i64x2_le_u = \"~lib/builtins/i64x2.le_u\";\n  export const i64x2_gt_s = \"~lib/builtins/i64x2.gt_s\";\n  export const i64x2_gt_u = \"~lib/builtins/i64x2.gt_u\";\n  export const i64x2_ge_s = \"~lib/builtins/i64x2.ge_s\";\n  export const i64x2_ge_u = \"~lib/builtins/i64x2.ge_u\";\n  export const i64x2_extend_low_i32x4_s = \"~lib/builtins/i64x2.extend_low_i32x4_s\";\n  export const i64x2_extend_low_i32x4_u = \"~lib/builtins/i64x2.extend_low_i32x4_u\";\n  export const i64x2_extend_high_i32x4_s = \"~lib/builtins/i64x2.extend_high_i32x4_s\";\n  export const i64x2_extend_high_i32x4_u = \"~lib/builtins/i64x2.extend_high_i32x4_u\";\n  export const i64x2_extmul_low_i32x4_s = \"~lib/builtins/i64x2.extmul_low_i32x4_s\";\n  export const i64x2_extmul_low_i32x4_u = \"~lib/builtins/i64x2.extmul_low_i32x4_u\";\n  export const i64x2_extmul_high_i32x4_s = \"~lib/builtins/i64x2.extmul_high_i32x4_s\";\n  export const i64x2_extmul_high_i32x4_u = \"~lib/builtins/i64x2.extmul_high_i32x4_u\";\n  export const i64x2_shuffle = \"~lib/builtins/i64x2.shuffle\";\n\n  export const f32x4_splat = \"~lib/builtins/f32x4.splat\";\n  export const f32x4_extract_lane = \"~lib/builtins/f32x4.extract_lane\";\n  export const f32x4_replace_lane = \"~lib/builtins/f32x4.replace_lane\";\n  export const f32x4_add = \"~lib/builtins/f32x4.add\";\n  export const f32x4_sub = \"~lib/builtins/f32x4.sub\";\n  export const f32x4_mul = \"~lib/builtins/f32x4.mul\";\n  export const f32x4_div = \"~lib/builtins/f32x4.div\";\n  export const f32x4_neg = \"~lib/builtins/f32x4.neg\";\n  export const f32x4_min = \"~lib/builtins/f32x4.min\";\n  export const f32x4_max = \"~lib/builtins/f32x4.max\";\n  export const f32x4_pmin = \"~lib/builtins/f32x4.pmin\";\n  export const f32x4_pmax = \"~lib/builtins/f32x4.pmax\";\n  export const f32x4_abs = \"~lib/builtins/f32x4.abs\";\n  export const f32x4_sqrt = \"~lib/builtins/f32x4.sqrt\";\n  export const f32x4_ceil = \"~lib/builtins/f32x4.ceil\";\n  export const f32x4_floor = \"~lib/builtins/f32x4.floor\";\n  export const f32x4_trunc = \"~lib/builtins/f32x4.trunc\";\n  export const f32x4_nearest = \"~lib/builtins/f32x4.nearest\";\n  export const f32x4_eq = \"~lib/builtins/f32x4.eq\";\n  export const f32x4_ne = \"~lib/builtins/f32x4.ne\";\n  export const f32x4_lt = \"~lib/builtins/f32x4.lt\";\n  export const f32x4_le = \"~lib/builtins/f32x4.le\";\n  export const f32x4_gt = \"~lib/builtins/f32x4.gt\";\n  export const f32x4_ge = \"~lib/builtins/f32x4.ge\";\n  export const f32x4_convert_i32x4_s = \"~lib/builtins/f32x4.convert_i32x4_s\";\n  export const f32x4_convert_i32x4_u = \"~lib/builtins/f32x4.convert_i32x4_u\";\n  export const f32x4_demote_f64x2_zero = \"~lib/builtins/f32x4.demote_f64x2_zero\";\n  export const f32x4_shuffle = \"~lib/builtins/f32x4.shuffle\";\n\n  export const f64x2_splat = \"~lib/builtins/f64x2.splat\";\n  export const f64x2_extract_lane = \"~lib/builtins/f64x2.extract_lane\";\n  export const f64x2_replace_lane = \"~lib/builtins/f64x2.replace_lane\";\n  export const f64x2_add = \"~lib/builtins/f64x2.add\";\n  export const f64x2_sub = \"~lib/builtins/f64x2.sub\";\n  export const f64x2_mul = \"~lib/builtins/f64x2.mul\";\n  export const f64x2_div = \"~lib/builtins/f64x2.div\";\n  export const f64x2_neg = \"~lib/builtins/f64x2.neg\";\n  export const f64x2_min = \"~lib/builtins/f64x2.min\";\n  export const f64x2_max = \"~lib/builtins/f64x2.max\";\n  export const f64x2_pmin = \"~lib/builtins/f64x2.pmin\";\n  export const f64x2_pmax = \"~lib/builtins/f64x2.pmax\";\n  export const f64x2_abs = \"~lib/builtins/f64x2.abs\";\n  export const f64x2_sqrt = \"~lib/builtins/f64x2.sqrt\";\n  export const f64x2_ceil = \"~lib/builtins/f64x2.ceil\";\n  export const f64x2_floor = \"~lib/builtins/f64x2.floor\";\n  export const f64x2_trunc = \"~lib/builtins/f64x2.trunc\";\n  export const f64x2_nearest = \"~lib/builtins/f64x2.nearest\";\n  export const f64x2_eq = \"~lib/builtins/f64x2.eq\";\n  export const f64x2_ne = \"~lib/builtins/f64x2.ne\";\n  export const f64x2_lt = \"~lib/builtins/f64x2.lt\";\n  export const f64x2_le = \"~lib/builtins/f64x2.le\";\n  export const f64x2_gt = \"~lib/builtins/f64x2.gt\";\n  export const f64x2_ge = \"~lib/builtins/f64x2.ge\";\n  export const f64x2_convert_low_i32x4_s = \"~lib/builtins/f64x2.convert_low_i32x4_s\";\n  export const f64x2_convert_low_i32x4_u = \"~lib/builtins/f64x2.convert_low_i32x4_u\";\n  export const f64x2_promote_low_f32x4 = \"~lib/builtins/f64x2.promote_low_f32x4\";\n  export const f64x2_shuffle = \"~lib/builtins/f64x2.shuffle\";\n\n  export const i8x16_relaxed_swizzle = \"~lib/builtins/i8x16.relaxed_swizzle\";\n  export const i32x4_relaxed_trunc_f32x4_s = \"~lib/builtins/i32x4.relaxed_trunc_f32x4_s\";\n  export const i32x4_relaxed_trunc_f32x4_u = \"~lib/builtins/i32x4.relaxed_trunc_f32x4_u\";\n  export const i32x4_relaxed_trunc_f64x2_s_zero = \"~lib/builtins/i32x4.relaxed_trunc_f64x2_s_zero\";\n  export const i32x4_relaxed_trunc_f64x2_u_zero = \"~lib/builtins/i32x4.relaxed_trunc_f64x2_u_zero\";\n  export const f32x4_relaxed_madd = \"~lib/builtins/f32x4.relaxed_madd\";\n  export const f32x4_relaxed_nmadd = \"~lib/builtins/f32x4.relaxed_nmadd\";\n  export const f64x2_relaxed_madd = \"~lib/builtins/f64x2.relaxed_madd\";\n  export const f64x2_relaxed_nmadd = \"~lib/builtins/f64x2.relaxed_nmadd\";\n  export const i8x16_relaxed_laneselect = \"~lib/builtins/i8x16.relaxed_laneselect\";\n  export const i16x8_relaxed_laneselect = \"~lib/builtins/i16x8.relaxed_laneselect\";\n  export const i32x4_relaxed_laneselect = \"~lib/builtins/i32x4.relaxed_laneselect\";\n  export const i64x2_relaxed_laneselect = \"~lib/builtins/i64x2.relaxed_laneselect\";\n  export const f32x4_relaxed_min = \"~lib/builtins/f32x4.relaxed_min\";\n  export const f32x4_relaxed_max = \"~lib/builtins/f32x4.relaxed_max\";\n  export const f64x2_relaxed_min = \"~lib/builtins/f64x2.relaxed_min\";\n  export const f64x2_relaxed_max = \"~lib/builtins/f64x2.relaxed_max\";\n  export const i16x8_relaxed_q15mulr_s = \"~lib/builtins/i16x8.relaxed_q15mulr_s\";\n  export const i16x8_relaxed_dot_i8x16_i7x16_s = \"~lib/builtins/i16x8.relaxed_dot_i8x16_i7x16_s\";\n  export const i32x4_relaxed_dot_i8x16_i7x16_add_s = \"~lib/builtins/i32x4.relaxed_dot_i8x16_i7x16_add_s\";\n\n  export const i31_new = \"~lib/builtins/i31.new\";\n  export const i31_get = \"~lib/builtins/i31.get\";\n\n  // internals\n  export const data_end = \"~lib/memory/__data_end\";\n  export const stack_pointer = \"~lib/memory/__stack_pointer\";\n  export const heap_base = \"~lib/memory/__heap_base\";\n  export const rtti_base = \"~lib/rt/__rtti_base\";\n  export const visit_globals = \"~lib/rt/__visit_globals\";\n  export const visit_members = \"~lib/rt/__visit_members\";\n  export const tostack = \"~lib/rt/__tostack\";\n\n  // std/number.ts\n  export const NaN = \"~lib/number/NaN\";\n  export const Infinity = \"~lib/number/Infinity\";\n  export const isNaN = \"~lib/number/isNaN\";\n  export const isFinite = \"~lib/number/isFinite\";\n\n  // std/diagnostics.ts\n  export const ERROR = \"~lib/diagnostics/ERROR\";\n  export const WARNING = \"~lib/diagnostics/WARNING\";\n  export const INFO = \"~lib/diagnostics/INFO\";\n\n  // std/function.ts\n  export const Function = \"~lib/function/Function\";\n  export const Function_call = \"~lib/function/Function#call\";\n\n  // std/memory.ts\n  export const memory_size = \"~lib/memory/memory.size\";\n  export const memory_grow = \"~lib/memory/memory.grow\";\n  export const memory_copy = \"~lib/memory/memory.copy\";\n  export const memory_fill = \"~lib/memory/memory.fill\";\n  export const memory_data = \"~lib/memory/memory.data\";\n\n  // std/typedarray.ts\n  export const Int8Array = \"~lib/typedarray/Int8Array\";\n  export const Uint8Array = \"~lib/typedarray/Uint8Array\";\n  export const Uint8ClampedArray = \"~lib/typedarray/Uint8ClampedArray\";\n  export const Int16Array = \"~lib/typedarray/Int16Array\";\n  export const Uint16Array = \"~lib/typedarray/Uint16Array\";\n  export const Int32Array = \"~lib/typedarray/Int32Array\";\n  export const Uint32Array = \"~lib/typedarray/Uint32Array\";\n  export const Int64Array = \"~lib/typedarray/Int64Array\";\n  export const Uint64Array = \"~lib/typedarray/Uint64Array\";\n  export const Float32Array = \"~lib/typedarray/Float32Array\";\n  export const Float64Array = \"~lib/typedarray/Float64Array\";\n\n  // std/string.ts\n  export const String_raw = \"~lib/string/String.raw\";\n  export const String_eq = \"~lib/string/String.__eq\";\n  export const String_ne = \"~lib/string/String.__ne\";\n  export const String_not = \"~lib/string/String.__not\";\n\n  // std/object.ts\n  export const Object = \"~lib/object/Object\";\n}\n\n/** Builtin variable compilation context. */\nexport class BuiltinVariableContext {\n  constructor(\n    /** Compiler reference. */\n    public compiler: Compiler,\n    /** Variable being accessed. */\n    public element: VariableLikeElement,\n    /** Contextual type. */\n    public contextualType: Type = element.type,\n    /** Respective report expression. */\n    public reportNode: IdentifierExpression = element.identifierNode\n  ) {}\n}\n\n/** Builtin function compilation context. */\nexport class BuiltinFunctionContext {\n  constructor(\n    /** Compiler reference. */\n    public compiler: Compiler,\n    /** Prototype being called. */\n    public prototype: FunctionPrototype,\n    /** Provided type arguments. */\n    public typeArguments: Type[] | null,\n    /** Provided operands. */\n    public operands: Expression[],\n    /** Provided this operand, if any. */\n    public thisOperand: Expression | null,\n    /** Contextual type. */\n    public contextualType: Type,\n    /** Respective call expression. */\n    public reportNode: CallExpression,\n    /** Whether originating from inline assembly. */\n    public contextIsExact: bool\n  ) {}\n}\n\n/** Builtin functions map. */\nexport const builtinFunctions = new Map<string, (ctx: BuiltinFunctionContext) => ExpressionRef>();\n\n/** Builtin variables map. */\nexport const builtinVariables_onCompile = new Map<string, (ctx: BuiltinVariableContext) => void>();\nexport const builtinVariables_onAccess = new Map<string, (ctx: BuiltinVariableContext) => ExpressionRef>();\n\n// === Static type evaluation =================================================================\n\n// helper global used by checkConstantType\nlet checkConstantType_expr: ExpressionRef = 0;\n\n// isBoolean<T!>() / isBoolean<T?>(value: T) -> bool\nfunction builtin_isBoolean(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return reifyConstantType(ctx, module.i32(type.isBooleanValue ? 1 : 0));\n}\nbuiltinFunctions.set(BuiltinNames.isBoolean, builtin_isBoolean);\n\n// isInteger<T!>() / isInteger<T?>(value: T) -> bool\nfunction builtin_isInteger(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return reifyConstantType(ctx, module.i32(type.isIntegerValue ? 1 : 0));\n}\nbuiltinFunctions.set(BuiltinNames.isInteger, builtin_isInteger);\n\n// isSigned<T!>() / isSigned<T?>(value: T) -> bool\nfunction builtin_isSigned(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return reifyConstantType(ctx, module.i32(type.isSignedIntegerValue ? 1 : 0));\n}\nbuiltinFunctions.set(BuiltinNames.isSigned, builtin_isSigned);\n\n// isFloat<T!>() / isFloat<T?>(value: T) -> bool\nfunction builtin_isFloat(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return reifyConstantType(ctx, module.i32(type.isFloatValue ? 1 : 0));\n}\nbuiltinFunctions.set(BuiltinNames.isFloat, builtin_isFloat);\n\n// isVector<T!>() / isVector<T?>(value: T) -> bool\nfunction builtin_isVector(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return reifyConstantType(ctx, module.i32(type.isVectorValue ? 1 : 0));\n}\nbuiltinFunctions.set(BuiltinNames.isVector, builtin_isVector);\n\n// isReference<T!>() / isReference<T?>(value: T) -> bool\nfunction builtin_isReference(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return reifyConstantType(ctx, module.i32(type.isReference ? 1 : 0));\n}\nbuiltinFunctions.set(BuiltinNames.isReference, builtin_isReference);\n\n// isString<T!>() / isString<T?>(value: T) -> bool\nfunction builtin_isString(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  let classReference = type.getClass();\n  return reifyConstantType(ctx,\n    module.i32(\n      classReference && classReference.isAssignableTo(compiler.program.stringInstance)\n        ? 1\n        : 0\n    )\n  );\n}\nbuiltinFunctions.set(BuiltinNames.isString, builtin_isString);\n\n// isArray<T!>() / isArray<T?>(value: T) -> bool\nfunction builtin_isArray(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  let classReference = type.getClass();\n  return reifyConstantType(ctx,\n    module.i32(\n      classReference && classReference.extendsPrototype(compiler.program.arrayPrototype)\n        ? 1\n        : 0\n    )\n  );\n}\nbuiltinFunctions.set(BuiltinNames.isArray, builtin_isArray);\n\n// isArrayLike<T!>() / isArrayLike<T?>(value: T) -> bool\nfunction builtin_isArrayLike(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  let classReference = type.getClass();\n  return reifyConstantType(ctx,\n    module.i32(\n      classReference && classReference.isArrayLike\n        ? 1\n        : 0\n    )\n  );\n}\nbuiltinFunctions.set(BuiltinNames.isArrayLike, builtin_isArrayLike);\n\n// isFunction<T!> / isFunction<T?>(value: T) -> bool\nfunction builtin_isFunction(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return reifyConstantType(ctx, module.i32(type.isFunction ? 1 : 0));\n}\nbuiltinFunctions.set(BuiltinNames.isFunction, builtin_isFunction);\n\n// isNullable<T!> / isNullable<T?>(value: T) -> bool\nfunction builtin_isNullable(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return reifyConstantType(ctx, module.i32(type.isNullableReference ? 1 : 0));\n}\nbuiltinFunctions.set(BuiltinNames.isNullable, builtin_isNullable);\n\n// isDefined(expression) -> bool\nfunction builtin_isDefined(ctx: BuiltinFunctionContext): ExpressionRef {\n  // Note that `isDefined` neither compiles nor evaluates the given expression\n  // but exclusively performs a check whether it can be compiled in theory.\n  // This is not exactly unsafe due to only seemingly having side effects which\n  // actually never happen, but may confuse tooling unaware of its semantics.\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = Type.bool;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let element = compiler.resolver.lookupExpression(\n    ctx.operands[0],\n    compiler.currentFlow,\n    Type.auto,\n    ReportMode.Swallow\n  );\n  return module.i32(element ? 1 : 0);\n}\nbuiltinFunctions.set(BuiltinNames.isDefined, builtin_isDefined);\n\n// isConstant(expression) -> bool\nfunction builtin_isConstant(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = Type.bool;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let expr = compiler.compileExpression(ctx.operands[0], Type.auto);\n  compiler.currentType = Type.bool;\n  if (!mustPreserveSideEffects(expr, module.ref)) {\n    return module.i32(module.isConstExpression(expr) ? 1 : 0);\n  }\n  return module.block(null, [\n    module.maybeDrop(expr),\n    module.i32(0)\n  ], getExpressionType(expr));\n}\nbuiltinFunctions.set(BuiltinNames.isConstant, builtin_isConstant);\n\n// isManaged<T!>() -> bool\nfunction builtin_isManaged(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return reifyConstantType(ctx, module.i32(type.isManaged ? 1 : 0));\n}\nbuiltinFunctions.set(BuiltinNames.isManaged, builtin_isManaged);\n\n// isVoid<T!>() -> bool\nfunction builtin_isVoid(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return reifyConstantType(ctx, module.i32(type.kind == TypeKind.Void ? 1 : 0));\n}\nbuiltinFunctions.set(BuiltinNames.isVoid, builtin_isVoid);\n\n// lengthof<T!>() -> i32\nfunction builtin_lengthof(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.i32;\n  if (!type) return module.unreachable();\n  let signatureReference = type.signatureReference;\n  if (!signatureReference) {\n    compiler.error(\n      DiagnosticCode.Type_0_has_no_call_signatures,\n      ctx.reportNode.range, type.toString()\n    );\n    return module.unreachable();\n  }\n  return reifyConstantType(ctx, module.i32(signatureReference.parameterTypes.length));\n}\nbuiltinFunctions.set(BuiltinNames.lengthof, builtin_lengthof);\n\n// sizeof<T!>() -> usize*\nfunction builtin_sizeof(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = compiler.options.usizeType;\n  if (\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 0)\n  ) return module.unreachable();\n  let type = ctx.typeArguments![0];\n  let byteSize = type.byteSize;\n  if (!byteSize) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"sizeof\", type.toString()\n    );\n    return module.unreachable();\n  }\n  return contextualUsize(compiler, i64_new(byteSize), ctx.contextualType);\n}\nbuiltinFunctions.set(BuiltinNames.sizeof, builtin_sizeof);\n\n// alignof<T!>() -> usize*\nfunction builtin_alignof(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = compiler.options.usizeType;\n  if (\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 0)\n  ) return module.unreachable();\n  let type = ctx.typeArguments![0];\n  let byteSize = type.byteSize;\n  if (!isPowerOf2(byteSize)) { // implies == 0\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"alignof\", type.toString()\n    );\n    return module.unreachable();\n  }\n  return contextualUsize(compiler, i64_new(ctz<i32>(byteSize)), ctx.contextualType);\n}\nbuiltinFunctions.set(BuiltinNames.alignof, builtin_alignof);\n\n// offsetof<T!>(fieldName?: string) -> usize*\nfunction builtin_offsetof(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = compiler.options.usizeType;\n  if (\n    checkTypeRequired(ctx) |\n    checkArgsOptional(ctx, 0, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let contextualType = ctx.contextualType;\n  let type = ctx.typeArguments![0];\n  let classReference = type.getClassOrWrapper(compiler.program);\n  if (!classReference) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"offsetof\", type.toString()\n    );\n    if (compiler.options.isWasm64) {\n      if (contextualType.isIntegerValue && contextualType.size <= 32) {\n        compiler.currentType = Type.u32;\n      }\n    } else {\n      if (contextualType.isIntegerValue && contextualType.size == 64) {\n        compiler.currentType = Type.u64;\n      }\n    }\n    return module.unreachable();\n  }\n  if (operands.length) {\n    let firstOperand = operands[0];\n    if (!firstOperand.isLiteralKind(LiteralKind.String)) {\n      compiler.error(\n        DiagnosticCode.String_literal_expected,\n        operands[0].range\n      );\n      return module.unreachable();\n    }\n    let fieldName = (<StringLiteralExpression>firstOperand).value;\n    let fieldMember = classReference.getMember(fieldName);\n    if (fieldMember && fieldMember.kind == ElementKind.PropertyPrototype) {\n      let property = (<PropertyPrototype>fieldMember).instance;\n      if (property && property.isField) {\n        assert(property.memoryOffset >= 0);\n        return contextualUsize(compiler, i64_new(property.memoryOffset), contextualType);\n      }\n    }\n    compiler.error(\n      DiagnosticCode.Type_0_has_no_property_1,\n      firstOperand.range, classReference.internalName, fieldName\n    );\n    return module.unreachable();\n  }\n  return contextualUsize(compiler, i64_new(classReference.nextMemoryOffset), contextualType);\n}\nbuiltinFunctions.set(BuiltinNames.offsetof, builtin_offsetof);\n\n// nameof<T> -> string\nfunction builtin_nameof(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let resultType = checkConstantType(ctx);\n  if (!resultType) {\n    compiler.currentType = compiler.program.stringInstance.type;\n    return module.unreachable();\n  }\n  let value: string;\n  if (resultType.isInternalReference) {\n    let classReference = resultType.getClass();\n    if (classReference) {\n      value = classReference.name;\n    } else {\n      assert(resultType.getSignature());\n      value = \"Function\";\n    }\n  } else {\n    value = resultType.toString();\n  }\n  return reifyConstantType(ctx, compiler.ensureStaticString(value));\n}\nbuiltinFunctions.set(BuiltinNames.nameof, builtin_nameof);\n\n// idof<T> -> u32\nfunction builtin_idof(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.u32;\n  if (!type) return module.unreachable();\n  let signatureReference = type.getSignature();\n  if (signatureReference) {\n    return reifyConstantType(ctx, module.i32(signatureReference.id));\n  }\n  let classReference = type.getClassOrWrapper(compiler.program);\n  if (classReference && !classReference.hasDecorator(DecoratorFlags.Unmanaged)) {\n    return reifyConstantType(ctx, module.i32(classReference.id));\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"idof\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.idof, builtin_idof);\n\n// === Math ===================================================================================\n\n// NaN\nfunction builtin_NaN_compile(ctx: BuiltinVariableContext): void {\n  let element = ctx.element;\n  if (element.is(CommonFlags.ModuleExport)) {\n    let module = ctx.compiler.module;\n    module.addGlobal(element.internalName, TypeRef.F64, false, module.f64(NaN));\n  }\n}\nbuiltinVariables_onCompile.set(BuiltinNames.NaN, builtin_NaN_compile);\n\n// NaN -> f32 | f64\nfunction builtin_NaN_access(ctx: BuiltinVariableContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (ctx.contextualType == Type.f32) {\n    compiler.currentType = Type.f32;\n    return module.f32(<f32>NaN);\n  }\n  compiler.currentType = Type.f64;\n  return module.f64(NaN);\n}\nbuiltinVariables_onAccess.set(BuiltinNames.NaN, builtin_NaN_access);\n\n// Infinity\nfunction builtin_Infinity_compile(ctx: BuiltinVariableContext): void {\n  let element = ctx.element;\n  if (element.is(CommonFlags.ModuleExport)) {\n    let module = ctx.compiler.module;\n    module.addGlobal(element.internalName, TypeRef.F64, false, module.f64(Infinity));\n  }\n}\nbuiltinVariables_onCompile.set(BuiltinNames.Infinity, builtin_Infinity_compile);\n\n// Infinity -> f32 | f64\nfunction builtin_Infinity_access(ctx: BuiltinVariableContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (ctx.contextualType == Type.f32) {\n    compiler.currentType = Type.f32;\n    return module.f32(<f32>Infinity);\n  }\n  compiler.currentType = Type.f64;\n  return module.f64(Infinity);\n}\nbuiltinVariables_onAccess.set(BuiltinNames.Infinity, builtin_Infinity_access);\n\n// clz<T?>(value: T) -> T\nfunction builtin_clz(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(ctx.operands[0], typeArguments[0], Constraints.ConvImplicit | Constraints.MustWrap)\n    : compiler.compileExpression(ctx.operands[0], Type.i32, Constraints.MustWrap);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Bool: // not wrapped\n      case TypeKind.I8:\n      case TypeKind.U8:\n      case TypeKind.I16:\n      case TypeKind.U16:\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.ClzI32, arg0);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.unary(UnaryOp.ClzSize, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.ClzI64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"clz\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.clz, builtin_clz);\n\n// ctz<T?>(value: T) -> T\nfunction builtin_ctz(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit | Constraints.MustWrap)\n    : compiler.compileExpression(operands[0], Type.i32, Constraints.MustWrap);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Bool: // not wrapped\n      case TypeKind.I8:\n      case TypeKind.U8:\n      case TypeKind.I16:\n      case TypeKind.U16:\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.CtzI32, arg0);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.unary(UnaryOp.CtzSize, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.CtzI64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"ctz\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.ctz, builtin_ctz);\n\n// popcnt<T?>(value: T) -> T\nfunction builtin_popcnt(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit | Constraints.MustWrap)\n    : compiler.compileExpression(operands[0], Type.i32, Constraints.MustWrap);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    switch (compiler.currentType.kind) {\n      case TypeKind.Bool: return arg0;\n      case TypeKind.I8: // not wrapped\n      case TypeKind.U8:\n      case TypeKind.I16:\n      case TypeKind.U16:\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.PopcntI32, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.PopcntI64, arg0);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.unary(UnaryOp.PopcntSize, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"popcnt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.popcnt, builtin_popcnt);\n\n// rotl<T?>(value: T, shift: T) -> T\nfunction builtin_rotl(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit | Constraints.MustWrap)\n    : compiler.compileExpression(operands[0], Type.i32, Constraints.MustWrap);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1 = compiler.compileExpression(operands[1], type, Constraints.ConvImplicit);\n    switch (type.kind) {\n      case TypeKind.Bool: return arg0;\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        // (value << (shift & mask)) | (value >>> ((0 - shift) & mask))\n        let flow = compiler.currentFlow;\n        let temp1 = flow.getTempLocal(type);\n        flow.setLocalFlag(temp1.index, LocalFlags.Wrapped);\n        let temp2 = flow.getTempLocal(type);\n        flow.setLocalFlag(temp2.index, LocalFlags.Wrapped);\n\n        let ret = module.binary(BinaryOp.OrI32,\n          module.binary(\n            BinaryOp.ShlI32,\n            module.local_tee(temp1.index, arg0, false), // i32\n            module.binary(\n              BinaryOp.AndI32,\n              module.local_tee(temp2.index, arg1, false), // i32\n              module.i32(type.size - 1)\n            )\n          ),\n          module.binary(\n            BinaryOp.ShrU32,\n            module.local_get(temp1.index, TypeRef.I32),\n            module.binary(\n              BinaryOp.AndI32,\n              module.binary(\n                BinaryOp.SubI32,\n                module.i32(0),\n                module.local_get(temp2.index, TypeRef.I32)\n              ),\n              module.i32(type.size - 1)\n            )\n          )\n        );\n\n        return ret;\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.RotlI32, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.RotlI64, arg0, arg1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.RotlSize, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"rotl\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.rotl, builtin_rotl);\n\n// rotr<T?>(value: T, shift: T) -> T\nfunction builtin_rotr(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit | Constraints.MustWrap)\n    : compiler.compileExpression(operands[0], Type.i32, Constraints.MustWrap);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1 = compiler.compileExpression(operands[1], type, Constraints.ConvImplicit);\n    switch (type.kind) {\n      case TypeKind.Bool: return arg0;\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        // (value >>> (shift & mask)) | (value << ((0 - shift) & mask))\n        let flow = compiler.currentFlow;\n        let temp1 = flow.getTempLocal(type);\n        flow.setLocalFlag(temp1.index, LocalFlags.Wrapped);\n        let temp2 = flow.getTempLocal(type);\n        flow.setLocalFlag(temp2.index, LocalFlags.Wrapped);\n\n        let ret = module.binary(BinaryOp.OrI32,\n          module.binary(\n            BinaryOp.ShrU32,\n            module.local_tee(temp1.index, arg0, false), // i32\n            module.binary(\n              BinaryOp.AndI32,\n              module.local_tee(temp2.index, arg1, false), // i32\n              module.i32(type.size - 1)\n            )\n          ),\n          module.binary(\n            BinaryOp.ShlI32,\n            module.local_get(temp1.index, TypeRef.I32),\n            module.binary(\n              BinaryOp.AndI32,\n              module.binary(\n                BinaryOp.SubI32,\n                module.i32(0),\n                module.local_get(temp2.index, TypeRef.I32)\n              ),\n              module.i32(type.size - 1)\n            )\n          )\n        );\n\n        return ret;\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.RotrI32, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.RotrI64, arg0, arg1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.RotrSize, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"rotr\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.rotr, builtin_rotr);\n\n// abs<T?>(value: T) -> T\nfunction builtin_abs(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit | Constraints.MustWrap)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.MustWrap);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.Usize: return arg0;\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32: {\n        let flow = compiler.currentFlow;\n\n        // possibly overflows, e.g. abs<i8>(-128) == 128\n        let temp1 = flow.getTempLocal(Type.i32);\n        let temp2 = flow.getTempLocal(Type.i32);\n        // (x + (x >> 31)) ^ (x >> 31)\n        let ret = module.binary(BinaryOp.XorI32,\n          module.binary(BinaryOp.AddI32,\n            module.local_tee(\n              temp2.index,\n              module.binary(BinaryOp.ShrI32,\n                module.local_tee(temp1.index, arg0, false), // i32\n                module.i32(31)\n              ),\n              false // i32\n            ),\n            module.local_get(temp1.index, TypeRef.I32)\n          ),\n          module.local_get(temp2.index, TypeRef.I32)\n        );\n        return ret;\n      }\n      case TypeKind.Isize: {\n        let options = compiler.options;\n        let flow = compiler.currentFlow;\n\n        let temp1 = flow.getTempLocal(options.usizeType);\n        let temp2 = flow.getTempLocal(options.usizeType);\n        let ret = module.binary(BinaryOp.XorSize,\n          module.binary(BinaryOp.AddSize,\n            module.local_tee(\n              temp2.index,\n              module.binary(BinaryOp.ShrISize,\n                module.local_tee(temp1.index, arg0, false), // i32/i64\n                compiler.options.isWasm64\n                  ? module.i64(63)\n                  : module.i32(31)\n              ),\n              false // i32/i64\n            ),\n            module.local_get(temp1.index, options.sizeTypeRef)\n          ),\n          module.local_get(temp2.index, options.sizeTypeRef)\n        );\n        return ret;\n      }\n      case TypeKind.I64: {\n        let flow = compiler.currentFlow;\n\n        let temp1 = flow.getTempLocal(Type.i64);\n        let temp2 = flow.getTempLocal(Type.i64);\n        // (x + (x >> 63)) ^ (x >> 63)\n        let ret = module.binary(BinaryOp.XorI64,\n          module.binary(BinaryOp.AddI64,\n            module.local_tee(\n              temp2.index,\n              module.binary(BinaryOp.ShrI64,\n                module.local_tee(temp1.index, arg0, false), // i64\n                module.i64(63)\n              ),\n              false // i64\n            ),\n            module.local_get(temp1.index, TypeRef.I64)\n          ),\n          module.local_get(temp2.index, TypeRef.I64)\n        );\n        return ret;\n      }\n      case TypeKind.F32: return module.unary(UnaryOp.AbsF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.AbsF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"abs\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.abs, builtin_abs);\n\n// max<T?>(left: T, right: T) -> T\nfunction builtin_max(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let left = operands[0];\n  let arg0 = typeArguments\n    ? compiler.compileExpression(left, typeArguments[0], Constraints.ConvImplicit | Constraints.MustWrap)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.MustWrap);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) { // prefer right type\n      arg1 = compiler.compileExpression(operands[1], type, Constraints.MustWrap);\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(left, type = compiler.currentType, Constraints.ConvImplicit | Constraints.MustWrap);\n      }\n    } else {\n      arg1 = compiler.compileExpression(operands[1], type, Constraints.ConvImplicit | Constraints.MustWrap);\n    }\n    // @ts-expect-error\n    let op: BinaryOp = -1;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:   { op = BinaryOp.GtI32; break; }\n      case TypeKind.Bool:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:   { op = BinaryOp.GtU32; break; }\n      case TypeKind.I64:   { op = BinaryOp.GtI64; break; }\n      case TypeKind.U64:   { op = BinaryOp.GtU64; break; }\n      case TypeKind.Isize: { op = BinaryOp.GtISize; break; }\n      case TypeKind.Usize: { op = BinaryOp.GtUSize; break; }\n      case TypeKind.F32: return module.binary(BinaryOp.MaxF32, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.MaxF64, arg0, arg1);\n    }\n    if (op as i32 != -1) {\n      let flow = compiler.currentFlow;\n      let typeRef = type.toRef();\n      let temp1 = flow.getTempLocal(type);\n      flow.setLocalFlag(temp1.index, LocalFlags.Wrapped);\n      let temp2 = flow.getTempLocal(type);\n      flow.setLocalFlag(temp2.index, LocalFlags.Wrapped);\n      let ret = module.select(\n        module.local_tee(temp1.index, arg0, false), // numeric\n        module.local_tee(temp2.index, arg1, false), // numeric\n        module.binary(op,\n          module.local_get(temp1.index, typeRef),\n          module.local_get(temp2.index, typeRef)\n        )\n      );\n      return ret;\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"max\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.max, builtin_max);\n\n// min<T?>(left: T, right: T) -> T\nfunction builtin_min(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let left = operands[0];\n  let arg0 = typeArguments\n    ? compiler.compileExpression(left, typeArguments[0], Constraints.ConvImplicit | Constraints.MustWrap)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.MustWrap);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) { // prefer right type\n      arg1 = compiler.compileExpression(operands[1], type, Constraints.MustWrap);\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(left, type = compiler.currentType, Constraints.ConvImplicit | Constraints.MustWrap);\n      }\n    } else {\n      arg1 = compiler.compileExpression(operands[1], type, Constraints.ConvImplicit | Constraints.MustWrap);\n    }\n    // @ts-expect-error\n    let op: BinaryOp = -1;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:   { op = BinaryOp.LtI32; break; }\n      case TypeKind.Bool:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:   { op = BinaryOp.LtU32; break; }\n      case TypeKind.I64:   { op = BinaryOp.LtI64; break; }\n      case TypeKind.U64:   { op = BinaryOp.LtU64; break; }\n      case TypeKind.Isize: { op = BinaryOp.LtISize; break; }\n      case TypeKind.Usize: { op = BinaryOp.LtUSize; break; }\n      case TypeKind.F32: return module.binary(BinaryOp.MinF32, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.MinF64, arg0, arg1);\n    }\n    if (op as i32 != -1) {\n      let flow = compiler.currentFlow;\n      let typeRef = type.toRef();\n      let temp1 = flow.getTempLocal(type);\n      flow.setLocalFlag(temp1.index, LocalFlags.Wrapped);\n      let temp2 = flow.getTempLocal(type);\n      flow.setLocalFlag(temp2.index, LocalFlags.Wrapped);\n      let ret = module.select(\n        module.local_tee(temp1.index, arg0, false), // numeric\n        module.local_tee(temp2.index, arg1, false), // numeric\n        module.binary(op,\n          module.local_get(temp1.index, typeRef),\n          module.local_get(temp2.index, typeRef)\n        )\n      );\n      return ret;\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"min\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.min, builtin_min);\n\n// ceil<T?>(value: T) -> T\nfunction builtin_ceil(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.None);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.Isize:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.Usize: return arg0; // considered rounded\n      case TypeKind.F32: return module.unary(UnaryOp.CeilF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.CeilF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"ceil\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.ceil, builtin_ceil);\n\n// floor<T?>(value: T) -> T\nfunction builtin_floor(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.None);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.Isize:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.Usize: return arg0; // considered rounded\n      case TypeKind.F32: return module.unary(UnaryOp.FloorF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.FloorF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"floor\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.floor, builtin_floor);\n\n// copysign<T?>(left: T, right: T) -> T\nfunction builtin_copysign(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit)\n    : compiler.compileExpression(operands[0], Type.f64, Constraints.None);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1 = compiler.compileExpression(operands[1], type, Constraints.ConvImplicit);\n    switch (type.kind) {\n      // TODO: does an integer version make sense?\n      case TypeKind.F32: return module.binary(BinaryOp.CopysignF32, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.CopysignF64, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"copysign\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.copysign, builtin_copysign);\n\n// nearest<T?>(value: T) -> T\nfunction builtin_nearest(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.None);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.Isize:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.Usize: return arg0;\n      case TypeKind.F32: return module.unary(UnaryOp.NearestF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.NearestF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"nearest\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.nearest, builtin_nearest);\n\n// reinterpret<T!>(value: *) -> T\nfunction builtin_reinterpret(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeRequired(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let type = typeArguments![0];\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        let arg0 = compiler.compileExpression(operands[0], Type.f32, Constraints.ConvImplicit);\n        compiler.currentType = type;\n        return module.unary(UnaryOp.ReinterpretF32ToI32, arg0);\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        let arg0 = compiler.compileExpression(operands[0], Type.f64, Constraints.ConvImplicit);\n        compiler.currentType = type;\n        return module.unary(UnaryOp.ReinterpretF64ToI64, arg0);\n      }\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        let isWasm64 = compiler.options.isWasm64;\n        let arg0 = compiler.compileExpression(operands[0],\n          isWasm64 ? Type.f64 : Type.f32,\n          Constraints.ConvImplicit\n        );\n        compiler.currentType = type;\n        return module.unary(\n          isWasm64\n            ? UnaryOp.ReinterpretF64ToI64\n            : UnaryOp.ReinterpretF32ToI32,\n          arg0\n        );\n      }\n      case TypeKind.F32: {\n        let arg0 = compiler.compileExpression(operands[0], Type.i32, Constraints.ConvImplicit);\n        compiler.currentType = Type.f32;\n        return module.unary(UnaryOp.ReinterpretI32ToF32, arg0);\n      }\n      case TypeKind.F64: {\n        let arg0 = compiler.compileExpression(operands[0], Type.i64, Constraints.ConvImplicit);\n        compiler.currentType = Type.f64;\n        return module.unary(UnaryOp.ReinterpretI64ToF64, arg0);\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"reinterpret\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.reinterpret, builtin_reinterpret);\n\n// sqrt<T?>(value: T) -> T\nfunction builtin_sqrt(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit)\n    : compiler.compileExpression(operands[0], Type.f64, Constraints.None);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      // TODO: integer versions (that return f64 or convert)?\n      case TypeKind.F32: return module.unary(UnaryOp.SqrtF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.SqrtF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"sqrt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.sqrt, builtin_sqrt);\n\n// trunc<T?>(value: T) -> T\nfunction builtin_trunc(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.None);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.Isize:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.Usize: return arg0; // considered truncated\n      case TypeKind.F32: return module.unary(UnaryOp.TruncF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.TruncF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"trunc\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.trunc, builtin_trunc);\n\n// isNaN<T?>(value: T) -> bool\nfunction builtin_isNaN(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.bool;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit)\n    : compiler.compileExpression(operands[0], Type.auto);\n  let type = compiler.currentType;\n  compiler.currentType = Type.bool;\n  if (type.isValue) {\n    switch (type.kind) {\n      // never NaN\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.Isize:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.Usize: {\n        return module.maybeDropCondition(arg0, module.i32(0));\n      }\n      // (t = arg0) != t\n      case TypeKind.F32: {\n        if (getExpressionId(arg0) == ExpressionId.LocalGet) {\n          return module.binary(BinaryOp.NeF32,\n            arg0,\n            module.local_get(getLocalGetIndex(arg0), TypeRef.F32)\n          );\n        }\n        let flow = compiler.currentFlow;\n        let temp = flow.getTempLocal(Type.f32);\n        let ret = module.binary(BinaryOp.NeF32,\n          module.local_tee(temp.index, arg0, false), // f32\n          module.local_get(temp.index, TypeRef.F32)\n        );\n        return ret;\n      }\n      case TypeKind.F64: {\n        if (getExpressionId(arg0) == ExpressionId.LocalGet) {\n          return module.binary(BinaryOp.NeF64,\n            arg0,\n            module.local_get(getLocalGetIndex(arg0), TypeRef.F64)\n          );\n        }\n        let flow = compiler.currentFlow;\n        let temp = flow.getTempLocal(Type.f64);\n        let ret = module.binary(BinaryOp.NeF64,\n          module.local_tee(temp.index, arg0, false), // f64\n          module.local_get(temp.index, TypeRef.F64)\n        );\n        return ret;\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"isNaN\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.isNaN, builtin_isNaN);\n\n// isFinite<T?>(value: T) -> bool\nfunction builtin_isFinite(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.bool;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit)\n    : compiler.compileExpression(operands[0], Type.auto);\n  let type = compiler.currentType;\n  compiler.currentType = Type.bool;\n  if (type.isValue) {\n    switch (type.kind) {\n      // always finite\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.Isize:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.Usize: {\n        return module.maybeDropCondition(arg0, module.i32(1));\n      }\n      // (t = arg0) - t == 0\n      case TypeKind.F32: {\n        if (getExpressionId(arg0) == ExpressionId.LocalGet) {\n          return module.binary(BinaryOp.EqF32,\n            module.binary(BinaryOp.SubF32,\n              arg0,\n              module.local_get(getLocalGetIndex(arg0), TypeRef.F32)\n            ),\n            module.f32(0)\n          );\n        }\n        let flow = compiler.currentFlow;\n        let temp = flow.getTempLocal(Type.f32);\n        let ret = module.binary(BinaryOp.EqF32,\n          module.binary(BinaryOp.SubF32,\n            module.local_tee(temp.index, arg0, false), // f32\n            module.local_get(temp.index, TypeRef.F32)\n          ),\n          module.f32(0)\n        );\n        return ret;\n      }\n      case TypeKind.F64: {\n        if (getExpressionId(arg0) == ExpressionId.LocalGet) {\n          return module.binary(BinaryOp.EqF64,\n            module.binary(BinaryOp.SubF64,\n              arg0,\n              module.local_get(getLocalGetIndex(arg0), TypeRef.F64)\n            ),\n            module.f64(0)\n          );\n        }\n        let flow = compiler.currentFlow;\n        let temp = flow.getTempLocal(Type.f64);\n        let ret = module.binary(BinaryOp.EqF64,\n          module.binary(BinaryOp.SubF64,\n            module.local_tee(temp.index, arg0, false), // f64\n            module.local_get(temp.index, TypeRef.F64)\n          ),\n          module.f64(0)\n        );\n        return ret;\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"isFinite\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.isFinite, builtin_isFinite);\n\n// === Memory access ==========================================================================\n\n// __heap_base\nfunction builtin_heap_base_compile(ctx: BuiltinVariableContext): void {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let element = ctx.element;\n  let type = element.type;\n  compiler.runtimeFeatures |= RuntimeFeatures.Heap;\n  module.addGlobal(element.internalName, type.toRef(), true, compiler.makeZero(type)); // dummy\n}\nbuiltinVariables_onCompile.set(BuiltinNames.heap_base, builtin_heap_base_compile);\n\n// __heap_base -> usize\nfunction builtin_heap_base_access(ctx: BuiltinVariableContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let element = ctx.element;\n  let type = element.type;\n  compiler.runtimeFeatures |= RuntimeFeatures.Heap;\n  compiler.currentType = type;\n  return module.global_get(element.internalName, type.toRef());\n}\nbuiltinVariables_onAccess.set(BuiltinNames.heap_base, builtin_heap_base_access);\n\n// __data_end\nfunction builtin_data_end_compile(ctx: BuiltinVariableContext): void {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let element = ctx.element;\n  let type = element.type;\n  compiler.runtimeFeatures |= RuntimeFeatures.Data;\n  module.addGlobal(element.internalName, type.toRef(), true, compiler.makeZero(type)); // dummy\n}\nbuiltinVariables_onCompile.set(BuiltinNames.data_end, builtin_data_end_compile);\n\n// __data_end -> usize\nfunction builtin_data_end_access(ctx: BuiltinVariableContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let element = ctx.element;\n  let type = element.type;\n  compiler.runtimeFeatures |= RuntimeFeatures.Data;\n  compiler.currentType = type;\n  return module.global_get(element.internalName, type.toRef());\n}\nbuiltinVariables_onAccess.set(BuiltinNames.data_end, builtin_data_end_access);\n\n// __stack_pointer\nfunction builtin_stack_pointer_compile(ctx: BuiltinVariableContext): void {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let element = ctx.element;\n  let type = element.type;\n  compiler.runtimeFeatures |= RuntimeFeatures.Stack;\n  module.addGlobal(element.internalName, type.toRef(), true, compiler.makeZero(type)); // dummy\n}\nbuiltinVariables_onCompile.set(BuiltinNames.stack_pointer, builtin_stack_pointer_compile);\n\n// __stack_pointer -> usize\nfunction builtin_stack_pointer_access(ctx: BuiltinVariableContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let element = ctx.element;\n  let type = element.type;\n  compiler.runtimeFeatures |= RuntimeFeatures.Stack;\n  compiler.currentType = type;\n  return module.global_get(element.internalName, type.toRef());\n}\nbuiltinVariables_onAccess.set(BuiltinNames.stack_pointer, builtin_stack_pointer_access);\n\n// __rtti_base\nfunction builtin_rtti_base_compile(ctx: BuiltinVariableContext): void {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let element = ctx.element;\n  let type = element.type;\n  compiler.runtimeFeatures |= RuntimeFeatures.Rtti;\n  module.addGlobal(element.internalName, type.toRef(), true, compiler.makeZero(type)); // dummy\n}\nbuiltinVariables_onCompile.set(BuiltinNames.rtti_base, builtin_rtti_base_compile);\n\n// __rtti_base -> usize\nfunction builtin_rtti_base_access(ctx: BuiltinVariableContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let element = ctx.element;\n  let type = element.type;\n  compiler.runtimeFeatures |= RuntimeFeatures.Rtti;\n  compiler.currentType = type;\n  return module.global_get(element.internalName, type.toRef());\n}\nbuiltinVariables_onAccess.set(BuiltinNames.rtti_base, builtin_rtti_base_access);\n\n// load<T!>(offset: usize, immOffset?: usize, immAlign?: usize) -> T*\nfunction builtin_load(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 1, 3)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let contextualType = ctx.contextualType;\n  let type = typeArguments![0];\n\n  let outType = (\n    contextualType != Type.auto &&\n    type.isIntegerValue &&\n    contextualType.isIntegerValue &&\n    contextualType.size > type.size\n  ) ? contextualType : type;\n\n  if (!outType.isMemory) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"load\", outType.toString()\n    );\n    compiler.currentType = Type.void;\n    return module.unreachable();\n  }\n\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let numOperands = operands.length;\n  let immOffset = 0;\n  let immAlign = type.byteSize;\n  if (numOperands >= 2) {\n    immOffset = evaluateImmediateOffset(operands[1], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = outType;\n      return module.unreachable();\n    }\n    if (numOperands == 3) {\n      immAlign = evaluateImmediateAlign(operands[2], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = outType;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = outType;\n  return module.load(\n    type.byteSize,\n    type.isSignedIntegerValue,\n    arg0,\n    outType.toRef(),\n    immOffset,\n    immAlign\n  );\n}\nbuiltinFunctions.set(BuiltinNames.load, builtin_load);\n\n// store<T!>(ptr: usize, value: T*, immOffset?: usize, immAlign?: usize) -> void\nfunction builtin_store(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = Type.void;\n  if (\n    checkTypeRequired(ctx) |\n    checkArgsOptional(ctx, 2, 4)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let numOperands = operands.length;\n  let typeArguments = ctx.typeArguments;\n  let contextualType = ctx.contextualType;\n  let type = typeArguments![0];\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let arg1 = ctx.contextIsExact\n    ? compiler.compileExpression(operands[1],\n        contextualType,\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(\n        operands[1],\n        type,\n        type.isIntegerValue\n          ? Constraints.None // no need to convert to small int (but now might result in a float)\n          : Constraints.ConvImplicit\n      );\n  let inType = compiler.currentType;\n  if (!inType.isMemory) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"store\", inType.toString()\n    );\n    compiler.currentType = Type.void;\n    return module.unreachable();\n  }\n  if (\n    type.isIntegerValue &&\n    (\n      !inType.isIntegerValue || // float to int\n      inType.size < type.size   // int to larger int (clear garbage bits)\n    )\n  ) {\n    // either conversion or memory operation clears garbage bits\n    arg1 = compiler.convertExpression(arg1, inType, type, false, operands[1]);\n    inType = type;\n  }\n  let immOffset = 0;\n  let immAlign = type.byteSize;\n  if (numOperands >= 3) {\n    immOffset = evaluateImmediateOffset(operands[2], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.void;\n      return module.unreachable();\n    }\n    if (numOperands == 4) {\n      immAlign = evaluateImmediateAlign(operands[3], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.void;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.void;\n  return module.store(type.byteSize, arg0, arg1, inType.toRef(), immOffset, immAlign);\n}\nbuiltinFunctions.set(BuiltinNames.store, builtin_store);\n\n// rem<T?>(left: T, right: T) -> T\nfunction builtin_rem(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let left = operands[0];\n  let arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  let type = compiler.currentType;\n  if (type.isIntegerValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.ConvImplicit\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.ConvImplicit\n      );\n    }\n    if (type.isIntegerValue) {\n      return compiler.makeRem(arg0, arg1, type, ctx.reportNode);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"rem\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.rem, builtin_rem);\n\n// add<T?>(left: T, right: T) -> T\nfunction builtin_add(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let left = operands[0];\n  let arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.ConvImplicit\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.ConvImplicit\n      );\n    }\n    if (type.isNumericValue) {\n      return compiler.makeAdd(arg0, arg1, type);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"add\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.add, builtin_add);\n\n// sub<T?>(left: T, right: T) -> T\nfunction builtin_sub(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let left = operands[0];\n  let arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.ConvImplicit\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.ConvImplicit\n      );\n    }\n    if (type.isNumericValue) {\n      return compiler.makeSub(arg0, arg1, type);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"sub\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.sub, builtin_sub);\n\n// mul<T?>(left: T, right: T) -> T\nfunction builtin_mul(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let left = operands[0];\n  let arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.ConvImplicit\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.ConvImplicit\n      );\n    }\n    if (type.isNumericValue) {\n      return compiler.makeMul(arg0, arg1, type);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"mul\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.mul, builtin_mul);\n\n// div<T?>(left: T, right: T) -> T\nfunction builtin_div(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let left = operands[0];\n  let arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.ConvImplicit\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.ConvImplicit\n      );\n    }\n    if (type.isNumericValue) {\n      return compiler.makeDiv(arg0, arg1, type);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"div\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.div, builtin_div);\n\n// eq<T?>(left: T, right: T) -> i32\nfunction builtin_eq(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let left = operands[0];\n  let arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.ConvImplicit\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.ConvImplicit\n      );\n    }\n    if (type.isNumericValue) {\n      compiler.currentType = Type.i32;\n      return compiler.makeEq(arg0, arg1, type, ctx.reportNode);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"eq\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.eq, builtin_eq);\n\n// ne<T?>(left: T, right: T) -> i32\nfunction builtin_ne(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let left = operands[0];\n  let arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.ConvImplicit\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.ConvImplicit\n      );\n    }\n    if (type.isNumericValue) {\n      compiler.currentType = Type.i32;\n      return compiler.makeNe(arg0, arg1, type, ctx.reportNode);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"ne\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.ne, builtin_ne);\n\n// === Atomics ================================================================================\n\n// atomic.load<T!>(offset: usize, immOffset?: usize) -> T*\nfunction builtin_atomic_load(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Threads) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 1, 2)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let contextualType = ctx.contextualType;\n  let type = typeArguments![0];\n  let outType = (\n    type.isIntegerValue &&\n    contextualType.isIntegerValue &&\n    contextualType.size > type.size\n  ) ? contextualType : type;\n  if (!type.isIntegerValue) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"atomic.load\", type.toString()\n    );\n    compiler.currentType = outType;\n    return module.unreachable();\n  }\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let immOffset = operands.length == 2 ? evaluateImmediateOffset(operands[1], compiler) : 0; // reports\n  if (immOffset < 0) {\n    compiler.currentType = outType;\n    return module.unreachable();\n  }\n  compiler.currentType = outType;\n  return module.atomic_load(\n    type.byteSize,\n    arg0,\n    outType.toRef(),\n    immOffset\n  );\n}\nbuiltinFunctions.set(BuiltinNames.atomic_load, builtin_atomic_load);\n\n// atomic.store<T!>(offset: usize, value: T*, immOffset?: usize) -> void\nfunction builtin_atomic_store(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Threads) |\n    checkTypeRequired(ctx) |\n    checkArgsOptional(ctx, 2, 3)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let contextualType = ctx.contextualType;\n  let type = typeArguments![0];\n  if (!type.isIntegerValue) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"atomic.store\", type.toString()\n    );\n    compiler.currentType = Type.void;\n    return module.unreachable();\n  }\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let arg1 = ctx.contextIsExact\n    ? compiler.compileExpression(\n        operands[1],\n        contextualType,\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(\n        operands[1],\n        type,\n        type.isIntegerValue\n          ? Constraints.None // no need to convert to small int (but now might result in a float)\n          : Constraints.ConvImplicit\n      );\n  let inType = compiler.currentType;\n  if (\n    type.isIntegerValue &&\n    (\n      !inType.isIntegerValue|| // float to int\n      inType.size < type.size  // int to larger int (clear garbage bits)\n    )\n  ) {\n    // either conversion or memory operation clears garbage bits\n    arg1 = compiler.convertExpression(arg1, inType, type, false, operands[1]);\n    inType = type;\n  }\n  let immOffset = operands.length == 3 ? evaluateImmediateOffset(operands[2], compiler) : 0; // reports\n  if (immOffset < 0) {\n    compiler.currentType = Type.void;\n    return module.unreachable();\n  }\n  compiler.currentType = Type.void;\n  return module.atomic_store(type.byteSize, arg0, arg1, inType.toRef(), immOffset);\n}\nbuiltinFunctions.set(BuiltinNames.atomic_store, builtin_atomic_store);\n\n// any_atomic_binary<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_binary(ctx: BuiltinFunctionContext, op: AtomicRMWOp, opName: string): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Threads) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 2, 3)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let contextualType = ctx.contextualType;\n  let type = typeArguments![0];\n  if (!type.isIntegerValue || type.size < 8) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, opName, type.toString()\n    );\n    return module.unreachable();\n  }\n  let arg0 = compiler.compileExpression(operands[0],\n    compiler.options.usizeType,\n    Constraints.ConvImplicit\n  );\n  let arg1 = ctx.contextIsExact\n    ? compiler.compileExpression(operands[1],\n        contextualType,\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(\n        operands[1],\n        type,\n        type.isIntegerValue\n          ? Constraints.None // no need to convert to small int (but now might result in a float)\n          : Constraints.ConvImplicit\n      );\n  let inType = compiler.currentType;\n  if (\n    type.isIntegerValue &&\n    (\n      !inType.isIntegerValue || // float to int\n      inType.size < type.size   // int to larger int (clear garbage bits)\n    )\n  ) {\n    // either conversion or memory operation clears garbage bits\n    arg1 = compiler.convertExpression(arg1, inType, type, false, operands[1]);\n    inType = type;\n  }\n  let immOffset = operands.length == 3 ? evaluateImmediateOffset(operands[2], compiler) : 0; // reports\n  if (immOffset < 0) {\n    compiler.currentType = inType;\n    return module.unreachable();\n  }\n  compiler.currentType = inType;\n  return module.atomic_rmw(op, type.byteSize, immOffset, arg0, arg1, inType.toRef());\n}\n\n// atomic.add<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_add(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Add, \"atomic.add\");\n}\nbuiltinFunctions.set(BuiltinNames.atomic_add, builtin_atomic_add);\n\n// atomic.sub<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_sub(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Sub, \"atomic.sub\");\n}\nbuiltinFunctions.set(BuiltinNames.atomic_sub, builtin_atomic_sub);\n\n// atomic.and<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_and(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.And, \"atomic.and\");\n}\nbuiltinFunctions.set(BuiltinNames.atomic_and, builtin_atomic_and);\n\n// atomic.or<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_or(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Or, \"atomic.or\");\n}\nbuiltinFunctions.set(BuiltinNames.atomic_or, builtin_atomic_or);\n\n// atomic.xor<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_xor(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Xor, \"atomic.xor\");\n}\nbuiltinFunctions.set(BuiltinNames.atomic_xor, builtin_atomic_xor);\n\n// atomic.xchg<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_xchg(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Xchg, \"atomic.xchg\");\n}\nbuiltinFunctions.set(BuiltinNames.atomic_xchg, builtin_atomic_xchg);\n\n// atomic.cmpxchg<T!>(ptr: usize, expected: T, replacement: T, off?: usize) -> T\nfunction builtin_atomic_cmpxchg(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Threads) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 3, 4)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let contextualType = ctx.contextualType;\n  let type = typeArguments![0];\n  if (!type.isIntegerValue || type.size < 8) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"atomic.cmpxchg\", type.toString()\n    );\n    return module.unreachable();\n  }\n  let arg0 = compiler.compileExpression(operands[0],\n    compiler.options.usizeType,\n    Constraints.ConvImplicit\n  );\n  let arg1 = ctx.contextIsExact\n    ? compiler.compileExpression(operands[1],\n        contextualType,\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(\n        operands[1],\n        type,\n        type.isIntegerValue\n          ? Constraints.None // no need to convert to small int (but now might result in a float)\n          : Constraints.ConvImplicit\n      );\n  let inType = compiler.currentType;\n  let arg2 = compiler.compileExpression(operands[2],\n    inType,\n    Constraints.ConvImplicit\n  );\n  if (\n    type.isIntegerValue &&\n    (\n      !inType.isIntegerValue || // float to int\n      inType.size < type.size   // int to larger int (clear garbage bits)\n    )\n  ) {\n    // either conversion or memory operation clears garbage bits\n    arg1 = compiler.convertExpression(arg1, inType, type, false, operands[1]);\n    arg2 = compiler.convertExpression(arg2, inType, type, false, operands[2]);\n    inType = type;\n  }\n  let immOffset = operands.length == 4 ? evaluateImmediateOffset(operands[3], compiler) : 0; // reports\n  if (immOffset < 0) {\n    compiler.currentType = inType;\n    return module.unreachable();\n  }\n  compiler.currentType = inType;\n  return module.atomic_cmpxchg(type.byteSize, immOffset, arg0, arg1, arg2, inType.toRef());\n}\nbuiltinFunctions.set(BuiltinNames.atomic_cmpxchg, builtin_atomic_cmpxchg);\n\n// atomic.wait<T!>(ptr: usize, expected: T, timeout?: i64) -> i32\nfunction builtin_atomic_wait(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Threads) |\n    checkTypeRequired(ctx) |\n    checkArgsOptional(ctx, 2, 3)\n  ) {\n    compiler.currentType = Type.i32;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let type = typeArguments![0];\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], type, Constraints.ConvImplicit);\n  let arg2 = operands.length == 3\n    ? compiler.compileExpression(operands[2], Type.i64, Constraints.ConvImplicit)\n    : module.i64(-1, -1); // Infinite timeout\n  compiler.currentType = Type.i32;\n  switch (type.kind) {\n    case TypeKind.I32:\n    case TypeKind.I64:\n    case TypeKind.Isize:\n    case TypeKind.U32:\n    case TypeKind.U64:\n    case TypeKind.Usize: return module.atomic_wait(arg0, arg1, arg2, type.toRef());\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"atomic.wait\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.atomic_wait, builtin_atomic_wait);\n\n// atomic.notify(ptr: usize, count?: i32) -> i32\nfunction builtin_atomic_notify(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Threads) |\n    checkTypeAbsent(ctx) |\n    checkArgsOptional(ctx, 1, 2)\n  ) {\n    compiler.currentType = Type.i32;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let arg1 = operands.length == 2\n    ? compiler.compileExpression(operands[1], Type.i32, Constraints.ConvImplicit)\n    : module.i32(-1); // Inifinity count of waiters\n  compiler.currentType = Type.i32;\n  return module.atomic_notify(arg0, arg1);\n}\nbuiltinFunctions.set(BuiltinNames.atomic_notify, builtin_atomic_notify);\n\n// atomic.fence() -> void\nfunction builtin_atomic_fence(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = Type.void;\n  if (\n    checkFeatureEnabled(ctx, Feature.Threads) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 0)\n  ) return module.unreachable();\n  return module.atomic_fence();\n}\nbuiltinFunctions.set(BuiltinNames.atomic_fence, builtin_atomic_fence);\n\n// === Control flow ===========================================================================\n\n// select<T?>(ifTrue: T, ifFalse: T, condition: bool) -> T\nfunction builtin_select(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 3)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit)\n    : compiler.compileExpression(operands[0], Type.auto);\n  let type = compiler.currentType;\n  if (!type.isAny(TypeFlags.Value | TypeFlags.Reference)) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"select\", type.toString()\n    );\n    return module.unreachable();\n  }\n  let arg1 = compiler.compileExpression(operands[1], type, Constraints.ConvImplicit);\n  let arg2 = compiler.makeIsTrueish(\n    compiler.compileExpression(operands[2], Type.bool),\n    compiler.currentType, // ^\n    operands[2]\n  );\n  compiler.currentType = type;\n  return module.select(arg0, arg1, arg2);\n}\nbuiltinFunctions.set(BuiltinNames.select, builtin_select);\n\n// unreachable() -> *\nfunction builtin_unreachable(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  checkArgsRequired(ctx, 0);\n  return ctx.compiler.module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.unreachable, builtin_unreachable);\n\n// === Memory =================================================================================\n\n// memory.size() -> i32\nfunction builtin_memory_size(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = Type.i32;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 0)\n  ) return module.unreachable();\n  return module.memory_size();\n}\nbuiltinFunctions.set(BuiltinNames.memory_size, builtin_memory_size);\n\n// memory.grow(pages: i32) -> i32\nfunction builtin_memory_grow(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = Type.i32;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  return module.memory_grow(compiler.compileExpression(ctx.operands[0], Type.i32, Constraints.ConvImplicit));\n}\nbuiltinFunctions.set(BuiltinNames.memory_grow, builtin_memory_grow);\n\n// memory.copy(dest: usize, src: usize: n: usize) -> void\nfunction builtin_memory_copy(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = Type.void;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  if (!compiler.options.hasFeature(Feature.BulkMemory)) {\n    // use stdlib alternative if not supported\n    let instance = compiler.resolver.resolveFunction(ctx.prototype, null); // reports\n    compiler.currentType = Type.void;\n    if (!instance || !compiler.compileFunction(instance, true)) return module.unreachable();\n    return compiler.compileCallDirect(instance, operands, ctx.reportNode);\n  }\n  let usizeType = compiler.options.usizeType;\n  let arg0 = compiler.compileExpression(operands[0], usizeType, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], usizeType, Constraints.ConvImplicit);\n  let arg2 = compiler.compileExpression(operands[2], usizeType, Constraints.ConvImplicit);\n  compiler.currentType = Type.void;\n  return module.memory_copy(arg0, arg1, arg2);\n}\nbuiltinFunctions.set(BuiltinNames.memory_copy, builtin_memory_copy);\n\n// memory.fill(dest: usize, value: u8, n: usize) -> void\nfunction builtin_memory_fill(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = Type.void;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  if (!compiler.options.hasFeature(Feature.BulkMemory)) {\n    // use stdlib alternative if not supported\n    let instance = compiler.resolver.resolveFunction(ctx.prototype, null); // reports\n    compiler.currentType = Type.void;\n    if (!instance || !compiler.compileFunction(instance, true)) return module.unreachable();\n    return compiler.compileCallDirect(instance, operands, ctx.reportNode);\n  }\n  let usizeType = compiler.options.usizeType;\n  let arg0 = compiler.compileExpression(operands[0], usizeType, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.u8, Constraints.ConvImplicit);\n  let arg2 = compiler.compileExpression(operands[2], usizeType, Constraints.ConvImplicit);\n  compiler.currentType = Type.void;\n  return module.memory_fill(arg0, arg1, arg2);\n}\nbuiltinFunctions.set(BuiltinNames.memory_fill, builtin_memory_fill);\n\n// memory.data(size[, align]) -> usize\n// memory.data<T>(values[, align]) -> usize\nfunction builtin_memory_data(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = Type.i32;\n  if (\n    checkTypeOptional(ctx) |\n    checkArgsOptional(ctx, 1, 2)\n  ) return module.unreachable();\n  let typeArguments = ctx.typeArguments;\n  let operands = ctx.operands;\n  let numOperands = operands.length;\n  let usizeType = compiler.options.usizeType;\n  let offset: i64;\n  if (typeArguments && typeArguments.length > 0) { // data<T>(values[, align])\n    let elementType = typeArguments[0];\n    if (!elementType.isValue) {\n      compiler.error(\n        DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n        ctx.reportNode.typeArgumentsRange, \"memory.data\", elementType.toString()\n      );\n      compiler.currentType = usizeType;\n      return module.unreachable();\n    }\n    let valuesOperand = operands[0];\n    if (valuesOperand.kind != NodeKind.Literal || (<LiteralExpression>valuesOperand).literalKind != LiteralKind.Array) {\n      compiler.error(\n        DiagnosticCode.Array_literal_expected,\n        operands[0].range\n      );\n      compiler.currentType = usizeType;\n      return module.unreachable();\n    }\n    let expressions = (<ArrayLiteralExpression>valuesOperand).elementExpressions;\n    let numElements = expressions.length;\n    let exprs = new Array<ExpressionRef>(numElements);\n    let isStatic = true;\n    for (let i = 0; i < numElements; ++i) {\n      let elementExpression = expressions[i];\n      if (elementExpression.kind != NodeKind.Omitted) {\n        let expr = compiler.compileExpression(elementExpression, elementType, Constraints.ConvImplicit);\n        let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n        if (precomp) {\n          expr = precomp;\n        } else {\n          isStatic = false;\n        }\n        exprs[i] = expr;\n      } else {\n        exprs[i] = compiler.makeZero(elementType);\n      }\n    }\n    if (!isStatic) {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        valuesOperand.range\n      );\n      compiler.currentType = usizeType;\n      return module.unreachable();\n    }\n    let align = elementType.byteSize;\n    if (numOperands == 2) {\n      align = evaluateImmediateAlign(operands[1], align, compiler); // reports\n      if (align < 0) {\n        compiler.currentType = usizeType;\n        return module.unreachable();\n      }\n    }\n    let buf = new Uint8Array(numElements * elementType.byteSize);\n    assert(compiler.writeStaticBuffer(buf, 0, elementType, exprs) == buf.byteLength);\n    offset = compiler.addAlignedMemorySegment(buf, align).offset;\n  } else { // data(size[, align])\n    let arg0 = compiler.compileExpression(operands[0], Type.i32, Constraints.ConvImplicit);\n    let precomp = module.runExpression(arg0, ExpressionRunnerFlags.PreserveSideeffects);\n    if (!precomp) {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        operands[0].range\n      );\n      compiler.currentType = usizeType;\n      return module.unreachable();\n    }\n    let size = getConstValueI32(precomp);\n    if (size < 1) {\n      compiler.error(\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n        operands[0].range, \"1\", i32.MAX_VALUE.toString()\n      );\n      compiler.currentType = usizeType;\n      return module.unreachable();\n    }\n    let align = 16;\n    if (numOperands == 2) {\n      align = evaluateImmediateAlign(operands[1], align, compiler); // reports\n      if (align < 0) {\n        compiler.currentType = usizeType;\n        return module.unreachable();\n      }\n    }\n    offset = compiler.addAlignedMemorySegment(new Uint8Array(size), align).offset;\n  }\n  // FIXME: what if recompiles happen? recompiles are bad.\n  compiler.currentType = usizeType;\n  if (usizeType == Type.usize32) {\n    assert(!i64_high(offset));\n    return module.i32(i64_low(offset));\n  } else {\n    return module.i64(i64_low(offset), i64_high(offset));\n  }\n}\nbuiltinFunctions.set(BuiltinNames.memory_data, builtin_memory_data);\n\n// === GC =====================================================================================\n\nfunction builtin_i31_new(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], Type.i32, Constraints.ConvImplicit);\n  compiler.currentType = Type.i31;\n  return module.i31_new(arg0);\n}\nbuiltinFunctions.set(BuiltinNames.i31_new, builtin_i31_new);\n\nfunction builtin_i31_get(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], Type.i31.asNullable(), Constraints.ConvImplicit);\n  if (ctx.contextualType.is(TypeFlags.Unsigned)) {\n    compiler.currentType = Type.u32;\n    return module.i31_get(arg0, false);\n  } else {\n    compiler.currentType = Type.i32;\n    return module.i31_get(arg0, true);\n  }\n}\nbuiltinFunctions.set(BuiltinNames.i31_get, builtin_i31_get);\n\n// === Helpers ================================================================================\n\n// changetype<T!>(value: *) -> T\nfunction builtin_changetype(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeRequired(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let toType = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.auto);\n  let fromType = compiler.currentType;\n  compiler.currentType = toType;\n  if (!fromType.isChangeableTo(toType)) {\n    compiler.error(\n      DiagnosticCode.Type_0_cannot_be_changed_to_type_1,\n      ctx.reportNode.range, fromType.toString(), toType.toString()\n    );\n    return module.unreachable();\n  }\n  return arg0;\n}\nbuiltinFunctions.set(BuiltinNames.changetype, builtin_changetype);\n\n// assert<T?>(isTrueish: T, message?: string) -> T{!= null}\nfunction builtin_assert(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let typeArguments = ctx.typeArguments;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsOptional(ctx, 1, 2)\n  ) {\n    if (typeArguments) {\n      assert(typeArguments.length); // otherwise invalid, should not been set at all\n      compiler.currentType = typeArguments[0].nonNullableType;\n    }\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let contextualType = ctx.contextualType;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit | Constraints.MustWrap)\n    : compiler.compileExpression(operands[0], Type.bool, Constraints.MustWrap);\n  let type = compiler.currentType;\n  compiler.currentType = type.nonNullableType;\n\n  // omit if assertions are disabled\n  if (compiler.options.noAssert) {\n    return arg0;\n  }\n\n  // omit if the assertion can be proven statically\n  let evaled = module.runExpression(arg0, ExpressionRunnerFlags.Default);\n  if (evaled) {\n    switch (<u32>getExpressionType(evaled)) {\n      case <u32>TypeRef.I32: {\n        if (getConstValueI32(evaled)) {\n          return arg0;\n        }\n        break;\n      }\n      case <u32>TypeRef.I64: {\n        if (getConstValueI64Low(evaled) | getConstValueI64High(evaled)) {\n          return arg0;\n        }\n        break;\n      }\n      case <u32>TypeRef.F32: {\n        if (getConstValueF32(evaled)) {\n          return arg0;\n        }\n        break;\n      }\n      case <u32>TypeRef.F64: {\n        if (getConstValueF64(evaled)) {\n          return arg0;\n        }\n        break;\n      }\n    }\n  }\n\n  // otherwise call abort if the assertion is false-ish\n  let abort = compiler.makeAbort(operands.length == 2 ? operands[1] : null, ctx.reportNode);\n  compiler.currentType = type.nonNullableType;\n  if (contextualType == Type.void) { // simplify if dropped anyway\n    compiler.currentType = Type.void;\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32: return module.if(module.unary(UnaryOp.EqzI32, arg0), abort);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.if(module.unary(UnaryOp.EqzI64, arg0), abort);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.if(module.unary(UnaryOp.EqzSize, arg0), abort);\n      // TODO: also check for NaN in float assertions, as in `Boolean(NaN) -> false`?\n      case TypeKind.F32: return module.if(module.binary(BinaryOp.EqF32, arg0, module.f32(0)), abort);\n      case TypeKind.F64: return module.if(module.binary(BinaryOp.EqF64, arg0, module.f64(0)), abort);\n      case TypeKind.Func:\n      case TypeKind.Extern:\n      case TypeKind.Any:\n      case TypeKind.Eq:\n      case TypeKind.Struct:\n      case TypeKind.Array:\n      case TypeKind.I31:\n      case TypeKind.String:\n      case TypeKind.StringviewWTF8:\n      case TypeKind.StringviewWTF16:\n      case TypeKind.StringviewIter: return module.if(module.ref_is_null(arg0), abort);\n    }\n  } else {\n    compiler.currentType = type.nonNullableType;\n    let flow = compiler.currentFlow;\n    switch (compiler.currentType.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32: {\n        let temp = flow.getTempLocal(type);\n        flow.setLocalFlag(temp.index, LocalFlags.Wrapped); // arg0 is wrapped\n        let ret = module.if(\n          module.local_tee(temp.index, arg0, false), // numeric\n          module.local_get(temp.index, TypeRef.I32),\n          abort\n        );\n        return ret;\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        let temp = flow.getTempLocal(Type.i64);\n        let ret = module.if(\n          module.unary(UnaryOp.EqzI64,\n            module.local_tee(temp.index, arg0, false) // i64\n          ),\n          abort,\n          module.local_get(temp.index, TypeRef.I64)\n        );\n        return ret;\n      }\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        let temp = flow.getTempLocal(compiler.options.usizeType);\n        let ret = module.if(\n          module.unary(\n            UnaryOp.EqzSize,\n            module.local_tee(temp.index, arg0, type.isManaged)\n          ),\n          abort,\n          module.local_get(temp.index, compiler.options.sizeTypeRef)\n        );\n        return ret;\n      }\n      case TypeKind.F32: {\n        let temp = flow.getTempLocal(Type.f32);\n        let ret = module.if(\n          module.binary(BinaryOp.EqF32,\n            module.local_tee(temp.index, arg0, false), // f32\n            module.f32(0)\n          ),\n          abort,\n          module.local_get(temp.index, TypeRef.F32)\n        );\n        return ret;\n      }\n      case TypeKind.F64: {\n        let temp = flow.getTempLocal(Type.f64);\n        let ret = module.if(\n          module.binary(BinaryOp.EqF64,\n            module.local_tee(temp.index, arg0, false), // f64\n            module.f64(0)\n          ),\n          abort,\n          module.local_get(temp.index, TypeRef.F64)\n        );\n        return ret;\n      }\n      case TypeKind.Func:\n      case TypeKind.Extern:\n      case TypeKind.Any:\n      case TypeKind.Eq:\n      case TypeKind.Struct:\n      case TypeKind.Array:\n      case TypeKind.I31:\n      case TypeKind.String:\n      case TypeKind.StringviewWTF8:\n      case TypeKind.StringviewWTF16:\n      case TypeKind.StringviewIter: {\n        let temp = flow.getTempLocal(type);\n        let ret = module.if(\n          module.ref_is_null(\n            module.local_tee(temp.index, arg0, false) // ref\n          ),\n          abort,\n          module.local_get(temp.index, type.toRef())\n        );\n        return ret;\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"assert\", compiler.currentType.toString()\n  );\n  return abort;\n}\nbuiltinFunctions.set(BuiltinNames.assert, builtin_assert);\n\n// unchecked(expr: *) -> *\nfunction builtin_unchecked(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let flow = compiler.currentFlow;\n  let ignoreUnchecked = compiler.options.uncheckedBehavior === UncheckedBehavior.Never;\n  let alreadyUnchecked = flow.is(FlowFlags.UncheckedContext);\n  if (ignoreUnchecked) assert(!alreadyUnchecked);\n  else flow.set(FlowFlags.UncheckedContext);\n  // eliminate unnecessary tees by preferring contextualType(=void)\n  let expr = compiler.compileExpression(ctx.operands[0], ctx.contextualType);\n  if (!alreadyUnchecked) flow.unset(FlowFlags.UncheckedContext);\n  return expr;\n}\nbuiltinFunctions.set(BuiltinNames.unchecked, builtin_unchecked);\n\n// inline.always(expr: *) -> *\nfunction builtin_inline_always(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let flow = compiler.currentFlow;\n  let alreadyInline = flow.is(FlowFlags.InlineContext);\n  if (!alreadyInline) flow.set(FlowFlags.InlineContext);\n  // eliminate unnecessary tees by preferring contextualType(=void)\n  let expr = compiler.compileExpression(ctx.operands[0], ctx.contextualType);\n  if (!alreadyInline) flow.unset(FlowFlags.InlineContext);\n  return expr;\n}\nbuiltinFunctions.set(BuiltinNames.inline_always, builtin_inline_always);\n\n// call_indirect<T?>(index: u32, ...args: *[]) -> T\nfunction builtin_call_indirect(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsOptional(ctx, 1, i32.MAX_VALUE)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let returnType: Type;\n  if (typeArguments) {\n    assert(typeArguments.length);\n    returnType = typeArguments[0];\n  } else {\n    returnType = ctx.contextualType;\n  }\n  let indexArg = compiler.compileExpression(operands[0], Type.u32, Constraints.ConvImplicit);\n  let numOperands = operands.length - 1;\n  let operandExprs = new Array<ExpressionRef>(numOperands);\n  let paramTypeRefs = new Array<TypeRef>(numOperands);\n  for (let i = 0; i < numOperands; ++i) {\n    operandExprs[i] = compiler.compileExpression(operands[1 + i], Type.auto);\n    if (compiler.currentType.isManaged) {\n      operandExprs[i] = module.tostack(operandExprs[i]);\n    }\n    paramTypeRefs[i] = compiler.currentType.toRef();\n  }\n  compiler.currentType = returnType;\n  return module.call_indirect(null /* TODO */, indexArg, operandExprs, createType(paramTypeRefs), returnType.toRef());\n}\nbuiltinFunctions.set(BuiltinNames.call_indirect, builtin_call_indirect);\n\n// instantiate<T!>(...args: *[]) -> T\nfunction builtin_instantiate(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeRequired(ctx, true)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let typeArgument = typeArguments[0];\n  let classInstance = typeArgument.getClass();\n  if (!classInstance) {\n    compiler.error(\n      DiagnosticCode.This_expression_is_not_constructable,\n      ctx.reportNode.expression.range\n    );\n    return module.unreachable();\n  }\n  compiler.currentType = classInstance.type;\n  let ctor = compiler.ensureConstructor(classInstance, ctx.reportNode);\n  compiler.checkFieldInitialization(classInstance, ctx.reportNode);\n  return compiler.compileInstantiate(ctor, operands, Constraints.None, ctx.reportNode);\n}\nbuiltinFunctions.set(BuiltinNames.instantiate, builtin_instantiate);\n\n// === User-defined diagnostics ===============================================================\n\nfunction builtin_diagnostic(ctx: BuiltinFunctionContext, category: DiagnosticCategory): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  checkTypeAbsent(ctx);\n  let operands = ctx.operands;\n  let reportNode = ctx.reportNode;\n  compiler.emitDiagnostic(\n    DiagnosticCode.User_defined_0,\n    category,\n    reportNode.range,\n    null,\n    operands.length\n      ? operands[0].range.toString()\n      : reportNode.range.toString()\n  );\n  return category == DiagnosticCategory.Error\n    ? module.unreachable()\n    : module.nop();\n}\n\n// ERROR(message?)\nfunction builtin_error(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_diagnostic(ctx, DiagnosticCategory.Error);\n}\nbuiltinFunctions.set(BuiltinNames.ERROR, builtin_error);\n\n// WARNING(message?)\nfunction builtin_warning(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_diagnostic(ctx, DiagnosticCategory.Warning);\n}\nbuiltinFunctions.set(BuiltinNames.WARNING, builtin_warning);\n\n// INFO(message?)\nfunction builtin_info(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_diagnostic(ctx, DiagnosticCategory.Info);\n}\nbuiltinFunctions.set(BuiltinNames.INFO, builtin_info);\n\n// === Function builtins ======================================================================\n\n// Function<T>#call(thisArg: thisof<T> | null, ...args: *[]) -> returnof<T>\nfunction builtin_function_call(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let parent = ctx.prototype.parent;\n  assert(parent.kind == ElementKind.Class);\n  let classInstance = <Class>parent;\n  assert(classInstance.prototype == compiler.program.functionPrototype);\n  let typeArguments = assert(classInstance.typeArguments);\n  assert(typeArguments.length == 1);\n  let ftype = typeArguments[0];\n  let signature = assert(ftype.getSignature());\n  let returnType = signature.returnType;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsOptional(ctx, 1 + signature.requiredParameters, 1 + signature.parameterTypes.length)\n  ) {\n    compiler.currentType = returnType;\n    return compiler.module.unreachable();\n  }\n  let functionArg = compiler.compileExpression(assert(ctx.thisOperand), ftype, Constraints.ConvImplicit);\n  let thisOperand = assert(ctx.operands.shift());\n  let thisType = signature.thisType;\n  let thisArg: usize = 0;\n  if (thisType) {\n    thisArg = compiler.compileExpression(thisOperand, thisType, Constraints.ConvImplicit);\n  } else if (thisOperand.kind != NodeKind.Null) {\n    compiler.error(\n      DiagnosticCode._this_cannot_be_referenced_in_current_location,\n      thisOperand.range\n    );\n    return compiler.module.unreachable();\n  }\n  return compiler.compileCallIndirect(signature, functionArg, ctx.operands, ctx.reportNode, thisArg, ctx.contextualType == Type.void);\n}\nbuiltinFunctions.set(BuiltinNames.Function_call, builtin_function_call);\n\n// String.raw(parts: TemplateStringsArray, ...values: unknown[]): string\nfunction builtin_string_raw(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = ctx.compiler.program.stringInstance.type;\n  compiler.error(\n    DiagnosticCode.Not_implemented_0,\n    ctx.reportNode.range, \"String.raw\"\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.String_raw, builtin_string_raw);\n\n// === Portable type conversions ==============================================================\n\nfunction builtin_conversion(ctx: BuiltinFunctionContext, toType: Type): ExpressionRef {\n  let compiler = ctx.compiler;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = toType;\n    return compiler.module.unreachable();\n  }\n  return compiler.compileExpression(ctx.operands[0], toType, Constraints.ConvExplicit);\n}\n\n// i8(*) -> i8\nfunction builtin_i8(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.i8);\n}\nbuiltinFunctions.set(BuiltinNames.i8, builtin_i8);\n\n// i16(*) -> i16\nfunction builtin_i16(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.i16);\n}\nbuiltinFunctions.set(BuiltinNames.i16, builtin_i16);\n\n// i32(*) -> i32\nfunction builtin_i32(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.i32);\n}\nbuiltinFunctions.set(BuiltinNames.i32, builtin_i32);\n\n// i64(*) -> i64\nfunction builtin_i64(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.i64);\n}\nbuiltinFunctions.set(BuiltinNames.i64, builtin_i64);\n\n// isize(*) -> isize\nfunction builtin_isize(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_conversion(ctx, ctx.compiler.options.isizeType);\n}\nbuiltinFunctions.set(BuiltinNames.isize, builtin_isize);\n\n// u8(*) -> u8\nfunction builtin_u8(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.u8);\n}\nbuiltinFunctions.set(BuiltinNames.u8, builtin_u8);\n\n// u16(*) -> u16\nfunction builtin_u16(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.u16);\n}\nbuiltinFunctions.set(BuiltinNames.u16, builtin_u16);\n\n// u32(*) -> u32\nfunction builtin_u32(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.u32);\n}\nbuiltinFunctions.set(BuiltinNames.u32, builtin_u32);\n\n// u64(*) -> u64\nfunction builtin_u64(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.u64);\n}\nbuiltinFunctions.set(BuiltinNames.u64, builtin_u64);\n\n// usize(*) -> usize\nfunction builtin_usize(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_conversion(ctx, ctx.compiler.options.usizeType);\n}\nbuiltinFunctions.set(BuiltinNames.usize, builtin_usize);\n\n// bool(*) -> bool\nfunction builtin_bool(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.bool);\n}\nbuiltinFunctions.set(BuiltinNames.bool, builtin_bool);\n\n// f32(*) -> f32\nfunction builtin_f32(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.f32);\n}\nbuiltinFunctions.set(BuiltinNames.f32, builtin_f32);\n\n// f64(*) -> f64\nfunction builtin_f64(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.f64);\n}\nbuiltinFunctions.set(BuiltinNames.f64, builtin_f64);\n\n// TODO: alias for now, splat input integer perhaps?\nfunction builtin_v128(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_i8x16(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128, builtin_v128);\n\n// === SIMD ===================================================================================\n\n// i8x16(...values: i8[16]) -> v128\nfunction builtin_i8x16(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 16)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let bytes = new Uint8Array(16);\n  let vars  = new Array<ExpressionRef>(16);\n  let numVars = 0;\n\n  for (let i = 0; i < 16; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.i8, Constraints.ConvImplicit);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      writeI8(getConstValueI32(precomp), bytes, i);\n    } else {\n      vars[i] = expr;\n      numVars++;\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (numVars == 0) {\n    // all constants\n    return module.v128(bytes);\n  } else {\n    let vec: ExpressionRef;\n    let fullVars = numVars == 16;\n    if (fullVars) {\n      // all variants\n      vec = module.unary(UnaryOp.SplatI8x16, vars[0]);\n    } else {\n      // mixed constants / variants\n      vec = module.v128(bytes);\n    }\n    for (let i = i32(fullVars); i < 16; i++) {\n      let expr = vars[i];\n      if (expr) vec = module.simd_replace(SIMDReplaceOp.ReplaceLaneI8x16, vec, <u8>i, expr);\n    }\n    return vec;\n  }\n}\nbuiltinFunctions.set(BuiltinNames.i8x16, builtin_i8x16);\n\n// i16x8(...values: i16[8]) -> v128\nfunction builtin_i16x8(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 8)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let bytes = new Uint8Array(16);\n  let vars  = new Array<ExpressionRef>(8);\n  let numVars = 0;\n\n  for (let i = 0; i < 8; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.i16, Constraints.ConvImplicit);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      writeI16(getConstValueI32(precomp), bytes, i << 1);\n    } else {\n      vars[i] = expr;\n      numVars++;\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (numVars == 0) {\n    // all constants\n    return module.v128(bytes);\n  } else {\n    let vec: ExpressionRef;\n    let fullVars = numVars == 8;\n    if (fullVars) {\n      // all variants\n      vec = module.unary(UnaryOp.SplatI16x8, vars[0]);\n    } else {\n      // mixed constants / variants\n      vec = module.v128(bytes);\n    }\n    for (let i = i32(fullVars); i < 8; i++) {\n      let expr = vars[i];\n      if (expr) vec = module.simd_replace(SIMDReplaceOp.ReplaceLaneI16x8, vec, <u8>i, expr);\n    }\n    return vec;\n  }\n}\nbuiltinFunctions.set(BuiltinNames.i16x8, builtin_i16x8);\n\n// i32x4(...values: i32[4]) -> v128\nfunction builtin_i32x4(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 4)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let bytes = new Uint8Array(16);\n  let vars  = new Array<ExpressionRef>(4);\n  let numVars = 0;\n\n  for (let i = 0; i < 4; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.i32, Constraints.ConvImplicit);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      writeI32(getConstValueI32(precomp), bytes, i << 2);\n    } else {\n      vars[i] = expr;\n      numVars++;\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (numVars == 0) {\n    // all constants\n    return module.v128(bytes);\n  } else {\n    let vec: ExpressionRef;\n    let fullVars = numVars == 4;\n    if (fullVars) {\n      // all variants\n      vec = module.unary(UnaryOp.SplatI32x4, vars[0]);\n    } else {\n      // mixed constants / variants\n      vec = module.v128(bytes);\n    }\n    for (let i = i32(fullVars); i < 4; i++) {\n      let expr = vars[i];\n      if (expr) vec = module.simd_replace(SIMDReplaceOp.ReplaceLaneI32x4, vec, <u8>i, expr);\n    }\n    return vec;\n  }\n}\nbuiltinFunctions.set(BuiltinNames.i32x4, builtin_i32x4);\n\n// i64x2(...values: i64[2]) -> v128\nfunction builtin_i64x2(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let bytes = new Uint8Array(16);\n  let vars  = new Array<ExpressionRef>(2);\n  let numVars = 0;\n\n  for (let i = 0; i < 2; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.i64, Constraints.ConvImplicit);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      let off = i << 3;\n      writeI32(getConstValueI64Low(precomp),  bytes, off + 0);\n      writeI32(getConstValueI64High(precomp), bytes, off + 4);\n    } else {\n      vars[i] = expr;\n      numVars++;\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (numVars == 0) {\n    // all constants\n    return module.v128(bytes);\n  } else {\n    let vec: ExpressionRef;\n    let fullVars = numVars == 2;\n    if (fullVars) {\n      // all variants\n      vec = module.unary(UnaryOp.SplatI64x2, vars[0]);\n    } else {\n      // mixed constants / variants\n      vec = module.v128(bytes);\n    }\n    for (let i = i32(fullVars); i < 2; i++) {\n      let expr = vars[i];\n      if (expr) vec = module.simd_replace(SIMDReplaceOp.ReplaceLaneI64x2, vec, <u8>i, expr);\n    }\n    return vec;\n  }\n}\nbuiltinFunctions.set(BuiltinNames.i64x2, builtin_i64x2);\n\n// f32x4(...values: f32[4]) -> v128\nfunction builtin_f32x4(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 4)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let bytes = new Uint8Array(16);\n  let vars  = new Array<ExpressionRef>(4);\n  let numVars = 0;\n\n  for (let i = 0; i < 4; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.f32, Constraints.ConvImplicit);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      writeF32(getConstValueF32(precomp), bytes, i << 2);\n    } else {\n      vars[i] = expr;\n      numVars++;\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (numVars == 0) {\n    // all constants\n    return module.v128(bytes);\n  } else {\n    let vec: ExpressionRef;\n    let fullVars = numVars == 4;\n    if (fullVars) {\n      // all variants\n      vec = module.unary(UnaryOp.SplatF32x4, vars[0]);\n    } else {\n      // mixed constants / variants\n      vec = module.v128(bytes);\n    }\n    for (let i = i32(fullVars); i < 4; i++) {\n      let expr = vars[i];\n      if (expr) vec = module.simd_replace(SIMDReplaceOp.ReplaceLaneF32x4, vec, <u8>i, expr);\n    }\n    return vec;\n  }\n}\nbuiltinFunctions.set(BuiltinNames.f32x4, builtin_f32x4);\n\n// f64x2(...values: f64[2]) -> v128\nfunction builtin_f64x2(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let bytes = new Uint8Array(16);\n  let vars  = new Array<ExpressionRef>(2);\n  let numVars = 0;\n\n  for (let i = 0; i < 2; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.f64, Constraints.ConvImplicit);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      writeF64(getConstValueF64(precomp), bytes, i << 3);\n    } else {\n      vars[i] = expr;\n      numVars++;\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (numVars == 0) {\n    // all constants\n    return module.v128(bytes);\n  } else {\n    let vec: ExpressionRef;\n    let fullVars = numVars == 2;\n    if (fullVars) {\n      // all variants\n      vec = module.unary(UnaryOp.SplatF64x2, vars[0]);\n    } else {\n      // mixed constants / variants\n      vec = module.v128(bytes);\n    }\n    for (let i = i32(fullVars); i < 2; i++) {\n      let expr = vars[i];\n      if (expr) vec = module.simd_replace(SIMDReplaceOp.ReplaceLaneF64x2, vec, <u8>i, expr);\n    }\n    return vec;\n  }\n}\nbuiltinFunctions.set(BuiltinNames.f64x2, builtin_f64x2);\n\n// v128.splat<T!>(x: T) -> v128\nfunction builtin_v128_splat(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], type, Constraints.ConvImplicit);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.unary(UnaryOp.SplatI8x16, arg0);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.unary(UnaryOp.SplatI16x8, arg0);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.SplatI32x4, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.SplatI64x2, arg0);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.SplatI64x2\n            : UnaryOp.SplatI32x4,\n          arg0\n        );\n      }\n      case TypeKind.F32: return module.unary(UnaryOp.SplatF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.SplatF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.splat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_splat, builtin_v128_splat);\n\n// v128.extract_lane<T!>(x: v128, idx: u8) -> T\nfunction builtin_v128_extract_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.u8, Constraints.ConvImplicit);\n  compiler.currentType = type;\n  let idx = 0;\n  let precomp = module.runExpression(arg1, ExpressionRunnerFlags.PreserveSideeffects);\n  if (precomp) {\n    idx = getConstValueI32(precomp);\n  } else {\n    compiler.error(\n      DiagnosticCode.Expression_must_be_a_compile_time_constant,\n      operands[1].range\n    );\n  }\n  if (type.isValue) {\n    let maxIdx = (16 / assert(type.byteSize)) - 1;\n    if (idx < 0 || idx > maxIdx) {\n      compiler.error(\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n        operands[1].range, \"Lane index\", \"0\", maxIdx.toString()\n      );\n      idx = 0;\n    }\n    switch (type.kind) {\n      case TypeKind.I8: return module.simd_extract(SIMDExtractOp.ExtractLaneI8x16, arg0, <u8>idx);\n      case TypeKind.U8: return module.simd_extract(SIMDExtractOp.ExtractLaneU8x16, arg0, <u8>idx);\n      case TypeKind.I16: return module.simd_extract(SIMDExtractOp.ExtractLaneI16x8, arg0, <u8>idx);\n      case TypeKind.U16: return module.simd_extract(SIMDExtractOp.ExtractLaneU16x8, arg0, <u8>idx);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.simd_extract(SIMDExtractOp.ExtractLaneI32x4, arg0, <u8>idx);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.simd_extract(SIMDExtractOp.ExtractLaneI64x2, arg0, <u8>idx);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.simd_extract(\n          compiler.options.isWasm64\n            ? SIMDExtractOp.ExtractLaneI64x2\n            : SIMDExtractOp.ExtractLaneI32x4,\n          arg0, <u8>idx\n        );\n      }\n      case TypeKind.F32: return module.simd_extract(SIMDExtractOp.ExtractLaneF32x4, arg0, <u8>idx);\n      case TypeKind.F64: return module.simd_extract(SIMDExtractOp.ExtractLaneF64x2, arg0, <u8>idx);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.extract_lane\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_extract_lane, builtin_v128_extract_lane);\n\n// v128.replace_lane<T!>(x: v128, idx: u8, value: T) -> v128\nfunction builtin_v128_replace_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.u8, Constraints.ConvImplicit);\n  let arg2 = compiler.compileExpression(operands[2], type, Constraints.ConvImplicit);\n  compiler.currentType = Type.v128;\n  let idx = 0;\n  let precomp = module.runExpression(arg1, ExpressionRunnerFlags.PreserveSideeffects);\n  if (precomp) {\n    idx = getConstValueI32(precomp);\n  } else {\n    compiler.error(\n      DiagnosticCode.Expression_must_be_a_compile_time_constant,\n      operands[1].range\n    );\n  }\n  if (type.isValue) {\n    let maxIdx = (16 / assert(type.byteSize)) - 1;\n    if (idx < 0 || idx > maxIdx) {\n      compiler.error(\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n        operands[1].range, \"Lane index\", \"0\", maxIdx.toString()\n      );\n      idx = 0;\n    }\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.simd_replace(SIMDReplaceOp.ReplaceLaneI8x16, arg0, <u8>idx, arg2);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.simd_replace(SIMDReplaceOp.ReplaceLaneI16x8, arg0, <u8>idx, arg2);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.simd_replace(SIMDReplaceOp.ReplaceLaneI32x4, arg0, <u8>idx, arg2);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.simd_replace(SIMDReplaceOp.ReplaceLaneI64x2, arg0, <u8>idx, arg2);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.simd_replace(\n          compiler.options.isWasm64\n            ? SIMDReplaceOp.ReplaceLaneI64x2\n            : SIMDReplaceOp.ReplaceLaneI32x4,\n          arg0, <u8>idx, arg2\n        );\n      }\n      case TypeKind.F32: return module.simd_replace(SIMDReplaceOp.ReplaceLaneF32x4, arg0, <u8>idx, arg2);\n      case TypeKind.F64: return module.simd_replace(SIMDReplaceOp.ReplaceLaneF64x2, arg0, <u8>idx, arg2);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.replace_lane\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_replace_lane, builtin_v128_replace_lane);\n\n// v128.shuffle<T!>(a: v128, b: v128, ...lanes: u8[]) -> v128\nfunction builtin_v128_shuffle(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  if (type.isValue) {\n    let laneWidth = type.byteSize;\n    let laneCount = 16 / laneWidth;\n    assert(Number.isInteger(laneCount) && isPowerOf2(laneCount));\n    if (\n      checkArgsRequired(ctx, 2 + laneCount)\n    ) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n    let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.Isize:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.Usize:\n      case TypeKind.F32:\n      case TypeKind.F64: {\n        let mask = new Uint8Array(16);\n        let maxIdx = (laneCount << 1) - 1;\n        for (let i = 0; i < laneCount; ++i) {\n          let operand = operands[2 + i];\n          let argN = compiler.compileExpression(operand, Type.u8, Constraints.ConvImplicit);\n          let precomp = module.runExpression(argN, ExpressionRunnerFlags.PreserveSideeffects);\n          let idx = 0;\n          if (precomp) {\n            idx = getConstValueI32(precomp);\n            if (idx < 0 || idx > maxIdx) {\n              compiler.error(\n                DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n                operand.range, \"Lane index\", \"0\", maxIdx.toString()\n              );\n              idx = 0;\n            }\n          } else {\n            compiler.error(\n              DiagnosticCode.Expression_must_be_a_compile_time_constant,\n              operand.range\n            );\n          }\n          switch (laneWidth) {\n            case 1: {\n              writeI8(idx, mask, i);\n              break;\n            }\n            case 2: {\n              let off8 = i << 1;\n              let idx8 = idx << 1;\n              writeI8(idx8    , mask, off8);\n              writeI8(idx8 + 1, mask, off8 + 1);\n              break;\n            }\n            case 4: {\n              let off8 = i << 2;\n              let idx8 = idx << 2;\n              writeI8(idx8    , mask, off8);\n              writeI8(idx8 + 1, mask, off8 + 1);\n              writeI8(idx8 + 2, mask, off8 + 2);\n              writeI8(idx8 + 3, mask, off8 + 3);\n              break;\n            }\n            case 8: {\n              let off8 = i << 3;\n              let idx8 = idx << 3;\n              writeI8(idx8    , mask, off8);\n              writeI8(idx8 + 1, mask, off8 + 1);\n              writeI8(idx8 + 2, mask, off8 + 2);\n              writeI8(idx8 + 3, mask, off8 + 3);\n              writeI8(idx8 + 4, mask, off8 + 4);\n              writeI8(idx8 + 5, mask, off8 + 5);\n              writeI8(idx8 + 6, mask, off8 + 6);\n              writeI8(idx8 + 7, mask, off8 + 7);\n              break;\n            }\n            default: assert(false);\n          }\n        }\n        compiler.currentType = Type.v128;\n        return module.simd_shuffle(arg0, arg1, mask);\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.shuffle\", type.toString()\n  );\n  compiler.currentType = Type.v128;\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_shuffle, builtin_v128_shuffle);\n\n// v128.swizzle(a: v128, b: v128) -> v128\nfunction builtin_v128_swizzle(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  return module.binary(BinaryOp.SwizzleI8x16, arg0, arg1);\n}\nbuiltinFunctions.set(BuiltinNames.v128_swizzle, builtin_v128_swizzle);\n\n// v128.load_splat<T!>(ptr: usize, immOffset?: usize, immAlign?: usize) -> v128\nfunction builtin_v128_load_splat(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 1, 3)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let numOperands = operands.length;\n  let immOffset = 0;\n  let immAlign = type.byteSize;\n  if (numOperands >= 2) {\n    immOffset = evaluateImmediateOffset(operands[1], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    if (numOperands == 3) {\n      immAlign = evaluateImmediateAlign(operands[2], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.v128;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: {\n        return module.simd_load(SIMDLoadOp.Load8Splat, arg0, immOffset, immAlign);\n      }\n      case TypeKind.I16:\n      case TypeKind.U16: {\n        return module.simd_load(SIMDLoadOp.Load16Splat, arg0, immOffset, immAlign);\n      }\n      case TypeKind.I32:\n      case TypeKind.U32:\n      case TypeKind.F32: {\n        return module.simd_load(SIMDLoadOp.Load32Splat, arg0, immOffset, immAlign);\n      }\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        if (!compiler.options.isWasm64) {\n          return module.simd_load(SIMDLoadOp.Load32Splat, arg0, immOffset, immAlign);\n        }\n        // fall-through\n      }\n      case TypeKind.I64:\n      case TypeKind.U64:\n      case TypeKind.F64: {\n        return module.simd_load(SIMDLoadOp.Load64Splat, arg0, immOffset, immAlign);\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.load_splat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_load_splat, builtin_v128_load_splat);\n\n// v128.load_ext<TFrom!>(ptr: usize, immOffset?: usize, immAlign?: usize) -> v128\nfunction builtin_v128_load_ext(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 1, 3)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let numOperands = operands.length;\n  let immOffset = 0;\n  let immAlign = type.byteSize;\n  if (numOperands >= 2) {\n    immOffset = evaluateImmediateOffset(operands[1], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    if (numOperands == 3) {\n      immAlign = evaluateImmediateAlign(operands[2], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.v128;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.simd_load(SIMDLoadOp.Load8x8S, arg0, immOffset, immAlign);\n      case TypeKind.U8: return module.simd_load(SIMDLoadOp.Load8x8U, arg0, immOffset, immAlign);\n      case TypeKind.I16: return module.simd_load(SIMDLoadOp.Load16x4S, arg0, immOffset, immAlign);\n      case TypeKind.U16: return module.simd_load(SIMDLoadOp.Load16x4U, arg0, immOffset, immAlign);\n      case TypeKind.Isize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.simd_load(SIMDLoadOp.Load32x2S, arg0, immOffset, immAlign);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.simd_load(SIMDLoadOp.Load32x2U, arg0, immOffset, immAlign);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.load_ext\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_load_ext, builtin_v128_load_ext);\n\n// v128.load_zero<TFrom!>(ptr: usize, immOffset?: usize, immAlign?: usize) -> v128\nfunction builtin_v128_load_zero(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 1, 3)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let numOperands = operands.length;\n  let immOffset = 0;\n  let immAlign = type.byteSize;\n  if (numOperands >= 2) {\n    immOffset = evaluateImmediateOffset(operands[1], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    if (numOperands == 3) {\n      immAlign = evaluateImmediateAlign(operands[2], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.v128;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I32:\n      case TypeKind.U32:\n      case TypeKind.F32: return module.simd_load(SIMDLoadOp.Load32Zero, arg0, immOffset, immAlign);\n      case TypeKind.I64:\n      case TypeKind.U64:\n      case TypeKind.F64: return module.simd_load(SIMDLoadOp.Load64Zero, arg0, immOffset, immAlign);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.simd_load(\n          compiler.options.isWasm64\n            ? SIMDLoadOp.Load64Zero\n            : SIMDLoadOp.Load32Zero,\n          arg0,\n          immOffset,\n          immAlign\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.load_zero\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_load_zero, builtin_v128_load_zero);\n\n// v128.load_lane<TFrom!>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize) -> v128\nfunction builtin_v128_load_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 3, 5)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  let arg2 = compiler.compileExpression(operands[2], Type.u8, Constraints.ConvImplicit);\n  let idx = 0;\n  let precomp = module.runExpression(arg2, ExpressionRunnerFlags.PreserveSideeffects);\n  if (precomp) {\n    idx = getConstValueI32(precomp);\n  } else {\n    compiler.error(\n      DiagnosticCode.Expression_must_be_a_compile_time_constant,\n      operands[2].range\n    );\n  }\n  let numOperands = operands.length;\n  let immOffset = 0;\n  let immAlign = type.byteSize;\n  if (numOperands >= 4) {\n    immOffset = evaluateImmediateOffset(operands[3], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    if (numOperands == 5) {\n      immAlign = evaluateImmediateAlign(operands[4], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.v128;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    let maxIdx = (16 / assert(type.byteSize)) - 1;\n    if (idx < 0 || idx > maxIdx) {\n      compiler.error(\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n        operands[1].range, \"Lane index\", \"0\", maxIdx.toString()\n      );\n      idx = 0;\n    }\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Load8Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Load16Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32:\n      case TypeKind.F32: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Load32Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64:\n      case TypeKind.F64: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Load64Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.simd_loadstorelane(\n          compiler.options.isWasm64\n            ? SIMDLoadStoreLaneOp.Load64Lane\n            : SIMDLoadStoreLaneOp.Load32Lane,\n          arg0,\n          immOffset,\n          immAlign,\n          <u8>idx,\n          arg1\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.load_lane\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_load_lane, builtin_v128_load_lane);\n\n// v128.store_lane<TFrom!>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize) -> void\nfunction builtin_v128_store_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 3, 5)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  let arg2 = compiler.compileExpression(operands[2], Type.u8, Constraints.ConvImplicit);\n  let idx = 0;\n  let precomp = module.runExpression(arg2, ExpressionRunnerFlags.PreserveSideeffects);\n  if (precomp) {\n    idx = getConstValueI32(precomp);\n  } else {\n    compiler.error(\n      DiagnosticCode.Expression_must_be_a_compile_time_constant,\n      operands[2].range\n    );\n  }\n  let numOperands = operands.length;\n  let immOffset = 0;\n  let immAlign = type.byteSize;\n  if (numOperands >= 4) {\n    immOffset = evaluateImmediateOffset(operands[3], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    if (numOperands == 5) {\n      immAlign = evaluateImmediateAlign(operands[4], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.v128;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.void;\n  if (type.isValue) {\n    let maxIdx = (16 / assert(type.byteSize)) - 1;\n    if (idx < 0 || idx > maxIdx) {\n      compiler.error(\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n        operands[1].range, \"Lane index\", \"0\", maxIdx.toString()\n      );\n      idx = 0;\n    }\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Store8Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Store16Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32:\n      case TypeKind.F32: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Store32Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64:\n      case TypeKind.F64: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Store64Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.simd_loadstorelane(\n          compiler.options.isWasm64\n            ? SIMDLoadStoreLaneOp.Store64Lane\n            : SIMDLoadStoreLaneOp.Store32Lane,\n          arg0,\n          immOffset,\n          immAlign,\n          <u8>idx,\n          arg1\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.store_lane\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_store_lane, builtin_v128_store_lane);\n\n// v128.add<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_add(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.binary(BinaryOp.AddI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.binary(BinaryOp.AddI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.AddI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.AddI64x2, arg0, arg1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.binary(\n          compiler.options.isWasm64\n            ? BinaryOp.AddI64x2\n            : BinaryOp.AddI32x4,\n          arg0, arg1\n        );\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.AddF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.AddF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.add\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_add, builtin_v128_add);\n\n// v128.sub<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_sub(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.binary(BinaryOp.SubI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.binary(BinaryOp.SubI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.SubI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.SubI64x2, arg0, arg1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.binary(\n          compiler.options.isWasm64\n            ? BinaryOp.SubI64x2\n            : BinaryOp.SubI32x4,\n          arg0, arg1\n        );\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.SubF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.SubF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.sub\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_sub, builtin_v128_sub);\n\n// v128.mul<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_mul(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I16:\n      case TypeKind.U16: return module.binary(BinaryOp.MulI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.MulI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.MulI64x2, arg0, arg1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(compiler.options.isWasm64 ? BinaryOp.MulI64x2 : BinaryOp.MulI32x4, arg0, arg1);\n      case TypeKind.F32: return module.binary(BinaryOp.MulF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.MulF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.mul\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_mul, builtin_v128_mul);\n\n// v128.div<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_div(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.binary(BinaryOp.DivF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.DivF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.div\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_div, builtin_v128_div);\n\n// v128.add_sat<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_add_sat(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.AddSatI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.AddSatU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.AddSatI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.AddSatU16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.add_sat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_add_sat, builtin_v128_add_sat);\n\n// v128.sub_sat<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_sub_sat(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.SubSatI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.SubSatU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.SubSatI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.SubSatU16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.sub_sat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_sub_sat, builtin_v128_sub_sat);\n\n// v128.min<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_min(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.MinI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.MinU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.MinI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.MinU16x8, arg0, arg1);\n      case TypeKind.Isize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.MinI32x4, arg0, arg1);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.binary(BinaryOp.MinU32x4, arg0, arg1);\n      case TypeKind.F32: return module.binary(BinaryOp.MinF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.MinF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.min\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_min, builtin_v128_min);\n\n// v128.max<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_max(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.MaxI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.MaxU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.MaxI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.MaxU16x8, arg0, arg1);\n      case TypeKind.Isize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.MaxI32x4, arg0, arg1);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.binary(BinaryOp.MaxU32x4, arg0, arg1);\n      case TypeKind.F32: return module.binary(BinaryOp.MaxF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.MaxF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.max\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_max, builtin_v128_max);\n\n// v128.pmin<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_pmin(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.binary(BinaryOp.PminF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.PminF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.pmin\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_pmin, builtin_v128_pmin);\n\n// v128.pmax<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_pmax(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.binary(BinaryOp.PmaxF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.PmaxF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.pmax\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_pmax, builtin_v128_pmax);\n\n// v128.dot<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_dot(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I16: return module.binary(BinaryOp.DotI16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.dot\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_dot, builtin_v128_dot);\n\n// v128.avgr<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_avgr(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.U8:  return module.binary(BinaryOp.AvgrU8x16, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.AvgrU16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.avgr\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_avgr, builtin_v128_avgr);\n\n// v128.eq<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_eq(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.binary(BinaryOp.EqI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.binary(BinaryOp.EqI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.EqI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.EqI64x2, arg0, arg1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(compiler.options.isWasm64 ? BinaryOp.EqI64x2 : BinaryOp.EqI32x4, arg0, arg1);\n      case TypeKind.F32: return module.binary(BinaryOp.EqF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.EqF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.eq\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_eq, builtin_v128_eq);\n\n// v128.ne<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_ne(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.binary(BinaryOp.NeI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.binary(BinaryOp.NeI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.NeI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.NeI64x2, arg0, arg1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(compiler.options.isWasm64 ? BinaryOp.NeI64x2 : BinaryOp.NeI32x4, arg0, arg1);\n      case TypeKind.F32: return module.binary(BinaryOp.NeF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.NeF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.ne\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_ne, builtin_v128_ne);\n\n// v128.lt<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_lt(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.LtI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.LtU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.LtI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.LtU16x8, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.LtI32x4, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.LtU32x4, arg0, arg1);\n      case TypeKind.I64: return module.binary(BinaryOp.LtI64x2, arg0, arg1);\n      // no LtU64x2\n      case TypeKind.Isize: return module.binary(compiler.options.isWasm64 ? BinaryOp.LtI64x2 : BinaryOp.LtI32x4, arg0, arg1);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        return module.binary(BinaryOp.LtU32x4, arg0, arg1);\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.LtF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.LtF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.lt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_lt, builtin_v128_lt);\n\n// v128.le<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_le(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.LeI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.LeU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.LeI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.LeU16x8, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.LeI32x4, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.LeU32x4, arg0, arg1);\n      case TypeKind.I64: return module.binary(BinaryOp.LeI64x2, arg0, arg1);\n      // no LeU64x2\n      case TypeKind.Isize: return module.binary(compiler.options.isWasm64 ? BinaryOp.LeI64x2 : BinaryOp.LeI32x4, arg0, arg1);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        return module.binary(BinaryOp.LeU32x4, arg0, arg1);\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.LeF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.LeF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.le\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_le, builtin_v128_le);\n\n// v128.gt<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_gt(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.GtI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.GtU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.GtI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.GtU16x8, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.GtI32x4, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.GtU32x4, arg0, arg1);\n      case TypeKind.I64: return module.binary(BinaryOp.GtI64x2, arg0, arg1);\n      // no GtU64x2\n      case TypeKind.Isize: return module.binary(compiler.options.isWasm64 ? BinaryOp.GtI64x2 : BinaryOp.GtI32x4, arg0, arg1);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        return module.binary(BinaryOp.GtU32x4, arg0, arg1);\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.GtF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.GtF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.gt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_gt, builtin_v128_gt);\n\n// v128.ge<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_ge(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.GeI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.GeU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.GeI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.GeU16x8, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.GeI32x4, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.GeU32x4, arg0, arg1);\n      case TypeKind.I64: return module.binary(BinaryOp.GeI64x2, arg0, arg1);\n      // no GeU64x2\n      case TypeKind.Isize: return module.binary(compiler.options.isWasm64 ? BinaryOp.GeI64x2 : BinaryOp.GeI32x4, arg0, arg1);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        return module.binary(BinaryOp.GeU32x4, arg0, arg1);\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.GeF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.GeF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.ge\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_ge, builtin_v128_ge);\n\n// v128.narrow<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_narrow(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I16: return module.binary(BinaryOp.NarrowI16x8ToI8x16, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.NarrowU16x8ToU8x16, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.NarrowI32x4ToI16x8, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.NarrowU32x4ToU16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.narrow\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_narrow, builtin_v128_narrow);\n\n// v128.neg<T!>(a: v128) -> v128\nfunction builtin_v128_neg(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.unary(UnaryOp.NegI8x16, arg0);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.unary(UnaryOp.NegI16x8, arg0);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.NegI32x4, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.NegI64x2, arg0);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.NegI64x2\n            : UnaryOp.NegI32x4,\n          arg0\n        );\n      }\n      case TypeKind.F32: return module.unary(UnaryOp.NegF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.NegF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.neg\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_neg, builtin_v128_neg);\n\n// v128.abs<T!>(a: v128) -> v128\nfunction builtin_v128_abs(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.unary(UnaryOp.AbsI8x16, arg0);\n      case TypeKind.I16: return module.unary(UnaryOp.AbsI16x8, arg0);\n      case TypeKind.I32: return module.unary(UnaryOp.AbsI32x4, arg0);\n      case TypeKind.I64: return module.unary(UnaryOp.AbsI64x2, arg0);\n      case TypeKind.Isize: return module.unary(compiler.options.isWasm64 ? UnaryOp.AbsI64x2 : UnaryOp.AbsI32x4, arg0);\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.Usize: return arg0;\n      case TypeKind.F32: return module.unary(UnaryOp.AbsF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.AbsF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.abs\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_abs, builtin_v128_abs);\n\n// v128.sqrt<T!>(a: v128) -> v128\nfunction builtin_v128_sqrt(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.SqrtF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.SqrtF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.sqrt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_sqrt, builtin_v128_sqrt);\n\n// v128.ceil<T!>(a: v128) -> v128\nfunction builtin_v128_ceil(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.CeilF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.CeilF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.ceil\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_ceil, builtin_v128_ceil);\n\n// v128.floor<T!>(a: v128) -> v128\nfunction builtin_v128_floor(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.FloorF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.FloorF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.floor\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_floor, builtin_v128_floor);\n\n// v128.trunc<T!>(a: v128) -> v128\nfunction builtin_v128_trunc(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.TruncF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.TruncF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.trunc\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_trunc, builtin_v128_trunc);\n\n// v128.nearest<T!>(a: v128) -> v128\nfunction builtin_v128_nearest(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.NearestF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.NearestF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.nearest\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_nearest, builtin_v128_nearest);\n\n// v128.convert<T!>(a: v128) -> v128\nfunction builtin_v128_convert(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Isize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.unary(UnaryOp.ConvertI32x4ToF32x4, arg0);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.unary(UnaryOp.ConvertU32x4ToF32x4, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.convert\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_convert, builtin_v128_convert);\n\n// v128.convert_low<T!>(a: v128) -> v128\nfunction builtin_v128_convert_low(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Isize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.unary(UnaryOp.ConvertLowI32x4ToF64x2, arg0);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.unary(UnaryOp.ConvertLowU32x4ToF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.convert_low\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_convert_low, builtin_v128_convert_low);\n\n// v128.trunc_sat<T!>(a: v128) -> v128\nfunction builtin_v128_trunc_sat(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Isize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.unary(UnaryOp.TruncSatF32x4ToI32x4, arg0);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.unary(UnaryOp.TruncSatF32x4ToU32x4, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.trunc_sat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_trunc_sat, builtin_v128_trunc_sat);\n\n// v128.trunc_sat_zero<T!>(a: v128) -> v128\nfunction builtin_v128_trunc_sat_zero(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Isize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.unary(UnaryOp.TruncSatF64x2ToI32x4Zero, arg0);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.unary(UnaryOp.TruncSatF64x2ToU32x4Zero, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.trunc_sat_zero\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_trunc_sat_zero, builtin_v128_trunc_sat_zero);\n\n// v128.extend_low<T!>(a: v128) -> v128\nfunction builtin_v128_extend_low(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.unary(UnaryOp.ExtendLowI8x16ToI16x8, arg0);\n      case TypeKind.U8: return module.unary(UnaryOp.ExtendLowU8x16ToU16x8, arg0);\n      case TypeKind.I16: return module.unary(UnaryOp.ExtendLowI16x8ToI32x4, arg0);\n      case TypeKind.U16: return module.unary(UnaryOp.ExtendLowU16x8ToU32x4, arg0);\n      case TypeKind.Isize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.unary(UnaryOp.ExtendLowI32x4ToI64x2, arg0);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.unary(UnaryOp.ExtendLowU32x4ToU64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.extend_low\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_extend_low, builtin_v128_extend_low);\n\n// v128.extend_high<T!>(a: v128) -> v128\nfunction builtin_v128_extend_high(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.unary(UnaryOp.ExtendHighI8x16ToI16x8, arg0);\n      case TypeKind.U8: return module.unary(UnaryOp.ExtendHighU8x16ToU16x8, arg0);\n      case TypeKind.I16: return module.unary(UnaryOp.ExtendHighI16x8ToI32x4, arg0);\n      case TypeKind.U16: return module.unary(UnaryOp.ExtendHighU16x8ToU32x4, arg0);\n      case TypeKind.Isize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.unary(UnaryOp.ExtendHighI32x4ToI64x2, arg0);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.unary(UnaryOp.ExtendHighU32x4ToU64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.extend_high\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_extend_high, builtin_v128_extend_high);\n\n// v128.shl<T!>(a: v128, b: i32) -> v128\nfunction builtin_v128_shl(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let type = ctx.typeArguments![0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.i32, Constraints.ConvImplicit);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.simd_shift(SIMDShiftOp.ShlI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.simd_shift(SIMDShiftOp.ShlI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.simd_shift(SIMDShiftOp.ShlI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.simd_shift(SIMDShiftOp.ShlI64x2, arg0, arg1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.simd_shift(\n          compiler.options.isWasm64\n            ? SIMDShiftOp.ShlI64x2\n            : SIMDShiftOp.ShlI32x4,\n          arg0, arg1\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.shl\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_shl, builtin_v128_shl);\n\n// v128.shr<T!>(a: v128, b: i32) -> v128\nfunction builtin_v128_shr(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let type = ctx.typeArguments![0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.i32, Constraints.ConvImplicit);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.simd_shift(SIMDShiftOp.ShrI8x16, arg0, arg1);\n      case TypeKind.U8: return module.simd_shift(SIMDShiftOp.ShrU8x16, arg0, arg1);\n      case TypeKind.I16: return module.simd_shift(SIMDShiftOp.ShrI16x8, arg0, arg1);\n      case TypeKind.U16: return module.simd_shift(SIMDShiftOp.ShrU16x8, arg0, arg1);\n      case TypeKind.I32: return module.simd_shift(SIMDShiftOp.ShrI32x4, arg0, arg1);\n      case TypeKind.U32: return module.simd_shift(SIMDShiftOp.ShrU32x4, arg0, arg1);\n      case TypeKind.I64: return module.simd_shift(SIMDShiftOp.ShrI64x2, arg0, arg1);\n      case TypeKind.U64: return module.simd_shift(SIMDShiftOp.ShrU64x2, arg0, arg1);\n      case TypeKind.Isize: {\n        return module.simd_shift(\n          compiler.options.isWasm64\n            ? SIMDShiftOp.ShrI64x2\n            : SIMDShiftOp.ShrI32x4,\n          arg0, arg1\n        );\n      }\n      case TypeKind.Usize: {\n        return module.simd_shift(\n          compiler.options.isWasm64\n            ? SIMDShiftOp.ShrU64x2\n            : SIMDShiftOp.ShrU32x4,\n          arg0, arg1\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.shr\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_shr, builtin_v128_shr);\n\nfunction builtin_v128_bitwise_binary(ctx: BuiltinFunctionContext, op: BinaryOp): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  return module.binary(op, arg0, arg1);\n}\n\n// v128.and(a: v128, b: v128) -> v128\nfunction builtin_v128_and(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_v128_bitwise_binary(ctx, BinaryOp.AndV128);\n}\nbuiltinFunctions.set(BuiltinNames.v128_and, builtin_v128_and);\n\n// v128.or(a: v128, b: v128) -> v128\nfunction builtin_v128_or(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_v128_bitwise_binary(ctx, BinaryOp.OrV128);\n}\nbuiltinFunctions.set(BuiltinNames.v128_or, builtin_v128_or);\n\n// v128.xor(a: v128, b: v128) -> v128\nfunction builtin_v128_xor(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_v128_bitwise_binary(ctx, BinaryOp.XorV128);\n}\nbuiltinFunctions.set(BuiltinNames.v128_xor, builtin_v128_xor);\n\n// v128.andnot(a: v128, b: v128) -> v128\nfunction builtin_v128_andnot(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_v128_bitwise_binary(ctx, BinaryOp.AndnotV128);\n}\nbuiltinFunctions.set(BuiltinNames.v128_andnot, builtin_v128_andnot);\n\nfunction builtin_v128_bitwise_unary(ctx: BuiltinFunctionContext, op: UnaryOp): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  return module.unary(op, arg0);\n}\n\n// v128.not(a: v128) -> v128\nfunction builtin_v128_not(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_v128_bitwise_unary(ctx, UnaryOp.NotV128);\n}\nbuiltinFunctions.set(BuiltinNames.v128_not, builtin_v128_not);\n\n// v128.bitselect(v1: v128, v2: v128, c: v128) -> v128\nfunction builtin_v128_bitselect(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  let arg2 = compiler.compileExpression(operands[2], Type.v128, Constraints.ConvImplicit);\n  return module.simd_ternary(SIMDTernaryOp.Bitselect, arg0, arg1, arg2);\n}\nbuiltinFunctions.set(BuiltinNames.v128_bitselect, builtin_v128_bitselect);\n\n// v128.any_true(a: v128) -> bool\nfunction builtin_v128_any_true(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.bool;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  compiler.currentType = Type.bool;\n  return module.unary(UnaryOp.AnyTrueV128, arg0);\n}\nbuiltinFunctions.set(BuiltinNames.v128_any_true, builtin_v128_any_true);\n\n// v128.all_true<T!>(a: v128) -> bool\nfunction builtin_v128_all_true(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.bool;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let type = ctx.typeArguments![0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  compiler.currentType = Type.bool;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.unary(UnaryOp.AllTrueI8x16, arg0);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.unary(UnaryOp.AllTrueI16x8, arg0);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.AllTrueI32x4, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.AllTrueI64x2, arg0);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.AllTrueI64x2\n            : UnaryOp.AllTrueI32x4,\n          arg0\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.all_true\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_all_true, builtin_v128_all_true);\n\n// v128.bitmask<T!>(a: v128) -> i32\nfunction builtin_v128_bitmask(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.i32;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let type = ctx.typeArguments![0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  compiler.currentType = Type.i32;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.unary(UnaryOp.BitmaskI8x16, arg0);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.unary(UnaryOp.BitmaskI16x8, arg0);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.BitmaskI32x4, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.BitmaskI64x2, arg0);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.BitmaskI64x2\n            : UnaryOp.BitmaskI32x4,\n          arg0\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.bitmask\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_bitmask, builtin_v128_bitmask);\n\n// v128.popcnt<T!>(a: v128) -> v128\nfunction builtin_v128_popcnt(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let type = ctx.typeArguments![0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.unary(UnaryOp.PopcntI8x16, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.popcnt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_popcnt, builtin_v128_popcnt);\n\n// v128.extadd_pairwise<T!>(a: v128) -> v128\nfunction builtin_v128_extadd_pairwise(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let type = ctx.typeArguments![0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.unary(UnaryOp.ExtaddPairwiseI8x16ToI16x8, arg0);\n      case TypeKind.U8: return module.unary(UnaryOp.ExtaddPairwiseU8x16ToU16x8, arg0);\n      case TypeKind.I16: return module.unary(UnaryOp.ExtaddPairwiseI16x8ToI32x4, arg0);\n      case TypeKind.U16: return module.unary(UnaryOp.ExtaddPairwiseU16x8ToU32x4, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.extadd_pairwise\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_extadd_pairwise, builtin_v128_extadd_pairwise);\n\n// v128.demote_zero<T?>(a: v128) -> v128\nfunction builtin_v128_demote_zero(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeOptional(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let type = typeArguments ? typeArguments[0] : Type.f64;\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F64: return module.unary(UnaryOp.DemoteZeroF64x2ToF32x4, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.demote_zero\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_demote_zero, builtin_v128_demote_zero);\n\n// v128.promote_low<T?>(a: v128) -> v128\nfunction builtin_v128_promote_low(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeOptional(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let type = typeArguments ? typeArguments[0] : Type.f32;\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.PromoteLowF32x4ToF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.promote_low\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_promote_low, builtin_v128_promote_low);\n\n// v128.q15mulr_sat<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_q15mulr_sat(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I16: return module.binary(BinaryOp.Q15mulrSatI16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.q15mulr_sat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_q15mulr_sat, builtin_v128_q15mulr_sat);\n\n// v128.extmul_low<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_extmul_low(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.ExtmulLowI16x8, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.ExtmulLowU16x8, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.ExtmulLowI32x4, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.ExtmulLowU32x4, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.ExtmulLowI64x2, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.ExtmulLowU64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.extmul_low\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_extmul_low, builtin_v128_extmul_low);\n\n// v128.extmul_high<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_extmul_high(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.ExtmulHighI16x8, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.ExtmulHighU16x8, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.ExtmulHighI32x4, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.ExtmulHighU32x4, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.ExtmulHighI64x2, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.ExtmulHighU64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.extmul_high\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_extmul_high, builtin_v128_extmul_high);\n\n// === Relaxed SIMD ===========================================================================\n\n// v128.relaxed_swizzle(a: v128, s: v128) -> v128\nfunction builtin_v128_relaxed_swizzle(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.RelaxedSimd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  return module.binary(BinaryOp.RelaxedSwizzleI8x16, arg0, arg1);\n}\nbuiltinFunctions.set(BuiltinNames.v128_relaxed_swizzle, builtin_v128_relaxed_swizzle);\n\n// v128.relaxed_trunc<T!>(a: v128) -> v128\nfunction builtin_v128_relaxed_trunc(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.RelaxedSimd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Isize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.unary(UnaryOp.RelaxedTruncF32x4ToI32x4, arg0);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.unary(UnaryOp.RelaxedTruncF32x4ToU32x4, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.relaxed_trunc\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_relaxed_trunc, builtin_v128_relaxed_trunc);\n\n// v128.relaxed_trunc_zero<T!>(a: v128) -> v128\nfunction builtin_v128_relaxed_trunc_zero(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.RelaxedSimd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Isize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.unary(UnaryOp.RelaxedTruncF64x2ToI32x4Zero, arg0);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.unary(UnaryOp.RelaxedTruncF64x2ToU32x4Zero, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.relaxed_trunc_zero\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_relaxed_trunc_zero, builtin_v128_relaxed_trunc_zero);\n\n// v128.relaxed_madd<T!>(a: v128, b: v128, c: v128) -> v128\nfunction builtin_v128_relaxed_madd(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.RelaxedSimd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  let arg2 = compiler.compileExpression(operands[2], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.simd_ternary(SIMDTernaryOp.RelaxedMaddF32x4, arg0, arg1, arg2);\n      case TypeKind.F64: return module.simd_ternary(SIMDTernaryOp.RelaxedMaddF64x2, arg0, arg1, arg2);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.relaxed_madd\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_relaxed_madd, builtin_v128_relaxed_madd);\n\n// v128.relaxed_nmadd<T!>(a: v128, b: v128, c: v128) -> v128\nfunction builtin_v128_relaxed_nmadd(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.RelaxedSimd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  let arg2 = compiler.compileExpression(operands[2], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.simd_ternary(SIMDTernaryOp.RelaxedNmaddF32x4, arg0, arg1, arg2);\n      case TypeKind.F64: return module.simd_ternary(SIMDTernaryOp.RelaxedNmaddF64x2, arg0, arg1, arg2);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.relaxed_nmadd\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_relaxed_nmadd, builtin_v128_relaxed_nmadd);\n\n// v128.relaxed_laneselect<T!>(a: v128, b: v128, m: v128) -> v128\nfunction builtin_v128_relaxed_laneselect(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.RelaxedSimd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  let arg2 = compiler.compileExpression(operands[2], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.simd_ternary(SIMDTernaryOp.RelaxedLaneselectI8x16, arg0, arg1, arg2);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.simd_ternary(SIMDTernaryOp.RelaxedLaneselectI16x8, arg0, arg1, arg2);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.simd_ternary(SIMDTernaryOp.RelaxedLaneselectI32x4, arg0, arg1, arg2);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.simd_ternary(SIMDTernaryOp.RelaxedLaneselectI64x2, arg0, arg1, arg2);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.simd_ternary(\n          compiler.options.isWasm64\n            ? SIMDTernaryOp.RelaxedLaneselectI64x2\n            : SIMDTernaryOp.RelaxedLaneselectI32x4,\n          arg0, arg1, arg2\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.relaxed_laneselect\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_relaxed_laneselect, builtin_v128_relaxed_laneselect);\n\n// v128.relaxed_min<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_relaxed_min(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.RelaxedSimd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.binary(BinaryOp.RelaxedMinF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.RelaxedMinF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.relaxed_min\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_relaxed_min, builtin_v128_relaxed_min);\n\n// v128.relaxed_max<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_relaxed_max(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.RelaxedSimd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.binary(BinaryOp.RelaxedMaxF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.RelaxedMaxF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.relaxed_max\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_relaxed_max, builtin_v128_relaxed_max);\n\n// v128.relaxed_q15mulr<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_relaxed_q15mulr(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.RelaxedSimd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I16: return module.binary(BinaryOp.RelaxedQ15MulrI16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.relaxed_q15mulr\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_relaxed_q15mulr, builtin_v128_relaxed_q15mulr);\n\n// v128.relaxed_dot<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_relaxed_dot(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.RelaxedSimd) |\n    checkArgsRequired(ctx, 2) |\n    checkTypeRequired(ctx)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  switch (type.kind) {\n    case TypeKind.I16: return module.binary(BinaryOp.RelaxedDotI8x16I7x16ToI16x8, arg0, arg1);\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.relaxed_dot\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_relaxed_dot, builtin_v128_relaxed_dot);\n\n// v128.relaxed_dot_add<T!>(a: v128, b: v128, c: v128) -> v128\nfunction builtin_v128_relaxed_dot_add(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.RelaxedSimd) |\n    checkArgsRequired(ctx, 3) |\n    checkTypeRequired(ctx)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  let arg2 = compiler.compileExpression(operands[2], Type.v128, Constraints.ConvImplicit);\n  switch (type.kind) {\n    // TOOD: emulate relaxed_dot_add of i16 with multiple instructions?\n    case TypeKind.Isize: {\n      if (compiler.options.isWasm64) break;\n      // fall-through\n    }\n    case TypeKind.I32: return module.simd_ternary(SIMDTernaryOp.RelaxedDotI8x16I7x16AddToI32x4, arg0, arg1, arg2);\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.relaxed_dot_add\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_relaxed_dot_add, builtin_v128_relaxed_dot_add);\n\n// === Internal runtime =======================================================================\n\n// __visit_globals(cookie: u32) -> void\nfunction builtin_visit_globals(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1) // cookie\n  ) {\n    compiler.currentType = Type.void;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], Type.u32, Constraints.ConvImplicit);\n  compiler.runtimeFeatures |= RuntimeFeatures.visitGlobals;\n  compiler.currentType = Type.void;\n  return module.call(BuiltinNames.visit_globals, [ arg0 ], TypeRef.None);\n}\nbuiltinFunctions.set(BuiltinNames.visit_globals, builtin_visit_globals);\n\n// __visit_members(ref: usize, cookie: u32) -> void\nfunction builtin_visit_members(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2) // ref, cookie\n  ) {\n    compiler.currentType = Type.void;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.u32, Constraints.ConvImplicit);\n  compiler.runtimeFeatures |= RuntimeFeatures.visitMembers;\n  compiler.currentType = Type.void;\n  return module.call(BuiltinNames.visit_members, [ arg0, arg1 ], TypeRef.None);\n}\nbuiltinFunctions.set(BuiltinNames.visit_members, builtin_visit_members);\n\n// === Inline assembler =======================================================================\n\n// TODO: Operators can't be just deferred (don't have a corresponding generic built-in)\n//   add, sub, mul, div_s, div_u, rem_s, rem_u\n//   and, or, xor, shl, shr_u, shr_s\n//   eq, eqz, ne, lt_s, lt_u, le_s, le_u, gt_s, gt_u, ge_s, ge_u\n\n// i32.clz -> clz<i32>\nfunction builtin_i32_clz(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_clz(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_clz, builtin_i32_clz);\n\n// i64.clz -> clz<i64>\nfunction builtin_i64_clz(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_clz(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_clz, builtin_i64_clz);\n\n// i32.ctz -> ctz<i32>\nfunction builtin_i32_ctz(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_ctz(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_ctz, builtin_i32_ctz);\n\n// i64.ctz -> ctz<i64>\nfunction builtin_i64_ctz(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_ctz(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_ctz, builtin_i64_ctz);\n\n// i32.popcnt -> popcnt<i32>\nfunction builtin_i32_popcnt(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_popcnt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_popcnt, builtin_i32_popcnt);\n\n// i64.popcnt -> popcnt<i64>\nfunction builtin_i64_popcnt(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_popcnt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_popcnt, builtin_i64_popcnt);\n\n// i32.rotl -> rotl<i32>\nfunction builtin_i32_rotl(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_rotl(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_rotl, builtin_i32_rotl);\n\n// i64.rotl -> rotl<i64>\nfunction builtin_i64_rotl(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_rotl(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_rotl, builtin_i64_rotl);\n\n// i32.rotr -> rotr<i32>\nfunction builtin_i32_rotr(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_rotr(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_rotr, builtin_i32_rotr);\n\n// i64.rotr -> rotr<i64>\nfunction builtin_i64_rotr(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_rotr(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_rotr, builtin_i64_rotr);\n\n// f32.abs -> abs<f32>\nfunction builtin_f32_abs(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_abs(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32_abs, builtin_f32_abs);\n\n// f64.abs -> abs<f64>\nfunction builtin_f64_abs(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_abs(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64_abs, builtin_f64_abs);\n\n// f32.max -> max<f32>\nfunction builtin_f32_max(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_max(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32_max, builtin_f32_max);\n\n// f64.max -> max<f64>\nfunction builtin_f64_max(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_max(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64_max, builtin_f64_max);\n\n// f32.min -> min<f32>\nfunction builtin_f32_min(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_min(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32_min, builtin_f32_min);\n\n// f64.min -> min<f64>\nfunction builtin_f64_min(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_min(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64_min, builtin_f64_min);\n\n// f32.ceil -> ceil<f32>\nfunction builtin_f32_ceil(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_ceil(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32_ceil, builtin_f32_ceil);\n\n// f64.ceil -> ceil<f64>\nfunction builtin_f64_ceil(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_ceil(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64_ceil, builtin_f64_ceil);\n\n// f32.floor -> floor<f32>\nfunction builtin_f32_floor(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_floor(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32_floor, builtin_f32_floor);\n\n// f64.floor -> floor<f64>\nfunction builtin_f64_floor(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_floor(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64_floor, builtin_f64_floor);\n\n// f32.copysign -> copysign<f32>\nfunction builtin_f32_copysign(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_copysign(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32_copysign, builtin_f32_copysign);\n\n// f64.copysign -> copysign<f64>\nfunction builtin_f64_copysign(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_copysign(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64_copysign, builtin_f64_copysign);\n\n// f32.nearest -> nearest<f32>\nfunction builtin_f32_nearest(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_nearest(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32_nearest, builtin_f32_nearest);\n\n// f64.nearest -> nearest<f64>\nfunction builtin_f64_nearest(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_nearest(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64_nearest, builtin_f64_nearest);\n\n// i32.reinterpret_f32 -> reinterpret<i32>\nfunction builtin_i32_reinterpret_f32(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_reinterpret(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_reinterpret_f32, builtin_i32_reinterpret_f32);\n\n// i64.reinterpret_f64 -> reinterpret<i64>\nfunction builtin_i64_reinterpret_f64(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_reinterpret(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_reinterpret_f64, builtin_i64_reinterpret_f64);\n\n// f32.reinterpret_i32 -> reinterpret<f32>\nfunction builtin_f32_reinterpret_i32(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_reinterpret(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32_reinterpret_i32, builtin_f32_reinterpret_i32);\n\n// f64.reinterpret_i64 -> reinterpret<f64>\nfunction builtin_f64_reinterpret_i64(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_reinterpret(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64_reinterpret_i64, builtin_f64_reinterpret_i64);\n\n// f32.sqrt -> sqrt<f32>\nfunction builtin_f32_sqrt(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_sqrt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32_sqrt, builtin_f32_sqrt);\n\n// f64.sqrt -> sqrt<f64>\nfunction builtin_f64_sqrt(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_sqrt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64_sqrt, builtin_f64_sqrt);\n\n// f32.trunc -> trunc<f32>\nfunction builtin_f32_trunc(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_trunc(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32_trunc, builtin_f32_trunc);\n\n// f64.trunc -> trunc<f64>\nfunction builtin_f64_trunc(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_trunc(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64_trunc, builtin_f64_trunc);\n\n// i32.rem_s -> rem<i32>\nfunction builtin_i32_rem_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_rem(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_rem_s, builtin_i32_rem_s);\n\n// i32.rem_u -> rem<u32>\nfunction builtin_i32_rem_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.u32;\n  return builtin_rem(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_rem_u, builtin_i32_rem_u);\n\n// i64.rem_s -> rem<i64>\nfunction builtin_i64_rem_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_rem(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_rem_s, builtin_i64_rem_s);\n\n// i64.rem_u -> rem<u64>\nfunction builtin_i64_rem_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.u64;\n  return builtin_rem(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_rem_u, builtin_i64_rem_u);\n\n// i32.add -> add<i32>\nfunction builtin_i32_add(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_add(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_add, builtin_i32_add);\n\n// i64.add -> add<i64>\nfunction builtin_i64_add(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_add(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_add, builtin_i64_add);\n\n// f32.add -> add<f32>\nfunction builtin_f32_add(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_add(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32_add, builtin_f32_add);\n\n// f64.add -> add<f64>\nfunction builtin_f64_add(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_add(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64_add, builtin_f64_add);\n\n// i32.sub -> sub<i32>\nfunction builtin_i32_sub(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_sub(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_sub, builtin_i32_sub);\n\n// i64.sub -> sub<i64>\nfunction builtin_i64_sub(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_sub(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_sub, builtin_i64_sub);\n\n// f32.sub -> sub<f32>\nfunction builtin_f32_sub(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_sub(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32_sub, builtin_f32_sub);\n\n// f64.sub -> sub<f64>\nfunction builtin_f64_sub(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_sub(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64_sub, builtin_f64_sub);\n\n// i32.mul -> mul<i32>\nfunction builtin_i32_mul(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_mul(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_mul, builtin_i32_mul);\n\n// i64.mul -> mul<i64>\nfunction builtin_i64_mul(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_mul(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_mul, builtin_i64_mul);\n\n// f32.mul -> mul<f32>\nfunction builtin_f32_mul(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_mul(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32_mul, builtin_f32_mul);\n\n// f64.mul -> mul<f64>\nfunction builtin_f64_mul(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_mul(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64_mul, builtin_f64_mul);\n\n// i32.div_s -> div<i32>\nfunction builtin_i32_div_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_div(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_div_s, builtin_i32_div_s);\n\n// i32.div_u -> div<u32>\nfunction builtin_i32_div_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.u32;\n  return builtin_div(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_div_u, builtin_i32_div_u);\n\n// i64.div_s -> div_s<i64>\nfunction builtin_i64_div_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_div(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_div_s, builtin_i64_div_s);\n\n// i64.div_u -> div_u<u64>\nfunction builtin_i64_div_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.u64;\n  return builtin_div(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_div_u, builtin_i64_div_u);\n\n// f32.div -> div<f32>\nfunction builtin_f32_div(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_div(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32_div, builtin_f32_div);\n\n// f64.div -> div<f64>\nfunction builtin_f64_div(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_div(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64_div, builtin_f64_div);\n\n// i32.eq -> eq<i32>\nfunction builtin_i32_eq(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_eq(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_eq, builtin_i32_eq);\n\n// i64.eq -> eq<i64>\nfunction builtin_i64_eq(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i32;\n  return builtin_eq(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_eq, builtin_i64_eq);\n\n// f32.eq -> eq<f32>\nfunction builtin_f32_eq(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_eq(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32_eq, builtin_f32_eq);\n\n// f64.eq -> eq<f64>\nfunction builtin_f64_eq(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.i32;\n  return builtin_eq(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64_eq, builtin_f64_eq);\n\n// i32.ne -> ne<i32>\nfunction builtin_i32_ne(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_ne(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_ne, builtin_i32_ne);\n\n// i64.ne -> ne<i64>\nfunction builtin_i64_ne(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i32;\n  return builtin_ne(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_ne, builtin_i64_ne);\n\n// f32.ne -> ne<f32>\nfunction builtin_f32_ne(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_ne(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32_ne, builtin_f32_ne);\n\n// f64.ne-> ne<f64>\nfunction builtin_f64_ne(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.i32;\n  return builtin_ne(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64_ne, builtin_f64_ne);\n\n// i32.load8_s -> <i32>load<i8>\nfunction builtin_i32_load8_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_load8_s, builtin_i32_load8_s);\n\n// i32.load8_u -> <i32>load<u8>\nfunction builtin_i32_load8_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_load8_u, builtin_i32_load8_u);\n\n// i32.load16_s -> <i32>load<i16>\nfunction builtin_i32_load16_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_load16_s, builtin_i32_load16_s);\n\n// i32.load16_u -> <i32>load<u16>\nfunction builtin_i32_load16_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_load16_u, builtin_i32_load16_u);\n\n// i32.load -> <i32>load<i32>\nfunction builtin_i32_load(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_load, builtin_i32_load);\n\n// i64.load8_s -> <i64>load<i8>\nfunction builtin_i64_load8_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_load8_s, builtin_i64_load8_s);\n\n// i64.load8_u -> <i64>load<u8>\nfunction builtin_i64_load8_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_load8_u, builtin_i64_load8_u);\n\n// i64.load16_s -> <i64>load<i16>\nfunction builtin_i64_load16_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_load16_s, builtin_i64_load16_s);\n\n// i64.load16_u -> <i64>load<u16>\nfunction builtin_i64_load16_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_load16_u, builtin_i64_load16_u);\n\n// i64.load32_s -> <i64>load<i32>\nfunction builtin_i64_load32_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_load32_s, builtin_i64_load32_s);\n\n// i64.load32_u -> <i64>load<u32>\nfunction builtin_i64_load32_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_load32_u, builtin_i64_load32_u);\n\n// i64.load -> <i64>load<i64>\nfunction builtin_i64_load(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_load, builtin_i64_load);\n\n// f32.load -> <f32>load<f32>\nfunction builtin_f32_load(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32_load, builtin_f32_load);\n\n// f64.load -> <f64>load<f64>\nfunction builtin_f64_load(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64_load, builtin_f64_load);\n\n// i32.store8 -> store<i8 from i32>\nfunction builtin_i32_store8(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_store8, builtin_i32_store8);\n\n// i32.store16 -> store<i16 from i32>\nfunction builtin_i32_store16(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_store16, builtin_i32_store16);\n\n// i32.store -> store<i32 from i32>\nfunction builtin_i32_store(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_store, builtin_i32_store);\n\n// i64.store8 -> store<i8 from i64>\nfunction builtin_i64_store8(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_store8, builtin_i64_store8);\n\n// i64.store16 -> store<i16 from i64>\nfunction builtin_i64_store16(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_store16, builtin_i64_store16);\n\n// i64.store32 -> store<i32 from i64>\nfunction builtin_i64_store32(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_store32, builtin_i64_store32);\n\n// i64.store -> store<i64 from i64>\nfunction builtin_i64_store(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_store, builtin_i64_store);\n\n// f32.store -> store<f32 from f64>\nfunction builtin_f32_store(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32_store, builtin_f32_store);\n\n// f64.store -> store<f64 from f64>\nfunction builtin_f64_store(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64_store, builtin_f64_store);\n\n// i32.atomic.load8_u -> <i32>atomic.load<u8>\nfunction builtin_i32_atomic_load8_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_atomic_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_load8_u, builtin_i32_atomic_load8_u);\n\n// i32.atomic.load16_u -> <i32>atomic.load<u16>\nfunction builtin_i32_atomic_load16_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_atomic_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_load16_u, builtin_i32_atomic_load16_u);\n\n// i32.atomic.load -> <i32>atomic.load<i32>\nfunction builtin_i32_atomic_load(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_atomic_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_load, builtin_i32_atomic_load);\n\n// i64.atomic.load8_u -> <i64>atomic.load<u8>\nfunction builtin_i64_atomic_load8_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  return builtin_atomic_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_load8_u, builtin_i64_atomic_load8_u);\n\n// i64.atomic.load16_u -> <i64>atomic.load<u16>\nfunction builtin_i64_atomic_load16_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  return builtin_atomic_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_load16_u, builtin_i64_atomic_load16_u);\n\n// i64.atomic.load32_u -> <i64>atomic.load<u32>\nfunction builtin_i64_atomic_load32_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  return builtin_atomic_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_load32_u, builtin_i64_atomic_load32_u);\n\n// i64.atomic.load -> <i64>atomic.load<i64>\nfunction builtin_i64_atomic_load(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_atomic_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_load, builtin_i64_atomic_load);\n\n// i32.atomic.store8 -> atomic.store<i8 from i32>\nfunction builtin_i32_atomic_store8(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_store8, builtin_i32_atomic_store8);\n\n// i32.atomic.store16 -> atomic.store<i16 from i32>\nfunction builtin_i32_atomic_store16(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_store16, builtin_i32_atomic_store16);\n\n// i32.atomic.store -> atomic.store<i32 from i32>\nfunction builtin_i32_atomic_store(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_store, builtin_i32_atomic_store);\n\n// i64.atomic.store8 -> atomic.store<i8 from i64>\nfunction builtin_i64_atomic_store8(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_store8, builtin_i64_atomic_store8);\n\n// i64.atomic.store16 -> atomic.store<i16 from i64>\nfunction builtin_i64_atomic_store16(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_store16, builtin_i64_atomic_store16);\n\n// i64.atomic.store32 -> atomic.store<i32 from i64>\nfunction builtin_i64_atomic_store32(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_store32, builtin_i64_atomic_store32);\n\n// i64.atomic.store -> atomic.store<i64 from i64>\nfunction builtin_i64_atomic_store(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_store, builtin_i64_atomic_store);\n\n// i32.atomic.rmw8.add_u -> <i32>atomic.add<u8 from i32>\nfunction builtin_i32_atomic_rmw8_add_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw8_add_u, builtin_i32_atomic_rmw8_add_u);\n\n// i32.atomic.rmw16.add_u -> <i32>atomic.add<u16 from i32>\nfunction builtin_i32_atomic_rmw16_add_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw16_add_u, builtin_i32_atomic_rmw16_add_u);\n\n// i32.atomic.rmw.add -> <i32>atomic.add<i32 from i32>\nfunction builtin_i32_atomic_rmw_add(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw_add, builtin_i32_atomic_rmw_add);\n\n// i64.atomic.rmw8.add_u -> <i64>atomic.add<u8 from i64>\nfunction builtin_i64_atomic_rmw8_add_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw8_add_u, builtin_i64_atomic_rmw8_add_u);\n\n// i64.atomic.rmw16.add_u -> <i64>atomic.add<u16 from i64>\nfunction builtin_i64_atomic_rmw16_add_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw16_add_u, builtin_i64_atomic_rmw16_add_u);\n\n// i64.atomic.rmw32.add_u -> <i64>atomic.add<u32 from i64>\nfunction builtin_i64_atomic_rmw32_add_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw32_add_u, builtin_i64_atomic_rmw32_add_u);\n\n// i64.atomic.rmw.add -> <i64>atomic.add<i64 from i64>\nfunction builtin_i64_atomic_rmw_add(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw_add, builtin_i64_atomic_rmw_add);\n\n// i32.atomic.rmw8.sub_u -> <i32>atomic.sub<u8 from i32>\nfunction builtin_i32_atomic_rmw8_sub_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw8_sub_u, builtin_i32_atomic_rmw8_sub_u);\n\n// i32.atomic.rmw16.sub_u -> <i32>atomic.sub<u16 from i32>\nfunction builtin_i32_atomic_rmw16_sub_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw16_sub_u, builtin_i32_atomic_rmw16_sub_u);\n\n// i32.atomic.rmw.sub -> <i32>atomic.sub<i32 from i32>\nfunction builtin_i32_atomic_rmw_sub(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw_sub, builtin_i32_atomic_rmw_sub);\n\n// i64.atomic.rmw8.sub_u -> <i64>atomic.sub<u8 from i64>\nfunction builtin_i64_atomic_rmw8_sub_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw8_sub_u, builtin_i64_atomic_rmw8_sub_u);\n\n// i64.atomic.rmw16.sub_u -> <i64>atomic.sub<u16 from i64>\nfunction builtin_i64_atomic_rmw16_sub_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw16_sub_u, builtin_i64_atomic_rmw16_sub_u);\n\n// i64.atomic.rmw32.sub_u -> <i64>atomic.sub<u32 from i64>\nfunction builtin_i64_atomic_rmw32_sub_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw32_sub_u, builtin_i64_atomic_rmw32_sub_u);\n\n// i64.atomic.rmw.sub -> <i64>atomic.sub<i64 from i64>\nfunction builtin_i64_atomic_rmw_sub(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw_sub, builtin_i64_atomic_rmw_sub);\n\n// i32.atomic.rmw8.and_u -> <i32>atomic.and<u8 from i32>\nfunction builtin_i32_atomic_rmw8_and_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw8_and_u, builtin_i32_atomic_rmw8_and_u);\n\n// i32.atomic.rmw16.and_u -> <i32>atomic.and<u16 from i32>\nfunction builtin_i32_atomic_rmw16_and_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw16_and_u, builtin_i32_atomic_rmw16_and_u);\n\n// i32.atomic.rmw.and -> <i32>atomic.and<i32 from i32>\nfunction builtin_i32_atomic_rmw_and(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw_and, builtin_i32_atomic_rmw_and);\n\n// i64.atomic.rmw8.and_u -> <i64>atomic.and<u8 from i64>\nfunction builtin_i64_atomic_rmw8_and_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw8_and_u, builtin_i64_atomic_rmw8_and_u);\n\n// i64.atomic.rmw16.and_u -> <i64>atomic.and<u16 from i64>\nfunction builtin_i64_atomic_rmw16_and_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw16_and_u, builtin_i64_atomic_rmw16_and_u);\n\n// i64.atomic.rmw32.and_u -> <i64>atomic.and<u32 from i64>\nfunction builtin_i64_atomic_rmw32_and_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw32_and_u, builtin_i64_atomic_rmw32_and_u);\n\n// i64.atomic.rmw.and -> <i64>atomic.and<i64 from i64>\nfunction builtin_i64_atomic_rmw_and(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw_and, builtin_i64_atomic_rmw_and);\n\n// i32.atomic.rmw8.or_u -> <i32>atomic.or<u8 from i32>\nfunction builtin_i32_atomic_rmw8_or_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw8_or_u, builtin_i32_atomic_rmw8_or_u);\n\n// i32.atomic.rmw16.or_u -> <i32atomic.or<u16 from i32>\nfunction builtin_i32_atomic_rmw16_or_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw16_or_u, builtin_i32_atomic_rmw16_or_u);\n\n// i32.atomic.rmw.or -> <i32>atomic.or<i32 from i32>\nfunction builtin_i32_atomic_rmw_or(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw_or, builtin_i32_atomic_rmw_or);\n\n// i64.atomic.rmw8.or_u -> <i64>atomic.or<u8 from i64>\nfunction builtin_i64_atomic_rmw8_or_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw8_or_u, builtin_i64_atomic_rmw8_or_u);\n\n// i64.atomic.rmw16.or_u -> <i64>atomic.or<u16 from i64>\nfunction builtin_i64_atomic_rmw16_or_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw16_or_u, builtin_i64_atomic_rmw16_or_u);\n\n// i64.atomic.rmw32.or_u -> <i64>atomic.or<u32 from i64>\nfunction builtin_i64_atomic_rmw32_or_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw32_or_u, builtin_i64_atomic_rmw32_or_u);\n\n// i64.atomic.rmw.or -> <i64>atomic.or<i64 from i64>\nfunction builtin_i64_atomic_rmw_or(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw_or, builtin_i64_atomic_rmw_or);\n\n// i32.atomic.rmw8.xor_u -> <i32>atomic.xor<u8 from i32>\nfunction builtin_i32_atomic_rmw8_xor_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw8_xor_u, builtin_i32_atomic_rmw8_xor_u);\n\n// i32.atomic.rmw16.xor_u -> <i32>atomic.xor<u16 from i32>\nfunction builtin_i32_atomic_rmw16_xor_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw16_xor_u, builtin_i32_atomic_rmw16_xor_u);\n\n// i32.atomic.rmw.xor -> <i32>atomic.xor<i32 from i32>\nfunction builtin_i32_atomic_rmw_xor(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw_xor, builtin_i32_atomic_rmw_xor);\n\n// i64.atomic.rmw8.xor_u -> <i64>atomic.xor<u8 from i64>\nfunction builtin_i64_atomic_rmw8_xor_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw8_xor_u, builtin_i64_atomic_rmw8_xor_u);\n\n// i64.atomic.rmw16.xor_u -> <i64>atomic.xor<u16 from i64>\nfunction builtin_i64_atomic_rmw16_xor_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw16_xor_u, builtin_i64_atomic_rmw16_xor_u);\n\n// i64.atomic.rmw32.xor_u -> <i64>atomic.xor<u32 from i64>\nfunction builtin_i64_atomic_rmw32_xor_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw32_xor_u, builtin_i64_atomic_rmw32_xor_u);\n\n// i64.atomic.rmw.xor -> <i64>atomic.xor<i64 from i64>\nfunction builtin_i64_atomic_rmw_xor(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw_xor, builtin_i64_atomic_rmw_xor);\n\n// i32.atomic.rmw8.xchg_u -> <i32>atomic.xchg<u8 from i32>\nfunction builtin_i32_atomic_rmw8_xchg_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw8_xchg_u, builtin_i32_atomic_rmw8_xchg_u);\n\n// i32.atomic.rmw16.xchg_u -> <i32>atomic.xchg<u16 from i32>\nfunction builtin_i32_atomic_rmw16_xchg_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw16_xchg_u, builtin_i32_atomic_rmw16_xchg_u);\n\n// i32.atomic.rmw.xchg -> <i32>atomic.xchg<i32 from i32>\nfunction builtin_i32_atomic_rmw_xchg(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw_xchg, builtin_i32_atomic_rmw_xchg);\n\n// i64.atomic.rmw8.xchg_u -> <i64>atomic.xchg<u8 from i64>\nfunction builtin_i64_atomic_rmw8_xchg_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw8_xchg_u, builtin_i64_atomic_rmw8_xchg_u);\n\n// i64.atomic.rmw16.xchg_u -> <i64>atomic.xchg<u16 from i64>\nfunction builtin_i64_atomic_rmw16_xchg_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw16_xchg_u, builtin_i64_atomic_rmw16_xchg_u);\n\n// i64.atomic.rmw32.xchg_u -> <i64>atomic.xchg<u32 from i64>\nfunction builtin_i64_atomic_rmw32_xchg_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw32_xchg_u, builtin_i64_atomic_rmw32_xchg_u);\n\n// i64.atomic.rmw.xchg -> <i64>atomic.xchg<i64 from i64>\nfunction builtin_i64_atomic_rmw_xchg(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw_xchg, builtin_i64_atomic_rmw_xchg);\n\n// i32.atomic.rmw8.cmpxchg_u -> <i32>atomic.cmpxchg<u8 from i32>\nfunction builtin_i32_atomic_rmw8_cmpxchg_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw8_cmpxchg_u, builtin_i32_atomic_rmw8_cmpxchg_u);\n\n// i32.atomic.rmw16.cmpxchg_u -> <i32>atomic.cmpxchg<u16 from i32>\nfunction builtin_i32_atomic_rmw16_cmpxchg_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw16_cmpxchg_u, builtin_i32_atomic_rmw16_cmpxchg_u);\n\n// i32.atomic.rmw.cmpxchg -> <i32>atomic.cmpxchg<i32 from i32>\nfunction builtin_i32_atomic_rmw_cmpxchg(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw_cmpxchg, builtin_i32_atomic_rmw_cmpxchg);\n\n// i64.atomic.rmw8.cmpxchg_u -> <i64>atomic.cmpxchg<u8 from i64>\nfunction builtin_i64_atomic_rmw8_cmpxchg_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw8_cmpxchg_u, builtin_i64_atomic_rmw8_cmpxchg_u);\n\n// i64.atomic.rmw16.cmpxchg_u -> <i64>atomic.cmpxchg<u16 from i64>\nfunction builtin_i64_atomic_rmw16_cmpxchg_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw16_cmpxchg_u, builtin_i64_atomic_rmw16_cmpxchg_u);\n\n// i64.atomic.rmw32.cmpxchg_u -> <i64>atomic.cmpxchg<u32 from i64>\nfunction builtin_i64_atomic_rmw32_cmpxchg_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw32_cmpxchg_u, builtin_i64_atomic_rmw32_cmpxchg_u);\n\n// i64.atomic.rmw.cmpxchg -> <i64>atomic.cmpxchg<i64 from i64>\nfunction builtin_i64_atomic_rmw_cmpxchg(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw_cmpxchg, builtin_i64_atomic_rmw_cmpxchg);\n\n// memory.atomic.wait32 -> atomic.wait<i32>\nfunction builtin_memory_atomic_wait32(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  return builtin_atomic_wait(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.memory_atomic_wait32, builtin_memory_atomic_wait32);\n\n// memory.atomic.wait64 -> atomic.wait<i64>\nfunction builtin_memory_atomic_wait64(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i32;\n  return builtin_atomic_wait(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.memory_atomic_wait64, builtin_memory_atomic_wait64);\n\n// v128.load -> load<v128>\nfunction builtin_v128_load(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.v128 ];\n  ctx.contextualType = Type.v128;\n  return builtin_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_load, builtin_v128_load);\n\n// v128.load8x8_s -> v128.load_ext<i8>\nfunction builtin_v128_load8x8_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_load8x8_s, builtin_v128_load8x8_s);\n\n// v128.load8x8_u -> v128.load_ext<u8>\nfunction builtin_v128_load8x8_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_load8x8_u, builtin_v128_load8x8_u);\n\n// v128.load16x4_s -> v128.load_ext<i16>\nfunction builtin_v128_load16x4_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_load16x4_s, builtin_v128_load16x4_s);\n\n// v128.load16x4_u -> v128.load_ext<u16>\nfunction builtin_v128_load16x4_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_load16x4_u, builtin_v128_load16x4_u);\n\n// v128.load32x2_s -> v128.load_ext<i32>\nfunction builtin_v128_load32x2_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_load32x2_s, builtin_v128_load32x2_s);\n\n// v128.load32x2_u -> v128.load_ext<u32>\nfunction builtin_v128_load32x2_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_load32x2_u, builtin_v128_load32x2_u);\n\n// v128.load8_splat -> v128.load_splat<u8>\nfunction builtin_v128_load8_splat(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_splat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_load8_splat, builtin_v128_load8_splat);\n\n// v128.load16_splat -> v128.load_splat<u16>\nfunction builtin_v128_load16_splat(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_splat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_load16_splat, builtin_v128_load16_splat);\n\n// v128.load32_splat -> v128.load_splat<u32>\nfunction builtin_v128_load32_splat(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_splat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_load32_splat, builtin_v128_load32_splat);\n\n// v128.load64_splat -> v128.load_splat<u64>\nfunction builtin_v128_load64_splat(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_splat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_load64_splat, builtin_v128_load64_splat);\n\n// v128.load32_zero -> v128.load_zero<u32>\nfunction builtin_v128_load32_zero(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_zero(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_load32_zero, builtin_v128_load32_zero);\n\n// v128.load64_zero -> v128.load_zero<u64>\nfunction builtin_v128_load64_zero(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_zero(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_load64_zero, builtin_v128_load64_zero);\n\n// v128.load8_lane -> v128.load_lane<u8>\nfunction builtin_v128_load8_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_load8_lane, builtin_v128_load8_lane);\n\n// v128.load16_lane -> v128.load_lane<u16>\nfunction builtin_v128_load16_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_load16_lane, builtin_v128_load16_lane);\n\n// v128.load32_lane -> v128.load_lane<u32>\nfunction builtin_v128_load32_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_load32_lane, builtin_v128_load32_lane);\n\n// v128.load64_lane -> v128.load_lane<u64>\nfunction builtin_v128_load64_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_load64_lane, builtin_v128_load64_lane);\n\n// v128.store8_lane -> v128.store_lane<u8>\nfunction builtin_v128_store8_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_store_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_store8_lane, builtin_v128_store8_lane);\n\n// v128.store16_lane -> v128.store_lane<u16>\nfunction builtin_v128_store16_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_store_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_store16_lane, builtin_v128_store16_lane);\n\n// v128.store32_lane -> v128.store_lane<u32>\nfunction builtin_v128_store32_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_store_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_store32_lane, builtin_v128_store32_lane);\n\n// v128.store64_lane -> v128.store_lane<u64>\nfunction builtin_v128_store64_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_store_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_store64_lane, builtin_v128_store64_lane);\n\n// v128.store -> store<v128 from v128>\nfunction builtin_v128_store(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.v128 ];\n  ctx.contextualType = Type.v128;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_store, builtin_v128_store);\n\n// i8x16_splat -> v128.splat<i8>\nfunction builtin_i8x16_splat(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_splat, builtin_i8x16_splat);\n\n// i8x16.extract_lane_s -> <i32>v128.extract_lane<i8>\nfunction builtin_i8x16_extract_lane_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_extract_lane_s, builtin_i8x16_extract_lane_s);\n\n// i8x16.extract_lane_u -> <i32>v128.extract_lane<u8>\nfunction builtin_i8x16_extract_lane_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_extract_lane_u, builtin_i8x16_extract_lane_u);\n\n// i8x16.replace_lane -> v128.replace_lane<i8>\nfunction builtin_i8x16_replace_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_replace_lane, builtin_i8x16_replace_lane);\n\n// i8x16.add -> v128.add<i8>\nfunction builtin_i8x16_add(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_add, builtin_i8x16_add);\n\n// i8x16.sub -> v128.sub<i8>\nfunction builtin_i8x16_sub(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_sub, builtin_i8x16_sub);\n\n// i8x16.min_s -> v128.min<i8>\nfunction builtin_i8x16_min_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_min_s, builtin_i8x16_min_s);\n\n// i8x16.min_u -> v128.min<u8>\nfunction builtin_i8x16_min_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_min_u, builtin_i8x16_min_u);\n\n// i8x16.max_s -> v128.max<i8>\nfunction builtin_i8x16_max_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_max_s, builtin_i8x16_max_s);\n\n// i8x16.max_u -> v128.max<u8>\nfunction builtin_i8x16_max_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_max_u, builtin_i8x16_max_u);\n\n// i8x16.avgr_u -> v128.avgr<u8>\nfunction builtin_i8x16_avgr_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_avgr(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_avgr_u, builtin_i8x16_avgr_u);\n\n// i8x16.abs -> v128.abs<i8>\nfunction builtin_i8x16_abs(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_abs, builtin_i8x16_abs);\n\n// i8x16.neg -> v128.neg<i8>\nfunction builtin_i8x16_neg(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_neg, builtin_i8x16_neg);\n\n// i8x16.add_sat_s -> v128.add_sat<i8>\nfunction builtin_i8x16_add_sat_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add_sat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_add_sat_s, builtin_i8x16_add_sat_s);\n\n// i8x16.add_sat_u -> v128.add_sat<u8>\nfunction builtin_i8x16_add_sat_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add_sat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_add_sat_u, builtin_i8x16_add_sat_u);\n\n// i8x16.sub_sat_s -> v128.sub_sat<i8>\nfunction builtin_i8x16_sub_sat_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub_sat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_sub_sat_s, builtin_i8x16_sub_sat_s);\n\n// i8x16.sub_sat_u -> v128.sub_sat<u8>\nfunction builtin_i8x16_sub_sat_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub_sat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_sub_sat_u, builtin_i8x16_sub_sat_u);\n\n// i8x16.shl -> v128.shl<i8>\nfunction builtin_i8x16_shl(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shl(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_shl, builtin_i8x16_shl);\n\n// i8x16.shr_s -> v128.shr<i8>\nfunction builtin_i8x16_shr_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_shr_s, builtin_i8x16_shr_s);\n\n// i8x16.shr_u -> v128.shr<u8>\nfunction builtin_i8x16_shr_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_shr_u, builtin_i8x16_shr_u);\n\n// i8x16.all_true -> v128.all_true<i8>\nfunction builtin_i8x16_all_true(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_all_true(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_all_true, builtin_i8x16_all_true);\n\n// i8x16.bitmask -> v128.bitmask<i8>\nfunction builtin_i8x16_bitmask(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_bitmask(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_bitmask, builtin_i8x16_bitmask);\n\n// i8x16.popcnt -> v128.popcnt<i8>\nfunction builtin_i8x16_popcnt(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_popcnt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_popcnt, builtin_i8x16_popcnt);\n\n// i8x16.eq -> v128.eq<i8>\nfunction builtin_i8x16_eq(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_eq, builtin_i8x16_eq);\n\n// i8x16.ne -> v128.ne<i8>\nfunction builtin_i8x16_ne(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_ne, builtin_i8x16_ne);\n\n// i8x16.lt_s -> v128.lt<i8>\nfunction builtin_i8x16_lt_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_lt_s, builtin_i8x16_lt_s);\n\n// i8x16.lt_u -> v128.lt<u8>\nfunction builtin_i8x16_lt_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_lt_u, builtin_i8x16_lt_u);\n\n// i8x16.le_s -> v128.le<i8>\nfunction builtin_i8x16_le_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_le_s, builtin_i8x16_le_s);\n\n// i8x16.le_u -> v128.le<u8>\nfunction builtin_i8x16_le_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_le_u, builtin_i8x16_le_u);\n\n// i8x16.gt_s -> v128.gt<i8>\nfunction builtin_i8x16_gt_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_gt_s, builtin_i8x16_gt_s);\n\n// i8x16.gt_u -> v128.gt<u8>\nfunction builtin_i8x16_gt_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_gt_u, builtin_i8x16_gt_u);\n\n// i8x16.ge_s -> v128.ge<i8>\nfunction builtin_i8x16_ge_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_ge_s, builtin_i8x16_ge_s);\n\n// i8x16.ge_u -> v128.ge<u8>\nfunction builtin_i8x16_ge_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_ge_u, builtin_i8x16_ge_u);\n\n// i8x16.narrow_i16x8_s -> v128.narrow<i16>\nfunction builtin_i8x16_narrow_i16x8_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_narrow(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_narrow_i16x8_s, builtin_i8x16_narrow_i16x8_s);\n\n// i8x16.narrow_i16x8_u -> v128.narrow<u16>\nfunction builtin_i8x16_narrow_i16x8_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_narrow(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_narrow_i16x8_u, builtin_i8x16_narrow_i16x8_u);\n\n// i8x16.shuffle -> v128.shuffle<i8>\nfunction builtin_i8x16_shuffle(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shuffle(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_shuffle, builtin_i8x16_shuffle);\n\n// i8x16.swizzle -> v128.swizzle\nfunction builtin_i8x16_swizzle(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = null;\n  ctx.contextualType = Type.v128;\n  return builtin_v128_swizzle(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_swizzle, builtin_i8x16_swizzle);\n\n// i16x8.splat -> v128.splat<i16>\nfunction builtin_i16x8_splat(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_splat, builtin_i16x8_splat);\n\n// i16x8.extract_lane_s -> v128.extract_lane<i16>\nfunction builtin_i16x8_extract_lane_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_extract_lane_s, builtin_i16x8_extract_lane_s);\n\n// i16x8..extract_lane_u -> v128.extract_lane<u16>\nfunction builtin_i16x8_extract_lane_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_extract_lane_u, builtin_i16x8_extract_lane_u);\n\n// i16x8.replace_lane -> v128.replace_lane<i16>\nfunction builtin_i16x8_replace_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_replace_lane, builtin_i16x8_replace_lane);\n\n// i16x8.add -> v128.add<i16>\nfunction builtin_i16x8_add(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_add, builtin_i16x8_add);\n\n// i16x8.sub -> v128.sub<i16>\nfunction builtin_i16x8_sub(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_sub, builtin_i16x8_sub);\n\n// i16x8.mul -> v128.mul<i16>\nfunction builtin_i16x8_mul(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_mul(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_mul, builtin_i16x8_mul);\n\n// i16x8.min_s -> v128.min<i16>\nfunction builtin_i16x8_min_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_min_s, builtin_i16x8_min_s);\n\n// i16x8.min_u -> v128.min<u16>\nfunction builtin_i16x8_min_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_min_u, builtin_i16x8_min_u);\n\n// i16x8.max_s -> v128.max<i16>\nfunction builtin_i16x8_max_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_max_s, builtin_i16x8_max_s);\n\n// i16x8.max_u -> v128.max<u16>\nfunction builtin_i16x8_max_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_max_u, builtin_i16x8_max_u);\n\n// i16x8.avgr_u -> v128.avgr<u16>\nfunction builtin_i16x8_avgr_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_avgr(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_avgr_u, builtin_i16x8_avgr_u);\n\n// i16x8.abs -> v128.abs<i16>\nfunction builtin_i16x8_abs(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_abs, builtin_i16x8_abs);\n\n// i16x8.neg -> v128.neg<i16>\nfunction builtin_i16x8_neg(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_neg, builtin_i16x8_neg);\n\n// i16x8.add_sat_s -> v128.add_sat<i16>\nfunction builtin_i16x8_add_sat_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add_sat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_add_sat_s, builtin_i16x8_add_sat_s);\n\n// i16x8.add_sat_u -> v128.add_sat<u16>\nfunction builtin_i16x8_add_sat_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add_sat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_add_sat_u, builtin_i16x8_add_sat_u);\n\n// i16x8.sub_sat_s -> v128.sub_sat<i16>\nfunction builtin_i16x8_sub_sat_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub_sat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_sub_sat_s, builtin_i16x8_sub_sat_s);\n\n// i16x8.sub_sat_u -> v128.sub_sat<u16>\nfunction builtin_i16x8_sub_sat_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub_sat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_sub_sat_u, builtin_i16x8_sub_sat_u);\n\n// i16x8.shl -> v128.shl<i16>\nfunction builtin_i16x8_shl(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shl(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_shl, builtin_i16x8_shl);\n\n// i16x8.shr_s -> v128.shr<i16>\nfunction builtin_i16x8_shr_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_shr_s, builtin_i16x8_shr_s);\n\n// i16x8.shr_u -> v128.shr<u16>\nfunction builtin_i16x8_shr_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_shr_u, builtin_i16x8_shr_u);\n\n// i16x8.all_true -> v128.all_true<i16>\nfunction builtin_i16x8_all_true(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_all_true(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_all_true, builtin_i16x8_all_true);\n\n// i16x8.bitmask -> v128.bitmask<i16>\nfunction builtin_i16x8_bitmask(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_bitmask(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_bitmask, builtin_i16x8_bitmask);\n\n// i16x8.eq -> v128.eq<i16>\nfunction builtin_i16x8_eq(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_eq, builtin_i16x8_eq);\n\n// i16x8.ne -> v128.ne<i16>\nfunction builtin_i16x8_ne(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_ne, builtin_i16x8_ne);\n\n// i16x8.lt_s -> v128.lt<i16>\nfunction builtin_i16x8_lt_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_lt_s, builtin_i16x8_lt_s);\n\n// i16x8.lt_u -> v128.lt<u16>\nfunction builtin_i16x8_lt_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_lt_u, builtin_i16x8_lt_u);\n\n// i16x8.le_s -> v128.le<i16>\nfunction builtin_i16x8_le_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_le_s, builtin_i16x8_le_s);\n\n// i16x8.le_u -> v128.le<u16>\nfunction builtin_i16x8_le_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_le_u, builtin_i16x8_le_u);\n\n// i16x8.gt_s -> v128.gt<i16>\nfunction builtin_i16x8_gt_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_gt_s, builtin_i16x8_gt_s);\n\n// i16x8.gt_u -> v128.gt<u16>\nfunction builtin_i16x8_gt_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_gt_u, builtin_i16x8_gt_u);\n\n// i16x8.ge_s -> v128.ge<i16>\nfunction builtin_i16x8_ge_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_ge_s, builtin_i16x8_ge_s);\n\n// i16x8.ge_u -> v128.ge<u16>\nfunction builtin_i16x8_ge_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_ge_u, builtin_i16x8_ge_u);\n\n// i16x8.narrow_i32x4_s -> v128.narrow<i32>\nfunction builtin_i16x8_narrow_i32x4_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_narrow(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_narrow_i32x4_s, builtin_i16x8_narrow_i32x4_s);\n\n// i16x8.narrow_i32x4_u -> v128.narrow<u32>\nfunction builtin_i16x8_narrow_i32x4_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_narrow(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_narrow_i32x4_u, builtin_i16x8_narrow_i32x4_u);\n\n// i16x8.extend_low_i8x16_s -> v128.extend_low<i8>\nfunction builtin_i16x8_extend_low_i8x16_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_low(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_extend_low_i8x16_s, builtin_i16x8_extend_low_i8x16_s);\n\n// i16x8.extend_low_i8x16_u -> v128.extend_low<u8>\nfunction builtin_i16x8_extend_low_i8x16_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_low(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_extend_low_i8x16_u, builtin_i16x8_extend_low_i8x16_u);\n\n// i16x8.extend_high_i8x16_s -> v128.extend_high<i8>\nfunction builtin_i16x8_extend_high_i8x16_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_high(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_extend_high_i8x16_s, builtin_i16x8_extend_high_i8x16_s);\n\n// i16x8.extend_high_i8x16_u -> v128.extend_high<u8>\nfunction builtin_i16x8_extend_high_i8x16_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_high(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_extend_high_i8x16_u, builtin_i16x8_extend_high_i8x16_u);\n\n// i16x8.extadd_pairwise_i8x16_s -> v128.extadd_pairwise<i8>\nfunction builtin_i16x8_extadd_pairwise_i8x16_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extadd_pairwise(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_extadd_pairwise_i8x16_s, builtin_i16x8_extadd_pairwise_i8x16_s);\n\n// i16x8.extadd_pairwise_i8x16_u -> v128.extadd_pairwise<u8>\nfunction builtin_i16x8_extadd_pairwise_i8x16_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extadd_pairwise(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_extadd_pairwise_i8x16_u, builtin_i16x8_extadd_pairwise_i8x16_u);\n\n// i16x8.q15mulr_sat_s -> v128.q15mulr_sat<i16>\nfunction builtin_i16x8_q15mulr_sat_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_q15mulr_sat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_q15mulr_sat_s, builtin_i16x8_q15mulr_sat_s);\n\n// i16x8.extmul_low_i8x16_s -> v128.extmul_low<i16>\nfunction builtin_i16x8_extmul_low_i8x16_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_low(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_extmul_low_i8x16_s, builtin_i16x8_extmul_low_i8x16_s);\n\n// i16x8.extmul_low_i8x16_u -> v128.extmul_low<u16>\nfunction builtin_i16x8_extmul_low_i8x16_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_low(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_extmul_low_i8x16_u, builtin_i16x8_extmul_low_i8x16_u);\n\n// i16x8.extmul_high_i8x16_s -> v128.extmul_high<i16>\nfunction builtin_i16x8_extmul_high_i8x16_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_high(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_extmul_high_i8x16_s, builtin_i16x8_extmul_high_i8x16_s);\n\n// i16x8.extmul_high_i8x16_u -> v128.extmul_high<u16>\nfunction builtin_i16x8_extmul_high_i8x16_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_high(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_extmul_high_i8x16_u, builtin_i16x8_extmul_high_i8x16_u);\n\n// i16x8.shuffle -> v128.shuffle<i16>\nfunction builtin_i16x8_shuffle(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shuffle(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_shuffle, builtin_i16x8_shuffle);\n\n// i32x4.splat -> v128.splat<i32>\nfunction builtin_i32x4_splat(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_splat, builtin_i32x4_splat);\n\n// i32x4.extract_lane -> <i32>v128.extract_lane<i32>\nfunction builtin_i32x4_extract_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_extract_lane, builtin_i32x4_extract_lane);\n\n// i32x4.replace_lane -> v128.replace_lane<i32>\nfunction builtin_i32x4_replace_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_replace_lane, builtin_i32x4_replace_lane);\n\n// i32x4.add -> v128.add<i32>\nfunction builtin_i32x4_add(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_add, builtin_i32x4_add);\n\n// i32x4.sub -> v128.sub<i32>\nfunction builtin_i32x4_sub(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_sub, builtin_i32x4_sub);\n\n// i32x4.mul -> v128.mul<i32>\nfunction builtin_i32x4_mul(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_mul(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_mul, builtin_i32x4_mul);\n\n// i32x4.min_s -> v128.min<i32>\nfunction builtin_i32x4_min_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_min_s, builtin_i32x4_min_s);\n\n// i32x4.min_u -> v128.min<u32>\nfunction builtin_i32x4_min_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_min_u, builtin_i32x4_min_u);\n\n// i32x4.max_s -> v128.max<i32>\nfunction builtin_i32x4_max_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_max_s, builtin_i32x4_max_s);\n\n// i32x4.max_u -> v128.max<u32>\nfunction builtin_i32x4_max_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_max_u, builtin_i32x4_max_u);\n\n// i32x4.dot_i16x8_s -> v128.dot<i16>\nfunction builtin_i32x4_dot_i16x8_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_dot(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_dot_i16x8_s, builtin_i32x4_dot_i16x8_s);\n\n// i32x4.abs -> v128.abs<i32>\nfunction builtin_i32x4_abs(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_abs, builtin_i32x4_abs);\n\n// i32x4.neg -> v128.neg<i32>\nfunction builtin_i32x4_neg(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_neg, builtin_i32x4_neg);\n\n// i32x4.shl -> v128.shl<i32>\nfunction builtin_i32x4_shl(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shl(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_shl, builtin_i32x4_shl);\n\n// i32x4.shr_s -> v128.shr<i32>\nfunction builtin_i32x4_shr_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_shr_s, builtin_i32x4_shr_s);\n\n// i32x4.shr_u -> v128.shr<u32>\nfunction builtin_i32x4_shr_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_shr_u, builtin_i32x4_shr_u);\n\n// i32x4.all_true -> v128.all_true<i32>\nfunction builtin_i32x4_all_true(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_all_true(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_all_true, builtin_i32x4_all_true);\n\n// i32x4.bitmask -> v128.bitmask<i32>\nfunction builtin_i32x4_bitmask(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_bitmask(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_bitmask, builtin_i32x4_bitmask);\n\n// i32x4.eq -> v128.eq<i32>\nfunction builtin_i32x4_eq(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_eq, builtin_i32x4_eq);\n\n// i32x4.ne -> v128.ne<i32>\nfunction builtin_i32x4_ne(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_ne, builtin_i32x4_ne);\n\n// i32x4.lt_s -> v128.lt<i32>\nfunction builtin_i32x4_lt_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_lt_s, builtin_i32x4_lt_s);\n\n// i32x4.lt_u -> v128.lt<u32>\nfunction builtin_i32x4_lt_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_lt_u, builtin_i32x4_lt_u);\n\n// i32x4.le_s -> v128.le<i32>\nfunction builtin_i32x4_le_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_le_s, builtin_i32x4_le_s);\n\n// i32x4.le_u -> v128.le<u32>\nfunction builtin_i32x4_le_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_le_u, builtin_i32x4_le_u);\n\n// i32x4.gt_s -> v128.gt<i32>\nfunction builtin_i32x4_gt_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_gt_s, builtin_i32x4_gt_s);\n\n// i32x4.gt_u -> v128.gt<u32>\nfunction builtin_i32x4_gt_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_gt_u, builtin_i32x4_gt_u);\n\n// i32x4.ge_s -> v128.ge<i32>\nfunction builtin_i32x4_ge_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_ge_s, builtin_i32x4_ge_s);\n\n// i32x4.ge_u -> v128.ge<u32>\nfunction builtin_i32x4_ge_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_ge_u, builtin_i32x4_ge_u);\n\n// i32x4.trunc_sat_f32x4_s -> v128.trunc_sat<i32>\nfunction builtin_i32x4_trunc_sat_f32x4_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc_sat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_trunc_sat_f32x4_s, builtin_i32x4_trunc_sat_f32x4_s);\n\n// i32x4.trunc_sat_f32x4_u -> v128.trunc_sat<u32>\nfunction builtin_i32x4_trunc_sat_f32x4_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc_sat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_trunc_sat_f32x4_u, builtin_i32x4_trunc_sat_f32x4_u);\n\n// i32x4.trunc_sat_f64x2_s_zero -> v128.trunc_sat_zero<i32>\nfunction builtin_i32x4_trunc_sat_f64x2_s_zero(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc_sat_zero(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_trunc_sat_f64x2_s_zero, builtin_i32x4_trunc_sat_f64x2_s_zero);\n\n// i32x4.trunc_sat_f64x2_u_zero -> v128.trunc_sat_zero<u32>\nfunction builtin_i32x4_trunc_sat_f64x2_u_zero(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc_sat_zero(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_trunc_sat_f64x2_u_zero, builtin_i32x4_trunc_sat_f64x2_u_zero);\n\n// i32x4.extend_low_i16x8_s -> // v128.extend_low<i16>\nfunction builtin_i32x4_extend_low_i16x8_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_low(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_extend_low_i16x8_s, builtin_i32x4_extend_low_i16x8_s);\n\n// i32x4.extend_low_i16x8_u -> v128.extend_low<u16>\nfunction builtin_i32x4_extend_low_i16x8_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_low(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_extend_low_i16x8_u, builtin_i32x4_extend_low_i16x8_u);\n\n// i32x4.extend_high_i16x8_s -> v128.extend_high<i16>\nfunction builtin_i32x4_extend_high_i16x8_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_high(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_extend_high_i16x8_s, builtin_i32x4_extend_high_i16x8_s);\n\n// i32x4.extend_high_i16x8_u -> v128.extend_high<u16>\nfunction builtin_i32x4_extend_high_i16x8_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_high(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_extend_high_i16x8_u, builtin_i32x4_extend_high_i16x8_u);\n\n// i32x4.extadd_pairwise_i16x8_s -> v128.extadd_pairwise<i16>\nfunction builtin_i32x4_extadd_pairwise_i16x8_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extadd_pairwise(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_extadd_pairwise_i16x8_s, builtin_i32x4_extadd_pairwise_i16x8_s);\n\n// i32x4.extadd_pairwise_i16x8_u -> v128.extadd_pairwise<u16>\nfunction builtin_i32x4_extadd_pairwise_i16x8_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extadd_pairwise(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_extadd_pairwise_i16x8_u, builtin_i32x4_extadd_pairwise_i16x8_u);\n\n// i32x4.extmul_low_i16x8_s -> v128.extmul_low<i16>\nfunction builtin_i32x4_extmul_low_i16x8_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_low(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_extmul_low_i16x8_s, builtin_i32x4_extmul_low_i16x8_s);\n\n// i32x4.extmul_low_i16x8_u -> v128.extmul_low<u16>\nfunction builtin_i32x4_extmul_low_i16x8_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_low(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_extmul_low_i16x8_u, builtin_i32x4_extmul_low_i16x8_u);\n\n// i32x4.extmul_high_i16x8_s -> v128.extmul_high<i16>\nfunction builtin_i32x4_extmul_high_i16x8_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_high(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_extmul_high_i16x8_s, builtin_i32x4_extmul_high_i16x8_s);\n\n// i32x4.extmul_high_i16x8_u -> v128.extmul_high<u16>\nfunction builtin_i32x4_extmul_high_i16x8_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_high(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_extmul_high_i16x8_u, builtin_i32x4_extmul_high_i16x8_u);\n\n// i32x4.shuffle -> v128.shuffle<i32>\nfunction builtin_i32x4_shuffle(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shuffle(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_shuffle, builtin_i32x4_shuffle);\n\n// i64x2.splat -> v128.splat<i64>\nfunction builtin_i64x2_splat(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_splat, builtin_i64x2_splat);\n\n// i64x2.extract_lane -> <i64>v128.extract_lane<i64>\nfunction builtin_i64x2_extract_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_extract_lane, builtin_i64x2_extract_lane);\n\n// i64x2.replace_lane -> v128.replace_lane<i64>\nfunction builtin_i64x2_replace_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_replace_lane, builtin_i64x2_replace_lane);\n\n// i64x2.add -> v128.add<i64>\nfunction builtin_i64x2_add(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_add, builtin_i64x2_add);\n\n// i64x2.sub -> v128.sub<i64>\nfunction builtin_i64x2_sub(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_sub, builtin_i64x2_sub);\n\n// i64x2.mul -> v128.mul<i64>\nfunction builtin_i64x2_mul(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_mul(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_mul, builtin_i64x2_mul);\n\n// i64x2.abs -> v128.abs<i64>\nfunction builtin_i64x2_abs(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_abs, builtin_i64x2_abs);\n\n// i64x2.neg -> v128.neg<i64>\nfunction builtin_i64x2_neg(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_neg, builtin_i64x2_neg);\n\n// i64x2.shl -> v128.shl<i64>\nfunction builtin_i64x2_shl(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shl(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_shl, builtin_i64x2_shl);\n\n// i64x2.shr_s -> v128.shr<i64>\nfunction builtin_i64x2_shr_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_shr_s, builtin_i64x2_shr_s);\n\n// i64x2.shr_u -> v128.shr<u64>\nfunction builtin_i64x2_shr_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_shr_u, builtin_i64x2_shr_u);\n\n// i64x2.all_true -> v128.all_true<i64>\nfunction builtin_i64x2_all_true(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_all_true(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_all_true, builtin_i64x2_all_true);\n\n// i64x2.bitmask -> v128.bitmask<i64>\nfunction builtin_i64x2_bitmask(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_bitmask(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_bitmask, builtin_i64x2_bitmask);\n\n// i64x2.eq -> v128.eq<i64>\nfunction builtin_i64x2_eq(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_eq, builtin_i64x2_eq);\n\n// i64x2.ne -> v128.ne<i64>\nfunction builtin_i64x2_ne(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_ne, builtin_i64x2_ne);\n\n// i64x2.lt_s -> v128.lt<i64>\nfunction builtin_i64x2_lt_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_lt_s, builtin_i64x2_lt_s);\n\n// i64x2.le_s -> v128.le<i64>\nfunction builtin_i64x2_le_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_le_s, builtin_i64x2_le_s);\n\n// i64x2.gt_s -> v128.gt<i64>\nfunction builtin_i64x2_gt_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_gt_s, builtin_i64x2_gt_s);\n\n// i64x2.ge_s -> v128.ge<i64>\nfunction builtin_i64x2_ge_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_ge_s, builtin_i64x2_ge_s);\n\n// i64x2.extend_low_i32x4_s -> // v128.extend_low<i32>\nfunction builtin_i64x2_extend_low_i32x4_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_low(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_extend_low_i32x4_s, builtin_i64x2_extend_low_i32x4_s);\n\n// i64x2.extend_low_i32x4_u -> v128.extend_low<u32>\nfunction builtin_i64x2_extend_low_i32x4_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_low(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_extend_low_i32x4_u, builtin_i64x2_extend_low_i32x4_u);\n\n// i64x2.extend_high_i32x4_s -> v128.extend_high<i32>\nfunction builtin_i64x2_extend_high_i32x4_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_high(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_extend_high_i32x4_s, builtin_i64x2_extend_high_i32x4_s);\n\n// i64x2.extend_high_i32x4_u -> v128.extend_high<u32>\nfunction builtin_i64x2_extend_high_i32x4_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_high(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_extend_high_i32x4_u, builtin_i64x2_extend_high_i32x4_u);\n\n// i64x2.extmul_low_i32x4_s -> v128.extmul_low<i32>\nfunction builtin_i64x2_extmul_low_i32x4_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_low(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_extmul_low_i32x4_s, builtin_i64x2_extmul_low_i32x4_s);\n\n// i64x2.extmul_low_i32x4_u -> v128.extmul_low<u32>\nfunction builtin_i64x2_extmul_low_i32x4_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_low(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_extmul_low_i32x4_u, builtin_i64x2_extmul_low_i32x4_u);\n\n// i64x2.extmul_high_i32x4_s -> v128.extmul_high<i32>\nfunction builtin_i64x2_extmul_high_i32x4_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_high(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_extmul_high_i32x4_s, builtin_i64x2_extmul_high_i32x4_s);\n\n// i64x2.extmul_high_i32x4_u -> v128.extmul_high<u32>\nfunction builtin_i64x2_extmul_high_i32x4_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_high(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_extmul_high_i32x4_u, builtin_i64x2_extmul_high_i32x4_u);\n\n// i64x2.shuffle -> v128.shuffle<i64>\nfunction builtin_i64x2_shuffle(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shuffle(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_shuffle, builtin_i64x2_shuffle);\n\n// f32x4.splat -> v128.splat<f32>\nfunction builtin_f32x4_splat(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_splat, builtin_f32x4_splat);\n\n// f32x4.extract_lane -> <f32>v128.extract_lane<f32>\nfunction builtin_f32x4_extract_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_extract_lane, builtin_f32x4_extract_lane);\n\n// f32x4.replace_lane -> v128.replace_lane<f32>\nfunction builtin_f32x4_replace_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_replace_lane, builtin_f32x4_replace_lane);\n\n// f32x4.add -> v128.add<f32>\nfunction builtin_f32x4_add(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_add, builtin_f32x4_add);\n\n// f32x4.sub -> v128.sub<f32>\nfunction builtin_f32x4_sub(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_sub, builtin_f32x4_sub);\n\n// f32x4.mul -> v128.mul<f32>\nfunction builtin_f32x4_mul(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_mul(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_mul, builtin_f32x4_mul);\n\n// f32x4.div -> v128.div<f32>\nfunction builtin_f32x4_div(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_div(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_div, builtin_f32x4_div);\n\n// f32x4.neg -> v128.neg<f32>\nfunction builtin_f32x4_neg(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_neg, builtin_f32x4_neg);\n\n// f32x4.min -> v128.min<f32>\nfunction builtin_f32x4_min(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_min, builtin_f32x4_min);\n\n// f32x4.max -> v128.max<f32>\nfunction builtin_f32x4_max(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_max, builtin_f32x4_max);\n\n// f32x4.pmin -> v128.pmin<f32>\nfunction builtin_f32x4_pmin(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_pmin(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_pmin, builtin_f32x4_pmin);\n\n// f32x4.pmax -> v128.pmax<f32>\nfunction builtin_f32x4_pmax(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_pmax(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_pmax, builtin_f32x4_pmax);\n\n// f32x4.abs -> v128.abs<f32>\nfunction builtin_f32x4_abs(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_abs, builtin_f32x4_abs);\n\n// f32x4.sqrt -> v128.sqrt<f32>\nfunction builtin_f32x4_sqrt(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sqrt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_sqrt, builtin_f32x4_sqrt);\n\n// f32x4.ceil -> v128.ceil<f32>\nfunction builtin_f32x4_ceil(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ceil(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_ceil, builtin_f32x4_ceil);\n\n// f32x4.floor -> v128.floor<f32>\nfunction builtin_f32x4_floor(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_floor(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_floor, builtin_f32x4_floor);\n\n// f32x4.trunc -> v128.trunc<f32>\nfunction builtin_f32x4_trunc(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_trunc, builtin_f32x4_trunc);\n\n// f32x4.nearest -> v128.nearest<f32>\nfunction builtin_f32x4_nearest(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_nearest(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_nearest, builtin_f32x4_nearest);\n\n// f32x4.eq -> v128.eq<f32>\nfunction builtin_f32x4_eq(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_eq, builtin_f32x4_eq);\n\n// f32x4.ne -> v128.ne<f32>\nfunction builtin_f32x4_ne(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_ne, builtin_f32x4_ne);\n\n// f32x4.lt -> v128.lt<f32>\nfunction builtin_f32x4_lt(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_lt, builtin_f32x4_lt);\n\n// f32x4.le -> v128.le<f32>\nfunction builtin_f32x4_le(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_le, builtin_f32x4_le);\n\n// f32x4.gt -> v128.gt<f32>\nfunction builtin_f32x4_gt(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_gt, builtin_f32x4_gt);\n\n// f32x4.ge -> v128.ge<f32>\nfunction builtin_f32x4_ge(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_ge, builtin_f32x4_ge);\n\n// f32x4.convert_i32x4_s -> v128.convert<i32>\nfunction builtin_f32x4_convert_i32x4_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_convert(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_convert_i32x4_s, builtin_f32x4_convert_i32x4_s);\n\n// f32x4.convert_i32x4_u -> v128.convert<u32>\nfunction builtin_f32x4_convert_i32x4_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_convert(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_convert_i32x4_u, builtin_f32x4_convert_i32x4_u);\n\n// f32x4.demote_f64x2_zero -> v128.demote_zero<f64>\nfunction builtin_f32x4_demote_f64x2_zero(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_demote_zero(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_demote_f64x2_zero, builtin_f32x4_demote_f64x2_zero);\n\n// f32x4.shuffle -> v128.shuffle<f32>\nfunction builtin_f32x4_shuffle(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shuffle(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_shuffle, builtin_f32x4_shuffle);\n\n// f64x2.splat -> v128.splat<f64>\nfunction builtin_f64x2_splat(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_splat, builtin_f64x2_splat);\n\n// f64x2.extract_lane -> <f64>v128.extract_lane<f64>\nfunction builtin_f64x2_extract_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_extract_lane, builtin_f64x2_extract_lane);\n\n// f64x2.replace_lane -> v128.replace_lane\nfunction builtin_f64x2_replace_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_replace_lane, builtin_f64x2_replace_lane);\n\n// f64x2.add -> v128.add<f64>\nfunction builtin_f64x2_add(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_add, builtin_f64x2_add);\n\n// f64x2.sub -> v128.sub<f64>\nfunction builtin_f64x2_sub(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_sub, builtin_f64x2_sub);\n\n// f64x2.mul -> v128.mul<f64>\nfunction builtin_f64x2_mul(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_mul(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_mul, builtin_f64x2_mul);\n\n// f64x2.div -> v128.div<f64>\nfunction builtin_f64x2_div(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_div(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_div, builtin_f64x2_div);\n\n// f64x2.neg -> v128.neg<f64>\nfunction builtin_f64x2_neg(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_neg, builtin_f64x2_neg);\n\n// f64x2.min -> v128.min<f64>\nfunction builtin_f64x2_min(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_min, builtin_f64x2_min);\n\n// f64x2.max -> v128.max<f64>\nfunction builtin_f64x2_max(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_max, builtin_f64x2_max);\n\n// f64x2.pmin -> v128.pmin<f64>\nfunction builtin_f64x2_pmin(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_pmin(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_pmin, builtin_f64x2_pmin);\n\n// f64x2.pmax -> v128.pmax<f64>\nfunction builtin_f64x2_pmax(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_pmax(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_pmax, builtin_f64x2_pmax);\n\n// f64x2.abs -> v128.abs<f64>\nfunction builtin_f64x2_abs(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_abs, builtin_f64x2_abs);\n\n// f64x2.sqrt -> v128.sqrt<f64>\nfunction builtin_f64x2_sqrt(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sqrt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_sqrt, builtin_f64x2_sqrt);\n\n// f64x2.ceil -> v128.ceil<f64>\nfunction builtin_f64x2_ceil(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ceil(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_ceil, builtin_f64x2_ceil);\n\n// f64x2.floor -> v128.floor<f64>\nfunction builtin_f64x2_floor(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_floor(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_floor, builtin_f64x2_floor);\n\n// f64x2.trunc -> v128.trunc<f64>\nfunction builtin_f64x2_trunc(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_trunc, builtin_f64x2_trunc);\n\n// f64x2.nearest -> v128.nearest<f64>\nfunction builtin_f64x2_nearest(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_nearest(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_nearest, builtin_f64x2_nearest);\n\n// f64x2.eq -> v128.eq<f64>\nfunction builtin_f64x2_eq(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_eq, builtin_f64x2_eq);\n\n// f64x2.ne -> v128.ne<f64>\nfunction builtin_f64x2_ne(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_ne, builtin_f64x2_ne);\n\n// f64x2.lt -> v128.lt<f64>\nfunction builtin_f64x2_lt(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_lt, builtin_f64x2_lt);\n\n// f64x2.le -> v128.le<f64>\nfunction builtin_f64x2_le(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_le, builtin_f64x2_le);\n\n// f64x2.gt -> v128.gt<f64>\nfunction builtin_f64x2_gt(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_gt, builtin_f64x2_gt);\n\n// f64x2.ge -> v128.ge<f64>\nfunction builtin_f64x2_ge(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_ge, builtin_f64x2_ge);\n\n// f64x2.convert_low_i32x4_s -> v128.convert_low<i32>\nfunction builtin_f64x2_convert_low_i32x4_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_convert_low(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_convert_low_i32x4_s, builtin_f64x2_convert_low_i32x4_s);\n\n// f64x2.convert_low_i32x4_u -> v128.convert_low<u32>\nfunction builtin_f64x2_convert_low_i32x4_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_convert_low(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_convert_low_i32x4_u, builtin_f64x2_convert_low_i32x4_u);\n\n// f64x2.promote_low_f32x4 -> v128.promote_low<f32>\nfunction builtin_f64x4_promote_low_f32x4(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_promote_low(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_promote_low_f32x4, builtin_f64x4_promote_low_f32x4);\n\n// f64x2.shuffle -> v128.shuffle<f32>\nfunction builtin_f64x2_shuffle(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shuffle(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_shuffle, builtin_f64x2_shuffle);\n\n// i8x16.relaxed_swizzle -> v128.relaxed_swizzle\nfunction builtin_i8x16_relaxed_swizzle(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = null;\n  ctx.contextualType = Type.v128;\n  return builtin_v128_relaxed_swizzle(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_relaxed_swizzle, builtin_i8x16_relaxed_swizzle);\n\n// i32x4.relaxed_trunc_f32x4_s -> v128.relaxed_trunc<i32>\nfunction builtin_i32x4_relaxed_trunc_f32x4_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_relaxed_trunc(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_relaxed_trunc_f32x4_s, builtin_i32x4_relaxed_trunc_f32x4_s);\n\n// i32x4.relaxed_trunc_f32x4_u -> v128.relaxed_trunc<u32>\nfunction builtin_i32x4_relaxed_trunc_f32x4_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_relaxed_trunc(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_relaxed_trunc_f32x4_u, builtin_i32x4_relaxed_trunc_f32x4_u);\n\n// i32x4.relaxed_trunc_f64x2_s_zero -> v128.relaxed_trunc_zero<i32>\nfunction builtin_i32x4_relaxed_trunc_f64x2_s_zero(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_relaxed_trunc_zero(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_relaxed_trunc_f64x2_s_zero, builtin_i32x4_relaxed_trunc_f64x2_s_zero);\n\n// i32x4.relaxed_trunc_f64x2_u_zero -> v128.relaxed_trunc_zero<u32>\nfunction builtin_i32x4_relaxed_trunc_f64x2_u_zero(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_relaxed_trunc_zero(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_relaxed_trunc_f64x2_u_zero, builtin_i32x4_relaxed_trunc_f64x2_u_zero);\n\n// f32x4.relaxed_madd -> v128.relaxed_madd<f32>\nfunction builtin_f32x4_relaxed_madd(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_relaxed_madd(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_relaxed_madd, builtin_f32x4_relaxed_madd);\n\n// f32x4.relaxed_nmadd -> v128.relaxed_nmadd<f32>\nfunction builtin_f32x4_relaxed_nmadd(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_relaxed_nmadd(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_relaxed_nmadd, builtin_f32x4_relaxed_nmadd);\n\n// f64x2.relaxed_madd -> v128.relaxed_madd<f64>\nfunction builtin_f64x2_relaxed_madd(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_relaxed_madd(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_relaxed_madd, builtin_f64x2_relaxed_madd);\n\n// f64x2.relaxed_nmadd -> v128.relaxed_nmadd<f64>\nfunction builtin_f64x2_relaxed_nmadd(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_relaxed_nmadd(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_relaxed_nmadd, builtin_f64x2_relaxed_nmadd);\n\n// i8x16.relaxed_laneselect -> v128.relaxed_laneselect<i8>\nfunction builtin_i8x16_relaxed_laneselect(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_relaxed_laneselect(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_relaxed_laneselect, builtin_i8x16_relaxed_laneselect);\n\n// i16x8.relaxed_laneselect -> v128.relaxed_laneselect<i16>\nfunction builtin_i16x8_relaxed_laneselect(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_relaxed_laneselect(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_relaxed_laneselect, builtin_i16x8_relaxed_laneselect);\n\n// i32x4.relaxed_laneselect -> v128.relaxed_laneselect<i32>\nfunction builtin_i32x4_relaxed_laneselect(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_relaxed_laneselect(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_relaxed_laneselect, builtin_i32x4_relaxed_laneselect);\n\n// i64x2.relaxed_laneselect -> v128.relaxed_laneselect<i64>\nfunction builtin_i64x2_relaxed_laneselect(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_relaxed_laneselect(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_relaxed_laneselect, builtin_i64x2_relaxed_laneselect);\n\n// f32x4.relaxed_min -> v128.relaxed_min<f32>\nfunction builtin_f32x4_relaxed_min(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_relaxed_min(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_relaxed_min, builtin_f32x4_relaxed_min);\n\n// f32x4.relaxed_max -> v128.relaxed_max<f32>\nfunction builtin_f32x4_relaxed_max(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_relaxed_max(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_relaxed_max, builtin_f32x4_relaxed_max);\n\n// f64x2.relaxed_min -> v128.relaxed_min<f64>\nfunction builtin_f64x2_relaxed_min(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_relaxed_min(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_relaxed_min, builtin_f64x2_relaxed_min);\n\n// f64x2.relaxed_max -> v128.relaxed_max<f64>\nfunction builtin_f64x2_relaxed_max(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_relaxed_max(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_relaxed_max, builtin_f64x2_relaxed_max);\n\n// i16x8.relaxed_q15mulr_s -> v128.relaxed_q15mulr<i16>\nfunction builtin_i16x8_relaxed_q15mulr_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_relaxed_q15mulr(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_relaxed_q15mulr_s, builtin_i16x8_relaxed_q15mulr_s);\n\n// i16x8.relaxed_dot_i8x16_i7x16_s -> v128.relaxed_dot<i16>\nfunction builtin_i16x8_relaxed_dot_i8x16_i7x16_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_relaxed_dot(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_relaxed_dot_i8x16_i7x16_s, builtin_i16x8_relaxed_dot_i8x16_i7x16_s);\n\n// i32x4.relaxed_dot_i8x16_i7x16_add_s -> v128.relaxed_dot_add<i32>\nfunction builtin_i32x4_relaxed_dot_i8x16_i7x16_add_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_relaxed_dot_add(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_relaxed_dot_i8x16_i7x16_add_s, builtin_i32x4_relaxed_dot_i8x16_i7x16_add_s);\n\n// === Internal helpers =======================================================================\n\n/** Compiles the `visit_globals` function. */\nexport function compileVisitGlobals(compiler: Compiler): void {\n  let module = compiler.module;\n  let exprs = new Array<ExpressionRef>();\n  let sizeTypeRef = compiler.options.sizeTypeRef;\n  let visitInstance = assert(compiler.program.visitInstance);\n\n  // this function is @lazy: make sure it exists\n  compiler.compileFunction(visitInstance, true);\n\n  // TODO: for (let element of compiler.program.elementsByName.values()) {\n  for (let _values = Map_values(compiler.program.elementsByName), i = 0, k = _values.length; i < k; ++i) {\n    let element = unchecked(_values[i]);\n    if (element.kind != ElementKind.Global) continue;\n    let global = <Global>element;\n    let globalType = global.type;\n    let classReference = globalType.getClass();\n    if (\n      classReference &&\n      !classReference.hasDecorator(DecoratorFlags.Unmanaged) &&\n      global.is(CommonFlags.Compiled)\n    ) {\n      if (global.is(CommonFlags.Inlined)) {\n        let value = global.constantIntegerValue;\n        if (i64_low(value) || i64_high(value)) {\n          exprs.push(\n            module.call(visitInstance.internalName, [\n              compiler.options.isWasm64\n                ? module.i64(i64_low(value), i64_high(value))\n                : module.i32(i64_low(value)),\n              module.local_get(0, TypeRef.I32) // cookie\n            ], TypeRef.None)\n          );\n        }\n      } else {\n        exprs.push(\n          module.if(\n            module.local_tee(1,\n              module.global_get(global.internalName, sizeTypeRef),\n              false // internal\n            ),\n            module.call(visitInstance.internalName, [\n              module.local_get(1, sizeTypeRef), // tempRef != null\n              module.local_get(0, TypeRef.I32) // cookie\n            ], TypeRef.None)\n          )\n        );\n      }\n    }\n  }\n  module.addFunction(BuiltinNames.visit_globals,\n    TypeRef.I32,  // cookie\n    TypeRef.None, // => void\n    [ sizeTypeRef ],\n    exprs.length\n      ? module.block(null, exprs)\n      : module.nop()\n  );\n}\n\n/** Ensures that the visitor function of the specified class is compiled. */\nfunction ensureVisitMembersOf(compiler: Compiler, instance: Class): void {\n  assert(instance.type.isManaged);\n  if (instance.visitRef) return;\n\n  let program = compiler.program;\n  let module = compiler.module;\n  let usizeType = program.options.usizeType;\n  let sizeTypeRef = usizeType.toRef();\n  let sizeTypeSize = usizeType.byteSize;\n  let visitInstance = assert(program.visitInstance);\n  let body = new Array<ExpressionRef>();\n\n  // If the class has a base class, call its visitor first\n  let base = instance.base;\n  if (base) {\n    body.push(\n      module.call(`${base.internalName}~visit`, [\n        module.local_get(0, sizeTypeRef), // this\n        module.local_get(1, TypeRef.I32)  // cookie\n      ], TypeRef.None)\n    );\n  }\n\n  // Some standard library components provide a custom visitor implementation,\n  // for example to visit all members of a collection, e.g. arrays and maps.\n  let hasVisitImpl = false;\n  if (instance.isDeclaredInLibrary) {\n    let visitPrototype = instance.getMember(\"__visit\");\n    if (visitPrototype) {\n      assert(visitPrototype.kind == ElementKind.FunctionPrototype);\n      let visitInstance = program.resolver.resolveFunction(<FunctionPrototype>visitPrototype, null);\n      if (!visitInstance || !compiler.compileFunction(visitInstance)) {\n        body.push(\n          module.unreachable()\n        );\n      } else {\n        let visitSignature = visitInstance.signature;\n        let visitThisType = assert(visitSignature.thisType);\n        assert(\n          visitSignature.parameterTypes.length == 1 &&\n          visitSignature.parameterTypes[0] == Type.u32 &&\n          visitSignature.returnType == Type.void &&\n          instance.type.isStrictlyAssignableTo(visitThisType) // incl. implemented on super\n        );\n        body.push(\n          module.call(visitInstance.internalName, [\n            module.local_get(0, sizeTypeRef), // this\n            module.local_get(1, TypeRef.I32)  // cookie\n          ], TypeRef.None)\n        );\n      }\n      hasVisitImpl = true;\n    }\n  }\n\n  // Otherwise, if there is no custom visitor, generate a visitor function\n  // according to class layout, visiting all _own_ managed members.\n  let needsTempValue = false;\n  if (!hasVisitImpl) {\n    let members = instance.members;\n    if (members) {\n      // TODO: for (let member of members.values()) {\n      for (let _values = Map_values(members), j = 0, l = _values.length; j < l; ++j) {\n        let member = unchecked(_values[j]);\n        if (member.kind != ElementKind.PropertyPrototype) continue;\n        // Class should have resolved fields during finalization\n        let property = (<PropertyPrototype>member).instance;\n        if (!property) continue;\n        let fieldType = property.type;\n        if (!property.isField || property.getBoundClassOrInterface() != instance || !fieldType.isManaged) continue;\n        let fieldOffset = property.memoryOffset;\n        assert(fieldOffset >= 0);\n        needsTempValue = true;\n        body.push(\n          // __visit(load<usize>($this, fieldOffset), $cookie)\n          module.call(visitInstance.internalName, [\n            module.load(sizeTypeSize, false,\n              module.local_get(0, sizeTypeRef),\n              sizeTypeRef, fieldOffset\n            ), // value\n            module.local_get(1, TypeRef.I32)  // cookie\n          ], TypeRef.None)\n        );\n      }\n    }\n  }\n\n  // Create the visitor function\n  instance.visitRef = module.addFunction(`${instance.internalName}~visit`,\n    createType([sizeTypeRef, TypeRef.I32]),\n    TypeRef.None,\n    needsTempValue ? [ sizeTypeRef ] : null,\n    module.flatten(body, TypeRef.None)\n  );\n\n  // And make sure the base visitor function exists\n  if (base && base.type.isManaged) {\n    // errored earlier if not managed\n    ensureVisitMembersOf(compiler, base);\n  }\n}\n\n/** Compiles the `__visit_members` function. */\nexport function compileVisitMembers(compiler: Compiler): void {\n  let program = compiler.program;\n  let module = compiler.module;\n  let usizeType = program.options.usizeType;\n  let sizeTypeRef = usizeType.toRef();\n  let managedClasses = program.managedClasses;\n  let visitInstance = assert(program.visitInstance);\n  compiler.compileFunction(visitInstance, true); // is lazy, make sure it is compiled\n\n  // Prepare a mapping of class names to visitor calls. Each name corresponds to\n  // the respective sequential (0..N) class id.\n  let names = new Array<string>();\n  let cases = new Array<ExpressionRef>();\n  let nextId = 0;\n  for (let _keys = Map_keys(managedClasses), i = 0, k = _keys.length; i < k; ++i) {\n    let instanceId = _keys[i];\n    assert(instanceId == nextId++);\n    let instance = assert(managedClasses.get(instanceId));\n    names[i] = instance.internalName;\n    if (instance.isPointerfree) {\n      cases[i] = module.return();\n    } else {\n      cases[i] = module.block(null, [\n        module.call(`${instance.internalName}~visit`, [\n          module.local_get(0, sizeTypeRef), // this\n          module.local_get(1, TypeRef.I32)  // cookie\n        ], TypeRef.None),\n        module.return()\n      ], TypeRef.None);\n      ensureVisitMembersOf(compiler, instance);\n    }\n  }\n\n  // Make a br_table of the mapping, calling visitor functions by unique class id\n  let current = module.block(names[0], [\n    module.switch(names, \"invalid\",\n      // load<u32>(changetype<usize>(this) - 8)\n      module.load(4, false,\n        sizeTypeRef == TypeRef.I64\n          ? module.binary(BinaryOp.SubI64,\n              module.local_get(0, sizeTypeRef),\n              module.i64(8)\n            )\n          : module.binary(BinaryOp.SubI32,\n              module.local_get(0, sizeTypeRef),\n              module.i32(8) // rtId is at -8\n            ),\n        TypeRef.I32, 0\n      )\n    )\n  ], TypeRef.None);\n\n  // Wrap blocks in order\n  for (let i = 0, k = names.length - 1; i < k; ++i) {\n    current = module.block(names[i + 1], [\n      current,\n      cases[i]\n    ], TypeRef.None);\n  }\n\n  // Wrap the last id in an 'invalid' block to break out of on invalid ids\n  current = module.block(\"invalid\", [\n    current,\n    cases[names.length - 1]\n  ], TypeRef.None);\n\n  // Add the function, executing an unreachable if breaking to 'invalid'\n  module.addFunction(BuiltinNames.visit_members,\n    createType([ sizeTypeRef, TypeRef.I32 ]), // this, cookie\n    TypeRef.None, // => void\n    null,\n    module.flatten([\n      current,\n      module.unreachable()\n    ])\n  );\n}\n\nfunction typeToRuntimeFlags(type: Type): TypeinfoFlags {\n  let flags = TypeinfoFlags.VALUE_ALIGN_0 * (1 << type.alignLog2);\n  if (type.is(TypeFlags.Signed))   flags |= TypeinfoFlags.VALUE_SIGNED;\n  if (type.is(TypeFlags.Float))    flags |= TypeinfoFlags.VALUE_FLOAT;\n  if (type.is(TypeFlags.Nullable)) flags |= TypeinfoFlags.VALUE_NULLABLE;\n  if (type.isManaged)              flags |= TypeinfoFlags.VALUE_MANAGED;\n  return flags / TypeinfoFlags.VALUE_ALIGN_0;\n}\n\n/** Compiles runtime type information for use by stdlib. */\nexport function compileRTTI(compiler: Compiler): void {\n  let program = compiler.program;\n  let module = compiler.module;\n  let managedClasses = program.managedClasses;\n  let count = managedClasses.size;\n  let size = 4 + 4 * count; // count | TypeInfo*\n  let data = new Uint8Array(size);\n  writeI32(count, data, 0);\n  let off = 4;\n  let abvInstance = program.arrayBufferViewInstance;\n  let abvPrototype = abvInstance.prototype;\n  let arrayPrototype = program.arrayPrototype;\n  let setPrototype = program.setPrototype;\n  let mapPrototype = program.mapPrototype;\n  let staticArrayPrototype = program.staticArrayPrototype;\n  let lastId = 0;\n  // TODO: for (let [instanceId, instance] of managedClasses) {\n  for (let _keys = Map_keys(managedClasses), i = 0, k = _keys.length; i < k; ++i) {\n    let instanceId = unchecked(_keys[i]);\n    let instance = assert(managedClasses.get(instanceId));\n    assert(instanceId == lastId++);\n    let flags: TypeinfoFlags = 0;\n    if (instance.isPointerfree) flags |= TypeinfoFlags.POINTERFREE;\n    if (instance != abvInstance && instance.extendsPrototype(abvPrototype)) {\n      let valueType = instance.getArrayValueType();\n      flags |= TypeinfoFlags.ARRAYBUFFERVIEW;\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(valueType);\n    } else if (instance.extendsPrototype(arrayPrototype)) {\n      let valueType = instance.getArrayValueType();\n      flags |= TypeinfoFlags.ARRAY;\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(valueType);\n    } else if (instance.extendsPrototype(setPrototype)) {\n      let typeArguments = assert(instance.getTypeArgumentsTo(setPrototype));\n      assert(typeArguments.length == 1);\n      flags |= TypeinfoFlags.SET;\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(typeArguments[0]);\n    } else if (instance.extendsPrototype(mapPrototype)) {\n      let typeArguments = assert(instance.getTypeArgumentsTo(mapPrototype));\n      assert(typeArguments.length == 2);\n      flags |= TypeinfoFlags.MAP;\n      flags |= TypeinfoFlags.KEY_ALIGN_0   * typeToRuntimeFlags(typeArguments[0]);\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(typeArguments[1]);\n    } else if (instance.extendsPrototype(staticArrayPrototype)) {\n      let valueType = instance.getArrayValueType();\n      flags |= TypeinfoFlags.STATICARRAY;\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(valueType);\n    }\n    writeI32(flags, data, off); off += 4;\n    instance.rttiFlags = flags;\n  }\n  assert(off == size);\n  let usizeType = program.options.usizeType;\n  let segment = compiler.addAlignedMemorySegment(data);\n  if (usizeType.size == 8) {\n    let offset = segment.offset;\n    module.addGlobal(BuiltinNames.rtti_base, TypeRef.I64, false, module.i64(i64_low(offset), i64_high(offset)));\n  } else {\n    module.addGlobal(BuiltinNames.rtti_base, TypeRef.I32, false, module.i32(i64_low(segment.offset)));\n  }\n}\n\n// Helpers\n\n/** Checks the constant type of a type argument *or* expression. */\nfunction checkConstantType(ctx: BuiltinFunctionContext): Type | null {\n  let compiler = ctx.compiler;\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  checkConstantType_expr = 0;\n  if (operands.length == 0) { // requires type argument\n    if (!typeArguments || typeArguments.length != 1) {\n      compiler.error(\n        DiagnosticCode.Expected_0_type_arguments_but_got_1,\n        ctx.reportNode.typeArgumentsRange, \"1\", typeArguments ? typeArguments.length.toString() : \"0\"\n      );\n      return null;\n    }\n    return typeArguments[0];\n  }\n  if (operands.length == 1) { // optional type argument\n    if (typeArguments && typeArguments.length > 0) {\n      if (typeArguments.length > 1) {\n        compiler.error(\n          DiagnosticCode.Expected_0_type_arguments_but_got_1,\n          ctx.reportNode.typeArgumentsRange, \"1\", typeArguments.length.toString()\n        );\n        return null;\n      }\n      checkConstantType_expr = compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit);\n    } else {\n      checkConstantType_expr = compiler.compileExpression(operands[0], Type.auto);\n    }\n    return compiler.currentType;\n  }\n  if (typeArguments && typeArguments.length > 1) {\n    compiler.error(\n      DiagnosticCode.Expected_0_type_arguments_but_got_1,\n      ctx.reportNode.typeArgumentsRange, \"1\", typeArguments.length.toString()\n    );\n  }\n  compiler.error(\n    DiagnosticCode.Expected_0_arguments_but_got_1,\n    ctx.reportNode.argumentsRange, \"1\", operands.length.toString()\n  );\n  return null;\n}\n\n/** Reifies a constant type check potentially involving an expression. */\nfunction reifyConstantType(ctx: BuiltinFunctionContext, expr: ExpressionRef): ExpressionRef {\n  let module = ctx.compiler.module;\n  if (checkConstantType_expr && mustPreserveSideEffects(checkConstantType_expr, module.ref)) {\n    expr = module.block(null, [\n      module.maybeDrop(checkConstantType_expr),\n      expr\n    ], getExpressionType(expr));\n  }\n  return expr;\n}\n\n/** Evaluates a compile-time constant immediate offset argument.*/\nfunction evaluateImmediateOffset(expression: Expression, compiler: Compiler): i32 {\n  let module = compiler.module;\n  let value: i32;\n  if (compiler.options.isWasm64) {\n    let expr = compiler.compileExpression(expression, Type.usize64, Constraints.ConvImplicit);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      assert(getConstValueI64High(precomp) == 0); // TODO\n      value = getConstValueI64Low(precomp);\n    } else {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        expression.range\n      );\n      value = -1;\n    }\n  } else {\n    let expr = compiler.compileExpression(expression, Type.usize32, Constraints.ConvImplicit);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      value = getConstValueI32(precomp);\n    } else {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        expression.range\n      );\n      value = -1;\n    }\n  }\n  return value;\n}\n\n/** Evaluates a compile-time constant immediate align argument. */\nfunction evaluateImmediateAlign(expression: Expression, naturalAlign: i32, compiler: Compiler): i32 {\n  let align = evaluateImmediateOffset(expression, compiler);\n  if (align < 0) return align;\n  if (align < 1 || naturalAlign > 16) {\n    compiler.error(\n      DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n      expression.range, \"Alignment\", \"1\", naturalAlign.toString()\n    );\n    return -1;\n  }\n  if (!isPowerOf2(align)) {\n    compiler.error(\n      DiagnosticCode._0_must_be_a_power_of_two,\n      expression.range, \"Alignment\"\n    );\n    return -1;\n  }\n  return align;\n}\n\n/** Checks that the specified feature is enabled. */\nfunction checkFeatureEnabled(ctx: BuiltinFunctionContext, feature: Feature): i32 {\n  let compiler = ctx.compiler;\n  if (!compiler.options.hasFeature(feature)) {\n    compiler.error(\n      DiagnosticCode.Feature_0_is_not_enabled,\n      ctx.reportNode.range, featureToString(feature)\n    );\n    return 1;\n  }\n  return 0;\n}\n\n/** Checks a call with a single required type argument. Returns `1` on error. */\nfunction checkTypeRequired(ctx: BuiltinFunctionContext, setCurrentTypeOnError: bool = false): i32 {\n  let compiler = ctx.compiler;\n  let typeArguments = ctx.typeArguments;\n  if (typeArguments) {\n    let numTypeArguments = typeArguments.length;\n    if (numTypeArguments == 1) return 0;\n    assert(numTypeArguments); // invalid if 0, must not be set at all instead\n    if (setCurrentTypeOnError) compiler.currentType = typeArguments[0];\n    compiler.error(\n      DiagnosticCode.Expected_0_type_arguments_but_got_1,\n      ctx.reportNode.typeArgumentsRange, \"1\", numTypeArguments.toString()\n    );\n  } else {\n    compiler.error(\n      DiagnosticCode.Expected_0_type_arguments_but_got_1,\n      ctx.reportNode.range, \"1\", \"0\"\n    );\n  }\n  return 1;\n}\n\n/** Checks a call with a single optional type argument. Returns `1` on error. */\nfunction checkTypeOptional(ctx: BuiltinFunctionContext, setCurrentTypeOnError: bool = false): i32 {\n  let typeArguments = ctx.typeArguments;\n  if (typeArguments) {\n    let compiler = ctx.compiler;\n    let numTypeArguments = typeArguments.length;\n    if (numTypeArguments == 1) return 0;\n    assert(numTypeArguments); // invalid if 0, must not be set at all instead\n    if (setCurrentTypeOnError) compiler.currentType = typeArguments[0];\n    compiler.error(\n      DiagnosticCode.Expected_0_type_arguments_but_got_1,\n      ctx.reportNode.typeArgumentsRange, \"1\", numTypeArguments.toString()\n    );\n    return 1;\n  }\n  return 0;\n}\n\n/** Checks a call that is not generic. Returns `1` on error. */\nfunction checkTypeAbsent(ctx: BuiltinFunctionContext): i32 {\n  let typeArguments = ctx.typeArguments;\n  if (typeArguments) {\n    let prototype = ctx.prototype;\n    prototype.program.error(\n      DiagnosticCode.Type_0_is_not_generic,\n      ctx.reportNode.typeArgumentsRange, prototype.internalName\n    );\n    return 1;\n  }\n  return 0;\n}\n\n/** Checks a call that requires a fixed number of arguments. Returns `1` on error. */\nfunction checkArgsRequired(ctx: BuiltinFunctionContext, expected: i32): i32 {\n  let operands = ctx.operands;\n  if (operands.length != expected) {\n    ctx.compiler.error(\n      DiagnosticCode.Expected_0_arguments_but_got_1,\n      ctx.reportNode.range, expected.toString(), operands.length.toString()\n    );\n    return 1;\n  }\n  return 0;\n}\n\n/** Checks a call that requires a variable number of arguments. Returns `1` on error. */\nfunction checkArgsOptional(ctx: BuiltinFunctionContext, expectedMinimum: i32, expectedMaximum: i32): i32 {\n  let operands = ctx.operands;\n  let numOperands = operands.length;\n  if (numOperands < expectedMinimum) {\n    ctx.compiler.error(\n      DiagnosticCode.Expected_at_least_0_arguments_but_got_1,\n      ctx.reportNode.range, expectedMinimum.toString(), numOperands.toString()\n    );\n    return 1;\n  } else if (numOperands > expectedMaximum) {\n    ctx.compiler.error(\n      DiagnosticCode.Expected_0_arguments_but_got_1,\n      ctx.reportNode.range, expectedMaximum.toString(), numOperands.toString()\n    );\n    return 1;\n  }\n  return 0;\n}\n\n/** Makes an usize constant matching contextual type if reasonable. */\nfunction contextualUsize(compiler: Compiler, value: i64, contextualType: Type): ExpressionRef {\n  let module = compiler.module;\n  // Check if contextual type fits\n  if (contextualType != Type.auto && contextualType.isIntegerValue) {\n    switch (contextualType.kind) {\n      case TypeKind.I32: {\n        if (i64_is_i32(value)) {\n          compiler.currentType = Type.i32;\n          return module.i32(i64_low(value));\n        }\n        break;\n      }\n      case TypeKind.U32: {\n        if (i64_is_u32(value)) {\n          compiler.currentType = Type.u32;\n          return module.i32(i64_low(value));\n        }\n        break;\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        compiler.currentType = contextualType;\n        return module.i64(i64_low(value), i64_high(value));\n      }\n      // isize/usize falls through\n      // small int is probably not intended\n    }\n  }\n  // Default to usize\n  if (compiler.options.isWasm64) {\n    compiler.currentType = Type.usize64;\n    return module.i64(i64_low(value), i64_high(value));\n  } else {\n    compiler.currentType = Type.usize32;\n    assert(!i64_high(value));\n    return module.i32(i64_low(value));\n  }\n}\n", "/**\n * @fileoverview Infrastructure for custom Binaryen passes.\n * @license Apache-2.0\n */\n\nimport {\n  Module,\n  ExpressionId,\n  ExpressionRef,\n  FunctionRef,\n  GlobalRef,\n  Index,\n  StringRef\n} from \"../module\";\n\nimport {\n  _BinaryenExpressionGetId,\n  _BinaryenBlockGetNumChildren,\n  _BinaryenBlockGetChildAt,\n  _BinaryenIfGetCondition,\n  _BinaryenIfGetIfTrue,\n  _BinaryenIfGetIfFalse,\n  _BinaryenLoopGetBody,\n  _BinaryenBreakGetCondition,\n  _BinaryenBreakGetValue,\n  _BinaryenGetNumFunctions,\n  _BinaryenGetFunctionByIndex,\n  _BinaryenGetNumGlobals,\n  _BinaryenGetGlobalByIndex,\n  _BinaryenFunctionGetBody,\n  _BinaryenSwitchGetCondition,\n  _BinaryenSwitchGetValue,\n  _BinaryenCallGetNumOperands,\n  _BinaryenCallGetOperandAt,\n  _BinaryenCallIndirectGetNumOperands,\n  _BinaryenCallIndirectGetOperandAt,\n  _BinaryenLocalSetGetValue,\n  _BinaryenGlobalSetGetValue,\n  _BinaryenGlobalGetInitExpr,\n  _BinaryenLoadGetPtr,\n  _BinaryenStoreGetPtr,\n  _BinaryenStoreGetValue,\n  _BinaryenUnaryGetValue,\n  _BinaryenBinaryGetLeft,\n  _BinaryenBinaryGetRight,\n  _BinaryenSelectGetIfTrue,\n  _BinaryenSelectGetIfFalse,\n  _BinaryenSelectGetCondition,\n  _BinaryenDropGetValue,\n  _BinaryenBlockSetChildAt,\n  _BinaryenCallIndirectGetTarget,\n  _BinaryenReturnGetValue,\n  _BinaryenMemoryGrowGetDelta,\n  _BinaryenAtomicRMWGetPtr,\n  _BinaryenAtomicRMWGetValue,\n  _BinaryenAtomicCmpxchgGetPtr,\n  _BinaryenAtomicCmpxchgGetExpected,\n  _BinaryenAtomicCmpxchgGetReplacement,\n  _BinaryenAtomicWaitGetPtr,\n  _BinaryenAtomicWaitGetExpected,\n  _BinaryenAtomicWaitGetTimeout,\n  _BinaryenAtomicNotifyGetPtr,\n  _BinaryenSIMDExtractGetVec,\n  _BinaryenSIMDReplaceGetVec,\n  _BinaryenSIMDReplaceGetValue,\n  _BinaryenSIMDShuffleGetLeft,\n  _BinaryenSIMDShuffleGetRight,\n  _BinaryenSIMDTernaryGetA,\n  _BinaryenSIMDTernaryGetB,\n  _BinaryenSIMDTernaryGetC,\n  _BinaryenSIMDShiftGetVec,\n  _BinaryenSIMDShiftGetShift,\n  _BinaryenSIMDLoadGetPtr,\n  _BinaryenMemoryInitGetDest,\n  _BinaryenMemoryInitGetOffset,\n  _BinaryenMemoryInitGetSize,\n  _BinaryenMemoryCopyGetDest,\n  _BinaryenMemoryCopyGetSource,\n  _BinaryenMemoryCopyGetSize,\n  _BinaryenMemoryFillGetDest,\n  _BinaryenMemoryFillGetValue,\n  _BinaryenMemoryFillGetSize,\n  _BinaryenRefIsNullGetValue,\n  _BinaryenRefAsGetValue,\n  _BinaryenTryGetBody,\n  _BinaryenTryGetNumCatchBodies,\n  _BinaryenTryGetCatchBodyAt,\n  _BinaryenThrowGetNumOperands,\n  _BinaryenThrowGetOperandAt,\n  _BinaryenTupleMakeGetOperandAt,\n  _BinaryenTupleMakeGetNumOperands,\n  _BinaryenIfSetCondition,\n  _BinaryenIfSetIfTrue,\n  _BinaryenIfSetIfFalse,\n  _BinaryenLoopSetBody,\n  _BinaryenBreakSetCondition,\n  _BinaryenBreakSetValue,\n  _BinaryenSwitchSetCondition,\n  _BinaryenSwitchSetValue,\n  _BinaryenCallSetOperandAt,\n  _BinaryenCallIndirectSetTarget,\n  _BinaryenCallIndirectSetOperandAt,\n  _BinaryenLocalSetSetValue,\n  _BinaryenGlobalSetSetValue,\n  _BinaryenLoadSetPtr,\n  _BinaryenStoreSetPtr,\n  _BinaryenStoreSetValue,\n  _BinaryenUnarySetValue,\n  _BinaryenExpressionFinalize,\n  _BinaryenBinarySetLeft,\n  _BinaryenBinarySetRight,\n  _BinaryenSelectSetIfTrue,\n  _BinaryenSelectSetIfFalse,\n  _BinaryenSelectSetCondition,\n  _BinaryenDropSetValue,\n  _BinaryenReturnSetValue,\n  _BinaryenMemoryGrowSetDelta,\n  _BinaryenAtomicRMWSetPtr,\n  _BinaryenAtomicRMWSetValue,\n  _BinaryenAtomicCmpxchgSetPtr,\n  _BinaryenAtomicCmpxchgSetExpected,\n  _BinaryenAtomicCmpxchgSetReplacement,\n  _BinaryenAtomicWaitSetPtr,\n  _BinaryenAtomicWaitSetExpected,\n  _BinaryenAtomicWaitSetTimeout,\n  _BinaryenAtomicNotifySetPtr,\n  _BinaryenSIMDExtractSetVec,\n  _BinaryenSIMDReplaceSetVec,\n  _BinaryenSIMDReplaceSetValue,\n  _BinaryenSIMDShuffleSetLeft,\n  _BinaryenSIMDShuffleSetRight,\n  _BinaryenSIMDTernarySetA,\n  _BinaryenSIMDTernarySetB,\n  _BinaryenSIMDTernarySetC,\n  _BinaryenSIMDShiftSetVec,\n  _BinaryenSIMDShiftSetShift,\n  _BinaryenSIMDLoadSetPtr,\n  _BinaryenSIMDLoadStoreLaneGetPtr,\n  _BinaryenSIMDLoadStoreLaneGetVec,\n  _BinaryenSIMDLoadStoreLaneSetPtr,\n  _BinaryenSIMDLoadStoreLaneSetVec,\n  _BinaryenMemoryInitSetDest,\n  _BinaryenMemoryInitSetOffset,\n  _BinaryenMemoryInitSetSize,\n  _BinaryenMemoryCopySetDest,\n  _BinaryenMemoryCopySetSource,\n  _BinaryenMemoryCopySetSize,\n  _BinaryenMemoryFillSetDest,\n  _BinaryenMemoryFillSetValue,\n  _BinaryenMemoryFillSetSize,\n  _BinaryenRefIsNullSetValue,\n  _BinaryenTrySetBody,\n  _BinaryenTrySetCatchBodyAt,\n  _BinaryenThrowSetOperandAt,\n  _BinaryenTupleMakeSetOperandAt,\n  _BinaryenBlockGetName,\n  _BinaryenLoopGetName,\n  _BinaryenBreakGetName,\n  _BinaryenSwitchGetDefaultName,\n  _BinaryenSwitchGetNumNames,\n  _BinaryenSwitchGetNameAt,\n  _BinaryenCallGetTarget,\n  _BinaryenLocalGetGetIndex,\n  _BinaryenLocalSetGetIndex,\n  _BinaryenGlobalGetGetName,\n  _BinaryenGlobalSetGetName,\n  _BinaryenAtomicNotifyGetNotifyCount,\n  _BinaryenAtomicNotifySetNotifyCount,\n  _BinaryenRefFuncGetFunc,\n  _BinaryenThrowGetTag,\n  _BinaryenTupleExtractGetTuple,\n  _BinaryenTupleExtractSetTuple,\n  _BinaryenRefEqGetLeft,\n  _BinaryenRefEqGetRight,\n  _BinaryenRefEqSetLeft,\n  _BinaryenRefEqSetRight,\n  _BinaryenFunctionSetBody,\n  _BinaryenRefI31GetValue,\n  _BinaryenI31GetGetI31,\n  _BinaryenRefI31SetValue,\n  _BinaryenI31GetSetI31,\n  _BinaryenCallRefGetNumOperands,\n  _BinaryenCallRefGetOperandAt,\n  _BinaryenCallRefGetTarget,\n  _BinaryenRefTestGetRef,\n  _BinaryenRefCastGetRef,\n  _BinaryenBrOnGetName,\n  _BinaryenBrOnGetRef,\n  _BinaryenStructNewGetNumOperands,\n  _BinaryenStructNewGetOperandAt,\n  _BinaryenStructGetGetRef,\n  _BinaryenStructSetGetRef,\n  _BinaryenStructSetGetValue,\n  _BinaryenStructSetGetIndex,\n  _BinaryenStructGetGetIndex,\n  _BinaryenArrayNewGetSize,\n  _BinaryenArrayNewGetInit,\n  _BinaryenArrayNewFixedGetNumValues,\n  _BinaryenArrayNewFixedGetValueAt,\n  _BinaryenArrayGetGetRef,\n  _BinaryenArrayGetGetIndex,\n  _BinaryenArraySetGetRef,\n  _BinaryenArraySetGetIndex,\n  _BinaryenArraySetGetValue,\n  _BinaryenArrayLenGetRef,\n  _BinaryenArrayCopyGetDestRef,\n  _BinaryenArrayCopyGetDestIndex,\n  _BinaryenArrayCopyGetSrcRef,\n  _BinaryenArrayCopyGetSrcIndex,\n  _BinaryenArrayCopyGetLength,\n  _BinaryenStringNewGetRef,\n  _BinaryenStringNewGetStart,\n  _BinaryenStringNewGetEnd,\n  _BinaryenStringMeasureGetRef,\n  _BinaryenStringEncodeGetArray,\n  _BinaryenStringEncodeGetStr,\n  _BinaryenStringEncodeGetStart,\n  _BinaryenStringConcatGetLeft,\n  _BinaryenStringConcatGetRight,\n  _BinaryenStringEqGetLeft,\n  _BinaryenStringEqGetRight,\n  _BinaryenStringWTF16GetGetRef,\n  _BinaryenStringWTF16GetGetPos,\n  _BinaryenStringSliceWTFGetRef,\n  _BinaryenStringSliceWTFGetStart,\n  _BinaryenStringSliceWTFGetEnd,\n  _BinaryenCallRefSetOperandAt,\n  _BinaryenCallRefSetTarget,\n  _BinaryenRefTestSetRef,\n  _BinaryenRefCastSetRef,\n  _BinaryenBrOnSetRef,\n  _BinaryenStructNewSetOperandAt,\n  _BinaryenStructGetSetRef,\n  _BinaryenStructSetSetRef,\n  _BinaryenStructSetSetValue,\n  _BinaryenArrayNewSetSize,\n  _BinaryenArrayNewSetInit,\n  _BinaryenArrayGetSetRef,\n  _BinaryenArrayGetSetIndex,\n  _BinaryenArraySetSetRef,\n  _BinaryenArraySetSetIndex,\n  _BinaryenArraySetSetValue,\n  _BinaryenArrayLenSetRef,\n  _BinaryenArrayCopySetDestRef,\n  _BinaryenArrayCopySetDestIndex,\n  _BinaryenArrayCopySetSrcRef,\n  _BinaryenArrayCopySetSrcIndex,\n  _BinaryenArrayCopySetLength,\n  _BinaryenRefAsSetValue,\n  _BinaryenStringNewSetRef,\n  _BinaryenStringNewSetStart,\n  _BinaryenStringNewSetEnd,\n  _BinaryenStringMeasureSetRef,\n  _BinaryenStringEncodeSetStr,\n  _BinaryenStringEncodeSetArray,\n  _BinaryenStringEncodeSetStart,\n  _BinaryenStringConcatSetLeft,\n  _BinaryenStringConcatSetRight,\n  _BinaryenStringEqSetLeft,\n  _BinaryenStringEqSetRight,\n  _BinaryenStringWTF16GetSetRef,\n  _BinaryenStringWTF16GetSetPos,\n  _BinaryenStringSliceWTFSetRef,\n  _BinaryenStringSliceWTFSetStart,\n  _BinaryenStringSliceWTFSetEnd,\n  _BinaryenArrayNewFixedSetValueAt\n} from \"../glue/binaryen\";\n\n/** Base class of custom Binaryen visitors. */\nexport abstract class Visitor {\n  /** Expression stack. */\n  private stack: ExpressionRef[] = new Array<ExpressionRef>();\n\n  /** Gets the current expression being walked. */\n  get currentExpression(): ExpressionRef {\n    let currentExpression = this._currentExpression;\n    if (!currentExpression) throw new Error(\"not walking expressions\");\n    return currentExpression;\n  }\n  _currentExpression: ExpressionRef = 0;\n\n  /** Gets the parent expression of the current expression being walked. Returns zero if already the top-most expression. */\n  get parentExpressionOrNull(): ExpressionRef {\n    let stack = this.stack;\n    let length = stack.length;\n    return length ? stack[length - 1] : 0;\n  }\n\n  // Expressions\n\n  visitBlock(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitIf(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitLoop(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitBreak(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSwitch(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitCallPre(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitCall(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitCallIndirectPre(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitCallIndirect(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitLocalGet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitLocalSet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitGlobalGet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitGlobalSet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitLoad(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStore(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitConst(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitUnary(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitBinary(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSelect(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitDrop(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitReturn(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitMemorySize(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitMemoryGrow(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitNop(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitUnreachable(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitAtomicRMW(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitAtomicCmpxchg(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitAtomicWait(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitAtomicNotify(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitAtomicFence(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDExtract(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDReplace(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDShuffle(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDTernary(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDShift(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDLoad(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDLoadStoreLane(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitMemoryInit(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitDataDrop(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitMemoryCopy(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitMemoryFill(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitPop(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefNull(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefIsNull(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefFunc(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefEq(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitTry(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitThrow(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRethrow(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitTupleMake(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitTupleExtract(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefI31(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitI31Get(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitCallRef(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefTest(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefCast(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitBrOn(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStructNew(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStructGet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStructSet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitArrayNew(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitArrayNewFixed(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitArrayGet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitArraySet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitArrayLen(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitArrayCopy(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefAs(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringNew(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringConst(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringMeasure(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringEncode(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringConcat(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringEq(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringAs(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringWTF8Advance(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringWTF16Get(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringIterNext(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringIterMove(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringSliceWTF(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringSliceIter(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  // Immediates\n\n  visitName(name: StringRef): void {\n    // unimp\n  }\n\n  visitLabel(name: StringRef): void {\n    // unimp\n  }\n\n  visitIndex(index: Index): void {\n    // unimp\n  }\n\n  visitTag(name: StringRef): void {\n    // unimp\n  }\n\n  // Delegate\n\n  /** Visits any expression, delegating to the respective visitor methods. */\n  visit(expr: ExpressionRef): void {\n    let previousExpression = this._currentExpression;\n    this._currentExpression = assert(expr);\n    switch (_BinaryenExpressionGetId(expr)) {\n      case ExpressionId.Block: {\n        this.stack.push(expr);\n        let name = _BinaryenBlockGetName(expr);\n        if (name) this.visitLabel(name);\n        for (let i: Index = 0, n = _BinaryenBlockGetNumChildren(expr); i < n; ++i) {\n          this.visit(_BinaryenBlockGetChildAt(expr, i));\n        }\n        assert(this.stack.pop() == expr);\n        this.visitBlock(expr);\n        break;\n      }\n      case ExpressionId.If: {\n        this.stack.push(expr);\n        this.visit(_BinaryenIfGetCondition(expr));\n        this.visit(_BinaryenIfGetIfTrue(expr));\n        let ifFalse = _BinaryenIfGetIfFalse(expr);\n        if (ifFalse) this.visit(ifFalse);\n        assert(this.stack.pop() == expr);\n        this.visitIf(expr);\n        break;\n      }\n      case ExpressionId.Loop: {\n        this.stack.push(expr);\n        let name = _BinaryenLoopGetName(expr);\n        if (name) this.visitLabel(name);\n        this.visit(_BinaryenLoopGetBody(expr));\n        assert(this.stack.pop() == expr);\n        this.visitLoop(expr);\n        break;\n      }\n      case ExpressionId.Break: {\n        this.stack.push(expr);\n        this.visitLabel(_BinaryenBreakGetName(expr));\n        let condition = _BinaryenBreakGetCondition(expr);\n        if (condition) this.visit(condition);\n        let value = _BinaryenBreakGetValue(expr);\n        if (value) this.visit(value);\n        assert(this.stack.pop() == expr);\n        this.visitBreak(expr);\n        break;\n      }\n      case ExpressionId.Switch: {\n        this.stack.push(expr);\n        let defaultName = _BinaryenSwitchGetDefaultName(expr);\n        if (defaultName) this.visitLabel(defaultName);\n        let numNames = _BinaryenSwitchGetNumNames(expr);\n        for (let i: Index = 0; i < numNames; ++i) {\n          this.visitLabel(_BinaryenSwitchGetNameAt(expr, i));\n        }\n        this.visit(_BinaryenSwitchGetCondition(expr));\n        let value = _BinaryenSwitchGetValue(expr);\n        if (value) this.visit(value);\n        assert(this.stack.pop() == expr);\n        this.visitSwitch(expr);\n        break;\n      }\n      case ExpressionId.Call: {\n        this.visitCallPre(expr);\n        this.stack.push(expr);\n        this.visitName(_BinaryenCallGetTarget(expr));\n        let numOperands = _BinaryenCallGetNumOperands(expr);\n        for (let i: Index = 0; i < numOperands; ++i) {\n          this.visit(_BinaryenCallGetOperandAt(expr, i));\n        }\n        assert(this.stack.pop() == expr);\n        this.visitCall(expr);\n        break;\n      }\n      case ExpressionId.CallIndirect: {\n        this.visitCallIndirectPre(expr);\n        this.stack.push(expr);\n        this.visit(_BinaryenCallIndirectGetTarget(expr));\n        for (let i: Index = 0, k = _BinaryenCallIndirectGetNumOperands(expr); i < k; ++i) {\n          this.visit(_BinaryenCallIndirectGetOperandAt(expr, i));\n        }\n        assert(this.stack.pop() == expr);\n        this.visitCallIndirect(expr);\n        break;\n      }\n      case ExpressionId.LocalGet: {\n        this.stack.push(expr);\n        this.visitIndex(_BinaryenLocalGetGetIndex(expr));\n        assert(this.stack.pop() == expr);\n        this.visitLocalGet(expr);\n        break;\n      }\n      case ExpressionId.LocalSet: {\n        this.stack.push(expr);\n        this.visitIndex(_BinaryenLocalSetGetIndex(expr));\n        this.visit(_BinaryenLocalSetGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitLocalSet(expr);\n        break;\n      }\n      case ExpressionId.GlobalGet: {\n        this.stack.push(expr);\n        this.visitName(_BinaryenGlobalGetGetName(expr));\n        assert(this.stack.pop() == expr);\n        this.visitGlobalGet(expr);\n        break;\n      }\n      case ExpressionId.GlobalSet: {\n        this.stack.push(expr);\n        this.visitName(_BinaryenGlobalSetGetName(expr));\n        this.visit(_BinaryenGlobalSetGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitGlobalSet(expr);\n        break;\n      }\n      case ExpressionId.Load: {\n        this.stack.push(expr);\n        this.visit(_BinaryenLoadGetPtr(expr));\n        assert(this.stack.pop() == expr);\n        this.visitLoad(expr);\n        break;\n      }\n      case ExpressionId.Store: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStoreGetPtr(expr));\n        this.visit(_BinaryenStoreGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStore(expr);\n        break;\n      }\n      case ExpressionId.Const: {\n        this.visitConst(expr);\n        break;\n      }\n      case ExpressionId.Unary: {\n        this.stack.push(expr);\n        this.visit(_BinaryenUnaryGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitUnary(expr);\n        break;\n      }\n      case ExpressionId.Binary: {\n        this.stack.push(expr);\n        this.visit(_BinaryenBinaryGetLeft(expr));\n        this.visit(_BinaryenBinaryGetRight(expr));\n        assert(this.stack.pop() == expr);\n        this.visitBinary(expr);\n        break;\n      }\n      case ExpressionId.Select: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSelectGetIfTrue(expr));\n        this.visit(_BinaryenSelectGetIfFalse(expr));\n        this.visit(_BinaryenSelectGetCondition(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSelect(expr);\n        break;\n      }\n      case ExpressionId.Drop: {\n        this.stack.push(expr);\n        this.visit(_BinaryenDropGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitDrop(expr);\n        break;\n      }\n      case ExpressionId.Return: {\n        let value = _BinaryenReturnGetValue(expr);\n        if (value) {\n          this.stack.push(expr);\n          this.visit(value);\n          assert(this.stack.pop() == expr);\n        }\n        this.visitReturn(expr);\n        break;\n      }\n      case ExpressionId.MemorySize: {\n        this.visitMemorySize(expr);\n        break;\n      }\n      case ExpressionId.MemoryGrow: {\n        this.stack.push(expr);\n        this.visit(_BinaryenMemoryGrowGetDelta(expr));\n        assert(this.stack.pop() == expr);\n        this.visitMemoryGrow(expr);\n        break;\n      }\n      case ExpressionId.Nop: {\n        this.visitNop(expr);\n        break;\n      }\n      case ExpressionId.Unreachable: {\n        this.visitUnreachable(expr);\n        break;\n      }\n      case ExpressionId.AtomicRMW: {\n        this.stack.push(expr);\n        this.visit(_BinaryenAtomicRMWGetPtr(expr));\n        this.visit(_BinaryenAtomicRMWGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitAtomicRMW(expr);\n        break;\n      }\n      case ExpressionId.AtomicCmpxchg: {\n        this.stack.push(expr);\n        this.visit(_BinaryenAtomicCmpxchgGetPtr(expr));\n        this.visit(_BinaryenAtomicCmpxchgGetExpected(expr));\n        this.visit(_BinaryenAtomicCmpxchgGetReplacement(expr));\n        assert(this.stack.pop() == expr);\n        this.visitAtomicCmpxchg(expr);\n        break;\n      }\n      case ExpressionId.AtomicWait: {\n        this.stack.push(expr);\n        this.visit(_BinaryenAtomicWaitGetPtr(expr));\n        this.visit(_BinaryenAtomicWaitGetExpected(expr));\n        this.visit(_BinaryenAtomicWaitGetTimeout(expr));\n        assert(this.stack.pop() == expr);\n        this.visitAtomicWait(expr);\n        break;\n      }\n      case ExpressionId.AtomicNotify: {\n        this.stack.push(expr);\n        this.visit(_BinaryenAtomicNotifyGetPtr(expr));\n        this.visit(_BinaryenAtomicNotifyGetNotifyCount(expr));\n        assert(this.stack.pop() == expr);\n        this.visitAtomicNotify(expr);\n        break;\n      }\n      case ExpressionId.AtomicFence: {\n        this.visitAtomicFence(expr);\n        break;\n      }\n      case ExpressionId.SIMDExtract: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDExtractGetVec(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDExtract(expr);\n        break;\n      }\n      case ExpressionId.SIMDReplace: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDReplaceGetVec(expr));\n        this.visit(_BinaryenSIMDReplaceGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDReplace(expr);\n        break;\n      }\n      case ExpressionId.SIMDShuffle: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDShuffleGetLeft(expr));\n        this.visit(_BinaryenSIMDShuffleGetRight(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDShuffle(expr);\n        break;\n      }\n      case ExpressionId.SIMDTernary: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDTernaryGetA(expr));\n        this.visit(_BinaryenSIMDTernaryGetB(expr));\n        this.visit(_BinaryenSIMDTernaryGetC(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDTernary(expr);\n        break;\n      }\n      case ExpressionId.SIMDShift: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDShiftGetVec(expr));\n        this.visit(_BinaryenSIMDShiftGetShift(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDShift(expr);\n        break;\n      }\n      case ExpressionId.SIMDLoad: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDLoadGetPtr(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDLoad(expr);\n        break;\n      }\n      case ExpressionId.SIMDLoadStoreLane: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDLoadStoreLaneGetPtr(expr));\n        this.visit(_BinaryenSIMDLoadStoreLaneGetVec(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDLoadStoreLane(expr);\n        break;\n      }\n      case ExpressionId.MemoryInit: {\n        this.stack.push(expr);\n        this.visit(_BinaryenMemoryInitGetDest(expr));\n        this.visit(_BinaryenMemoryInitGetOffset(expr));\n        this.visit(_BinaryenMemoryInitGetSize(expr));\n        assert(this.stack.pop() == expr);\n        this.visitMemoryInit(expr);\n        break;\n      }\n      case ExpressionId.DataDrop: {\n        this.visitDataDrop(expr);\n        break;\n      }\n      case ExpressionId.MemoryCopy: {\n        this.stack.push(expr);\n        this.visit(_BinaryenMemoryCopyGetDest(expr));\n        this.visit(_BinaryenMemoryCopyGetSource(expr));\n        this.visit(_BinaryenMemoryCopyGetSize(expr));\n        assert(this.stack.pop() == expr);\n        this.visitMemoryCopy(expr);\n        break;\n      }\n      case ExpressionId.MemoryFill: {\n        this.stack.push(expr);\n        this.visit(_BinaryenMemoryFillGetDest(expr));\n        this.visit(_BinaryenMemoryFillGetValue(expr));\n        this.visit(_BinaryenMemoryFillGetSize(expr));\n        assert(this.stack.pop() == expr);\n        this.visitMemoryFill(expr);\n        break;\n      }\n      case ExpressionId.Pop: {\n        this.visitPop(expr);\n        break;\n      }\n      case ExpressionId.RefNull: {\n        this.visitRefNull(expr);\n        break;\n      }\n      case ExpressionId.RefIsNull: {\n        this.stack.push(expr);\n        this.visit(_BinaryenRefIsNullGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitRefIsNull(expr);\n        break;\n      }\n      case ExpressionId.RefFunc: {\n        this.stack.push(expr);\n        this.visitName(_BinaryenRefFuncGetFunc(expr));\n        assert(this.stack.pop() == expr);\n        this.visitRefFunc(expr);\n        break;\n      }\n      case ExpressionId.RefEq: {\n        this.stack.push(expr);\n        this.visit(_BinaryenRefEqGetLeft(expr));\n        this.visit(_BinaryenRefEqGetRight(expr));\n        assert(this.stack.pop() == expr);\n        this.visitRefEq(expr);\n        break;\n      }\n      case ExpressionId.Try: {\n        this.stack.push(expr);\n        this.visit(_BinaryenTryGetBody(expr));\n        let numCatchBodies = _BinaryenTryGetNumCatchBodies(expr);\n        for (let i: Index = 0; i < numCatchBodies; ++i) {\n          this.visit(_BinaryenTryGetCatchBodyAt(expr, i));\n        }\n        assert(this.stack.pop() == expr);\n        this.visitTry(expr);\n        break;\n      }\n      case ExpressionId.Throw: {\n        this.stack.push(expr);\n        this.visitTag(_BinaryenThrowGetTag(expr));\n        let numOperands = _BinaryenThrowGetNumOperands(expr);\n        for (let i: Index = 0; i < numOperands; ++i) {\n          this.visit(_BinaryenThrowGetOperandAt(expr, i));\n        }\n        assert(this.stack.pop() == expr);\n        this.visitThrow(expr);\n        break;\n      }\n      case ExpressionId.Rethrow: {\n        this.visitRethrow(expr);\n        break;\n      }\n      case ExpressionId.TupleMake: {\n        let numOperands = _BinaryenTupleMakeGetNumOperands(expr);\n        if (numOperands) {\n          this.stack.push(expr);\n          for (let i: Index = 0; i < numOperands; ++i) {\n            this.visit(_BinaryenTupleMakeGetOperandAt(expr, i));\n          }\n          assert(this.stack.pop() == expr);\n        }\n        this.visitTupleMake(expr);\n        break;\n      }\n      case ExpressionId.TupleExtract: {\n        this.stack.push(expr);\n        this.visit(_BinaryenTupleExtractGetTuple(expr));\n        assert(this.stack.pop() == expr);\n        this.visitTupleExtract(expr);\n        break;\n      }\n      case ExpressionId.RefI31: {\n        this.stack.push(expr);\n        this.visit(_BinaryenRefI31GetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitRefI31(expr);\n        break;\n      }\n      case ExpressionId.I31Get: {\n        this.stack.push(expr);\n        this.visit(_BinaryenI31GetGetI31(expr));\n        assert(this.stack.pop() == expr);\n        this.visitI31Get(expr);\n        break;\n      }\n      case ExpressionId.CallRef: {\n        this.stack.push(expr);\n        let numOperands = _BinaryenCallRefGetNumOperands(expr);\n        if (numOperands) {\n          for (let i: Index = 0; i < numOperands; ++i) {\n            this.visit(_BinaryenCallRefGetOperandAt(expr, i));\n          }\n        }\n        this.visit(_BinaryenCallRefGetTarget(expr));\n        assert(this.stack.pop() == expr);\n        this.visitCallRef(expr);\n        break;\n      }\n      case ExpressionId.RefTest: {\n        this.stack.push(expr);\n        this.visit(_BinaryenRefTestGetRef(expr));\n        assert(this.stack.pop() == expr);\n        this.visitRefTest(expr);\n        break;\n      }\n      case ExpressionId.RefCast: {\n        this.stack.push(expr);\n        this.visit(_BinaryenRefCastGetRef(expr));\n        assert(this.stack.pop() == expr);\n        this.visitRefCast(expr);\n        break;\n      }\n      case ExpressionId.BrOn: {\n        this.stack.push(expr);\n        this.visitLabel(_BinaryenBrOnGetName(expr));\n        this.visit(_BinaryenBrOnGetRef(expr));\n        assert(this.stack.pop() == expr);\n        this.visitBrOn(expr);\n        break;\n      }\n      case ExpressionId.StructNew: {\n        let numOperands = _BinaryenStructNewGetNumOperands(expr);\n        if (numOperands) {\n          this.stack.push(expr);\n          for (let i: Index = 0; i < numOperands; ++i) {\n            this.visit(_BinaryenStructNewGetOperandAt(expr, i));\n          }\n          assert(this.stack.pop() == expr);\n        }\n        this.visitStructNew(expr);\n        break;\n      }\n      case ExpressionId.StructGet: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStructGetGetRef(expr));\n        this.visitIndex(_BinaryenStructGetGetIndex(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStructGet(expr);\n        break;\n      }\n      case ExpressionId.StructSet: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStructSetGetRef(expr));\n        this.visitIndex(_BinaryenStructSetGetIndex(expr));\n        this.visit(_BinaryenStructSetGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStructSet(expr);\n        break;\n      }\n      case ExpressionId.ArrayNew: {\n        this.stack.push(expr);\n        this.visit(_BinaryenArrayNewGetSize(expr));\n        let init = _BinaryenArrayNewGetInit(expr);\n        if (init) this.visit(init);\n        assert(this.stack.pop() == expr);\n        this.visitArrayNew(expr);\n        break;\n      }\n      case ExpressionId.ArrayNewFixed: {\n        let numValues = _BinaryenArrayNewFixedGetNumValues(expr);\n        if (numValues) {\n          this.stack.push(expr);\n          for (let i: Index = 0; i < numValues; ++i) {\n            this.visit(_BinaryenArrayNewFixedGetValueAt(expr, i));\n          }\n          assert(this.stack.pop() == expr);\n        }\n        this.visitArrayNewFixed(expr);\n        break;\n      }\n      case ExpressionId.ArrayGet: {\n        this.stack.push(expr);\n        this.visit(_BinaryenArrayGetGetRef(expr));\n        this.visit(_BinaryenArrayGetGetIndex(expr));\n        assert(this.stack.pop() == expr);\n        this.visitArrayGet(expr);\n        break;\n      }\n      case ExpressionId.ArraySet: {\n        this.stack.push(expr);\n        this.visit(_BinaryenArraySetGetRef(expr));\n        this.visit(_BinaryenArraySetGetIndex(expr));\n        this.visit(_BinaryenArraySetGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitArraySet(expr);\n        break;\n      }\n      case ExpressionId.ArrayLen: {\n        this.stack.push(expr);\n        this.visit(_BinaryenArrayLenGetRef(expr));\n        assert(this.stack.pop() == expr);\n        this.visitArrayLen(expr);\n        break;\n      }\n      case ExpressionId.ArrayCopy: {\n        this.stack.push(expr);\n        this.visit(_BinaryenArrayCopyGetDestRef(expr));\n        this.visit(_BinaryenArrayCopyGetDestIndex(expr));\n        this.visit(_BinaryenArrayCopyGetSrcRef(expr));\n        this.visit(_BinaryenArrayCopyGetSrcIndex(expr));\n        this.visit(_BinaryenArrayCopyGetLength(expr));\n        assert(this.stack.pop() == expr);\n        this.visitArrayCopy(expr);\n        break;\n      }\n      case ExpressionId.RefAs: {\n        this.stack.push(expr);\n        this.visit(_BinaryenRefAsGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitRefAs(expr);\n        break;\n      }\n      case ExpressionId.StringNew: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringNewGetRef(expr));\n        let start = _BinaryenStringNewGetStart(expr); // GC only\n        if (start) this.visit(start);\n        let end = _BinaryenStringNewGetEnd(expr); // GC only\n        if (end) this.visit(end);\n        assert(this.stack.pop() == expr);\n        this.visitStringNew(expr);\n        break;\n      }\n      case ExpressionId.StringConst: {\n        this.stack.push(expr);\n        assert(this.stack.pop() == expr);\n        this.visitStringConst(expr);\n        break;\n      }\n      case ExpressionId.StringMeasure: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringMeasureGetRef(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStringMeasure(expr);\n        break;\n      }\n      case ExpressionId.StringEncode: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringEncodeGetStr(expr));\n        this.visit(_BinaryenStringEncodeGetArray(expr));\n        let start = _BinaryenStringEncodeGetStart(expr); // GC only\n        if (start) this.visit(start);\n        assert(this.stack.pop() == expr);\n        this.visitStringEncode(expr);\n        break;\n      }\n      case ExpressionId.StringConcat: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringConcatGetLeft(expr));\n        this.visit(_BinaryenStringConcatGetRight(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStringConcat(expr);\n        break;\n      }\n      case ExpressionId.StringEq: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringEqGetLeft(expr));\n        this.visit(_BinaryenStringEqGetRight(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStringEq(expr);\n        break;\n      }\n      case ExpressionId.StringWTF16Get: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringWTF16GetGetRef(expr));\n        this.visit(_BinaryenStringWTF16GetGetPos(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStringWTF16Get(expr);\n        break;\n      }\n      case ExpressionId.StringSliceWTF: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringSliceWTFGetRef(expr));\n        this.visit(_BinaryenStringSliceWTFGetStart(expr));\n        this.visit(_BinaryenStringSliceWTFGetEnd(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStringSliceWTF(expr);\n        break;\n      }\n      default: throw new Error(\"unexpected expression kind\");\n    }\n    this._currentExpression = previousExpression;\n  }\n}\n\n/** Base class of custom Binaryen passes. */\nexport abstract class Pass extends Visitor {\n\n  /** Gets the current function being walked. */\n  get currentFunction(): FunctionRef {\n    let currentFunction = this._currentFunction;\n    if (!currentFunction) throw new Error(\"not walking a function\");\n    return currentFunction;\n  }\n  private _currentFunction: FunctionRef = 0;\n\n  /** Gets the current global being walked. */\n  get currentGlobal(): GlobalRef {\n    let currentGlobal = this._currentGlobal;\n    if (!currentGlobal) throw new Error(\"not walking a global\");\n    return currentGlobal;\n  }\n  private _currentGlobal: GlobalRef = 0;\n\n  /** Constructs a new Binaryen pass. */\n  constructor(readonly module: Module) {\n    super();\n  }\n\n  // Walking\n\n  /** Walks the entire module. */\n  walkModule(): void {\n    this.walkFunctions();\n    this.walkGlobals();\n  }\n\n  /** Walks all functions. */\n  walkFunctions(): void {\n    let moduleRef = this.module.ref;\n    for (let i: Index = 0, k = _BinaryenGetNumFunctions(moduleRef); i < k; ++i) {\n      this.walkFunction(_BinaryenGetFunctionByIndex(moduleRef, i));\n    }\n  }\n\n  /** Walks a specific function. */\n  walkFunction(func: FunctionRef): void {\n    let body = _BinaryenFunctionGetBody(func);\n    if (body) {\n      this._currentFunction = func;\n      this.visit(body);\n      this._currentFunction = 0;\n    }\n  }\n\n  /** Walks all global variables. */\n  walkGlobals(): void {\n    let moduleRef = this.module.ref;\n    for (let i: Index = 0, k = _BinaryenGetNumGlobals(moduleRef); i < k; ++i) {\n      this.walkGlobal(_BinaryenGetGlobalByIndex(moduleRef, i));\n    }\n  }\n\n  /** Walks a specific global variable. */\n  walkGlobal(global: GlobalRef): void {\n    this._currentGlobal = global;\n    let init = _BinaryenGlobalGetInitExpr(global);\n    if (init) this.visit(init);\n    this._currentGlobal = 0;\n  }\n\n  // Utility\n\n  /** Replaces the current expression with the specified replacement. */\n  replaceCurrent(replacement: ExpressionRef): void {\n    let search = this.currentExpression;\n    let func = this.currentFunction;\n    let body = _BinaryenFunctionGetBody(func);\n    if (body == search) {\n      _BinaryenFunctionSetBody(func, replacement);\n    } else {\n      let parent = assert(this.parentExpressionOrNull);\n      let replaced = replaceChild(parent, search, replacement);\n      if (!replaced) throw Error(\"failed to replace expression\");\n      _BinaryenExpressionFinalize(parent);\n    }\n  }\n}\n\n/** Replaces an expression within a parent expression. Returns the replaced expression on success, otherwise `0`. */\nexport function replaceChild(\n  /** Parent expression containing `search`. */\n  parent: ExpressionRef,\n  /** Expression to replace. */\n  search: ExpressionRef,\n  /** Expression to replace `search` with. */\n  replacement: ExpressionRef\n): ExpressionRef {\n  switch (_BinaryenExpressionGetId(parent)) {\n    case ExpressionId.Block: {\n      let numChildren = _BinaryenBlockGetNumChildren(parent);\n      for (let i: Index = 0; i < numChildren; ++i) {\n        let child = _BinaryenBlockGetChildAt(parent, i);\n        if (child == search) {\n          _BinaryenBlockSetChildAt(parent, i, replacement);\n          return child;\n        }\n      }\n      break;\n    }\n    case ExpressionId.If: {\n      let condition = _BinaryenIfGetCondition(parent);\n      if (condition == search) {\n        _BinaryenIfSetCondition(parent, replacement);\n        return condition;\n      }\n      let ifTrue = _BinaryenIfGetIfTrue(parent);\n      if (ifTrue == search) {\n        _BinaryenIfSetIfTrue(parent, replacement);\n        return ifTrue;\n      }\n      let ifFalse = _BinaryenIfGetIfFalse(parent);\n      if (ifFalse == search) {\n        _BinaryenIfSetIfFalse(parent, replacement);\n        return ifFalse;\n      }\n      break;\n    }\n    case ExpressionId.Loop: {\n      let body = _BinaryenLoopGetBody(parent);\n      if (body == search) {\n        _BinaryenLoopSetBody(parent, replacement);\n        return body;\n      }\n      break;\n    }\n    case ExpressionId.Break: {\n      let condition = _BinaryenBreakGetCondition(parent);\n      if (condition == search) {\n        _BinaryenBreakSetCondition(parent, replacement);\n        return condition;\n      }\n      let value = _BinaryenBreakGetValue(parent);\n      if (value == search) {\n        _BinaryenBreakSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.Switch: {\n      let condition = _BinaryenSwitchGetCondition(parent);\n      if (condition == search) {\n        _BinaryenSwitchSetCondition(parent, replacement);\n        return condition;\n      }\n      let value = _BinaryenSwitchGetValue(parent);\n      if (value == search) {\n        _BinaryenSwitchSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.Call: {\n      let numOperands = _BinaryenCallGetNumOperands(parent);\n      for (let i: Index = 0; i < numOperands; ++i) {\n        let operand = _BinaryenCallGetOperandAt(parent, i);\n        if (operand == search) {\n          _BinaryenCallSetOperandAt(parent, i, replacement);\n          return operand;\n        }\n      }\n      break;\n    }\n    case ExpressionId.CallIndirect: {\n      let target = _BinaryenCallIndirectGetTarget(parent);\n      if (target == search) {\n        _BinaryenCallIndirectSetTarget(parent, replacement);\n        return target;\n      }\n      let numOperands = _BinaryenCallIndirectGetNumOperands(parent);\n      for (let i: Index = 0; i < numOperands; ++i) {\n        let operand = _BinaryenCallIndirectGetOperandAt(parent, i);\n        if (operand == search) {\n          _BinaryenCallIndirectSetOperandAt(parent, i, replacement);\n          return operand;\n        }\n      }\n      break;\n    }\n    case ExpressionId.LocalGet: {\n      break;\n    }\n    case ExpressionId.LocalSet: {\n      let value = _BinaryenLocalSetGetValue(parent);\n      if (value == search) {\n        _BinaryenLocalSetSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.GlobalGet: {\n      break;\n    }\n    case ExpressionId.GlobalSet: {\n      let value = _BinaryenGlobalSetGetValue(parent);\n      if (value == search) {\n        _BinaryenGlobalSetSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.Load: {\n      let ptr = _BinaryenLoadGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenLoadSetPtr(parent, replacement);\n        return ptr;\n      }\n      break;\n    }\n    case ExpressionId.Store: {\n      let ptr = _BinaryenStoreGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenStoreSetPtr(parent, replacement);\n        return ptr;\n      }\n      let value = _BinaryenStoreGetValue(parent);\n      if (value == search) {\n        _BinaryenStoreSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.Const: {\n      break;\n    }\n    case ExpressionId.Unary: {\n      let value = _BinaryenUnaryGetValue(parent);\n      if (value == search) {\n        _BinaryenUnarySetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.Binary: {\n      let left = _BinaryenBinaryGetLeft(parent);\n      if (left == search) {\n        _BinaryenBinarySetLeft(parent, replacement);\n        return left;\n      }\n      let right = _BinaryenBinaryGetRight(parent);\n      if (right == search) {\n        _BinaryenBinarySetRight(parent, replacement);\n        return right;\n      }\n      break;\n    }\n    case ExpressionId.Select: {\n      let ifTrue = _BinaryenSelectGetIfTrue(parent);\n      if (ifTrue == search) {\n        _BinaryenSelectSetIfTrue(parent, replacement);\n        return ifTrue;\n      }\n      let ifFalse = _BinaryenSelectGetIfFalse(parent);\n      if (ifFalse == search) {\n        _BinaryenSelectSetIfFalse(parent, replacement);\n        return ifFalse;\n      }\n      let condition = _BinaryenSelectGetCondition(parent);\n      if (condition == search) {\n        _BinaryenSelectSetCondition(parent, replacement);\n        return condition;\n      }\n      break;\n    }\n    case ExpressionId.Drop: {\n      let value = _BinaryenDropGetValue(parent);\n      if (value == search) {\n        _BinaryenDropSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.Return: {\n      let value = _BinaryenReturnGetValue(parent);\n      if (value == search) {\n        _BinaryenReturnSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.MemorySize: {\n      break;\n    }\n    case ExpressionId.MemoryGrow: {\n      let delta = _BinaryenMemoryGrowGetDelta(parent);\n      if (delta == search) {\n        _BinaryenMemoryGrowSetDelta(parent, replacement);\n        return delta;\n      }\n      break;\n    }\n    case ExpressionId.Nop: {\n      break;\n    }\n    case ExpressionId.Unreachable: {\n      break;\n    }\n    case ExpressionId.AtomicRMW: {\n      let ptr = _BinaryenAtomicRMWGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenAtomicRMWSetPtr(parent, replacement);\n        return ptr;\n      }\n      let value = _BinaryenAtomicRMWGetValue(parent);\n      if (value == search) {\n        _BinaryenAtomicRMWSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.AtomicCmpxchg: {\n      let ptr = _BinaryenAtomicCmpxchgGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenAtomicCmpxchgSetPtr(parent, replacement);\n        return ptr;\n      }\n      let expected = _BinaryenAtomicCmpxchgGetExpected(parent);\n      if (expected == search) {\n        _BinaryenAtomicCmpxchgSetExpected(parent, replacement);\n        return expected;\n      }\n      let repl = _BinaryenAtomicCmpxchgGetReplacement(parent);\n      if (repl == search) {\n        _BinaryenAtomicCmpxchgSetReplacement(parent, replacement);\n        return repl;\n      }\n      break;\n    }\n    case ExpressionId.AtomicWait: {\n      let ptr = _BinaryenAtomicWaitGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenAtomicWaitSetPtr(parent, replacement);\n        return ptr;\n      }\n      let expected = _BinaryenAtomicWaitGetExpected(parent);\n      if (expected == search) {\n        _BinaryenAtomicWaitSetExpected(parent, replacement);\n        return expected;\n      }\n      let timeout = _BinaryenAtomicWaitGetTimeout(parent);\n      if (timeout == search) {\n        _BinaryenAtomicWaitSetTimeout(parent, replacement);\n        return timeout;\n      }\n      break;\n    }\n    case ExpressionId.AtomicNotify: {\n      let ptr = _BinaryenAtomicNotifyGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenAtomicNotifySetPtr(parent, replacement);\n        return ptr;\n      }\n      let notifyCount = _BinaryenAtomicNotifyGetNotifyCount(parent);\n      if (notifyCount == search) {\n        _BinaryenAtomicNotifySetNotifyCount(parent, replacement);\n        return notifyCount;\n      }\n      break;\n    }\n    case ExpressionId.AtomicFence: {\n      break;\n    }\n    case ExpressionId.SIMDExtract: {\n      let vec = _BinaryenSIMDExtractGetVec(parent);\n      if (vec == search) {\n        _BinaryenSIMDExtractSetVec(parent, replacement);\n        return vec;\n      }\n      break;\n    }\n    case ExpressionId.SIMDReplace: {\n      let vec = _BinaryenSIMDReplaceGetVec(parent);\n      if (vec == search) {\n        _BinaryenSIMDReplaceSetVec(parent, replacement);\n        return vec;\n      }\n      let value = _BinaryenSIMDReplaceGetValue(parent);\n      if (value == search) {\n        _BinaryenSIMDReplaceSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.SIMDShuffle: {\n      let left = _BinaryenSIMDShuffleGetLeft(parent);\n      if (left == search) {\n        _BinaryenSIMDShuffleSetLeft(parent, replacement);\n        return left;\n      }\n      let right = _BinaryenSIMDShuffleGetRight(parent);\n      if (right == search) {\n        _BinaryenSIMDShuffleSetRight(parent, replacement);\n        return right;\n      }\n      break;\n    }\n    case ExpressionId.SIMDTernary: {\n      let a = _BinaryenSIMDTernaryGetA(parent);\n      if (a == search) {\n        _BinaryenSIMDTernarySetA(parent, replacement);\n        return a;\n      }\n      let b = _BinaryenSIMDTernaryGetB(parent);\n      if (b == search) {\n        _BinaryenSIMDTernarySetB(parent, replacement);\n        return b;\n      }\n      let c = _BinaryenSIMDTernaryGetC(parent);\n      if (c == search) {\n        _BinaryenSIMDTernarySetC(parent, replacement);\n        return c;\n      }\n      break;\n    }\n    case ExpressionId.SIMDShift: {\n      let vec = _BinaryenSIMDShiftGetVec(parent);\n      if (vec == search) {\n        _BinaryenSIMDShiftSetVec(parent, replacement);\n        return vec;\n      }\n      let shift = _BinaryenSIMDShiftGetShift(parent);\n      if (shift == search) {\n        _BinaryenSIMDShiftSetShift(parent, replacement);\n        return shift;\n      }\n      break;\n    }\n    case ExpressionId.SIMDLoad: {\n      let ptr = _BinaryenSIMDLoadGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenSIMDLoadSetPtr(parent, replacement);\n        return ptr;\n      }\n      break;\n    }\n    case ExpressionId.SIMDLoadStoreLane: {\n      let ptr = _BinaryenSIMDLoadStoreLaneGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenSIMDLoadStoreLaneSetPtr(parent, replacement);\n        return ptr;\n      }\n      let vec = _BinaryenSIMDLoadStoreLaneGetVec(parent);\n      if (vec == search) {\n        _BinaryenSIMDLoadStoreLaneSetVec(parent, replacement);\n        return ptr;\n      }\n      break;\n    }\n    case ExpressionId.MemoryInit: {\n      let dest = _BinaryenMemoryInitGetDest(parent);\n      if (dest == search) {\n        _BinaryenMemoryInitSetDest(parent, replacement);\n        return dest;\n      }\n      let offset = _BinaryenMemoryInitGetOffset(parent);\n      if (offset == search) {\n        _BinaryenMemoryInitSetOffset(parent, replacement);\n        return offset;\n      }\n      let size = _BinaryenMemoryInitGetSize(parent);\n      if (size == search) {\n        _BinaryenMemoryInitSetSize(parent, replacement);\n        return size;\n      }\n      break;\n    }\n    case ExpressionId.DataDrop: {\n      break;\n    }\n    case ExpressionId.MemoryCopy: {\n      let dest = _BinaryenMemoryCopyGetDest(parent);\n      if (dest == search) {\n        _BinaryenMemoryCopySetDest(parent, replacement);\n        return dest;\n      }\n      let source = _BinaryenMemoryCopyGetSource(parent);\n      if (source == search) {\n        _BinaryenMemoryCopySetSource(parent, replacement);\n        return source;\n      }\n      let size = _BinaryenMemoryCopyGetSize(parent);\n      if (size == search) {\n        _BinaryenMemoryCopySetSize(parent, replacement);\n        return size;\n      }\n      break;\n    }\n    case ExpressionId.MemoryFill: {\n      let dest = _BinaryenMemoryFillGetDest(parent);\n      if (dest == search) {\n        _BinaryenMemoryFillSetDest(parent, replacement);\n        return dest;\n      }\n      let value = _BinaryenMemoryFillGetValue(parent);\n      if (value == search) {\n        _BinaryenMemoryFillSetValue(parent, replacement);\n        return value;\n      }\n      let size = _BinaryenMemoryFillGetSize(parent);\n      if (size == search) {\n        _BinaryenMemoryFillSetSize(parent, replacement);\n        return size;\n      }\n      break;\n    }\n    case ExpressionId.Pop: {\n      break;\n    }\n    case ExpressionId.RefNull: {\n      break;\n    }\n    case ExpressionId.RefIsNull: {\n      let value = _BinaryenRefIsNullGetValue(parent);\n      if (value == search) {\n        _BinaryenRefIsNullSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.RefFunc: {\n      break;\n    }\n    case ExpressionId.RefEq: {\n      let left = _BinaryenRefEqGetLeft(parent);\n      if (left == search) {\n        _BinaryenRefEqSetLeft(parent, replacement);\n        return left;\n      }\n      let right = _BinaryenRefEqGetRight(parent);\n      if (right == search) {\n        _BinaryenRefEqSetRight(parent, replacement);\n        return right;\n      }\n      break;\n    }\n    case ExpressionId.Try: {\n      let body = _BinaryenTryGetBody(parent);\n      if (body == search) {\n        _BinaryenTrySetBody(parent, replacement);\n        return body;\n      }\n      let numCatchBodies = _BinaryenTryGetNumCatchBodies(parent);\n      for (let i: Index = 0; i < numCatchBodies; ++i) {\n        let catchBody = _BinaryenTryGetCatchBodyAt(parent, i);\n        if (catchBody == search) {\n          _BinaryenTrySetCatchBodyAt(parent, i, replacement);\n          return catchBody;\n        }\n      }\n      break;\n    }\n    case ExpressionId.Throw: {\n      let numOperands = _BinaryenThrowGetNumOperands(parent);\n      for (let i: Index = 0; i < numOperands; ++i) {\n        let operand = _BinaryenThrowGetOperandAt(parent, i);\n        if (operand == search) {\n          _BinaryenThrowSetOperandAt(parent, i, replacement);\n          return operand;\n        }\n      }\n      break;\n    }\n    case ExpressionId.Rethrow: {\n      break;\n    }\n    case ExpressionId.TupleMake: {\n      let numOperands = _BinaryenTupleMakeGetNumOperands(parent);\n      for (let i: Index = 0; i < numOperands; ++i) {\n        let operand = _BinaryenTupleMakeGetOperandAt(parent, i);\n        if (operand == search) {\n          _BinaryenTupleMakeSetOperandAt(parent, i, replacement);\n          return operand;\n        }\n      }\n      break;\n    }\n    case ExpressionId.TupleExtract: {\n      let tuple = _BinaryenTupleExtractGetTuple(parent);\n      if (tuple == search) {\n        _BinaryenTupleExtractSetTuple(parent, replacement);\n        return tuple;\n      }\n      break;\n    }\n    case ExpressionId.RefI31: {\n      let value = _BinaryenRefI31GetValue(parent);\n      if (value == search) {\n        _BinaryenRefI31SetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.I31Get: {\n      let i31Expr = _BinaryenI31GetGetI31(parent);\n      if (i31Expr == search) {\n        _BinaryenI31GetSetI31(parent, replacement);\n        return i31Expr;\n      }\n      break;\n    }\n    case ExpressionId.CallRef: {\n      let numOperands = _BinaryenCallRefGetNumOperands(parent);\n      for (let i: Index = 0; i < numOperands; ++i) {\n        let operand = _BinaryenCallRefGetOperandAt(parent, i);\n        if (operand == search) {\n          _BinaryenCallRefSetOperandAt(parent, i, replacement);\n          return operand;\n        }\n      }\n      let target = _BinaryenCallRefGetTarget(parent);\n      if (target == search) {\n        _BinaryenCallRefSetTarget(parent, replacement);\n        return target;\n      }\n      break;\n    }\n    case ExpressionId.RefTest: {\n      let ref = _BinaryenRefTestGetRef(parent);\n      if (ref == search) {\n        _BinaryenRefTestSetRef(parent, replacement);\n        return ref;\n      }\n      break;\n    }\n    case ExpressionId.RefCast: {\n      let ref = _BinaryenRefCastGetRef(parent);\n      if (ref == search) {\n        _BinaryenRefCastSetRef(parent, replacement);\n        return ref;\n      }\n      break;\n    }\n    case ExpressionId.BrOn: {\n      let ref = _BinaryenBrOnGetRef(parent);\n      if (ref == search) {\n        _BinaryenBrOnSetRef(parent, replacement);\n        return ref;\n      }\n      break;\n    }\n    case ExpressionId.StructNew: {\n      let numOperands = _BinaryenStructNewGetNumOperands(parent);\n      for (let i: Index = 0; i < numOperands; ++i) {\n        let operand = _BinaryenStructNewGetOperandAt(parent, i);\n        if (operand == search) {\n          _BinaryenStructNewSetOperandAt(parent, i, replacement);\n          return operand;\n        }\n      }\n      break;\n    }\n    case ExpressionId.StructGet: {\n      let ref = _BinaryenStructGetGetRef(parent);\n      if (ref == search) {\n        _BinaryenStructGetSetRef(parent, replacement);\n        return ref;\n      }\n      break;\n    }\n    case ExpressionId.StructSet: {\n      let ref = _BinaryenStructSetGetRef(parent);\n      if (ref == search) {\n        _BinaryenStructSetSetRef(parent, replacement);\n        return ref;\n      }\n      let value = _BinaryenStructSetGetValue(parent);\n      if (value == search) {\n        _BinaryenStructSetSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.ArrayNew: {\n      let size = _BinaryenArrayNewGetSize(parent);\n      if (size == search) {\n        _BinaryenArrayNewSetSize(parent, replacement);\n        return size;\n      }\n      let init = _BinaryenArrayNewGetInit(parent);\n      if (init == search) {\n        _BinaryenArrayNewSetInit(parent, replacement);\n        return init;\n      }\n      break;\n    }\n    case ExpressionId.ArrayNewFixed: {\n      let numValues = _BinaryenArrayNewFixedGetNumValues(parent);\n      for (let i: Index = 0; i < numValues; ++i) {\n        let value = _BinaryenArrayNewFixedGetValueAt(parent, i);\n        if (value == search) {\n          _BinaryenArrayNewFixedSetValueAt(parent, i, replacement);\n          return value;\n        }\n      }\n      break;\n    }\n    case ExpressionId.ArrayGet: {\n      let ref = _BinaryenArrayGetGetRef(parent);\n      if (ref == search) {\n        _BinaryenArrayGetSetRef(parent, replacement);\n        return ref;\n      }\n      let index = _BinaryenArrayGetGetIndex(parent);\n      if (index == search) {\n        _BinaryenArrayGetSetIndex(parent, replacement);\n        return index;\n      }\n      break;\n    }\n    case ExpressionId.ArraySet: {\n      let ref = _BinaryenArraySetGetRef(parent);\n      if (ref == search) {\n        _BinaryenArraySetSetRef(parent, replacement);\n        return ref;\n      }\n      let index = _BinaryenArraySetGetIndex(parent);\n      if (index == search) {\n        _BinaryenArraySetSetIndex(parent, replacement);\n        return index;\n      }\n      let value = _BinaryenArraySetGetValue(parent);\n      if (value == search) {\n        _BinaryenArraySetSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.ArrayLen: {\n      let ref = _BinaryenArrayLenGetRef(parent);\n      if (ref == search) {\n        _BinaryenArrayLenSetRef(parent, replacement);\n        return ref;\n      }\n      break;\n    }\n    case ExpressionId.ArrayCopy: {\n      let destRef = _BinaryenArrayCopyGetDestRef(parent);\n      if (destRef == search) {\n        _BinaryenArrayCopySetDestRef(parent, replacement);\n        return destRef;\n      }\n      let destIndex = _BinaryenArrayCopyGetDestIndex(parent);\n      if (destIndex == search) {\n        _BinaryenArrayCopySetDestIndex(parent, replacement);\n        return destIndex;\n      }\n      let srcRef = _BinaryenArrayCopyGetSrcRef(parent);\n      if (srcRef == search) {\n        _BinaryenArrayCopySetSrcRef(parent, replacement);\n        return srcRef;\n      }\n      let srcIndex = _BinaryenArrayCopyGetSrcIndex(parent);\n      if (srcIndex == search) {\n        _BinaryenArrayCopySetSrcIndex(parent, replacement);\n        return srcIndex;\n      }\n      let length = _BinaryenArrayCopyGetLength(parent);\n      if (length == search) {\n        _BinaryenArrayCopySetLength(parent, replacement);\n        return length;\n      }\n      break;\n    }\n    case ExpressionId.RefAs: {\n      let value = _BinaryenRefAsGetValue(parent);\n      if (value == search) {\n        _BinaryenRefAsSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.StringNew: {\n      let ptr = _BinaryenStringNewGetRef(parent);\n      if (ptr == search) {\n        _BinaryenStringNewSetRef(parent, replacement);\n        return ptr;\n      }\n      let start = _BinaryenStringNewGetStart(parent);\n      if (start == search) {\n        _BinaryenStringNewSetStart(parent, replacement);\n        return start;\n      }\n      let end = _BinaryenStringNewGetEnd(parent);\n      if (end == search) {\n        _BinaryenStringNewSetEnd(parent, replacement);\n        return end;\n      }\n      break;\n    }\n    case ExpressionId.StringConst: {\n      break;\n    }\n    case ExpressionId.StringMeasure: {\n      let ref = _BinaryenStringMeasureGetRef(parent);\n      if (ref == search) {\n        _BinaryenStringMeasureSetRef(parent, replacement);\n        return ref;\n      }\n      break;\n    }\n    case ExpressionId.StringEncode: {\n      let ref = _BinaryenStringEncodeGetStr(parent);\n      if (ref == search) {\n        _BinaryenStringEncodeSetStr(parent, replacement);\n        return ref;\n      }\n      let ptr = _BinaryenStringEncodeGetArray(parent);\n      if (ptr == search) {\n        _BinaryenStringEncodeSetArray(parent, replacement);\n        return ptr;\n      }\n      let start = _BinaryenStringEncodeGetStart(parent);\n      if (start == search) {\n        _BinaryenStringEncodeSetStart(parent, replacement);\n        return start;\n      }\n      break;\n    }\n    case ExpressionId.StringConcat: {\n      let left = _BinaryenStringConcatGetLeft(parent);\n      if (left == search) {\n        _BinaryenStringConcatSetLeft(parent, replacement);\n        return left;\n      }\n      let right = _BinaryenStringConcatGetRight(parent);\n      if (right == search) {\n        _BinaryenStringConcatSetRight(parent, replacement);\n        return right;\n      }\n      break;\n    }\n    case ExpressionId.StringEq: {\n      let left = _BinaryenStringEqGetLeft(parent);\n      if (left == search) {\n        _BinaryenStringEqSetLeft(parent, replacement);\n        return left;\n      }\n      let right = _BinaryenStringEqGetRight(parent);\n      if (right == search) {\n        _BinaryenStringEqSetRight(parent, replacement);\n        return right;\n      }\n      break;\n    }\n    case ExpressionId.StringWTF16Get: {\n      let ref = _BinaryenStringWTF16GetGetRef(parent);\n      if (ref == search) {\n        _BinaryenStringWTF16GetSetRef(parent, replacement);\n        return ref;\n      }\n      let pos = _BinaryenStringWTF16GetGetPos(parent);\n      if (pos == search) {\n        _BinaryenStringWTF16GetSetPos(parent, replacement);\n        return pos;\n      }\n      break;\n    }\n    case ExpressionId.StringSliceWTF: {\n      let ref = _BinaryenStringSliceWTFGetRef(parent);\n      if (ref == search) {\n        _BinaryenStringSliceWTFSetRef(parent, replacement);\n        return ref;\n      }\n      let start = _BinaryenStringSliceWTFGetStart(parent);\n      if (start == search) {\n        _BinaryenStringSliceWTFSetStart(parent, replacement);\n        return start;\n      }\n      let end = _BinaryenStringSliceWTFGetEnd(parent);\n      if (end == search) {\n        _BinaryenStringSliceWTFSetEnd(parent, replacement);\n        return end;\n      }\n      break;\n    }\n    default: throw new Error(\"unexpected expression id\");\n  }\n  return 0;\n}\n", "/**\n * @fileoverview A lightweight store instrumentation pass.\n * \n * Can be used to find rogue stores to protected memory addresses like object\n * headers or similar, without going overboard with instrumentation. Also\n * passes a flag whether a store originates within the runtime or other code.\n * \n * @license Apache-2.0\n */\n\nimport {\n  Pass\n} from \"./pass\";\n\nimport {\n  Compiler\n} from \"../compiler\";\n\nimport {\n  createType,\n  ExpressionRef,\n  TypeRef\n} from \"../module\";\n\nimport {\n  _BinaryenFunctionGetName,\n  _BinaryenStoreGetBytes,\n  _BinaryenStoreGetOffset,\n  _BinaryenStoreGetPtr,\n  _BinaryenStoreSetPtr\n} from \"../glue/binaryen\";\n\n/** Instruments stores to also call an import. */\nexport class RtraceMemory extends Pass {\n  /** Whether we've seen any stores. */\n  seenStores: bool = false;\n  /** Target pointer type. */\n  ptrType: TypeRef;\n\n  constructor(compiler: Compiler) {\n    super(compiler.module);\n    this.ptrType = compiler.options.sizeTypeRef;\n  }\n\n  checkRT(): bool {\n    let functionName = this.module.readStringCached(_BinaryenFunctionGetName(this.currentFunction))!;\n    return functionName.startsWith(\"~lib/rt/\");\n  }\n\n  /** @override */\n  visitStore(store: ExpressionRef): void {\n    let module = this.module;\n    let ptr = _BinaryenStoreGetPtr(store);\n    let offset = _BinaryenStoreGetOffset(store);\n    let bytes = _BinaryenStoreGetBytes(store);\n    // onstore(ptr: usize, offset: i32, bytes: i32, isRT: bool) -> ptr\n    _BinaryenStoreSetPtr(store,\n      module.call(\"~onstore\", [\n        ptr,\n        module.i32(offset),\n        module.i32(bytes),\n        module.i32(i32(this.checkRT()))\n      ], this.ptrType)\n    );\n    this.seenStores = true;\n  }\n\n  // TODO: MemoryFill, Atomics\n\n  /** @override */\n  walkModule(): void {\n    super.walkModule();\n    if (this.seenStores) {\n      this.module.addFunctionImport(\"~onstore\", \"rtrace\", \"onstore\",\n        createType([ this.ptrType, TypeRef.I32, TypeRef.I32, TypeRef.I32 ]),\n        this.ptrType\n      );\n    }\n  }\n}\n", "/**\n * @fileoverview Shadow stack instrumentation for a precise GC.\n *\n * Instruments function arguments and local assignments marked with a 'tostack'\n * call to also do stores to a shadow stack of managed values only.\n *\n * Consider a simple call to a function looking like the following, taking\n * managed arguments, plus assigning managed values to locals:\n *\n *   function foo(a: Obj, b: Obj): Obj {\n *     let c = __tostack(a) // slot 2\n *     __collect()\n *     return b\n *   }\n *\n *   foo(__tostack(a), __tostack(b)) // slot 0, 1\n *\n * At the call to `__collect()` the 32-bit stack frame of the function is:\n *\n *   Offset | Value stored\n *   -------|----------------------------\n *      0   | First managed argument 'a'\n *      4   | Second managed argument 'b'\n *   -------|----------------------------\n *      8   | First managed local 'c'\n *\n * We are splitting the frame in two halves as annotated since both halves are\n * only known separately for indirect calls, with the first half becoming an\n * extension of the calling function's stack frame by means of treating the\n * arguments as if these were locals beyond the caller's `numLocals`. Function\n * arguments stay a bit longer on the stack than usually, but we also don't have\n * to modify the stack pointer pre-call at all this way. The caller's amended\n * stack frame when assuming one managed local may look like this:\n *\n *   Offset | Value stored\n *   -------|----------------------------\n *      0   | First managed local '?'\n *      4   | Extended with first managed argument 'a'\n *      8   | Extended with second managed argument 'b'\n *\n * with the callee's stack frame becoming just:\n *\n *   Offset | Value stored\n *   -------|----------------------------\n *      0   | First managed local 'c'\n *\n * Instrumentation added below looks about like the following, with the stack\n * growing downwards and 't' and 'r' being new temporary locals:\n *\n *   // callee frameSize = 1 * sizeof<usize>()\n *   function foo(a: usize, b: usize): usize {\n *     memory.fill(__stack_pointer -= frameSize, 0, frameSize)\n *     store<usize>(__stack_pointer, c = a, 0 * sizeof<usize>())\n *     __collect()\n *     let r = b\n *     __stack_pointer += frameSize\n *     return r\n *   }\n *\n *   // caller frameSize = (numLocalSlots + 2 [by extension]) * sizeof<usize>()\n *   (\n *     r = foo(\n *       ( t = a,\n *         store<usize>(__stack_pointer, t, (numLocalSlots + 0) * sizeof<usize>()),\n *         t ),\n *       ( t = b,\n *         store<usize>(__stack_pointer, t, (numLocalSlots + 1) * sizeof<usize>()),\n *         t )\n *     ),\n *     r\n *   )\n *\n * Also note that we have to `memory.fill` the second half because the first\n * assignment to a local may happen at a later point within the function. The\n * invariant we need to maintain for a precise GC is that it only sees zeroes\n * or valid pointers, but never an invalid pointer left on the stack earlier.\n * Since most frames are small, we unroll a sequence of `store`s up to a frame\n * size of 16 bytes, and `memory.fill`, if available, beyond.\n *\n * @license Apache-2.0\n */\n\nimport {\n  Pass\n} from \"./pass\";\n\nimport {\n  _BinaryenAddFunction,\n  _BinaryenAddFunctionExport,\n  _BinaryenCallGetNumOperands,\n  _BinaryenCallGetOperandAt,\n  _BinaryenCallGetTarget,\n  _BinaryenCallIndirectGetNumOperands,\n  _BinaryenCallIndirectGetOperandAt,\n  _BinaryenCallIndirectSetOperandAt,\n  _BinaryenCallSetOperandAt,\n  _BinaryenExportGetKind,\n  _BinaryenExportGetName,\n  _BinaryenExportGetValue,\n  _BinaryenExpressionGetId,\n  _BinaryenExpressionGetType,\n  _BinaryenFunctionGetBody,\n  _BinaryenFunctionGetName,\n  _BinaryenFunctionGetNumLocals,\n  _BinaryenFunctionGetNumVars,\n  _BinaryenFunctionGetParams,\n  _BinaryenFunctionGetResults,\n  _BinaryenFunctionGetVar,\n  _BinaryenFunctionSetBody,\n  _BinaryenGetExport,\n  _BinaryenGetFunction,\n  _BinaryenLocalSetGetIndex,\n  _BinaryenLocalSetGetValue,\n  _BinaryenLocalSetIsTee,\n  _BinaryenLocalSetSetValue,\n  _BinaryenRemoveExport,\n  _BinaryenRemoveFunction,\n  _BinaryenReturnGetValue,\n  _BinaryenReturnSetValue,\n  _free\n} from \"../glue/binaryen\";\n\nimport {\n  ExpressionId,\n  ExpressionRef,\n  FunctionRef,\n  Index,\n  BinaryOp,\n  TypeRef,\n  allocPtrArray,\n  Module,\n  ExternalKind,\n  ExportRef,\n  expandType,\n  isConstZero,\n} from \"../module\";\n\nimport {\n  Compiler,\n  Options\n} from \"../compiler\";\n\nimport {\n  Feature\n} from \"../common\";\n\nimport {\n  BuiltinNames\n} from \"../builtins\";\n\nimport {\n  Source\n} from \"../ast\";\n\ntype LocalIndex = Index;\ntype SlotIndex = Index;\ntype SlotMap = Map<LocalIndex,SlotIndex>;\ntype TempMap = Map<TypeRef,LocalIndex>;\n\n/** Attempts to match the `__tostack(value)` pattern. Returns `value` if a match, otherwise `0`.  */\nfunction matchPattern(module: Module, expr: ExpressionRef): ExpressionRef {\n  let isFound = false;\n  while (\n    _BinaryenExpressionGetId(expr) == ExpressionId.Call &&\n    module.readStringCached(_BinaryenCallGetTarget(expr)) == BuiltinNames.tostack\n  ) {\n    assert(_BinaryenCallGetNumOperands(expr) == 1);\n    expr = _BinaryenCallGetOperandAt(expr, 0);\n    isFound = true;\n  }\n  if (!isFound) return 0;\n  return expr;\n}\n\n/** Tests whether a `value` matched by `matchTostack` needs a slot. */\nfunction needsSlot(value: ExpressionRef): bool {\n  switch (_BinaryenExpressionGetId(value)) {\n    // no need to stack null pointers\n    case ExpressionId.Const: return !isConstZero(value);\n    // note: can't omit a slot when assigning from another local since the other\n    // local might have shorter lifetime and become reassigned, say in a loop,\n    // then no longer holding on to the previous value in its stack slot.\n  }\n  return true;\n}\n\n/** Instruments a module with a shadow stack for precise GC. */\nexport class ShadowStackPass extends Pass {\n  /** Stack frame slots, per function. */\n  slotMaps: Map<FunctionRef, SlotMap> = new Map();\n  /** Temporary locals, per function. */\n  tempMaps: Map<FunctionRef, TempMap> = new Map();\n  /** Exports (with managed operands) map. */\n  exportMap: Map<string,i32[]> = new Map();\n  /** Compiler reference. */\n  compiler: Compiler;\n\n  constructor(compiler: Compiler) {\n    super(compiler.module);\n    this.compiler = compiler;\n  }\n\n  /** Compiler options. */\n  get options(): Options { return this.compiler.options; }\n  /** Target pointer type. */\n  get ptrType(): TypeRef { return this.options.sizeTypeRef; }\n  /** Target pointer size. */\n  get ptrSize(): i32 { return this.ptrType == TypeRef.I64 ? 8 : 4; }\n  /** Target pointer addition operation. */\n  get ptrBinaryAdd(): BinaryOp { return this.ptrType == TypeRef.I64 ? BinaryOp.AddI64 : BinaryOp.AddI32; }\n  /** Target pointer subtraction operation. */\n  get ptrBinarySub(): BinaryOp { return this.ptrType == TypeRef.I64 ? BinaryOp.SubI64 : BinaryOp.SubI32; }\n\n  /** Gets a constant with the specified value of the target pointer type. */\n  ptrConst(value: i32): ExpressionRef {\n    return this.ptrType == TypeRef.I64\n      ? this.module.i64(value)\n      : this.module.i32(value);\n  }\n\n  /** Notes the presence of a slot for the specified (imaginary) local, returning the slot index. */\n  noteSlot(func: FunctionRef, localIndex: Index): i32 {\n    let slotMap: SlotMap;\n    if (this.slotMaps.has(func)) {\n      slotMap = changetype<SlotMap>(this.slotMaps.get(func));\n      if (slotMap.has(localIndex)) {\n        return changetype<i32>(slotMap.get(localIndex));\n      }\n    } else {\n      slotMap = new Map();\n      this.slotMaps.set(func, slotMap);\n    }\n    let slotIndex = slotMap.size;\n    slotMap.set(localIndex, slotIndex);\n    return slotIndex;\n  }\n\n  /** Notes the presence of an exported function taking managed operands. */\n  noteExport(name: string, managedOperandIndices: i32[]): void {\n    if (!managedOperandIndices.length) return;\n    this.exportMap.set(name, managedOperandIndices);\n  }\n\n  /** Gets a shared temporary local of the given type in the specified functions. */\n  getSharedTemp(func: FunctionRef, type: TypeRef): Index {\n    let tempMap: TempMap;\n    if (this.tempMaps.has(func)) {\n      tempMap = changetype<TempMap>(this.tempMaps.get(func));\n      if (tempMap.has(type)) {\n        return changetype<Index>(tempMap.get(type));\n      }\n    } else {\n      tempMap = new Map();\n      this.tempMaps.set(func, tempMap);\n    }\n    let numLocals = _BinaryenFunctionGetNumLocals(func);\n    let localIndex = numLocals + tempMap.size;\n    tempMap.set(type, localIndex);\n    return localIndex;\n  }\n\n  /** Makes an expression modifying the stack pointer by the given offset. */\n  makeStackOffset(offset: i32): ExpressionRef {\n    assert(offset != 0);\n    let module = this.module;\n    let expr = module.global_set(BuiltinNames.stack_pointer,\n      module.binary(offset >= 0 ? this.ptrBinaryAdd : this.ptrBinarySub,\n        module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n        this.ptrConst(abs(offset))\n      )\n    );\n    if (offset > 0) return expr;\n    return module.block(null, [\n      expr,\n      this.makeStackCheck()\n    ], TypeRef.None);\n  }\n\n  /** Makes a sequence of expressions zeroing the stack frame. */\n  makeStackFill(frameSize: i32, stmts: ExpressionRef[]): void {\n    assert(frameSize > 0);\n    let module = this.module;\n    if (this.options.hasFeature(Feature.BulkMemory) && frameSize > 16) {\n      stmts.push(\n        module.memory_fill(\n          module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n          module.i32(0), // TODO: Wasm64 also i32?\n          this.ptrConst(frameSize)\n        )\n      );\n    } else {\n      let remain = frameSize;\n      while (remain >= 8) {\n        // store<i64>(__stack_pointer, 0, frameSize - remain)\n        stmts.push(\n          module.store(8,\n            module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n            module.i64(0),\n            TypeRef.I64,\n            frameSize - remain\n          )\n        );\n        remain -= 8;\n      }\n      if (remain) {\n        assert(remain == 4);\n        // store<i32>(__stack_pointer, 0, frameSize - remain)\n        stmts.push(\n          module.store(4,\n            module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n            module.i32(0),\n            TypeRef.I32,\n            frameSize - remain\n          )\n        );\n      }\n    }\n  }\n\n  private hasStackCheckFunction: bool = false;\n\n  /** Makes a check that the current stack pointer is valid. */\n  makeStackCheck(): ExpressionRef {\n    let module = this.module;\n    if (!this.hasStackCheckFunction) {\n      this.hasStackCheckFunction = true;\n      module.addFunction(\"~stack_check\", TypeRef.None, TypeRef.None, null,\n        module.if(\n          module.binary(BinaryOp.LtI32,\n            module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n            module.global_get(BuiltinNames.data_end, this.ptrType)\n          ),\n          this.compiler.makeStaticAbort(\n            this.compiler.ensureStaticString(\"stack overflow\"),\n            Source.native\n          )\n        )\n      );\n    }\n    return module.call(\"~stack_check\", null, TypeRef.None);\n  }\n\n  private updateCallOperands(operands: ExpressionRef[]): i32 {\n    let module = this.module;\n    let numSlots = 0;\n    for (let i = 0, k = operands.length; i < k; ++i) {\n      let operand = operands[i];\n      let match = matchPattern(module, operand);\n      if (!match) continue;\n      if (!needsSlot(match)) {\n        operands[i] = match;\n        continue;\n      }\n      let currentFunction = this.currentFunction;\n      let numLocals = _BinaryenFunctionGetNumLocals(currentFunction);\n      let slotIndex = this.noteSlot(currentFunction, numLocals + this.callSlotOffset + numSlots);\n      let temp = this.getSharedTemp(currentFunction, this.ptrType);\n      let stmts = new Array<ExpressionRef>();\n      // t = value\n      stmts.push(\n        module.local_set(temp, match, false)\n      );\n      // store<usize>(__stack_pointer, t, slotIndex * ptrSize)\n      stmts.push(\n        module.store(this.ptrSize,\n          module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n          module.local_get(temp, this.ptrType),\n          this.ptrType, slotIndex * this.ptrSize\n        )\n      );\n      // -> t\n      stmts.push(\n        module.local_get(temp, this.ptrType)\n      );\n      operands[i] = module.block(null, stmts, this.ptrType);\n      ++numSlots;\n    }\n    return numSlots;\n  }\n\n  /** Slot offset accounting for nested calls. */\n  private callSlotOffset: i32 = 0;\n  /** Slot offset stack in nested calls. */\n  private callSlotStack: i32[] = new Array();\n\n  /** @override */\n  visitCallPre(call: ExpressionRef): void {\n    let numOperands = _BinaryenCallGetNumOperands(call);\n    let operands = new Array<ExpressionRef>(numOperands);\n    for (let i: Index = 0; i < numOperands; ++i) {\n      operands[i] = _BinaryenCallGetOperandAt(call, i);\n    }\n    let numSlots = this.updateCallOperands(operands);\n    for (let i = 0, k = operands.length; i < k; ++i) {\n      _BinaryenCallSetOperandAt(call, i, operands[i]);\n    }\n    if (numSlots) {\n      // Reserve these slots for us so nested calls use their own\n      this.callSlotOffset += numSlots;\n    }\n    this.callSlotStack.push(numSlots);\n  }\n\n  /** @override */\n  visitCall(call: ExpressionRef): void {\n    let numSlots = this.callSlotStack.pop();\n    if (numSlots) this.callSlotOffset -= numSlots;\n  }\n\n  /** @override */\n  visitCallIndirectPre(callIndirect: ExpressionRef): void {\n    let numOperands = _BinaryenCallIndirectGetNumOperands(callIndirect);\n    let operands = new Array<ExpressionRef>(numOperands);\n    for (let i: Index = 0; i < numOperands; ++i) {\n      operands[i] = _BinaryenCallIndirectGetOperandAt(callIndirect, i);\n    }\n    let numSlots = this.updateCallOperands(operands);\n    for (let i = 0, k = operands.length; i < k; ++i) {\n      _BinaryenCallIndirectSetOperandAt(callIndirect, i, operands[i]);\n    }\n    if (numSlots) {\n      // Reserve these slots for us so nested calls use their own\n      this.callSlotOffset += numSlots;\n    }\n    this.callSlotStack.push(numSlots);\n  }\n\n  /** @override */\n  visitCallIndirect(callIndirect: ExpressionRef): void {\n    let numSlots = this.callSlotStack.pop();\n    if (numSlots) this.callSlotOffset -= numSlots;\n  }\n\n  /** @override */\n  visitLocalSet(localSet: ExpressionRef): void {\n    let module = this.module;\n    let value = _BinaryenLocalSetGetValue(localSet);\n    let match = matchPattern(module, value);\n    if (!match) return;\n    if (!needsSlot(match)) {\n      _BinaryenLocalSetSetValue(localSet, match);\n      return;\n    }\n    let index = _BinaryenLocalSetGetIndex(localSet);\n    let slotIndex = this.noteSlot(this.currentFunction, index);\n    let stmts = new Array<ExpressionRef>();\n    // store<usize>(__stack_pointer, local = match, slotIndex * ptrSize)\n    stmts.push(\n      module.store(this.ptrSize,\n        module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n        module.local_tee(index, match, false),\n        this.ptrType, slotIndex * this.ptrSize\n      )\n    );\n    if (_BinaryenLocalSetIsTee(localSet)) {\n      // -> local\n      stmts.push(\n        module.local_get(index, this.ptrType)\n      );\n      this.replaceCurrent(module.flatten(stmts, this.ptrType));\n    } else {\n      this.replaceCurrent(module.flatten(stmts, TypeRef.None));\n    }\n  }\n\n  /** Updates a function with additional locals etc. */\n  updateFunction(funcRef: FunctionRef): void {\n    let name = _BinaryenFunctionGetName(funcRef);\n    let params = _BinaryenFunctionGetParams(funcRef);\n    let results = _BinaryenFunctionGetResults(funcRef);\n    let body = assert(_BinaryenFunctionGetBody(funcRef));\n    let numVars = _BinaryenFunctionGetNumVars(funcRef);\n    let vars = new Array<TypeRef>();\n    for (let i: Index = 0; i < numVars; ++i) {\n      vars[i] = _BinaryenFunctionGetVar(funcRef, i);\n    }\n    let tempMaps = this.tempMaps;\n    if (tempMaps.has(funcRef)) {\n      let tempMap = changetype<TempMap>(tempMaps.get(funcRef));\n      for (let _keys = Map_keys(tempMap), i = 0, k = _keys.length; i < k; ++i) {\n        vars.push(_keys[i]);\n      }\n    }\n    let moduleRef = this.module.ref;\n    _BinaryenRemoveFunction(moduleRef, name);\n    let cArr = allocPtrArray(vars);\n    let newFuncRef = _BinaryenAddFunction(moduleRef, name, params, results, cArr, vars.length, body);\n    if (this.options.sourceMap || this.options.debugInfo) {\n      let func = this.compiler.program.searchFunctionByRef(newFuncRef);\n      if (func) func.addDebugInfo(this.module, newFuncRef);\n    }\n    _free(cArr);\n  }\n\n  /** Updates a function export taking managed arguments. */\n  updateExport(exportRef: ExportRef, managedOperandIndices: i32[]): void {\n    let module = this.module;\n    let moduleRef = module.ref;\n    assert(_BinaryenExportGetKind(exportRef) == ExternalKind.Function);\n\n    let internalNameRef = _BinaryenExportGetValue(exportRef);\n    let internalName = module.readStringCached(internalNameRef)!;\n    let externalNameRef = _BinaryenExportGetName(exportRef);\n    let funcRef = _BinaryenGetFunction(moduleRef, internalNameRef);\n    let params = _BinaryenFunctionGetParams(funcRef);\n    let paramTypes = expandType(params);\n    let numParams = paramTypes.length;\n    let results = _BinaryenFunctionGetResults(funcRef);\n    let numLocals = numParams;\n    let vars = new Array<TypeRef>();\n    let numSlots = assert(managedOperandIndices.length);\n    let frameSize = numSlots * this.ptrSize;\n    let wrapperName = \"export:\" + internalName;\n    let wrapperNameRef = module.allocStringCached(wrapperName);\n\n    if (_BinaryenGetFunction(moduleRef, wrapperNameRef) == 0) {\n      let stmts = new Array<ExpressionRef>();\n      // __stack_pointer -= frameSize\n      stmts.push(\n        this.makeStackOffset(-frameSize)\n      );\n      for (let slotIndex = 0; slotIndex < numSlots; ++slotIndex) {\n        // store<usize>(__stack_pointer, $local, slotIndex * ptrSize)\n        stmts.push(\n          module.store(this.ptrSize,\n            module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n            module.local_get(managedOperandIndices[slotIndex], this.ptrType),\n            this.ptrType, slotIndex * this.ptrSize\n          )\n        );\n      }\n      let forwardedOperands = new Array<ExpressionRef>(numParams);\n      for (let i = 0; i < numParams; ++i) {\n        forwardedOperands[i] = module.local_get(i, paramTypes[i]);\n      }\n      if (results != TypeRef.None) {\n        let tempIndex = numLocals++;\n        vars.push(results);\n        // t = original(...)\n        stmts.push(\n          module.local_set(tempIndex,\n            module.call(internalName, forwardedOperands, results),\n            false // internal\n          )\n        );\n        // __stack_pointer += frameSize\n        stmts.push(\n          this.makeStackOffset(+frameSize)\n        );\n        // -> t\n        stmts.push(\n          module.local_get(tempIndex, results)\n        );\n      } else {\n        // original(...)\n        stmts.push(\n          module.call(internalName, forwardedOperands, results)\n        );\n        // __stack_pointer += frameSize\n        stmts.push(\n          this.makeStackOffset(+frameSize)\n        );\n      }\n      let cArr = allocPtrArray(vars);\n      _BinaryenAddFunction(moduleRef, wrapperNameRef, params, results, cArr, vars.length,\n        module.block(null, stmts, results)\n      );\n      _free(cArr);\n    }\n    _BinaryenRemoveExport(moduleRef, externalNameRef);\n    _BinaryenAddFunctionExport(moduleRef, wrapperNameRef, externalNameRef);\n  }\n\n  /** @override */\n  walkModule(): void {\n    // Run the pass normally\n    super.walkModule();\n\n    // Instrument returns in functions utilizing stack slots\n    let module = this.module;\n    let instrumentReturns = new InstrumentReturns(this);\n    for (let _keys = Map_keys(this.slotMaps), i = 0, k = _keys.length; i < k; ++i) {\n      let func = _keys[i];\n      let slotMap = changetype<SlotMap>(this.slotMaps.get(func));\n      let frameSize = slotMap.size * this.ptrSize;\n\n      // Instrument function returns\n      instrumentReturns.frameSize = frameSize;\n      instrumentReturns.walkFunction(func);\n\n      // Instrument function entry\n      let stmts = new Array<ExpressionRef>();\n      // __stack_pointer -= frameSize\n      stmts.push(\n        this.makeStackOffset(-frameSize)\n      );\n      // memory.fill(__stack_pointer, 0, frameSize)\n      this.makeStackFill(frameSize, stmts);\n\n      // Handle implicit return\n      let body = _BinaryenFunctionGetBody(func);\n      let bodyType = _BinaryenExpressionGetType(body);\n      if (bodyType == TypeRef.Unreachable) {\n        // body\n        stmts.push(\n          body\n        );\n      } else if (bodyType == TypeRef.None) {\n        // body\n        stmts.push(\n          body\n        );\n        // __stack_pointer += frameSize\n        stmts.push(\n          this.makeStackOffset(+frameSize)\n        );\n      } else {\n        let temp = this.getSharedTemp(func, bodyType);\n        // t = body\n        stmts.push(\n          module.local_set(temp, body, false)\n        );\n        // __stack_pointer += frameSize\n        stmts.push(\n          this.makeStackOffset(+frameSize)\n        );\n        // -> t\n        stmts.push(\n          module.local_get(temp, bodyType)\n        );\n      }\n      _BinaryenFunctionSetBody(func, module.flatten(stmts, bodyType));\n    }\n\n    // Update functions we added more locals to\n    // TODO: _BinaryenFunctionAddVar ?\n    for (let _keys = Map_keys(this.tempMaps), i = 0, k = _keys.length; i < k; ++i) {\n      this.updateFunction(_keys[i]);\n    }\n\n    // Update exports taking managed arguments\n    let exportMap = this.exportMap;\n    for (let _keys = Map_keys(exportMap), i = 0, k = _keys.length; i < k; ++i) {\n      let exportName = _keys[i];\n      let exportRef = _BinaryenGetExport(module.ref, module.allocStringCached(exportName));\n      let managedOperandIndices = changetype<i32[]>(exportMap.get(exportName));\n      this.updateExport(exportRef, managedOperandIndices);\n    }\n  }\n}\n\n/** Companion pass instrumenting `return` statements to restore the stack frame. */\nclass InstrumentReturns extends Pass {\n  /** Parent pass. */\n  parentPass: ShadowStackPass;\n  /** Frame size of the current function being processed. */\n  frameSize: i32 = 0;\n\n  constructor(shadowStack: ShadowStackPass) {\n    super(shadowStack.module);\n    this.parentPass = shadowStack;\n  }\n\n  /** @override */\n  visitReturn(ret: ExpressionRef): void {\n    assert(this.frameSize);\n    let module = this.module;\n    let value = _BinaryenReturnGetValue(ret);\n    let stmts = new Array<ExpressionRef>();\n    if (value) {\n      let returnType = _BinaryenExpressionGetType(value);\n      if (returnType == TypeRef.Unreachable) return;\n      let temp = this.parentPass.getSharedTemp(this.currentFunction, returnType);\n      // t = value\n      stmts.push(\n        module.local_set(temp, value, false)\n      );\n      // __stack_pointer += frameSize\n      stmts.push(\n        this.parentPass.makeStackOffset(+this.frameSize)\n      );\n      // return t\n      _BinaryenReturnSetValue(ret, module.local_get(temp, returnType));\n    } else {\n      // __stack_pointer += frameSize\n      stmts.push(\n        this.parentPass.makeStackOffset(+this.frameSize)\n      );\n      // return\n    }\n    stmts.push(\n      ret\n    );\n    this.replaceCurrent(module.flatten(stmts, TypeRef.Unreachable));\n  }\n}\n", "import {\n  SourceKind\n} from \"../ast\";\n\nimport {\n  CommonFlags\n} from \"../common\";\n\nimport {\n  ClassPrototype,\n  Element,\n  ElementKind,\n  Function,\n  Enum,\n  Class,\n  Interface,\n  File,\n  FunctionPrototype,\n  Global,\n  Program,\n  Property,\n  PropertyPrototype,\n  InterfacePrototype\n} from \"../program\";\n\n/** Walker base class. */\nexport abstract class ExportsWalker {\n\n  /** Program reference. */\n  program: Program;\n  /** Whether to include private members */\n  includePrivate: bool;\n  /** Already seen elements. */\n  seen: Map<Element,string> = new Map();\n\n  /** Constructs a new Element walker. */\n  constructor(program: Program, includePrivate: bool = false) {\n    this.program = program;\n    this.includePrivate = includePrivate;\n  }\n\n  /** Walks all elements and calls the respective handlers. */\n  walk(): void {\n    // TODO: for (let file of this.program.filesByName.values()) {\n    for (let _values = Map_values(this.program.filesByName), i = 0, k = _values.length; i < k; ++i) {\n      let file = unchecked(_values[i]);\n      if (file.source.sourceKind == SourceKind.UserEntry) this.visitFile(file);\n    }\n  }\n\n  /** Visits all exported elements of a file. */\n  visitFile(file: File): void {\n    let exports = file.exports;\n    if (exports) {\n      // TODO: for (let [memberName, member] of exports) {\n      for (let _keys = Map_keys(exports), i = 0, k = _keys.length; i < k; ++i) {\n        let memberName = unchecked(_keys[i]);\n        let member = assert(exports.get(memberName));\n        this.visitElement(memberName, member);\n      }\n    }\n    let exportsStar = file.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        let exportStar = unchecked(exportsStar[i]);\n        this.visitFile(exportStar);\n      }\n    }\n  }\n\n  /** Visits an element.*/\n  visitElement(name: string, element: Element): void {\n    if (element.is(CommonFlags.Private) && !this.includePrivate) return;\n    let seen = this.seen;\n    if (!element.is(CommonFlags.Instance) && seen.has(element)) {\n      this.visitAlias(name, element, assert(seen.get(element)));\n      return;\n    }\n    seen.set(element, name);\n    switch (element.kind) {\n      case ElementKind.Global: {\n        if (element.is(CommonFlags.Compiled)) this.visitGlobal(name, <Global>element);\n        break;\n      }\n      case ElementKind.Enum: {\n        if (element.is(CommonFlags.Compiled)) this.visitEnum(name, <Enum>element);\n        break;\n      }\n      case ElementKind.EnumValue: break; // handled by visitEnum\n      case ElementKind.FunctionPrototype: {\n        this.visitFunctionInstances(name, <FunctionPrototype>element);\n        break;\n      }\n      case ElementKind.ClassPrototype: {\n        this.visitClassInstances(name, <ClassPrototype>element);\n        break;\n      }\n      case ElementKind.InterfacePrototype: {\n        this.visitInterfaceInstances(name, <InterfacePrototype>element);\n        break;\n      }\n      case ElementKind.PropertyPrototype: {\n        let propertyInstance = (<PropertyPrototype>element).instance;\n        if (!propertyInstance) break;\n        element = propertyInstance;\n        // fall-through\n      }\n      case ElementKind.Property: {\n        let propertyInstance = <Property>element;\n        let getterInstance = propertyInstance.getterInstance;\n        if (getterInstance) this.visitFunction(name, getterInstance);\n        let setterInstance = propertyInstance.setterInstance;\n        if (setterInstance) this.visitFunction(name, setterInstance);\n        break;\n      }\n      case ElementKind.Namespace: {\n        if (hasCompiledMember(element)) this.visitNamespace(name, element);\n        break;\n      }\n      case ElementKind.TypeDefinition:\n      case ElementKind.IndexSignature: break;\n      default: {\n        // Not (directly) reachable exports:\n        // File, Local, Function, Class, Interface\n        assert(false);\n      }\n    }\n  }\n\n  private visitFunctionInstances(name: string, element: FunctionPrototype): void {\n    let instances = element.instances;\n    if (instances) {\n      // TODO: for (let instance of instances.values()) {\n      for (let _values = Map_values(instances), i = 0, k = _values.length; i < k; ++i) {\n        let instance = unchecked(_values[i]);\n        if (instance.is(CommonFlags.Compiled)) this.visitFunction(name, instance);\n      }\n    }\n  }\n\n  private visitClassInstances(name: string, element: ClassPrototype): void {\n    let instances = element.instances;\n    if (instances) {\n      // TODO: for (let instance of instances.values()) {\n      for (let _values = Map_values(instances), i = 0, k = _values.length; i < k; ++i) {\n        let instance = unchecked(_values[i]);\n        assert(instance.kind == ElementKind.Class);\n        if (instance.is(CommonFlags.Compiled)) this.visitClass(name, instance);\n      }\n    }\n  }\n\n  private visitInterfaceInstances(name: string, element: InterfacePrototype): void {\n    let instances = element.instances;\n    if (instances) {\n      // TODO: for (let instance of instances.values()) {\n      for (let _values = Map_values(instances), i = 0, k = _values.length; i < k; ++i) {\n        let instance = <Interface>unchecked(_values[i]);\n        assert(instance.kind == ElementKind.Interface);\n        if (instance.is(CommonFlags.Compiled)) this.visitInterface(name, instance);\n      }\n    }\n  }\n\n  abstract visitGlobal(name: string, element: Global): void;\n  abstract visitEnum(name: string, element: Enum): void;\n  abstract visitFunction(name: string, element: Function): void;\n  abstract visitClass(name: string, element: Class): void;\n  abstract visitInterface(name: string, element: Interface): void;\n  abstract visitNamespace(name: string, element: Element): void;\n  abstract visitAlias(name: string, element: Element, originalName: string): void;\n}\n\n// Helpers\n\n/** Tests if a namespace-like element has at least one compiled member. */\nexport function hasCompiledMember(element: Element): bool {\n  let members = element.members;\n  if (members) {\n    // TODO: for (let member of members.values()) {\n    for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n      let member = unchecked(_values[i]);\n      switch (member.kind) {\n        case ElementKind.FunctionPrototype: {\n          let instances = (<FunctionPrototype>member).instances;\n          if (instances) {\n            // TODO: for (let instance of instances.values()) {\n            for (let _values = Map_values(instances), j = 0, l = _values.length; j < l; ++j) {\n              let instance = unchecked(_values[j]);\n              if (instance.is(CommonFlags.Compiled)) return true;\n            }\n          }\n          break;\n        }\n        case ElementKind.ClassPrototype: {\n          let instances = (<ClassPrototype>member).instances;\n          if (instances) {\n            // TODO: for (let instance of instances.values()) {\n            for (let _values = Map_values(instances), j = 0, l = _values.length; j < l; ++j) {\n              let instance = unchecked(_values[j]);\n              if (instance.is(CommonFlags.Compiled)) return true;\n            }\n          }\n          break;\n        }\n        default: {\n          if (member.is(CommonFlags.Compiled) || hasCompiledMember(member)) return true;\n          break;\n        }\n      }\n    }\n  }\n  return false;\n}\n", "import {\n  NodeKind,\n  DecoratorKind,\n  LiteralKind,\n  LiteralExpression,\n  StringLiteralExpression,\n  TemplateLiteralExpression,\n  findDecorator,\n  Source\n} from \"../ast\";\n\nimport {\n  CommonFlags\n} from \"../common\";\n\nimport {\n  runtimeFunctions,\n  runtimeGlobals\n} from \"../compiler\";\n\nimport {\n  ElementKind,\n  Element,\n  Program,\n  Function,\n  Global,\n  Class,\n  Interface,\n  Enum,\n  EnumValue,\n  PropertyPrototype\n} from \"../program\";\n\nimport {\n  Type,\n  TypeFlags,\n  Signature\n} from \"../types\";\n\nimport {\n  CharCode,\n  escapeString,\n  indent,\n  isIdentifier\n} from \"../util\";\n\nimport {\n  ExportsWalker\n} from \"./util\";\n\n// Limitations\n//\n// - Instrumented globals are no longer WebAssembly.Global, hence cannot be\n//   imported the same way as non-instrumented globals would allow. Affects both\n//   globals imported here and globals imported elsewhere.\n//\n// - Since little is known about how class imports and exports will behave,\n//   there is currently no glue generated for them. In IT there appears to be\n//   a concept of protocols that may or may not map in the future. In GC there\n//   doesn't appear to be a connection between classes and their methods so far.\n//\n//   Instead, generated bindings are limited to lifting and lowering of plain\n//   objects when the class has no constructor and no non-public elements. In\n//   any other sitation an internal or external reference is passed.\n//\n// - Linking two instrumented modules with separate bindings produces\n//   intermediate garbage (i.e. goes through a temporary JS object). Any native\n//   mechanism enabling communication between modules directly would help here.\n//\n// - Cycles between the internal and the external GC cannot be resolved. Using\n//   a common GC as envisioned by the GC proposal can help here, but so far it\n//   seems that the same limitations as for IT will remain.\n//\n// - Duplicate Wasm imports don't yet work when instrumentation is required as\n//   provided argument types cannot be told apart when these only come in as\n//   numbers. It might be possible to modify the binary post compilation, but\n//   this has not been attempted yet.\n//\n// Oddities\n//\n// - Interface Types `string` will be incompatible with JavaScript `String` and\n//   it remains unclear how to proceed on this front. We could either use the IT\n//   mechanism and accept potential hazards or keep using unfortunate glue code.\n//\n// - Functions with a variable number of arguments need some special glue to\n//   inform the binary how many arguments have been provided so it can fill in\n//   defaults for the omitted arguments. No native mechanism in sight, yet.\n//\n// - Optional BigInt arguments must be coerced to 0n since JS does not\n//   implicitly coerce from `null` or `undefined`. Numbers do, however.\n//\n// - Generated bindings assume little endian architecture with typed arrays as\n//   it appears to be more efficient than using a DataView and BE use cases\n//   haven't been seen in the wild so far.\n//\n// - It is assumed that generated import bindings call JavaScript and that the\n//   callee expects a properly coerced integer value, leading to more `>>> 0`\n//   coercions than necessary when the import is actually another Wasm module.\n\n/** Maps special imports to their actual modules. */\nfunction importToModule(moduleName: string): string {\n  // Map rtrace via `imports` in package.json\n  if (moduleName == \"rtrace\") return \"#rtrace\";\n  return moduleName;\n}\n\n/** Determines whether a module's imports should be instrumented. */\nfunction shouldInstrument(moduleName: string): bool {\n  return moduleName != \"rtrace\";\n}\n\n/** A JavaScript bindings builder. */\nexport class JSBuilder extends ExportsWalker {\n\n  /** Builds JavaScript bindings for the specified program. */\n  static build(program: Program, esm: bool = true): string {\n    return new JSBuilder(program, esm).build();\n  }\n\n  private esm: bool;\n  private sb: string[] = [];\n  private indentLevel: i32 = 0;\n\n  private needsLiftBuffer: bool = false;\n  private needsLowerBuffer: bool = false;\n  private needsLiftString: bool = false;\n  private needsLowerString: bool = false;\n  private needsLiftArray: bool = false;\n  private needsLowerArray: bool = false;\n  private needsLiftTypedArray: bool = false;\n  private needsLowerTypedArray: bool = false;\n  private needsLiftStaticArray: bool = false;\n  private needsLowerStaticArray: bool = false;\n  private needsLiftInternref: bool = false;\n  private needsLowerInternref: bool = false;\n  private needsRetain: bool = false;\n  private needsRelease: bool = false;\n  private needsNotNull: bool = false;\n  private needsSetU8: bool = false;\n  private needsSetU16: bool = false;\n  private needsSetU32: bool = false;\n  private needsSetU64: bool = false;\n  private needsSetF32: bool = false;\n  private needsSetF64: bool = false;\n  private needsGetI8: bool = false;\n  private needsGetU8: bool = false;\n  private needsGetI16: bool = false;\n  private needsGetU16: bool = false;\n  private needsGetI32: bool = false;\n  private needsGetU32: bool = false;\n  private needsGetI64: bool = false;\n  private needsGetU64: bool = false;\n  private needsGetF32: bool = false;\n  private needsGetF64: bool = false;\n\n  private deferredLifts: Set<Element> = new Set();\n  private deferredLowers: Set<Element> = new Set();\n  private deferredCode: string[] = new Array<string>();\n\n  private exports: string[] = new Array();\n  private importMappings: Map<string,i32> = new Map();\n\n  /** Constructs a new JavaScript bindings builder. */\n  constructor(program: Program, esm: bool, includePrivate: bool = false) {\n    super(program, includePrivate);\n    this.esm = esm;\n  }\n\n  visitGlobal(name: string, element: Global): void {\n    let sb = this.sb;\n    let type = element.type;\n    this.exports.push(name);\n    if (!isPlainValue(type, Mode.Export)) {\n      indent(sb, this.indentLevel);\n      sb.push(name);\n      sb.push(\": {\\n\");\n      indent(sb, ++this.indentLevel);\n      sb.push(\"// \");\n      sb.push(element.internalName);\n      sb.push(\": \");\n      sb.push(type.toString());\n      sb.push(\"\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(\"valueOf() { return this.value; },\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(\"get value() {\\n\");\n      indent(sb, ++this.indentLevel);\n      sb.push(\"return \");\n      this.makeLiftFromValue(\"exports.\" + name + \".value\", type, sb);\n      sb.push(\";\\n\");\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n      if (!element.is(CommonFlags.Const)) {\n        sb.push(\",\\n\");\n        indent(sb, this.indentLevel);\n        sb.push(\"set value(value) {\\n\");\n        indent(sb, ++this.indentLevel);\n        sb.push(\"exports.\");\n        sb.push(name);\n        sb.push(\".value = \");\n        this.makeLowerToValue(\"value\", type, sb);\n        sb.push(\";\\n\");\n        indent(sb, --this.indentLevel);\n        sb.push(\"}\");\n      }\n      sb.push(\"\\n\");\n      indent(sb, --this.indentLevel);\n      sb.push(\"},\\n\");\n    }\n    this.visitNamespace(name, element);\n  }\n\n  visitEnum(name: string, element: Enum): void {\n    let sb = this.sb;\n    this.exports.push(name);\n    indent(sb, this.indentLevel);\n    sb.push(name);\n    sb.push(\": (values => (\\n\");\n    indent(sb, ++this.indentLevel);\n    sb.push(\"// \");\n    sb.push(element.internalName);\n    sb.push(\"\\n\");\n    let members = element.members;\n    if (members) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let value = _values[i];\n        if (value.kind != ElementKind.EnumValue) continue;\n        indent(sb, this.indentLevel);\n        sb.push(\"values[values.\");\n        sb.push(value.name);\n        if (value.is(CommonFlags.Inlined)) {\n          sb.push(\" = \");\n          sb.push(i64_low((<EnumValue>value).constantIntegerValue).toString());\n        } else {\n          sb.push(\" = exports[\\\"\");\n          sb.push(escapeString(name + \".\" + value.name, CharCode.DoubleQuote));\n          sb.push(\"\\\"].valueOf()\");\n        }\n        sb.push(\"] = \\\"\");\n        sb.push(escapeString(value.name, CharCode.DoubleQuote));\n        sb.push(\"\\\",\\n\");\n      }\n    }\n    indent(sb, this.indentLevel);\n    sb.push(\"values\\n\");\n    indent(sb, --this.indentLevel);\n    sb.push(\"))({}),\\n\");\n    this.visitNamespace(name, element);\n  }\n\n  makeGlobalImport(moduleName: string, name: string, element: Global): void {\n    let sb = this.sb;\n    let type = element.type;\n    indent(sb, this.indentLevel);\n    if (isIdentifier(name)) {\n      sb.push(name);\n    } else {\n      sb.push(\"\\\"\");\n      sb.push(escapeString(name, CharCode.DoubleQuote));\n      sb.push(\"\\\": \");\n    }\n    let moduleId = this.ensureModuleId(moduleName);\n    if (isPlainValue(type, Mode.Import)) {\n      sb.push(\"(\\n\");\n      indent(sb, this.indentLevel + 1);\n      sb.push(\"// \");\n      sb.push(element.internalName);\n      sb.push(\": \");\n      sb.push(element.type.toString());\n      sb.push(\"\\n\");\n      indent(sb, this.indentLevel + 1);\n      if (moduleName != \"env\") {\n        sb.push(\"__module\");\n        sb.push(moduleId.toString());\n        sb.push(\".\");\n      }\n      sb.push(name);\n      sb.push(\"\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(\")\");\n    } else {\n      sb.push(\"{\\n\");\n      indent(sb, ++this.indentLevel);\n      sb.push(\"// \");\n      sb.push(element.internalName);\n      sb.push(\": \");\n      sb.push(element.type.toString());\n      sb.push(\"\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(\"// not supported: cannot lower before instantiate completes\\n\");\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    }\n    sb.push(\",\\n\");\n  }\n\n  makeFunctionImport(moduleName: string, name: string, element: Function, code: string | null = null): void {\n    let sb = this.sb;\n    let signature = element.signature;\n    indent(sb, this.indentLevel);\n    if (isIdentifier(name)) {\n      sb.push(name);\n    } else {\n      sb.push(\"\\\"\");\n      sb.push(escapeString(name, CharCode.DoubleQuote));\n      sb.push(\"\\\"\");\n    }\n    if (isPlainFunction(signature, Mode.Import) && !code && isIdentifier(name)) {\n      sb.push(\": (\\n\");\n      indent(sb, this.indentLevel + 1);\n      sb.push(\"// \");\n      sb.push(element.internalName);\n      sb.push(element.signature.toString());\n      sb.push(\"\\n\");\n      indent(sb, this.indentLevel + 1);\n      if (moduleName != \"env\") {\n        sb.push(moduleName);\n        sb.push(\".\");\n      }\n      sb.push(name);\n      sb.push(\"\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(\")\");\n    } else {\n      sb.push(\"(\");\n      let parameterTypes = signature.parameterTypes;\n      let parameterNames = new Array<string>();\n      for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n        parameterNames.push(element.getParameterName(i));\n      }\n      sb.push(parameterNames.join(\", \"));\n      sb.push(\") {\\n\");\n      indent(sb, ++this.indentLevel);\n      sb.push(\"// \");\n      sb.push(element.internalName);\n      sb.push(element.signature.toString());\n      sb.push(\"\\n\");\n      for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n        let type = parameterTypes[i];\n        if (!isPlainValue(type, Mode.Export)) {\n          let name = element.getParameterName(i);\n          indent(sb, this.indentLevel);\n          sb.push(name);\n          sb.push(\" = \");\n          this.makeLiftFromValue(name, type, sb);\n          sb.push(\";\\n\");\n        }\n      }\n      let expr = new Array<string>();\n      let moduleId = this.ensureModuleId(moduleName);\n      if (code) {\n        expr.push(\"(() => {\\n\");\n        indent(expr, 1);\n        expr.push(\"// @external.js\\n\");\n        indentText(code, 1, expr);\n        expr.push(\"\\n})()\");\n      } else {\n        if (moduleName != \"env\") {\n          expr.push(\"__module\");\n          expr.push(moduleId.toString());\n          expr.push(\".\");\n        }\n        expr.push(name);\n        expr.push(\"(\");\n        expr.push(parameterNames.join(\", \"));\n        expr.push(\")\");\n      }\n      code = expr.join(\"\");\n      expr.length = 0;\n      indentText(code, this.indentLevel, expr, true);\n      code = expr.join(\"\");\n      indent(sb, this.indentLevel);\n      if (signature.returnType != Type.void) {\n        sb.push(\"return \");\n        this.makeLowerToValue(code, signature.returnType, sb);\n        sb.push(\";\\n\");\n      } else {\n        sb.push(code);\n        sb.push(\";\\n\");\n      }\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    }\n    sb.push(\",\\n\");\n  }\n\n  visitFunction(name: string, element: Function): void {\n    if (element.is(CommonFlags.Private)) return;\n    let sb = this.sb;\n    let signature = element.signature;\n    this.exports.push(name);\n    if (!isPlainFunction(signature, Mode.Export)) {\n      indent(sb, this.indentLevel);\n      sb.push(name);\n      sb.push(\"(\");\n      let parameterTypes = signature.parameterTypes;\n      let numReferences = 0;\n      for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n        if (parameterTypes[i].isInternalReference) numReferences++;\n        if (i > 0) sb.push(\", \");\n        sb.push(element.getParameterName(i));\n      }\n      sb.push(\") {\\n\");\n      indent(sb, ++this.indentLevel);\n      sb.push(\"// \");\n      sb.push(element.internalName);\n      sb.push(signature.toString());\n      sb.push(\"\\n\");\n      let releases = new Array<string>();\n      for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n        let type = parameterTypes[i];\n        if (!isPlainValue(type, Mode.Import)) {\n          let name = element.getParameterName(i);\n          indent(sb, this.indentLevel);\n          sb.push(name);\n          sb.push(\" = \");\n          let needsRetainRelease = type.isInternalReference && --numReferences > 0;\n          if (needsRetainRelease) {\n            this.needsRetain = true;\n            this.needsRelease = true;\n            sb.push(\"__retain(\");\n            releases.push(name);\n          }\n          this.makeLowerToValue(name, type, sb);\n          if (needsRetainRelease) {\n            sb.push(\")\");\n          }\n          sb.push(\";\\n\");\n        }\n      }\n      if (releases.length) {\n        indent(sb, this.indentLevel++);\n        sb.push(\"try {\\n\");\n      }\n      if (signature.requiredParameters < parameterTypes.length) {\n        indent(sb, this.indentLevel);\n        sb.push(\"exports.__setArgumentsLength(arguments.length);\\n\");\n      }\n      const expr = new Array<string>();\n      expr.push(\"exports.\");\n      expr.push(name);\n      expr.push(\"(\");\n      for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n        if (i > 0) expr.push(\", \");\n        expr.push(element.getParameterName(i));\n      }\n      expr.push(\")\");\n      if (signature.returnType != Type.void) {\n        indent(sb, this.indentLevel);\n        sb.push(\"return \");\n        this.makeLiftFromValue(expr.join(\"\"), signature.returnType, sb);\n      } else {\n        indent(sb, this.indentLevel);\n        sb.push(expr.join(\"\"));\n      }\n      sb.push(\";\\n\");\n      if (releases.length) {\n        indent(sb, this.indentLevel - 1);\n        sb.push(\"} finally {\\n\");\n        for (let i = 0, k = releases.length; i < k; ++i) {\n          indent(sb, this.indentLevel);\n          sb.push(\"__release(\");\n          sb.push(releases[i]);\n          sb.push(\");\\n\");\n        }\n        indent(sb, --this.indentLevel);\n        sb.push(\"}\\n\");\n      }\n      indent(sb, --this.indentLevel);\n      sb.push(\"},\\n\");\n    }\n    this.visitNamespace(name, element);\n  }\n\n  visitClass(name: string, element: Class): void {\n    // not implemented\n  }\n\n  visitInterface(name: string, element: Interface): void {\n    this.visitClass(name, element);\n  }\n\n  visitNamespace(name: string, element: Element): void {\n    // not implemented\n  }\n\n  visitAlias(name: string, element: Element, originalName: string): void {\n    // not implemented\n    // let sb = this.sb;\n    // sb.push(\"export const \");\n    // sb.push(name);\n    // sb.push(\" = \");\n    // sb.push(originalName);\n    // sb.push(\";\\n\");\n  }\n\n  getExternalCode(element: Function): string | null {\n    let decorator = findDecorator(DecoratorKind.ExternalJs, element.decoratorNodes);\n    if (decorator) {\n      let args = decorator.args;\n      if (args && args.length == 1) {\n        let codeArg = args[0];\n        if (codeArg.kind == NodeKind.Literal) {\n          let literal = <LiteralExpression>codeArg;\n          if (literal.literalKind == LiteralKind.String) {\n            return (<StringLiteralExpression>literal).value;\n          }\n          if (literal.literalKind == LiteralKind.Template) {\n            let parts = (<TemplateLiteralExpression>literal).parts;\n            if (parts.length == 1) {\n              return parts[0];\n            }\n          }\n        }\n      }\n    }\n    return null;\n  }\n\n  build(): string {\n    let exports = this.exports;\n    let moduleImports = this.program.moduleImports;\n    let program = this.program;\n    let options = program.options;\n    let sb = this.sb;\n\n    sb.push(\"\"); // placeholder\n    indent(sb, this.indentLevel++);\n    if (!this.esm) sb.push(\"export \");\n    sb.push(\"async function instantiate(module, imports = {}) {\\n\");\n    const insertPos = sb.push(\"\") - 1;\n\n    // Instrument module imports. Keeps raw (JS) imports on the respective\n    // prototypes and overrides selectively where instrumentation is required.\n    indent(sb, this.indentLevel++);\n    sb.push(\"const adaptedImports = {\\n\");\n    let sbLengthBefore = sb.length;\n    for (let _keys = Map_keys(moduleImports), i = 0, k = _keys.length; i < k; ++i) {\n      let moduleName = _keys[i];\n      let moduleId = this.ensureModuleId(moduleName);\n      let module = <Map<string,Element>>moduleImports.get(moduleName);\n      indent(sb, this.indentLevel);\n      if (isIdentifier(moduleName)) {\n        sb.push(moduleName);\n      } else {\n        sb.push(\"\\\"\");\n        sb.push(escapeString(moduleName, CharCode.DoubleQuote));\n        sb.push(\"\\\"\");\n      }\n      if (!shouldInstrument(moduleName)) {\n        sb.push(\": __module\");\n        sb.push(moduleId.toString());\n        sb.push(\",\\n\");\n        continue;\n      }\n      let resetPos = sb.length;\n\n      // Use Object.setPrototypeOf to avoid issues with read-only properties\n      // on module objects created by bundlers (issue #2659)\n      sb.push(\": Object.setPrototypeOf({\\n\");\n      ++this.indentLevel;\n      let numInstrumented = 0;\n      for (let _keys2 = Map_keys(module), j = 0, l = _keys2.length; j < l; ++j) {\n        let name = _keys2[j];\n        let elem = assert(module.get(name));\n        if (elem.kind == ElementKind.Function) {\n          let func = <Function>elem;\n          let code = this.getExternalCode(func);\n          if (!isPlainFunction(func.signature, Mode.Import) || !isIdentifier(name) || code) {\n            this.makeFunctionImport(moduleName, name, <Function>elem, code);\n            ++numInstrumented;\n          }\n        } else if (elem.kind == ElementKind.Global) {\n          let global = <Global>elem;\n          if (!isPlainValue(global.type, Mode.Import) || !isIdentifier(name)) {\n            this.makeGlobalImport(moduleName, name, global);\n            ++numInstrumented;\n          }\n        }\n      }\n      --this.indentLevel;\n      if (!numInstrumented) {\n        sb.length = resetPos;\n        if (moduleName == \"env\") {\n          sb.push(\": Object.assign(Object.create(globalThis), imports.env || {})\");\n        } else {\n          sb.push(\": __module\");\n          sb.push(moduleId.toString());\n        }\n        sb.push(\",\\n\");\n      } else {\n        indent(sb, this.indentLevel);\n        sb.push(\"}, \");\n        if (moduleName == \"env\") {\n          // TODO: If necessary, use \"Object.setPrototypeOf(Object.assign({}, imports.env || {}), globalThis)\"\n          sb.push(\"Object.assign(Object.create(globalThis), imports.env || {})\");\n        } else {\n          sb.push(\"__module\");\n          sb.push(moduleId.toString());\n        }\n        sb.push(\"),\\n\");\n      }\n    }\n    --this.indentLevel;\n    let hasAdaptedImports = sb.length > sbLengthBefore;\n    if (hasAdaptedImports) {\n      indent(sb, this.indentLevel);\n      sb.push(\"};\\n\");\n    } else {\n      sb.length = sbLengthBefore - 2; // incl. indent\n    }\n\n    let mappings = this.importMappings;\n    let map = new Array<string>();\n    for (let _keys = Map_keys(mappings), i = 0, k = _keys.length; i < k; ++i) {\n      let moduleName = _keys[i];\n      if (moduleName == \"env\") {\n        map.push(\"  const env = imports.env;\\n\");\n      } else {\n        let moduleId = <i32>mappings.get(moduleName);\n        if (moduleName == \"rtrace\") {\n          // Rtrace is special in that it needs to be installed on the imports\n          // object. Use sensible defaults and substitute the original import.\n          map.push(\"  ((rtrace) => {\\n\");\n          map.push(\"    delete imports.rtrace;\\n\");\n          map.push(\"    new rtrace.Rtrace({ getMemory() { return memory; }, onerror(err) { console.log(`RTRACE: ${err.stack}`); } }).install(imports);\\n\");\n          map.push(\"  })(imports.rtrace);\\n\");\n        }\n        map.push(\"  const __module\");\n        map.push(moduleId.toString());\n        map.push(\" = imports\");\n        if (isIdentifier(moduleName)) {\n          map.push(\".\");\n          map.push(moduleName);\n        } else {\n          map.push(\"[\\\"\");\n          map.push(escapeString(moduleName, CharCode.DoubleQuote));\n          map.push(\"\\\"]\");\n        }\n        map.push(\";\\n\");\n      }\n    }\n    sb[insertPos] = map.join(\"\");\n\n    indent(sb, this.indentLevel);\n    sb.push(\"const { exports } = await WebAssembly.instantiate(module\");\n    if (hasAdaptedImports) {\n      sb.push(\", adaptedImports);\\n\");\n    } else {\n      sb.push(\", imports);\\n\");\n    }\n    indent(sb, this.indentLevel);\n    sb.push(\"const memory = exports.memory || imports.env.memory;\\n\");\n    indent(sb, this.indentLevel++);\n    sb.push(\"const adaptedExports = Object.setPrototypeOf({\\n\");\n    sbLengthBefore = sb.length;\n\n    // Instrument module exports. Keeps raw (Wasm) exports on the prototype and\n    // overrides selectively where instrumentation is required.\n    this.walk();\n    --this.indentLevel;\n    let hasAdaptedExports = sb.length > sbLengthBefore;\n    if (hasAdaptedExports) {\n      indent(sb, this.indentLevel);\n      sb.push(\"}, exports);\\n\");\n    } else {\n      if (\n        this.needsLiftBuffer || this.needsLowerBuffer ||\n        this.needsLiftString || this.needsLowerString ||\n        this.needsLiftArray || this.needsLowerArray ||\n        this.needsLiftTypedArray || this.needsLowerTypedArray ||\n        this.needsLiftStaticArray\n      ) {\n        sb.length = sbLengthBefore - 2; // skip adaptedExports + 1x indent\n      } else {\n        sb.length = sbLengthBefore - 4; // skip memory and adaptedExports + 2x indent\n      }\n    }\n\n    // Add external JS code fragments\n    let deferredCode = this.deferredCode;\n    if (deferredCode.length) {\n      for (let i = 0, k = deferredCode.length; i < k; ++i) {\n        sb.push(deferredCode[i]);\n      }\n    }\n\n    // Add the respective lifting and lowering adapters\n    if (this.needsLiftBuffer) {\n      let objectInstance = program.OBJECTInstance;\n      let rtSizeOffset = objectInstance.offsetof(\"rtSize\") - objectInstance.nextMemoryOffset;\n      sb.push(`  function __liftBuffer(pointer) {\n    if (!pointer) return null;\n    return memory.buffer.slice(pointer, pointer + new Uint32Array(memory.buffer)[pointer - ${-rtSizeOffset} >>> 2]);\n  }\n`);\n    }\n    if (this.needsLowerBuffer) {\n      let arrayBufferId = program.arrayBufferInstance.id;\n      sb.push(`  function __lowerBuffer(value) {\n    if (value == null) return 0;\n    const pointer = exports.__new(value.byteLength, ${arrayBufferId}) >>> 0;\n    new Uint8Array(memory.buffer).set(new Uint8Array(value), pointer);\n    return pointer;\n  }\n`);\n    }\n    if (this.needsLiftString) {\n      let objectInstance = program.OBJECTInstance;\n      let rtSizeOffset = objectInstance.offsetof(\"rtSize\") - objectInstance.nextMemoryOffset;\n      let chunkSize = 1024;\n      sb.push(`  function __liftString(pointer) {\n    if (!pointer) return null;\n    const\n      end = pointer + new Uint32Array(memory.buffer)[pointer - ${-rtSizeOffset} >>> 2] >>> 1,\n      memoryU16 = new Uint16Array(memory.buffer);\n    let\n      start = pointer >>> 1,\n      string = \"\";\n    while (end - start > ${chunkSize}) string += String.fromCharCode(...memoryU16.subarray(start, start += ${chunkSize}));\n    return string + String.fromCharCode(...memoryU16.subarray(start, end));\n  }\n`);\n    }\n    if (this.needsLowerString) {\n      let stringId = program.stringInstance.id;\n      sb.push(`  function __lowerString(value) {\n    if (value == null) return 0;\n    const\n      length = value.length,\n      pointer = exports.__new(length << 1, ${stringId}) >>> 0,\n      memoryU16 = new Uint16Array(memory.buffer);\n    for (let i = 0; i < length; ++i) memoryU16[(pointer >>> 1) + i] = value.charCodeAt(i);\n    return pointer;\n  }\n`);\n    }\n    if (this.needsLiftArray) {\n      let dataStartOffset = program.arrayBufferViewInstance.offsetof(\"dataStart\");\n      let lengthOffset = program.arrayBufferViewInstance.nextMemoryOffset;\n      this.needsGetU32 = true;\n      sb.push(`  function __liftArray(liftElement, align, pointer) {\n    if (!pointer) return null;\n    const\n      dataStart = __getU32(pointer + ${dataStartOffset}),\n      length = __dataview.getUint32(pointer + ${lengthOffset}, true),\n      values = new Array(length);\n    for (let i = 0; i < length; ++i) values[i] = liftElement(dataStart + (i << align >>> 0));\n    return values;\n  }\n`);\n    }\n    if (this.needsLowerArray) {\n      let arrayBufferId = program.arrayBufferInstance.id;\n      let arrayBufferViewInstance = program.arrayBufferViewInstance;\n      let arraySize = arrayBufferViewInstance.nextMemoryOffset + 4; // + length\n      let bufferOffset = arrayBufferViewInstance.offsetof(\"buffer\");\n      let dataStartOffset = arrayBufferViewInstance.offsetof(\"dataStart\");\n      let byteLengthOffset = arrayBufferViewInstance.offsetof(\"byteLength\");\n      let lengthOffset = byteLengthOffset + 4;\n      this.needsSetU32 = true;\n      sb.push(`  function __lowerArray(lowerElement, id, align, values) {\n    if (values == null) return 0;\n    const\n      length = values.length,\n      buffer = exports.__pin(exports.__new(length << align, ${arrayBufferId})) >>> 0,\n      header = exports.__pin(exports.__new(${arraySize}, id)) >>> 0;\n    __setU32(header + ${bufferOffset}, buffer);\n    __dataview.setUint32(header + ${dataStartOffset}, buffer, true);\n    __dataview.setUint32(header + ${byteLengthOffset}, length << align, true);\n    __dataview.setUint32(header + ${lengthOffset}, length, true);\n    for (let i = 0; i < length; ++i) lowerElement(buffer + (i << align >>> 0), values[i]);\n    exports.__unpin(buffer);\n    exports.__unpin(header);\n    return header;\n  }\n`);\n    }\n    if (this.needsLiftTypedArray) {\n      let arrayBufferViewInstance = program.arrayBufferViewInstance;\n      let dataStartOffset = arrayBufferViewInstance.offsetof(\"dataStart\");\n      let byteLengthOffset = arrayBufferViewInstance.offsetof(\"byteLength\");\n      this.needsGetU32 = true;\n      sb.push(`  function __liftTypedArray(constructor, pointer) {\n    if (!pointer) return null;\n    return new constructor(\n      memory.buffer,\n      __getU32(pointer + ${dataStartOffset}),\n      __dataview.getUint32(pointer + ${byteLengthOffset}, true) / constructor.BYTES_PER_ELEMENT\n    ).slice();\n  }\n`);\n    }\n    if (this.needsLowerTypedArray) {\n      let arrayBufferId = program.arrayBufferInstance.id;\n      let arrayBufferViewInstance = program.arrayBufferViewInstance;\n      let size = arrayBufferViewInstance.nextMemoryOffset;\n      let bufferOffset = arrayBufferViewInstance.offsetof(\"buffer\");\n      let dataStartOffset = arrayBufferViewInstance.offsetof(\"dataStart\");\n      let byteLengthOffset = arrayBufferViewInstance.offsetof(\"byteLength\");\n      this.needsSetU32 = true;\n      sb.push(`  function __lowerTypedArray(constructor, id, align, values) {\n    if (values == null) return 0;\n    const\n      length = values.length,\n      buffer = exports.__pin(exports.__new(length << align, ${arrayBufferId})) >>> 0,\n      header = exports.__new(${size}, id) >>> 0;\n    __setU32(header + ${bufferOffset}, buffer);\n    __dataview.setUint32(header + ${dataStartOffset}, buffer, true);\n    __dataview.setUint32(header + ${byteLengthOffset}, length << align, true);\n    new constructor(memory.buffer, buffer, length).set(values);\n    exports.__unpin(buffer);\n    return header;\n  }\n`);\n    }\n    if (this.needsLiftStaticArray) {\n      let objectInstance = program.OBJECTInstance;\n      let rtSizeOffset = objectInstance.offsetof(\"rtSize\") - objectInstance.nextMemoryOffset;\n      this.needsGetU32 = true;\n      sb.push(`  function __liftStaticArray(liftElement, align, pointer) {\n    if (!pointer) return null;\n    const\n      length = __getU32(pointer - ${-rtSizeOffset}) >>> align,\n      values = new Array(length);\n    for (let i = 0; i < length; ++i) values[i] = liftElement(pointer + (i << align >>> 0));\n    return values;\n  }\n`);\n    }\n    if (this.needsLowerStaticArray) {\n      sb.push(`  function __lowerStaticArray(lowerElement, id, align, values, typedConstructor) {\n    if (values == null) return 0;\n    const\n      length = values.length,\n      buffer = exports.__pin(exports.__new(length << align, id)) >>> 0;\n    if (typedConstructor) {\n      new typedConstructor(memory.buffer, buffer, length).set(values);\n    } else {\n      for (let i = 0; i < length; i++) lowerElement(buffer + (i << align >>> 0), values[i]);\n    }\n    exports.__unpin(buffer);\n    return buffer;\n  }\n`);\n    }\n    if (this.needsLiftInternref || this.needsLowerInternref) {\n      sb.push(\"  class Internref extends Number {}\\n\");\n    }\n    if (this.needsLiftInternref) {\n      this.needsRetain = true;\n      this.needsRelease = true;\n      sb.push(`  const registry = new FinalizationRegistry(__release);\n  function __liftInternref(pointer) {\n    if (!pointer) return null;\n    const sentinel = new Internref(__retain(pointer));\n    registry.register(sentinel, pointer);\n    return sentinel;\n  }\n`);\n    }\n    if (this.needsLowerInternref) {\n      sb.push(`  function __lowerInternref(value) {\n    if (value == null) return 0;\n    if (value instanceof Internref) return value.valueOf();\n    throw TypeError(\"internref expected\");\n  }\n`);\n    }\n    if (this.needsRetain || this.needsRelease) {\n      sb.push(`  const refcounts = new Map();\n`);\n    }\n    if (this.needsRetain) {\n      sb.push(`  function __retain(pointer) {\n    if (pointer) {\n      const refcount = refcounts.get(pointer);\n      if (refcount) refcounts.set(pointer, refcount + 1);\n      else refcounts.set(exports.__pin(pointer), 1);\n    }\n    return pointer;\n  }\n`);\n    }\n    if (this.needsRelease) {\n      sb.push(`  function __release(pointer) {\n    if (pointer) {\n      const refcount = refcounts.get(pointer);\n      if (refcount === 1) exports.__unpin(pointer), refcounts.delete(pointer);\n      else if (refcount) refcounts.set(pointer, refcount - 1);\n      else throw Error(\\`invalid refcount '\\${refcount}' for reference '\\${pointer}'\\`);\n    }\n  }\n`);\n    }\n    if (this.needsNotNull) {\n      sb.push(`  function __notnull() {\n    throw TypeError(\"value must not be null\");\n  }\n`);\n    }\n    if (\n      this.needsSetU8 ||\n      this.needsSetU16 ||\n      this.needsSetU32 ||\n      this.needsSetU64 ||\n      this.needsSetF32 ||\n      this.needsSetF64 ||\n      this.needsGetI8 ||\n      this.needsGetU8 ||\n      this.needsGetI16 ||\n      this.needsGetU16 ||\n      this.needsGetI32 ||\n      this.needsGetU32 ||\n      this.needsGetI64 ||\n      this.needsGetU64 ||\n      this.needsGetF32 ||\n      this.needsGetF64\n    ) {\n      sb.push(\"  let __dataview = new DataView(memory.buffer);\\n\");\n    }\n    if (this.needsSetU8) sb.push(makeCheckedSetter(\"U8\", \"setUint8\"));\n    if (this.needsSetU16) sb.push(makeCheckedSetter(\"U16\", \"setUint16\"));\n    if (this.needsSetU32) sb.push(makeCheckedSetter(\"U32\", \"setUint32\"));\n    if (this.needsSetU64) sb.push(makeCheckedSetter(\"U64\", \"setBigUint64\"));\n    if (this.needsSetF32) sb.push(makeCheckedSetter(\"F32\", \"setFloat32\"));\n    if (this.needsSetF64) sb.push(makeCheckedSetter(\"F64\", \"setFloat64\"));\n    if (this.needsGetI8) sb.push(makeCheckedGetter(\"I8\", \"getInt8\"));\n    if (this.needsGetU8) sb.push(makeCheckedGetter(\"U8\", \"getUint8\"));\n    if (this.needsGetI16) sb.push(makeCheckedGetter(\"I16\", \"getInt16\"));\n    if (this.needsGetU16) sb.push(makeCheckedGetter(\"U16\", \"getUint16\"));\n    if (this.needsGetI32) sb.push(makeCheckedGetter(\"I32\", \"getInt32\"));\n    if (this.needsGetU32) sb.push(makeCheckedGetter(\"U32\", \"getUint32\"));\n    if (this.needsGetI64) sb.push(makeCheckedGetter(\"I64\", \"getBigInt64\"));\n    if (this.needsGetU64) sb.push(makeCheckedGetter(\"U64\", \"getBigUint64\"));\n    if (this.needsGetF32) sb.push(makeCheckedGetter(\"F32\", \"getFloat32\"));\n    if (this.needsGetF64) sb.push(makeCheckedGetter(\"F64\", \"getFloat64\"));\n\n    let exportStart = options.exportStart;\n    if (exportStart) {\n      sb.push(`  exports.${exportStart}();\\n`);\n    }\n\n    if (hasAdaptedExports) {\n      sb.push(\"  return adaptedExports;\\n}\\n\");\n    } else {\n      sb.push(\"  return exports;\\n}\\n\");\n    }\n    --this.indentLevel;\n    assert(this.indentLevel == 0);\n\n    if (this.esm) {\n      sb.push(\"export const {\\n\");\n      if (this.program.options.exportMemory) {\n        sb.push(\"  memory,\\n\");\n      }\n      if (this.program.options.exportTable) {\n        sb.push(\"  table,\\n\");\n      }\n      if (this.program.options.exportRuntime) {\n        for (let i = 0, k = runtimeFunctions.length; i < k; ++i) {\n          sb.push(\"  \");\n          sb.push(runtimeFunctions[i]);\n          sb.push(\",\\n\");\n        }\n        for (let i = 0, k = runtimeGlobals.length; i < k; ++i) {\n          sb.push(\"  \");\n          sb.push(runtimeGlobals[i]);\n          sb.push(\",\\n\");\n        }\n      }\n      for (let i = 0, k = exports.length; i < k; ++i) {\n        sb.push(\"  \");\n        sb.push(exports[i]);\n        sb.push(\",\\n\");\n      }\n      sb.push(`} = await (async url => instantiate(\n  await (async () => {\n    const isNodeOrBun = typeof process != \"undefined\" && process.versions != null && (process.versions.node != null || process.versions.bun != null);\n    if (isNodeOrBun) { return globalThis.WebAssembly.compile(await (await import(\"node:fs/promises\")).readFile(url)); }\n    else { return await globalThis.WebAssembly.compileStreaming(globalThis.fetch(url)); }\n  })(), {\n`);\n      let needsMaybeDefault = false;\n      let importExpr = new Array<string>();\n      for (let _keys = Map_keys(mappings), i = 0, k = _keys.length; i < k; ++i) {\n        let moduleName = _keys[i];\n        if (moduleName == \"env\") {\n          indent(sb, 2);\n          sb.push(\"env: globalThis,\\n\");\n        } else {\n          let moduleId = this.ensureModuleId(moduleName);\n          indent(sb, 2);\n          if (isIdentifier(moduleName)) {\n            sb.push(moduleName);\n          } else {\n            sb.push(\"\\\"\");\n            sb.push(escapeString(moduleName, CharCode.DoubleQuote));\n            sb.push(\"\\\"\");\n          }\n          sb.push(\": __maybeDefault(__import\");\n          sb.push(moduleId.toString());\n          sb.push(\"),\\n\");\n          importExpr.push(\"import * as __import\");\n          importExpr.push(moduleId.toString());\n          importExpr.push(\" from \\\"\");\n          importExpr.push(escapeString(importToModule(moduleName), CharCode.DoubleQuote));\n          importExpr.push(\"\\\";\\n\");\n          needsMaybeDefault = true;\n        }\n      }\n      sb[0] = importExpr.join(\"\");\n      sb.push(`  }\n))(new URL(\"${escapeString(options.basenameHint, CharCode.DoubleQuote)}.wasm\", import.meta.url));\n`);\n      if (needsMaybeDefault) {\n        sb.push(`function __maybeDefault(module) {\n  return typeof module.default === \"object\" && Object.keys(module).length == 1\n    ? module.default\n    : module;\n}\n`);\n      }\n    }\n    return sb.join(\"\");\n  }\n\n  ensureModuleId(moduleName: string): i32 {\n    if (moduleName == \"env\") return -1;\n    let importMap = this.importMappings;\n    let moduleId = importMap.has(moduleName)\n      ? i32(importMap.get(moduleName))\n      : importMap.size;\n    importMap.set(moduleName, moduleId);\n    return moduleId;\n  }\n\n  /** Lifts a WebAssembly value to a JavaScript value, as an expression. */\n  makeLiftFromValue(valueExpr: string, type: Type, sb: string[] = this.sb): void {\n    if (type.isInternalReference) {\n      // Lift reference types\n      const clazz = assert(type.getClassOrWrapper(this.program));\n      if (clazz.extendsPrototype(this.program.arrayBufferInstance.prototype)) {\n        sb.push(\"__liftBuffer(\");\n        this.needsLiftBuffer = true;\n      } else if (clazz.extendsPrototype(this.program.stringInstance.prototype)) {\n        sb.push(\"__liftString(\");\n        this.needsLiftString = true;\n      } else if (clazz.extendsPrototype(this.program.arrayPrototype)) {\n        let valueType = clazz.getArrayValueType();\n        sb.push(\"__liftArray(\");\n        this.makeLiftFromMemoryFunc(valueType, sb);\n        sb.push(\", \");\n        sb.push(valueType.alignLog2.toString());\n        sb.push(\", \");\n        this.needsLiftArray = true;\n      } else if (clazz.extendsPrototype(this.program.staticArrayPrototype)) {\n        let valueType = clazz.getArrayValueType();\n        sb.push(\"__liftStaticArray(\");\n        this.makeLiftFromMemoryFunc(valueType, sb);\n        sb.push(\", \");\n        sb.push(valueType.alignLog2.toString());\n        sb.push(\", \");\n        this.needsLiftStaticArray = true;\n      } else if (clazz.extendsPrototype(this.program.arrayBufferViewInstance.prototype)) {\n        sb.push(\"__liftTypedArray(\");\n        if (clazz.name == \"Uint64Array\") {\n          sb.push(\"BigUint64Array\");\n        } else if (clazz.name == \"Int64Array\") {\n          sb.push(\"BigInt64Array\");\n        } else {\n          sb.push(clazz.name); // TODO: what if extended?\n        }\n        sb.push(\", \");\n        this.needsLiftTypedArray = true;\n      } else if (isPlainObject(clazz)) {\n        sb.push(\"__liftRecord\");\n        sb.push(clazz.id.toString());\n        sb.push(\"(\");\n        if (!this.deferredLifts.has(clazz)) {\n          this.deferredLifts.add(clazz);\n          let prevIndentLevel = this.indentLevel;\n          this.indentLevel = 1;\n          this.deferredCode.push(this.makeLiftRecord(clazz));\n          this.indentLevel = prevIndentLevel;\n        }\n      } else {\n        sb.push(\"__liftInternref(\");\n        this.needsLiftInternref = true;\n      }\n      sb.push(valueExpr);\n      if (!valueExpr.startsWith(\"__get\")) {\n        // no need to coerce when lifting with indirection\n        sb.push(\" >>> 0\");\n      }\n      sb.push(\")\");\n    } else {\n      // Lift and coerce basic values (from a Wasm export)\n      if (type == Type.bool) { // i32 to boolean\n        sb.push(`${valueExpr} != 0`);\n      } else if (type.isUnsignedIntegerValue && type.size >= 32) {\n        if (type.size == 64) { // i64 to unsigned bigint\n          sb.push(`BigInt.asUintN(64, ${valueExpr})`);\n        } else { // i32 to unsigned\n          sb.push(`${valueExpr} >>> 0`);\n        }\n      } else {\n        sb.push(valueExpr);\n      }\n    }\n  }\n\n  /** Lowers a JavaScript value to a WebAssembly value, as an expression. */\n  makeLowerToValue(valueExpr: string, type: Type, sb: string[] = this.sb): void {\n    if (type.isInternalReference) {\n      // Lower reference types\n      const clazz = assert(type.getClassOrWrapper(this.program));\n      if (clazz.extendsPrototype(this.program.arrayBufferInstance.prototype)) {\n        sb.push(\"__lowerBuffer(\");\n        this.needsLowerBuffer = true;\n      } else if (clazz.extendsPrototype(this.program.stringInstance.prototype)) {\n        sb.push(\"__lowerString(\");\n        this.needsLowerString = true;\n      } else if (clazz.extendsPrototype(this.program.arrayPrototype)) {\n        let valueType = clazz.getArrayValueType();\n        sb.push(\"__lowerArray(\");\n        this.makeLowerToMemoryFunc(valueType, sb);\n        sb.push(\", \");\n        sb.push(clazz.id.toString());\n        sb.push(\", \");\n        sb.push(clazz.getArrayValueType().alignLog2.toString());\n        sb.push(\", \");\n        this.needsLowerArray = true;\n      } else if (clazz.extendsPrototype(this.program.staticArrayPrototype)) {\n        let valueType = clazz.getArrayValueType();\n        sb.push(\"__lowerStaticArray(\");\n        this.makeLowerToMemoryFunc(valueType, sb);\n        sb.push(\", \");\n        sb.push(clazz.id.toString());\n        sb.push(\", \");\n        sb.push(valueType.alignLog2.toString());\n        sb.push(\", \");\n        this.needsLowerStaticArray = true;\n      } else if (clazz.extendsPrototype(this.program.arrayBufferViewInstance.prototype)) {\n        let valueType = clazz.getArrayValueType();\n        sb.push(\"__lowerTypedArray(\");\n        if (valueType == Type.u64) {\n          sb.push(\"BigUint64Array\");\n        } else if (valueType == Type.i64) {\n          sb.push(\"BigInt64Array\");\n        } else {\n          sb.push(clazz.name); // TODO: what if extended?\n        }\n        sb.push(\", \");\n        sb.push(clazz.id.toString());\n        sb.push(\", \");\n        sb.push(clazz.getArrayValueType().alignLog2.toString());\n        sb.push(\", \");\n        this.needsLowerTypedArray = true;\n      } else if (isPlainObject(clazz)) {\n        sb.push(\"__lowerRecord\");\n        sb.push(clazz.id.toString());\n        sb.push(\"(\");\n        if (!this.deferredLowers.has(clazz)) {\n          this.deferredLowers.add(clazz);\n          let prevIndentLevel = this.indentLevel;\n          this.indentLevel = 1;\n          this.deferredCode.push(this.makeLowerRecord(clazz));\n          this.indentLevel = prevIndentLevel;\n        }\n      } else {\n        sb.push(\"__lowerInternref(\");\n        this.needsLowerInternref = true;\n      }\n      sb.push(valueExpr);\n      if (clazz.extendsPrototype(this.program.staticArrayPrototype)) {\n        // optional last argument for __lowerStaticArray\n        let valueType = clazz.getArrayValueType();\n        if (valueType.isNumericValue) {\n          sb.push(\", \");\n          if (valueType == Type.u8 || valueType == Type.bool) {\n            sb.push(\"Uint8Array\");\n          } else if (valueType == Type.i8) {\n            sb.push(\"Int8Array\");\n          } else if (valueType == Type.u16) {\n            sb.push(\"Uint16Array\");\n          } else if (valueType == Type.i16) {\n            sb.push(\"Int16Array\");\n          } else if (valueType == Type.u32 || valueType == Type.usize32) {\n            sb.push(\"Uint32Array\");\n          } else if (valueType == Type.i32 || valueType == Type.isize32) {\n            sb.push(\"Int32Array\");\n          } else if (valueType == Type.u64 || valueType == Type.usize64) {\n            sb.push(\"BigUint64Array\");\n          } else if (valueType == Type.i64 || valueType == Type.isize64) {\n            sb.push(\"BigInt64Array\");\n          } else if (valueType == Type.f32) {\n            sb.push(\"Float32Array\");\n          } else if (valueType == Type.f64) {\n            sb.push(\"Float64Array\");\n          } else {\n            // unreachable\n            assert(false);\n          }\n        }\n      }\n      sb.push(\")\");\n      if (!type.is(TypeFlags.Nullable)) {\n        this.needsNotNull = true;\n        sb.push(\" || __notnull()\");\n      }\n    } else {\n      // Lower basic types\n      sb.push(valueExpr); // basic value\n      if (type.isIntegerValue && type.size == 64) {\n        sb.push(\" || 0n\");\n      } else if (type == Type.bool) {\n        // may be stored to an Uint8Array, make sure to store 1/0\n        sb.push(\" ? 1 : 0\");\n      }\n    }\n  }\n\n  ensureLiftFromMemoryFn(valueType: Type): string {\n    if (valueType.isInternalReference) {\n      if (this.program.options.isWasm64) {\n        this.needsGetU64 = true;\n        return \"__getU64\";\n      } else {\n        this.needsGetU32 = true;\n        return \"__getU32\";\n      }\n    }\n    if (valueType == Type.i8) {\n      this.needsGetI8 = true;\n      return \"__getI8\";\n    }\n    if (valueType == Type.u8 || valueType == Type.bool) {\n      this.needsGetU8 = true;\n      return \"__getU8\";\n    }\n    if (valueType == Type.i16) {\n      this.needsGetI16 = true;\n      return \"__getI16\";\n    }\n    if (valueType == Type.u16) {\n      this.needsGetU16 = true;\n      return \"__getU16\";\n    }\n    if (valueType == Type.i32 || valueType == Type.isize32) {\n      this.needsGetI32 = true;\n      return \"__getI32\";\n    }\n    if (valueType == Type.u32 || valueType == Type.usize32) {\n      this.needsGetU32 = true;\n      return \"__getU32\";\n    }\n    if (valueType == Type.i64 || valueType == Type.isize64) {\n      this.needsGetI64 = true;\n      return \"__getI64\";\n    }\n    if (valueType == Type.u64 || valueType == Type.usize64) {\n      this.needsGetU64 = true;\n      return \"__getU64\";\n    }\n    if (valueType == Type.f32) {\n      this.needsGetF32 = true;\n      return \"__getF32\";\n    }\n    if (valueType == Type.f64) {\n      this.needsGetF64 = true;\n      return \"__getF64\";\n    }\n    return \"(() => { throw Error(\\\"unsupported type\\\"); })\";\n  }\n\n  /** Lifts a WebAssembly memory address to a JavaScript value, as a function. */\n  makeLiftFromMemoryFunc(valueType: Type, sb: string[] = this.sb): void {\n    let fn = this.ensureLiftFromMemoryFn(valueType);\n    if (\n      // Compound or with coercion, see makeLiftFromValue\n      valueType.isInternalReference ||\n      valueType == Type.bool ||\n      (valueType.isUnsignedIntegerValue && valueType.size >= 32)\n    ) {\n      sb.push(\"pointer => \");\n      this.makeLiftFromValue(`${fn}(pointer)`, valueType, sb);\n    } else {\n      sb.push(fn);\n    }\n  }\n\n  /** Lifts a WebAssembly memory address to a JavaScript value, as a call. */\n  makeLiftFromMemoryCall(valueType: Type, sb: string[] = this.sb, pointerExpr: string = \"pointer\"): void {\n    let fn = this.ensureLiftFromMemoryFn(valueType);\n    if (valueType.isInternalReference) {\n      this.makeLiftFromValue(`${fn}(${pointerExpr})`, valueType, sb);\n    } else {\n      sb.push(fn);\n      sb.push(\"(\");\n      sb.push(pointerExpr);\n      sb.push(\")\");\n      if (valueType == Type.bool) {\n        sb.push(\" != 0\");\n      }\n      // Other integers are known to be coerced here by loading from a view\n    }\n  }\n\n  ensureLowerToMemoryFn(valueType: Type): string {\n    if (valueType.isInternalReference) {\n      if (this.program.options.isWasm64) {\n        this.needsSetU64 = true;\n        return \"__setU64\";\n      } else {\n        this.needsSetU32 = true;\n        return \"__setU32\";\n      }\n    }\n    if (valueType == Type.i8 || valueType == Type.u8 || valueType == Type.bool) {\n      this.needsSetU8 = true;\n      return \"__setU8\";\n    }\n    if (valueType == Type.i16 || valueType == Type.u16) {\n      this.needsSetU16 = true;\n      return \"__setU16\";\n    }\n    if (valueType == Type.i32 || valueType == Type.u32 || valueType == Type.isize32 || valueType == Type.usize32) {\n      this.needsSetU32 = true;\n      return \"__setU32\";\n    }\n    if (valueType == Type.i64 || valueType == Type.u64 || valueType == Type.isize64 || valueType == Type.usize64) {\n      this.needsSetU64 = true;\n      return \"__setU64\";\n    }\n    if (valueType == Type.f32) {\n      this.needsSetF32 = true;\n      return \"__setF32\";\n    }\n    if (valueType == Type.f64) {\n      this.needsSetF64 = true;\n      return \"__setF64\";\n    }\n    return \"(() => { throw Error(\\\"unsupported type\\\") })\";\n  }\n\n  /** Lowers a JavaScript value to a WebAssembly memory address, as a function. */\n  makeLowerToMemoryFunc(valueType: Type, sb: string[] = this.sb): void {\n    let fn = this.ensureLowerToMemoryFn(valueType);\n    if (valueType.isInternalReference) {\n      sb.push(\"(pointer, value) => { \");\n      sb.push(fn);\n      sb.push(\"(pointer, \");\n      this.makeLowerToValue(\"value\", valueType, sb);\n      sb.push(\"); }\");\n    } else {\n      sb.push(fn);\n    }\n  }\n\n  /** Lowers a JavaScript value to a WebAssembly memory address, as a call. */\n  makeLowerToMemoryCall(valueType: Type, sb: string[] = this.sb, pointerExpr: string = \"pointer\", valueExpr: string = \"value\"): void {\n    let fn = this.ensureLowerToMemoryFn(valueType);\n    sb.push(fn);\n    sb.push(\"(\");\n    sb.push(pointerExpr);\n    sb.push(\", \");\n    this.makeLowerToValue(valueExpr, valueType, sb);\n    sb.push(\")\");\n  }\n\n  makeLiftRecord(clazz: Class): string {\n    assert(isPlainObject(clazz));\n    let sb = new Array<string>();\n    indent(sb, this.indentLevel);\n    sb.push(\"function __liftRecord\");\n    sb.push(clazz.id.toString());\n    sb.push(\"(pointer) {\\n\");\n    indent(sb, ++this.indentLevel);\n    sb.push(\"// \");\n    sb.push(clazz.type.toString());\n    sb.push(\"\\n\");\n    indent(sb, this.indentLevel);\n    sb.push(\"// Hint: Opt-out from lifting as a record by providing an empty constructor\\n\");\n    indent(sb, this.indentLevel);\n    sb.push(\"if (!pointer) return null;\\n\");\n    indent(sb, this.indentLevel++);\n    sb.push(\"return {\\n\");\n    let members = clazz.members;\n    if (members) {\n      for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n        let memberName = _keys[i];\n        let member = assert(members.get(memberName));\n        if (member.kind != ElementKind.PropertyPrototype) continue;\n        let property = (<PropertyPrototype>member).instance; // resolved during class finalization\n        if (!property || !property.isField) continue;\n        assert(property.memoryOffset >= 0);\n        indent(sb, this.indentLevel);\n        sb.push(property.name);\n        sb.push(\": \");\n        this.makeLiftFromMemoryCall(property.type, sb, `pointer + ${property.memoryOffset}`);\n        sb.push(\",\\n\");\n      }\n    }\n    indent(sb, --this.indentLevel);\n    sb.push(\"};\\n\");\n    indent(sb, --this.indentLevel);\n    sb.push(\"}\\n\");\n    return sb.join(\"\");\n  }\n\n  makeLowerRecord(clazz: Class): string {\n    assert(isPlainObject(clazz));\n    let sb = new Array<string>();\n    indent(sb, this.indentLevel);\n    sb.push(\"function __lowerRecord\");\n    sb.push(clazz.id.toString());\n    sb.push(\"(value) {\\n\");\n    indent(sb, ++this.indentLevel);\n    sb.push(\"// \");\n    sb.push(clazz.type.toString());\n    sb.push(\"\\n\");\n    indent(sb, this.indentLevel);\n    sb.push(\"// Hint: Opt-out from lowering as a record by providing an empty constructor\\n\");\n    indent(sb, this.indentLevel);\n    sb.push(\"if (value == null) return 0;\\n\");\n    indent(sb, this.indentLevel);\n    sb.push(\"const pointer = exports.__pin(exports.__new(\");\n    sb.push(clazz.nextMemoryOffset.toString());\n    sb.push(\", \");\n    sb.push(clazz.id.toString());\n    sb.push(\"));\\n\");\n    let members = clazz.members;\n    if (members) {\n      for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n        let memberName = _keys[i];\n        let member = assert(members.get(memberName));\n        if (member.kind != ElementKind.PropertyPrototype) continue;\n        let property = (<PropertyPrototype>member).instance; // resolved during class finalization\n        if (!property || !property.isField) continue;\n        assert(property.memoryOffset >= 0);\n        indent(sb, this.indentLevel);\n        this.makeLowerToMemoryCall(property.type, sb, `pointer + ${property.memoryOffset}`, `value.${memberName}`);\n        sb.push(\";\\n\");\n      }\n    }\n    indent(sb, this.indentLevel);\n    sb.push(\"exports.__unpin(pointer);\\n\");\n    indent(sb, this.indentLevel);\n    sb.push(\"return pointer;\\n\");\n    indent(sb, --this.indentLevel);\n    sb.push(\"}\\n\");\n    return sb.join(\"\");\n  }\n}\n\n// Helpers\n\nenum Mode {\n  Import,\n  Export\n}\n\nfunction isPlainValue(type: Type, kind: Mode): bool {\n  if (kind == Mode.Import) {\n    // may be stored to an Uint8Array, make sure to store 1/0\n    if (type == Type.bool) return false;\n    // requires coercion of undefined to 0n\n    if (type.isIntegerValue && type.size == 64) return false;\n  } else {\n    // requires coercion from 1/0 to true/false\n    if (type == Type.bool) return false;\n    // requires coercion from signed to unsigned for u32 and u64.\n    // Note, u8 and u16 doesn't overflow in native type so mark as plain\n    if (type.isUnsignedIntegerValue && type.size >= 32) return false;\n  }\n  return !type.isInternalReference;\n}\n\nfunction isPlainFunction(signature: Signature, mode: Mode): bool {\n  let parameterTypes = signature.parameterTypes;\n  let inverseMode = mode == Mode.Import ? Mode.Export : Mode.Import;\n  if (!isPlainValue(signature.returnType, mode)) return false;\n  for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n    if (!isPlainValue(parameterTypes[i], inverseMode)) return false;\n  }\n  return true;\n}\n\nfunction isPlainObject(clazz: Class): bool {\n  // A plain object does not inherit and does not have a constructor or private properties\n  if (clazz.base && !clazz.prototype.implicitlyExtendsObject) return false;\n  let members = clazz.members;\n  if (members) {\n    for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n      let member = _values[i];\n      if (member.isAny(CommonFlags.Private | CommonFlags.Protected)) return false;\n      if (member.is(CommonFlags.Constructor)) {\n        // a generated constructor is ok\n        if (member.declaration.range != Source.native.range) return false;\n      }\n    }\n  }\n  return true;\n}\n\nfunction indentText(text: string, indentLevel: i32, sb: string[], butFirst: bool = false): void {\n  let lineStart = 0;\n  let length = text.length;\n  let pos = 0;\n  while (pos < length) {\n    if (text.charCodeAt(pos) == CharCode.LineFeed) {\n      if (butFirst) butFirst = false;\n      else indent(sb, indentLevel);\n      sb.push(text.substring(lineStart, lineStart = pos + 1));\n    }\n    ++pos;\n  }\n  if (lineStart < length) {\n    if (!butFirst) indent(sb, indentLevel);\n    sb.push(text.substring(lineStart));\n  }\n}\n\nexport function liftRequiresExportRuntime(type: Type): bool {\n  // TODO: enable v128 in signatures in future\n  // if (type.isVectorValue) return true;\n  if (!type.isInternalReference) return false;\n  let clazz = type.classReference;\n  if (!clazz) {\n    // functions lift as internref using __pin\n    assert(type.signatureReference);\n    return true;\n  }\n  let program = clazz.program;\n  // flat collections lift via memory copy\n  if (\n    clazz.extendsPrototype(program.arrayBufferInstance.prototype) ||\n    clazz.extendsPrototype(program.stringInstance.prototype) ||\n    clazz.extendsPrototype(program.arrayBufferViewInstance.prototype)\n  ) {\n    return false;\n  }\n  // nested collections lift depending on element type\n  if (\n    clazz.extendsPrototype(program.arrayPrototype) ||\n    clazz.extendsPrototype(program.staticArrayPrototype)\n  ) {\n    return liftRequiresExportRuntime(clazz.getArrayValueType());\n  }\n  // complex objects lift as internref using __pin. plain objects may or may not\n  // involve the runtime: assume that they do to avoid potentially costly checks\n  return true;\n}\n\nexport function lowerRequiresExportRuntime(type: Type): bool {\n  // TODO: enable v128 in signatures in future\n  // if (type.isVectorValue) return true;\n  if (!type.isInternalReference) return false;\n  let clazz = type.classReference;\n  if (!clazz) {\n    // lowers by reference\n    assert(type.signatureReference);\n    return false;\n  }\n  // lowers using __new\n  let program = clazz.program;\n  if (\n    clazz.extendsPrototype(program.arrayBufferInstance.prototype) ||\n    clazz.extendsPrototype(program.stringInstance.prototype) ||\n    clazz.extendsPrototype(program.arrayBufferViewInstance.prototype) ||\n    clazz.extendsPrototype(program.arrayPrototype) ||\n    clazz.extendsPrototype(program.staticArrayPrototype)\n  ) {\n    return true;\n  }\n  // complex objects lower via internref by reference,\n  // while plain objects lower using __new\n  return isPlainObject(clazz);\n}\n\n/** Makes a checked setter function to memory for the given basic type. */\nfunction makeCheckedSetter(type: string, fn: string): string {\n  return `  function __set${type}(pointer, value) {\n    try {\n      __dataview.${fn}(pointer, value, true);\n    } catch {\n      __dataview = new DataView(memory.buffer);\n      __dataview.${fn}(pointer, value, true);\n    }\n  }\n`;\n}\n\n/** Makes a checked getter function from memory for the given basic type. */\nfunction makeCheckedGetter(type: string, fn: string): string {\n  return `  function __get${type}(pointer) {\n    try {\n      return __dataview.${fn}(pointer, true);\n    } catch {\n      __dataview = new DataView(memory.buffer);\n      return __dataview.${fn}(pointer, true);\n    }\n  }\n`;\n}\n", "/**\n * @fileoverview The AssemblyScript compiler.\n * @license Apache-2.0\n */\n\n// helper globals used by mangleImportName\nlet mangleImportName_moduleName: string = \"\";\nlet mangleImportName_elementName: string = \"\";\n\nimport {\n  BuiltinNames,\n  BuiltinFunctionContext,\n  BuiltinVariableContext,\n  builtinFunctions,\n  builtinVariables_onAccess,\n  builtinVariables_onCompile,\n  compileVisitGlobals,\n  compileVisitMembers,\n  compileRTTI\n} from \"./builtins\";\n\nimport {\n  Range,\n  DiagnosticCode,\n  DiagnosticEmitter\n} from \"./diagnostics\";\n\nimport {\n  Module,\n  MemorySegment,\n  ExpressionRef,\n  UnaryOp,\n  BinaryOp,\n  TypeRef,\n  FunctionRef,\n  ExpressionId,\n  GlobalRef,\n  FeatureFlags,\n  Index,\n  getExpressionId,\n  getExpressionType,\n  getConstValueI32,\n  getConstValueI64Low,\n  getConstValueI64High,\n  getConstValueF32,\n  getConstValueF64,\n  getConstValueV128,\n  getBlockChildCount,\n  getBlockChildAt,\n  getBlockName,\n  getLocalSetValue,\n  getGlobalGetName,\n  isGlobalMutable,\n  getSideEffects,\n  SideEffects,\n  SwitchBuilder,\n  ExpressionRunnerFlags,\n  isConstNegZero,\n  isConstExpressionNaN,\n  ensureType,\n  createType,\n  getConstValueInteger\n} from \"./module\";\n\nimport {\n  CommonFlags,\n  STATIC_DELIMITER,\n  INDEX_SUFFIX,\n  CommonNames,\n  Feature,\n  Target,\n  Runtime\n} from \"./common\";\n\nimport {\n  Program,\n  ClassPrototype,\n  Class,\n  Element,\n  ElementKind,\n  DeclaredElement,\n  Enum,\n  FunctionPrototype,\n  Function,\n  Global,\n  Local,\n  EnumValue,\n  Property,\n  VariableLikeElement,\n  ConstantValueKind,\n  OperatorKind,\n  DecoratorFlags,\n  PropertyPrototype,\n  IndexSignature,\n  File,\n  mangleInternalName,\n  TypeDefinition\n} from \"./program\";\n\nimport {\n  FlowFlags,\n  Flow,\n  LocalFlags,\n  FieldFlags,\n  ConditionKind\n} from \"./flow\";\n\nimport {\n  Resolver,\n  ReportMode\n} from \"./resolver\";\n\nimport {\n  Token,\n  operatorTokenToString\n} from \"./tokenizer\";\n\nimport {\n  Node,\n  NodeKind,\n  DecoratorKind,\n  AssertionKind,\n  SourceKind,\n  FunctionTypeNode,\n  DecoratorNode,\n\n  Statement,\n  BlockStatement,\n  BreakStatement,\n  ClassDeclaration,\n  ContinueStatement,\n  DeclarationStatement,\n  DoStatement,\n  EmptyStatement,\n  EnumDeclaration,\n  ExportDefaultStatement,\n  ExportStatement,\n  ExpressionStatement,\n  FieldDeclaration,\n  ForStatement,\n  ForOfStatement,\n  FunctionDeclaration,\n  IfStatement,\n  ImportStatement,\n  InstanceOfExpression,\n  NamespaceDeclaration,\n  ReturnStatement,\n  SwitchStatement,\n  ThrowStatement,\n  TryStatement,\n  VariableStatement,\n  VoidStatement,\n  WhileStatement,\n\n  Expression,\n  AssertionExpression,\n  BinaryExpression,\n  CallExpression,\n  CommaExpression,\n  ElementAccessExpression,\n  FloatLiteralExpression,\n  FunctionExpression,\n  IdentifierExpression,\n  IntegerLiteralExpression,\n  LiteralExpression,\n  LiteralKind,\n  NewExpression,\n  ObjectLiteralExpression,\n  ParenthesizedExpression,\n  PropertyAccessExpression,\n  TernaryExpression,\n  ArrayLiteralExpression,\n  StringLiteralExpression,\n  TemplateLiteralExpression,\n  UnaryPostfixExpression,\n  UnaryPrefixExpression,\n  CompiledExpression,\n\n  TypeNode,\n  NamedTypeNode,\n\n  findDecorator,\n  isTypeOmitted,\n  Source,\n  TypeDeclaration,\n  ParameterKind\n} from \"./ast\";\n\nimport {\n  Type,\n  TypeKind,\n  TypeFlags,\n  Signature,\n  typesToRefs\n} from \"./types\";\n\nimport {\n  writeI8,\n  writeI16,\n  writeI32,\n  writeI64,\n  writeF32,\n  writeF64,\n  writeV128,\n  cloneMap,\n  isPowerOf2,\n  readI32,\n  isIdentifier,\n  accuratePow64,\n  v128_zero,\n  v128_ones,\n} from \"./util\";\n\nimport {\n  RtraceMemory\n} from \"./passes/rtrace\";\n\nimport {\n  ShadowStackPass\n} from \"./passes/shadowstack\";\n\nimport {\n  liftRequiresExportRuntime,\n  lowerRequiresExportRuntime\n} from \"./bindings/js\";\n\n/** Features enabled by default. */\nexport const defaultFeatures = Feature.MutableGlobals\n                             | Feature.SignExtension\n                             | Feature.NontrappingF2I\n                             | Feature.BulkMemory;\n\n/** Compiler options. */\nexport class Options {\n  constructor() { /* as internref */ }\n\n  /** WebAssembly target. Defaults to {@link Target.Wasm32}. */\n  target: Target = Target.Wasm32;\n  /** Runtime type. Defaults to Incremental GC. */\n  runtime: Runtime = Runtime.Incremental;\n  /** If true, indicates that debug information will be emitted by Binaryen. */\n  debugInfo: bool = false;\n  /** If true, replaces assertions with nops. */\n  noAssert: bool = false;\n  /** It true, exports the memory to the embedder. */\n  exportMemory: bool = true;\n  /** If true, imports the memory provided by the embedder. */\n  importMemory: bool = false;\n  /** Initial memory size, in pages. */\n  initialMemory: u32 = 0;\n  /** Maximum memory size, in pages. */\n  maximumMemory: u32 = 0;\n  /** If true, memory is declared as shared. */\n  sharedMemory: bool = false;\n  /** If true, imported memory is zero filled. */\n  zeroFilledMemory: bool = false;\n  /** If true, imports the function table provided by the embedder. */\n  importTable: bool = false;\n  /** If true, exports the function table. */\n  exportTable: bool = false;\n  /** If true, generates information necessary for source maps. */\n  sourceMap: bool = false;\n  /** Unchecked behavior. Defaults to only using unchecked operations inside unchecked(). */\n  uncheckedBehavior: UncheckedBehavior = UncheckedBehavior.Default;\n  /** If given, exports the start function instead of calling it implicitly. */\n  exportStart: string | null = null;\n  /** Static memory start offset. */\n  memoryBase: u32 = 0;\n  /** Static table start offset. */\n  tableBase: u32 = 0;\n  /** Global aliases, mapping alias names as the key to internal names to be aliased as the value. */\n  globalAliases: Map<string,string> | null = null;\n  /** Features to activate by default. */\n  features: Feature = defaultFeatures;\n  /** If true, disallows unsafe features in user code. */\n  noUnsafe: bool = false;\n  /** If true, enables pedantic diagnostics. */\n  pedantic: bool = false;\n  /** Indicates a very low (<64k) memory limit. */\n  lowMemoryLimit: u32 = 0;\n  /** If true, exports the runtime helpers. */\n  exportRuntime: bool = false;\n  /** Stack size in bytes, if using a stack. */\n  stackSize: i32 = 0;\n  /** Semantic major bundle version from root package.json */\n  bundleMajorVersion: i32 = 0;\n  /** Semantic minor bundle version from root package.json */\n  bundleMinorVersion: i32 = 0;\n  /** Semantic patch bundle version from root package.json */\n  bundlePatchVersion: i32 = 0;\n\n  /** Hinted optimize level. Not applied by the compiler itself. */\n  optimizeLevelHint: i32 = 0;\n  /** Hinted shrink level. Not applied by the compiler itself. */\n  shrinkLevelHint: i32 = 0;\n  /** Hinted basename. */\n  basenameHint: string = \"output\";\n  /** Hinted bindings generation. */\n  bindingsHint: bool = false;\n\n  /** Tests if the target is WASM64 or, otherwise, WASM32. */\n  get isWasm64(): bool {\n    return this.target == Target.Wasm64;\n  }\n\n  /** Gets the unsigned size type matching the target. */\n  get usizeType(): Type {\n    return this.target == Target.Wasm64 ? Type.usize64 : Type.usize32;\n  }\n\n  /** Gets the signed size type matching the target. */\n  get isizeType(): Type {\n    return this.target == Target.Wasm64 ? Type.isize64 : Type.isize32;\n  }\n\n  /** Gets the size type reference matching the target. */\n  get sizeTypeRef(): TypeRef {\n    return this.target == Target.Wasm64 ? TypeRef.I64 : TypeRef.I32;\n  }\n\n  /** Gets if any optimizations will be performed. */\n  get willOptimize(): bool {\n    return this.optimizeLevelHint > 0 || this.shrinkLevelHint > 0;\n  }\n\n  /** Sets whether a feature is enabled. */\n  setFeature(feature: Feature, on: bool = true): void {\n    if (on) {\n      // Enabling Stringref also enables GC\n      if (feature & Feature.Stringref) feature |= Feature.GC;\n      // Enabling GC also enables Reference Types\n      if (feature & Feature.GC) feature |= Feature.ReferenceTypes;\n      // Enabling Relaxed SIMD also enables SIMD\n      if (feature & Feature.RelaxedSimd) feature |= Feature.Simd;\n      this.features |= feature;\n    } else {\n      // Disabling Reference Types also disables GC\n      if (feature & Feature.ReferenceTypes) feature |= Feature.GC;\n      // Disabling GC also disables Stringref\n      if (feature & Feature.GC) feature |= Feature.Stringref;\n      // Disabling SIMD also disables Relaxed SIMD\n      if (feature & Feature.Simd) feature |= Feature.RelaxedSimd;\n      this.features &= ~feature;\n    }\n  }\n\n  /** Tests if a specific feature is activated. */\n  hasFeature(feature: Feature): bool {\n    return (this.features & feature) != 0;\n  }\n}\n\n/** Behaviors regarding unchecked operations. */\nexport const enum UncheckedBehavior {\n  /** Only use unchecked operations inside unchecked(). */\n  Default = 0,\n  /** Never use unchecked operations. */\n  Never = 1,\n  /** Always use unchecked operations if possible. */\n  Always = 2\n}\n\n/** Various constraints in expression compilation. */\nexport const enum Constraints {\n  None = 0,\n\n  /** Must implicitly convert to the target type. */\n  ConvImplicit = 1 << 0,\n  /** Must explicitly convert to the target type. */\n  ConvExplicit = 1 << 1,\n  /** Must wrap small integer values to match the target type. */\n  MustWrap = 1 << 2,\n\n  /** Indicates that the value will be dropped immediately. */\n  WillDrop = 1 << 3,\n  /** Indicates that static data is preferred. */\n  PreferStatic = 1 << 4,\n  /** Indicates that the value will become `this` of a property access or instance call. */\n  IsThis = 1 << 5\n}\n\n/** Runtime features to be activated by the compiler. */\nexport const enum RuntimeFeatures {\n  None = 0,\n  /** Requires data setup. */\n  Data = 1 << 0,\n  /** Requires a stack. */\n  Stack = 1 << 1,\n  /** Requires heap setup. */\n  Heap = 1 << 2,\n  /** Requires runtime type information setup. */\n  Rtti = 1 << 3,\n  /** Requires the built-in globals visitor. */\n  visitGlobals = 1 << 4,\n  /** Requires the built-in members visitor. */\n  visitMembers = 1 << 5,\n  /** Requires the setArgumentsLength export. */\n  setArgumentsLength = 1 << 6\n}\n\n/** Imported default names of compiler-generated elements. */\nexport namespace ImportNames {\n  /** Name of the default namespace */\n  export const DefaultNamespace = \"env\";\n  /** Name of the memory instance, if imported. */\n  export const Memory = \"memory\";\n  /** Name of the table instance, if imported. */\n  export const Table = \"table\";\n}\n\n/** Exported names of compiler-generated elements. */\nexport namespace ExportNames {\n  /** Name of the memory instance, if exported. */\n  export const Memory = \"memory\";\n  /** Name of the table instance, if exported. */\n  export const Table = \"table\";\n  /** Name of the argumentsLength varargs helper global. */\n  export const argumentsLength = \"__argumentsLength\";\n  /** Name of the alternative argumentsLength setter function. */\n  export const setArgumentsLength = \"__setArgumentsLength\";\n}\n\n/** Functions to export if `--exportRuntime` is set. */\nexport const runtimeFunctions = [ \"__new\", \"__pin\", \"__unpin\", \"__collect\" ];\n/** Globals to export if `--exportRuntime` is set. */\nexport const runtimeGlobals = [ \"__rtti_base\" ];\n\n/** Compiler interface. */\nexport class Compiler extends DiagnosticEmitter {\n\n  /** Program reference. */\n  program: Program;\n  /** Module instance being compiled. */\n  get module(): Module { return this.program.module; }\n  /** Provided options. */\n  get options(): Options { return this.program.options; }\n  /** Resolver reference. */\n  get resolver(): Resolver { return this.program.resolver; }\n\n  /** Current control flow. */\n  currentFlow: Flow;\n  /** Current parent element if not a function, i.e. an enum or namespace. */\n  currentParent: Element | null = null;\n  /** Current type in compilation. */\n  currentType: Type = Type.void;\n  /** Start function statements. */\n  currentBody: ExpressionRef[];\n  /** Counting memory offset. */\n  memoryOffset: i64;\n  /** Memory segments being compiled. */\n  memorySegments: MemorySegment[] = [];\n  /** Map of already compiled static string segments. */\n  stringSegments: Map<string,MemorySegment> = new Map();\n  /** Set of static GC object offsets. tostack is unnecessary for them. */\n  staticGcObjectOffsets: Map<i32, Set<i32>> = new Map();\n  /** Function table being compiled. First elem is blank. */\n  functionTable: Function[] = [];\n  /** Arguments length helper global. */\n  builtinArgumentsLength: GlobalRef = 0;\n  /** Requires runtime features. */\n  runtimeFeatures: RuntimeFeatures = RuntimeFeatures.None;\n  /** Current inline functions stack. */\n  inlineStack: Function[] = [];\n  /** Lazily compiled functions. */\n  lazyFunctions: Set<Function> = new Set();\n  /** Pending instanceof helpers and their names. */\n  pendingInstanceOf: Map<DeclaredElement, string> = new Map();\n  /** Stubs to defer calls to overridden methods. */\n  overrideStubs: Set<Function> = new Set();\n  /** Elements currently undergoing compilation. */\n  pendingElements: Set<Element> = new Set();\n  /** Elements, that are module exports, already processed */\n  doneModuleExports: Set<Element> = new Set();\n  /** Shadow stack reference. */\n  shadowStack!: ShadowStackPass;\n  /** Whether the module has custom function exports. */\n  hasCustomFunctionExports: bool = false;\n  /** Whether the module would use the exported runtime to lift/lower. */\n  desiresExportRuntime: bool = false;\n\n  /** Compiles a {@link Program} to a {@link Module} using the specified options. */\n  static compile(program: Program): Module {\n    return new Compiler(program).compile();\n  }\n\n  /** Constructs a new compiler for a {@link Program} using the specified options. */\n  constructor(program: Program) {\n    super(program.diagnostics);\n    this.program = program;\n    let module = program.module;\n    let options = program.options;\n    if (options.memoryBase) {\n      this.memoryOffset = i64_new(options.memoryBase);\n      module.setLowMemoryUnused(false);\n    } else {\n      if (!options.lowMemoryLimit && options.optimizeLevelHint >= 2) {\n        this.memoryOffset = i64_new(1024);\n        module.setLowMemoryUnused(true);\n      } else {\n        this.memoryOffset = i64_new(8);\n        module.setLowMemoryUnused(false);\n      }\n    }\n    let featureFlags: FeatureFlags = 0;\n    if (options.hasFeature(Feature.SignExtension)) featureFlags |= FeatureFlags.SignExt;\n    if (options.hasFeature(Feature.MutableGlobals)) featureFlags |= FeatureFlags.MutableGlobals;\n    if (options.hasFeature(Feature.NontrappingF2I)) featureFlags |= FeatureFlags.TruncSat;\n    if (options.hasFeature(Feature.BulkMemory)) featureFlags |= FeatureFlags.BulkMemory;\n    if (options.hasFeature(Feature.Simd)) featureFlags |= FeatureFlags.SIMD;\n    if (options.hasFeature(Feature.Threads)) featureFlags |= FeatureFlags.Atomics;\n    if (options.hasFeature(Feature.ExceptionHandling)) featureFlags |= FeatureFlags.ExceptionHandling;\n    if (options.hasFeature(Feature.TailCalls)) featureFlags |= FeatureFlags.TailCall;\n    if (options.hasFeature(Feature.ReferenceTypes)) featureFlags |= FeatureFlags.ReferenceTypes;\n    if (options.hasFeature(Feature.MultiValue)) featureFlags |= FeatureFlags.MultiValue;\n    if (options.hasFeature(Feature.GC)) featureFlags |= FeatureFlags.GC;\n    if (options.hasFeature(Feature.Memory64)) featureFlags |= FeatureFlags.Memory64;\n    if (options.hasFeature(Feature.RelaxedSimd)) featureFlags |= FeatureFlags.RelaxedSIMD;\n    if (options.hasFeature(Feature.ExtendedConst)) featureFlags |= FeatureFlags.ExtendedConst;\n    if (options.hasFeature(Feature.Stringref)) featureFlags |= FeatureFlags.Stringref;\n    module.setFeatures(featureFlags);\n\n    // set up the main start function\n    let startFunctionInstance = program.makeNativeFunction(BuiltinNames.start, Signature.create(program, [], Type.void));\n    startFunctionInstance.internalName = BuiltinNames.start;\n    this.currentFlow = startFunctionInstance.flow;\n    this.currentBody = new Array<ExpressionRef>();\n    this.shadowStack = new ShadowStackPass(this);\n  }\n\n  /** Performs compilation of the underlying {@link Program} to a {@link Module}. */\n  compile(): Module {\n    let options = this.options;\n    let module = this.module;\n    let program = this.program;\n    let resolver = this.resolver;\n    let hasShadowStack = options.stackSize > 0; // implies runtime=incremental\n\n    // initialize lookup maps, built-ins, imports, exports, etc.\n    this.program.initialize();\n\n\n    // Binaryen treats all function references as being leaked to the outside world when\n    // the module isn't marked as closed-world (see WebAssembly/binaryen#7135). Therefore,\n    // we should mark the module as closed-world when we're definitely sure it is.\n    module.setClosedWorld(true);\n\n    // obtain the main start function\n    let startFunctionInstance = this.currentFlow.targetFunction;\n    assert(startFunctionInstance.internalName == BuiltinNames.start);\n    let startFunctionBody = this.currentBody;\n    assert(startFunctionBody.length == 0);\n\n    // compile entry file(s) while traversing reachable elements\n    let files = program.filesByName;\n    // TODO: for (let file of files.values()) {\n    for (let _values = Map_values(files), i = 0, k = _values.length; i < k; ++i) {\n      let file = unchecked(_values[i]);\n      if (file.source.sourceKind == SourceKind.UserEntry) {\n        this.compileFile(file);\n        this.compileModuleExports(file);\n      }\n    }\n\n    // compile and export runtime if requested or necessary\n    if (this.options.exportRuntime || (this.options.bindingsHint && this.desiresExportRuntime)) {\n      for (let i = 0, k = runtimeFunctions.length; i < k; ++i) {\n        let name = runtimeFunctions[i];\n        let instance = program.requireFunction(name);\n        if (this.compileFunction(instance) && !module.hasExport(name)) {\n          module.addFunctionExport(instance.internalName, name);\n        }\n      }\n      for (let i = 0, k = runtimeGlobals.length; i < k; ++i) {\n        let name = runtimeGlobals[i];\n        let instance = program.requireGlobal(name);\n        if (this.compileGlobal(instance) && !module.hasExport(name)) {\n          module.addGlobalExport(instance.internalName, name);\n        }\n      }\n    }\n\n    // compile lazy functions\n    let lazyFunctions = this.lazyFunctions;\n    do {\n      let functionsToCompile = new Array<Function>();\n      // TODO: for (let instance of lazyLibraryFunctions) {\n      for (let _values = Set_values(lazyFunctions), i = 0, k = _values.length; i < k; ++i) {\n        let instance = unchecked(_values[i]);\n        functionsToCompile.push(instance);\n      }\n      lazyFunctions.clear();\n      for (let i = 0, k = functionsToCompile.length; i < k; ++i) {\n        this.compileFunction(unchecked(functionsToCompile[i]), true);\n      }\n    } while (lazyFunctions.size);\n\n    // set up override stubs\n    let functionTable = this.functionTable;\n    let overrideStubs = this.overrideStubs;\n    for (let i = 0, k = functionTable.length; i < k; ++i) {\n      let instance = functionTable[i];\n      if (instance.is(CommonFlags.Overridden)) {\n        assert(instance.is(CommonFlags.Instance));\n        functionTable[i] = this.ensureOverrideStub(instance); // includes varargs stub\n      } else if (instance.signature.requiredParameters < instance.signature.parameterTypes.length) {\n        functionTable[i] = this.ensureVarargsStub(instance);\n      }\n    }\n    let overrideStubsSeen = new Set<Function>();\n    do {\n      // override stubs and overrides have cross-dependencies on each other, in that compiling\n      // either may discover the respective other. do this in a loop until no more are found.\n      resolver.discoveredOverride = false;\n      for (let _values = Set_values(overrideStubs), i = 0, k = _values.length; i < k; ++i) {\n        let instance = unchecked(_values[i]);\n        let overrideInstances = resolver.resolveOverrides(instance);\n        if (overrideInstances) {\n          for (let i = 0, k = overrideInstances.length; i < k; ++i) {\n            this.compileFunction(overrideInstances[i]);\n          }\n        }\n        overrideStubsSeen.add(instance);\n      }\n    } while (overrideStubs.size > overrideStubsSeen.size || resolver.discoveredOverride);\n    overrideStubsSeen.clear();\n    for (let _values = Set_values(overrideStubs), i = 0, k = _values.length; i < k; ++i) {\n      this.finalizeOverrideStub(_values[i]);\n    }\n\n    // compile pending instanceof helpers\n    for (let _keys = Map_keys(this.pendingInstanceOf), i = 0, k = _keys.length; i < k; ++i) {\n      let elem = _keys[i];\n      let name = assert(this.pendingInstanceOf.get(elem));\n      switch (elem.kind) {\n        case ElementKind.Class:\n        case ElementKind.Interface: {\n          this.finalizeInstanceOf(<Class>elem, name);\n          break;\n        }\n        case ElementKind.ClassPrototype:\n        case ElementKind.InterfacePrototype: {\n          this.finalizeAnyInstanceOf(<ClassPrototype>elem, name);\n          break;\n        }\n        default: assert(false);\n      }\n    }\n\n    // finalize runtime features\n    module.removeGlobal(BuiltinNames.rtti_base);\n    if (this.runtimeFeatures & RuntimeFeatures.Rtti) compileRTTI(this);\n    if (this.runtimeFeatures & RuntimeFeatures.visitGlobals) compileVisitGlobals(this);\n    if (this.runtimeFeatures & RuntimeFeatures.visitMembers) compileVisitMembers(this);\n\n    let memoryOffset = i64_align(this.memoryOffset, options.usizeType.byteSize);\n\n    // finalize data\n    module.removeGlobal(BuiltinNames.data_end);\n    if ((this.runtimeFeatures & RuntimeFeatures.Data) != 0 || hasShadowStack) {\n      if (options.isWasm64) {\n        module.addGlobal(BuiltinNames.data_end, TypeRef.I64, false,\n          module.i64(i64_low(memoryOffset), i64_high(memoryOffset))\n        );\n      } else {\n        module.addGlobal(BuiltinNames.data_end, TypeRef.I32, false,\n          module.i32(i64_low(memoryOffset))\n        );\n      }\n    }\n\n    // finalize stack (grows down from __heap_base to __data_end)\n    module.removeGlobal(BuiltinNames.stack_pointer);\n    if ((this.runtimeFeatures & RuntimeFeatures.Stack) != 0 || hasShadowStack) {\n      memoryOffset = i64_align(\n        i64_add(memoryOffset, i64_new(options.stackSize)),\n        options.usizeType.byteSize\n      );\n      if (options.isWasm64) {\n        module.addGlobal(BuiltinNames.stack_pointer, TypeRef.I64, true,\n          module.i64(i64_low(memoryOffset), i64_high(memoryOffset))\n        );\n      } else {\n        module.addGlobal(BuiltinNames.stack_pointer, TypeRef.I32, true,\n          module.i32(i64_low(memoryOffset))\n        );\n      }\n    }\n\n    // finalize heap\n    module.removeGlobal(BuiltinNames.heap_base);\n    if ((this.runtimeFeatures & RuntimeFeatures.Heap) != 0 || hasShadowStack) {\n      if (options.isWasm64) {\n        module.addGlobal(BuiltinNames.heap_base, TypeRef.I64, false,\n          module.i64(i64_low(memoryOffset), i64_high(memoryOffset))\n        );\n      } else {\n        module.addGlobal(BuiltinNames.heap_base, TypeRef.I32, false,\n          module.i32(i64_low(memoryOffset))\n        );\n      }\n    }\n\n    // setup default memory & table\n    this.initDefaultMemory(memoryOffset);\n    this.initDefaultTable();\n\n    // expose the arguments length helper if there are varargs exports\n    if (this.runtimeFeatures & RuntimeFeatures.setArgumentsLength) {\n      module.addFunction(BuiltinNames.setArgumentsLength, TypeRef.I32, TypeRef.None, null,\n        module.global_set(this.ensureArgumentsLength(), module.local_get(0, TypeRef.I32))\n      );\n      module.addFunctionExport(BuiltinNames.setArgumentsLength, ExportNames.setArgumentsLength);\n    }\n\n    // NOTE: no more element compiles from here. may go to the start function!\n\n    // compile the start function if not empty or if explicitly requested\n    let startIsEmpty = !startFunctionBody.length;\n    let exportStart = options.exportStart;\n    if (!startIsEmpty || exportStart != null) {\n      let signature = startFunctionInstance.signature;\n      if (!startIsEmpty && exportStart != null) {\n        module.addGlobal(BuiltinNames.started, TypeRef.I32, true, module.i32(0));\n        startFunctionBody.unshift(\n          module.global_set(BuiltinNames.started, module.i32(1))\n        );\n        startFunctionBody.unshift(\n          module.if(\n            module.global_get(BuiltinNames.started, TypeRef.I32),\n            module.return()\n          )\n        );\n      }\n      let funcRef = module.addFunction(\n        startFunctionInstance.internalName,\n        signature.paramRefs,\n        signature.resultRefs,\n        typesToRefs(startFunctionInstance.getNonParameterLocalTypes()),\n        module.flatten(startFunctionBody)\n      );\n      startFunctionInstance.finalize(module, funcRef);\n      if (exportStart == null) module.setStart(funcRef);\n      else {\n        if (!isIdentifier(exportStart) || module.hasExport(exportStart)) {\n          this.error(\n            DiagnosticCode.Start_function_name_0_is_invalid_or_conflicts_with_another_export,\n            Source.native.range, exportStart\n          );\n        } else {\n          module.addFunctionExport(startFunctionInstance.internalName, exportStart);\n        }\n      }\n    }\n\n    // Run custom passes\n    if (hasShadowStack) {\n      this.shadowStack.walkModule();\n    }\n    if (program.lookup(\"ASC_RTRACE\") != null) {\n      new RtraceMemory(this).walkModule();\n    }\n\n    return module;\n  }\n\n  private initDefaultMemory(memoryOffset: i64): void {\n    this.memoryOffset = memoryOffset;\n\n    let options = this.options;\n    let module = this.module;\n    let memorySegments = this.memorySegments;\n\n    let initialPages: u32 = 0;\n    let maximumPages = Module.UNLIMITED_MEMORY;\n    let isSharedMemory = false;\n\n    if (options.memoryBase /* is specified */ || memorySegments.length) {\n      initialPages = u32(i64_low(i64_shr_u(i64_align(memoryOffset, 0x10000), i64_new(16))));\n    }\n\n    if (options.initialMemory) {\n      if (options.initialMemory < initialPages) {\n        this.error(\n          DiagnosticCode.Module_requires_at_least_0_pages_of_initial_memory,\n          null,\n          initialPages.toString()\n        );\n      } else {\n        initialPages = options.initialMemory;\n      }\n    }\n\n    if (options.maximumMemory) {\n      if (options.maximumMemory < initialPages) {\n        this.error(\n          DiagnosticCode.Module_requires_at_least_0_pages_of_maximum_memory,\n          null,\n          initialPages.toString()\n        );\n      } else {\n        maximumPages = options.maximumMemory;\n      }\n    }\n\n    if (options.sharedMemory) {\n      isSharedMemory = true;\n      if (!options.maximumMemory) {\n        this.error(\n          DiagnosticCode.Shared_memory_requires_maximum_memory_to_be_defined,\n          null\n        );\n        isSharedMemory = false;\n      }\n      if (!options.hasFeature(Feature.Threads)) {\n        this.error(\n          DiagnosticCode.Shared_memory_requires_feature_threads_to_be_enabled,\n          null\n        );\n        isSharedMemory = false;\n      }\n    }\n\n    // check that we didn't exceed lowMemoryLimit already\n    let lowMemoryLimit32 = options.lowMemoryLimit;\n    if (lowMemoryLimit32) {\n      let lowMemoryLimit = i64_new(lowMemoryLimit32 & ~15);\n      if (i64_gt(memoryOffset, lowMemoryLimit)) {\n        this.error(\n          DiagnosticCode.Low_memory_limit_exceeded_by_static_data_0_1,\n          null, i64_to_string(memoryOffset), i64_to_string(lowMemoryLimit)\n        );\n      }\n    }\n\n    // Setup internal memory with default name \"0\"\n    module.setMemory(\n      initialPages,\n      maximumPages,\n      memorySegments,\n      options.target,\n      options.exportMemory ? ExportNames.Memory : null,\n      CommonNames.DefaultMemory,\n      isSharedMemory\n    );\n\n    // import memory if requested (default memory is named '0' by Binaryen)\n    if (options.importMemory) {\n      module.addMemoryImport(\n        CommonNames.DefaultMemory,\n        ImportNames.DefaultNamespace,\n        ImportNames.Memory,\n        isSharedMemory\n      );\n    }\n  }\n\n  private initDefaultTable(): void {\n    let options = this.options;\n    let module = this.module;\n\n    // import and/or export table if requested (default table is named '0' by Binaryen)\n    if (options.importTable) {\n      module.addTableImport(\n        CommonNames.DefaultTable,\n        ImportNames.DefaultNamespace,\n        ImportNames.Table\n      );\n      module.setClosedWorld(false);\n      if (options.pedantic && options.willOptimize) {\n        this.pedantic(\n          DiagnosticCode.Importing_the_table_disables_some_indirect_call_optimizations,\n          null\n        );\n      }\n    }\n    if (options.exportTable) {\n      module.addTableExport(CommonNames.DefaultTable, ExportNames.Table);\n      module.setClosedWorld(false);\n      if (options.pedantic && options.willOptimize) {\n        this.pedantic(\n          DiagnosticCode.Exporting_the_table_disables_some_indirect_call_optimizations,\n          null\n        );\n      }\n    }\n\n    // set up function table (first elem is blank)\n    let tableBase = options.tableBase;\n    if (!tableBase) tableBase = 1; // leave first elem blank\n    let functionTable = this.functionTable;\n    let functionTableNames = new Array<string>(functionTable.length);\n    for (let i = 0, k = functionTable.length; i < k; ++i) {\n      functionTableNames[i] = functionTable[i].internalName;\n    }\n\n    let initialTableSize = <Index>tableBase + functionTable.length;\n    let maximumTableSize = Module.UNLIMITED_TABLE;\n\n    if (!(options.importTable || options.exportTable)) {\n      // use fixed size for non-imported and non-exported tables\n      maximumTableSize = initialTableSize;\n      if (options.willOptimize) {\n        // Hint for directize pass which indicate table's content will not change\n        // and can be better optimized\n        module.setPassArgument(\"directize-initial-contents-immutable\", \"true\");\n      }\n    }\n    module.addFunctionTable(\n      CommonNames.DefaultTable,\n      initialTableSize,\n      maximumTableSize,\n      functionTableNames,\n      module.i32(tableBase)\n    );\n  }\n\n  // === Exports ==================================================================================\n\n  /** Compiles the respective module exports for the specified entry file. */\n  private compileModuleExports(file: File): void {\n    let exports = file.exports;\n    if (exports) {\n      // TODO: for (let [elementName, element] of exports) {\n      for (let _keys = Map_keys(exports), i = 0, k = _keys.length; i < k; ++i) {\n        let elementName = unchecked(_keys[i]);\n        let element = assert(exports.get(elementName));\n        this.compileModuleExport(elementName, element);\n      }\n    }\n    let exportsStar = file.exportsStar;\n    if (exportsStar)  {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        this.compileModuleExports(exportsStar[i]);\n      }\n    }\n  }\n\n  /** Compiles the respective module export(s) for the specified element. */\n  private compileModuleExport(name: string, element: DeclaredElement, prefix: string = \"\"): void {\n    let module = this.module;\n    switch (element.kind) {\n      case ElementKind.FunctionPrototype: {\n        // obtain the default instance\n        let functionPrototype = <FunctionPrototype>element;\n        if (!functionPrototype.is(CommonFlags.Generic)) {\n          let functionInstance = this.resolver.resolveFunction(functionPrototype, null);\n          if (functionInstance) {\n            this.compileModuleExport(name, functionInstance, prefix);\n          }\n          return;\n        }\n        break;\n      }\n      case ElementKind.Function: {\n        let functionInstance = <Function>element;\n        if (!functionInstance.hasDecorator(DecoratorFlags.Builtin)) {\n          let signature = functionInstance.signature;\n          if (signature.requiredParameters < signature.parameterTypes.length) {\n            // utilize varargs stub to fill in omitted arguments\n            functionInstance = this.ensureVarargsStub(functionInstance);\n            this.runtimeFeatures |= RuntimeFeatures.setArgumentsLength;\n          }\n          this.compileFunction(functionInstance);\n          if (functionInstance.is(CommonFlags.Compiled)) {\n            let exportName = prefix + name;\n            if (!module.hasExport(exportName)) {\n              module.addFunctionExport(functionInstance.internalName, exportName);\n              this.hasCustomFunctionExports = true;\n              let hasManagedOperands = signature.hasManagedOperands;\n              if (hasManagedOperands) {\n                this.shadowStack.noteExport(exportName, signature.getManagedOperandIndices());\n              }\n              if (!this.desiresExportRuntime) {\n                let thisType = signature.thisType;\n                if (\n                  thisType && lowerRequiresExportRuntime(thisType) ||\n                  liftRequiresExportRuntime(signature.returnType)\n                ) {\n                  this.desiresExportRuntime = true;\n                } else {\n                  let parameterTypes = signature.parameterTypes;\n                  for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n                    if (lowerRequiresExportRuntime(parameterTypes[i])) {\n                      this.desiresExportRuntime = true;\n                      break;\n                    }\n                  }\n                }\n              }\n              if (functionInstance.signature.returnType.kind == TypeKind.Func) this.module.setClosedWorld(false);\n            }\n            return;\n          }\n        }\n        break;\n      }\n      case ElementKind.Global: {\n        let global = <Global>element;\n        let isConst = global.is(CommonFlags.Const) || global.is(CommonFlags.Static | CommonFlags.Readonly);\n        if (!isConst && !this.options.hasFeature(Feature.MutableGlobals)) {\n          this.warning(\n            DiagnosticCode.Feature_0_is_not_enabled,\n            global.identifierNode.range, \"mutable-globals\"\n          );\n          return;\n        }\n        this.compileGlobal(global);\n        if (global.is(CommonFlags.Compiled)) {\n          let exportName = prefix + name;\n          if (!module.hasExport(exportName)) {\n            module.addGlobalExport(element.internalName, exportName);\n            if (!this.desiresExportRuntime) {\n              let type = global.type;\n              if (\n                liftRequiresExportRuntime(type) ||\n                !global.is(CommonFlags.Const) && lowerRequiresExportRuntime(type)\n              ) {\n                this.desiresExportRuntime = true;\n              }\n            }\n            if (global.type.kind == TypeKind.Func) this.module.setClosedWorld(false);\n          }\n          if (global.type == Type.v128) {\n            this.warning(\n              DiagnosticCode.Exchange_of_0_values_is_not_supported_by_all_embeddings,\n              global.typeNode\n                ? assert(global.typeNode).range\n                : global.identifierNode.range,\n              \"v128\"\n            );\n          }\n          return;\n        }\n        break;\n      }\n      case ElementKind.Enum: {\n        this.compileEnum(<Enum>element);\n        let members = element.members;\n        if (members) {\n          let subPrefix = prefix + name + STATIC_DELIMITER;\n          for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n            let memberName = unchecked(_keys[i]);\n            let member = assert(members.get(memberName));\n            if (!member.is(CommonFlags.Private)) {\n              this.compileModuleExport(memberName, member, subPrefix);\n            }\n          }\n        }\n        return;\n      }\n      case ElementKind.EnumValue: {\n        let enumValue = <EnumValue>element;\n        if (!enumValue.isImmutable && !this.options.hasFeature(Feature.MutableGlobals)) {\n          this.error(\n            DiagnosticCode.Feature_0_is_not_enabled,\n            enumValue.identifierNode.range, \"mutable-globals\"\n          );\n          return;\n        }\n        if (enumValue.is(CommonFlags.Compiled)) {\n          let exportName = prefix + name;\n          if (!module.hasExport(exportName)) {\n            module.addGlobalExport(element.internalName, exportName);\n          }\n          return;\n        }\n        break;\n      }\n    }\n    this.warning(\n      DiagnosticCode.Only_variables_functions_and_enums_become_WebAssembly_module_exports,\n      element.identifierNode.range\n    );\n  }\n\n  // files\n\n  /** Compiles the file matching the specified path. */\n  compileFileByPath(normalizedPathWithoutExtension: string, reportNode: Node): void {\n    let file: File;\n    let filesByName = this.program.filesByName;\n    let pathWithIndex: string;\n    if (filesByName.has(normalizedPathWithoutExtension)) {\n      file = assert(filesByName.get(normalizedPathWithoutExtension));\n    } else if (filesByName.has(pathWithIndex = normalizedPathWithoutExtension + INDEX_SUFFIX)) {\n      file = assert(filesByName.get(pathWithIndex));\n    } else {\n      this.error(\n        DiagnosticCode.File_0_not_found,\n        reportNode.range, normalizedPathWithoutExtension\n      );\n      return;\n    }\n    this.compileFile(file);\n  }\n\n  /** Compiles the specified file. */\n  compileFile(file: File): void {\n    if (file.is(CommonFlags.Compiled)) return;\n    file.set(CommonFlags.Compiled);\n\n    // compile top-level statements within the file's start function\n    let startFunction = file.startFunction;\n    let startSignature = startFunction.signature;\n    let previousBody = this.currentBody;\n    let startFunctionBody = new Array<ExpressionRef>();\n    this.currentBody = startFunctionBody;\n\n    // compile top-level statements\n    let previousFlow = this.currentFlow;\n    let flow = startFunction.flow;\n    this.currentFlow = flow;\n    for (let statements = file.source.statements, i = 0, k = statements.length; i < k; ++i) {\n      this.compileTopLevelStatement(statements[i], startFunctionBody);\n    }\n    // no need to insert unreachable since last statement should have done that\n    this.currentFlow = previousFlow;\n    this.currentBody = previousBody;\n\n    // if top-level statements are present, make the per-file start function and call it in start\n    if (startFunctionBody.length) {\n      let module = this.module;\n      let locals = startFunction.localsByIndex;\n      let numLocals = locals.length;\n      let varTypes = new Array<TypeRef>(numLocals);\n      for (let i = 0; i < numLocals; ++i) varTypes[i] = locals[i].type.toRef();\n      const funcRef = module.addFunction(\n        startFunction.internalName,\n        startSignature.paramRefs,\n        startSignature.resultRefs,\n        varTypes,\n        module.flatten(startFunctionBody)\n      );\n      startFunction.finalize(module, funcRef);\n      previousBody.push(\n        module.call(startFunction.internalName, null, TypeRef.None)\n      );\n    }\n  }\n\n  // === Globals ==================================================================================\n\n  /** Tries to compile a global variable lazily. */\n  compileGlobalLazy(global: Global, reportNode: Node): bool {\n    if (global.is(CommonFlags.Compiled)) return !global.is(CommonFlags.Errored);\n    if (global.hasAnyDecorator(DecoratorFlags.Lazy | DecoratorFlags.Builtin) || global.is(CommonFlags.Ambient)) {\n      return this.compileGlobal(global); // compile now\n    }\n    // Otherwise the global is used before its initializer executes\n    this.errorRelated(\n      DiagnosticCode.Variable_0_used_before_its_declaration,\n      reportNode.range, global.identifierNode.range, global.internalName\n    );\n    return false;\n  }\n\n  /** Compiles a global variable. */\n  compileGlobal(global: Global): bool {\n    if (global.is(CommonFlags.Compiled)) return !global.is(CommonFlags.Errored);\n    global.set(CommonFlags.Compiled);\n\n    let pendingElements = this.pendingElements;\n    pendingElements.add(global);\n\n    let module = this.module;\n    let initExpr: ExpressionRef = 0;\n    let typeNode = global.typeNode;\n    let initializerNode = global.initializerNode;\n\n    if (!global.is(CommonFlags.Resolved)) {\n\n      // Resolve type if annotated\n      if (typeNode) {\n        let resolvedType = this.resolver.resolveType(typeNode, null, global.parent); // reports\n        if (!resolvedType) {\n          global.set(CommonFlags.Errored);\n          pendingElements.delete(global);\n          return false;\n        }\n        if (resolvedType == Type.void) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            typeNode.range\n          );\n          global.set(CommonFlags.Errored);\n          pendingElements.delete(global);\n          return false;\n        }\n        global.setType(resolvedType);\n        this.program.checkTypeSupported(resolvedType, typeNode);\n\n      // Otherwise infer type from initializer\n      } else if (initializerNode) {\n        let previousFlow = this.currentFlow;\n        if (global.hasDecorator(DecoratorFlags.Lazy)) {\n          this.currentFlow = global.file.startFunction.flow;\n        }\n        initExpr = this.compileExpression(initializerNode, Type.auto, // reports\n          Constraints.MustWrap | Constraints.PreferStatic\n        );\n        this.currentFlow = previousFlow;\n        if (this.currentType == Type.void) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            initializerNode.range, this.currentType.toString(), \"<auto>\"\n          );\n          global.set(CommonFlags.Errored);\n          pendingElements.delete(global);\n          return false;\n        }\n        global.setType(this.currentType);\n\n      // Error if there's neither a type nor an initializer\n      } else {\n        this.error(\n          DiagnosticCode.Type_expected,\n          global.identifierNode.range.atEnd\n        );\n        global.set(CommonFlags.Errored);\n        pendingElements.delete(global);\n        return false;\n      }\n    }\n\n    // Handle builtins like '__heap_base' that need to be resolved but are added explicitly\n    if (global.hasDecorator(DecoratorFlags.Builtin)) {\n      let internalName = global.internalName;\n      if (builtinVariables_onCompile.has(internalName)) { // optional\n        let fn = assert(builtinVariables_onCompile.get(internalName));\n        fn(new BuiltinVariableContext(this, global));\n      }\n      pendingElements.delete(global);\n      return true;\n    }\n\n    let type = global.type;\n\n    // Enforce either an initializer, a definitive assignment or a nullable type\n    // to guarantee soundness when globals are accessed. In the absence of an\n    // initializer, a definitive assignment guarantees a runtime check, whereas\n    // a nullable type guarantees that obtaining default `null` is OK. Avoids:\n    //\n    //   let foo: string;\n    //   function bar() {\n    //     foo.length; // no error in TS even though undefined\n    //   }\n    //   bar();\n    if (\n      !initializerNode && !global.is(CommonFlags.DefinitelyAssigned) &&\n      type.isReference && !type.isNullableReference\n    ) {\n      this.error(\n        DiagnosticCode.Initializer_definitive_assignment_or_nullable_type_expected,\n        global.identifierNode.range\n      );\n    }\n\n    let typeRef = type.toRef();\n    let isDeclaredConstant = global.is(CommonFlags.Const) || global.is(CommonFlags.Static | CommonFlags.Readonly);\n    let isDeclaredInline = global.hasDecorator(DecoratorFlags.Inline);\n\n    // Handle imports\n    if (global.is(CommonFlags.Ambient)) {\n\n      // Constant global or mutable globals enabled\n      if (isDeclaredConstant || this.options.hasFeature(Feature.MutableGlobals)) {\n        mangleImportName(global, global.declaration);\n        this.program.markModuleImport(mangleImportName_moduleName, mangleImportName_elementName, global);\n        module.addGlobalImport(\n          global.internalName,\n          mangleImportName_moduleName,\n          mangleImportName_elementName,\n          typeRef,\n          !isDeclaredConstant\n        );\n        pendingElements.delete(global);\n        if (!this.desiresExportRuntime && lowerRequiresExportRuntime(type)) {\n          this.desiresExportRuntime = true;\n        }\n        return true;\n      }\n\n      // Importing mutable globals is not supported in the MVP\n      this.error(\n        DiagnosticCode.Feature_0_is_not_enabled,\n        global.declaration.range, \"mutable-globals\"\n      );\n      global.set(CommonFlags.Errored);\n      pendingElements.delete(global);\n      return false;\n    }\n\n    // The MVP does not yet support initializer expressions other than constants and gets of\n    // imported immutable globals, hence such initializations must be performed in the start.\n    let initializeInStart = false;\n\n    // Evaluate initializer if present\n    if (initializerNode) {\n      if (!initExpr) {\n        let previousFlow = this.currentFlow;\n        if (global.hasDecorator(DecoratorFlags.Lazy)) {\n          this.currentFlow = global.file.startFunction.flow;\n        }\n        initExpr = this.compileExpression(initializerNode, type,\n          Constraints.ConvImplicit | Constraints.MustWrap | Constraints.PreferStatic\n        );\n        this.currentFlow = previousFlow;\n      }\n\n      // If not a constant expression, attempt to precompute\n      if (!module.isConstExpression(initExpr)) {\n        if (isDeclaredConstant) {\n          let precomp = module.runExpression(initExpr, ExpressionRunnerFlags.PreserveSideeffects);\n          if (precomp) {\n            initExpr = precomp;\n          } else {\n            initializeInStart = true;\n          }\n        } else {\n          initializeInStart = true;\n        }\n      }\n\n      // Handle special case of initializing from imported immutable global\n      if (initializeInStart && getExpressionId(initExpr) == ExpressionId.GlobalGet) {\n        let fromName = assert(getGlobalGetName(initExpr));\n        if (!isGlobalMutable(module.getGlobal(fromName))) {\n          let elementsByName = this.program.elementsByName;\n          if (elementsByName.has(fromName)) {\n            let global = assert(elementsByName.get(fromName));\n            if (global.is(CommonFlags.Ambient)) initializeInStart = false;\n          }\n        }\n      }\n\n      // Explicitly inline if annotated\n      if (isDeclaredInline) {\n        if (initializeInStart) {\n          this.warning(\n            DiagnosticCode.Mutable_value_cannot_be_inlined,\n            initializerNode.range\n          );\n        } else {\n          assert(getExpressionId(initExpr) == ExpressionId.Const);\n          let exprType = getExpressionType(initExpr);\n          switch (<u32>exprType) {\n            case <u32>TypeRef.I32: {\n              global.constantValueKind = ConstantValueKind.Integer;\n              global.constantIntegerValue = i64_new(getConstValueI32(initExpr), 0);\n              break;\n            }\n            case <u32>TypeRef.I64: {\n              global.constantValueKind = ConstantValueKind.Integer;\n              global.constantIntegerValue = i64_new(\n                getConstValueI64Low(initExpr),\n                getConstValueI64High(initExpr)\n              );\n              break;\n            }\n            case <u32>TypeRef.F32: {\n              global.constantValueKind = ConstantValueKind.Float;\n              global.constantFloatValue = getConstValueF32(initExpr);\n              break;\n            }\n            case <u32>TypeRef.F64: {\n              global.constantValueKind = ConstantValueKind.Float;\n              global.constantFloatValue = getConstValueF64(initExpr);\n              break;\n            }\n            default: {\n              assert(false);\n              global.set(CommonFlags.Errored);\n              pendingElements.delete(global);\n              return false;\n            }\n          }\n          global.set(CommonFlags.Inlined); // inline the value from now on\n        }\n      }\n\n    // Initialize to zero if there's no initializer\n    } else {\n      if (global.is(CommonFlags.Inlined)) {\n        initExpr = this.compileInlineConstant(global, global.type, Constraints.PreferStatic);\n      } else {\n        initExpr = this.makeZero(type);\n      }\n    }\n\n    let internalName = global.internalName;\n\n    if (initializeInStart) { // initialize to mutable zero and set the actual value in start\n      if (isDeclaredInline) {\n        this.error(\n          DiagnosticCode.Decorator_0_is_not_valid_here,\n          findDecorator(DecoratorKind.Inline, global.decoratorNodes)!.range, \"inline\"\n        );\n      }\n      let internalType = type;\n      if (type.isExternalReference && !type.is(TypeFlags.Nullable)) {\n        // There is no default value for non-nullable external references, so\n        // make the global nullable internally and use `null`.\n        global.set(CommonFlags.InternallyNullable);\n        internalType = type.asNullable();\n      }\n      module.addGlobal(internalName, internalType.toRef(), true, this.makeZero(internalType));\n      this.currentBody.push(\n        module.global_set(internalName, initExpr)\n      );\n    } else if (!isDeclaredInline) { // compile normally\n      module.addGlobal(internalName, typeRef, !isDeclaredConstant, initExpr);\n    }\n    pendingElements.delete(global);\n    return true;\n  }\n\n  // === Enums ====================================================================================\n\n  /** Compiles an enum. */\n  compileEnum(element: Enum): bool {\n    if (element.is(CommonFlags.Compiled)) return !element.is(CommonFlags.Errored);\n    element.set(CommonFlags.Compiled);\n\n    let pendingElements = this.pendingElements;\n    pendingElements.add(element);\n\n    let module = this.module;\n    let previousParent = this.currentParent;\n    this.currentParent = element;\n    let previousValue: EnumValue | null = null;\n    let previousValueIsMut = false;\n    let isInline = element.is(CommonFlags.Const) || element.hasDecorator(DecoratorFlags.Inline);\n\n    let members = element.members;\n    if (members) {\n      // TODO: for (let member of element.members.values()) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        if (member.kind != ElementKind.EnumValue) continue; // happens if an enum is also a namespace\n        let initInStart = false;\n        let enumValue = <EnumValue>member;\n        let valueNode = enumValue.valueNode;\n        enumValue.set(CommonFlags.Compiled);\n        let previousFlow = this.currentFlow;\n        if (element.hasDecorator(DecoratorFlags.Lazy)) {\n          this.currentFlow = element.file.startFunction.flow;\n        }\n        let initExpr: ExpressionRef;\n        if (valueNode) {\n          initExpr = this.compileExpression(valueNode, Type.i32,\n            Constraints.ConvImplicit\n          );\n          if (getExpressionId(initExpr) != ExpressionId.Const) {\n            let precomp = module.runExpression(initExpr, ExpressionRunnerFlags.PreserveSideeffects);\n            if (precomp) {\n              initExpr = precomp;\n            } else {\n              if (element.is(CommonFlags.Const)) {\n                this.error(\n                  DiagnosticCode.In_const_enum_declarations_member_initializer_must_be_constant_expression,\n                  valueNode.range\n                );\n              }\n              initInStart = true;\n            }\n          }\n        } else if (previousValue == null) {\n          initExpr = module.i32(0);\n        } else {\n          if (previousValueIsMut) {\n            this.error(\n              DiagnosticCode.Enum_member_must_have_initializer,\n              enumValue.identifierNode.range.atEnd\n            );\n          }\n          if (isInline) {\n            let value = i64_add(previousValue.constantIntegerValue, i64_new(1));\n            assert(!i64_high(value));\n            initExpr = module.i32(i64_low(value));\n          } else {\n            initExpr = module.binary(BinaryOp.AddI32,\n              module.global_get(previousValue.internalName, TypeRef.I32),\n              module.i32(1)\n            );\n            let precomp = module.runExpression(initExpr, ExpressionRunnerFlags.PreserveSideeffects);\n            if (precomp) {\n              initExpr = precomp;\n            } else {\n              if (element.is(CommonFlags.Const)) {\n                this.error(\n                  DiagnosticCode.In_const_enum_declarations_member_initializer_must_be_constant_expression,\n                  member.declaration.range\n                );\n              }\n              initInStart = true;\n            }\n          }\n        }\n        this.currentFlow = previousFlow;\n        if (initInStart) {\n          module.addGlobal(enumValue.internalName, TypeRef.I32, true, module.i32(0));\n          this.currentBody.push(\n            this.makeGlobalAssignment(enumValue, initExpr, Type.i32, false)\n          );\n          previousValueIsMut = true;\n        } else {\n          if (isInline) {\n            enumValue.setConstantIntegerValue(i64_new(getConstValueI32(initExpr)), Type.i32);\n            if (enumValue.is(CommonFlags.ModuleExport)) {\n              module.addGlobal(enumValue.internalName, TypeRef.I32, false, initExpr);\n            }\n          } else {\n            module.addGlobal(enumValue.internalName, TypeRef.I32, false, initExpr);\n          }\n          enumValue.isImmutable = true;\n          previousValueIsMut = false;\n        }\n        previousValue = enumValue;\n      }\n    }\n    this.currentParent = previousParent;\n    pendingElements.delete(element);\n    return true;\n  }\n\n  // === Functions ================================================================================\n\n  /** Compiles a priorly resolved function. */\n  compileFunction(\n    /** Function to compile. */\n    instance: Function,\n    /** Force compilation of stdlib alternative if a builtin. */\n    forceStdAlternative: bool = false\n  ): bool {\n    if (instance.is(CommonFlags.Compiled)) return !instance.is(CommonFlags.Errored);\n\n    if (!forceStdAlternative) {\n      if (instance.hasDecorator(DecoratorFlags.Builtin)) return true;\n      if (instance.hasDecorator(DecoratorFlags.Lazy)) {\n        this.lazyFunctions.add(instance);\n        return true;\n      }\n    }\n\n    // ensure the function has no duplicate parameters\n    let parameters = instance.prototype.functionTypeNode.parameters;\n    let numParameters = parameters.length;\n    if (numParameters >= 2) {\n      let visited = new Set<string>();\n      visited.add(parameters[0].name.text);\n      for (let i = 1; i < numParameters; i++) {\n        let paramIdentifier = parameters[i].name;\n        let paramName = paramIdentifier.text;\n        if (!visited.has(paramName)) {\n          visited.add(paramName);\n        } else {\n          this.error(\n            DiagnosticCode.Duplicate_identifier_0,\n            paramIdentifier.range, paramName\n          );\n        }\n      }\n    }\n\n    instance.set(CommonFlags.Compiled);\n    let pendingElements = this.pendingElements;\n    pendingElements.add(instance);\n\n    let previousType = this.currentType;\n    let module = this.module;\n    let signature = instance.signature;\n    let bodyNode = instance.prototype.bodyNode;\n    let declarationNode = instance.declaration;\n    assert(declarationNode.kind == NodeKind.FunctionDeclaration || declarationNode.kind == NodeKind.MethodDeclaration);\n    this.checkSignatureSupported(instance.signature, (<FunctionDeclaration>declarationNode).signature);\n\n    let funcRef: FunctionRef = 0;\n\n    // concrete function\n    if (bodyNode) {\n\n      // must not be ambient\n      if (instance.is(CommonFlags.Ambient)) {\n        this.error(\n          DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts,\n          instance.identifierNode.range\n        );\n      }\n\n      // cannot have an annotated external name or code\n      if (instance.hasAnyDecorator(DecoratorFlags.External | DecoratorFlags.ExternalJs)) {\n        let decoratorNodes = instance.decoratorNodes;\n        let decorator: DecoratorNode | null;\n        if (decorator = findDecorator(DecoratorKind.External, decoratorNodes)) {\n          this.error(\n            DiagnosticCode.Decorator_0_is_not_valid_here,\n            decorator.range, \"external\"\n          );\n        }\n        if (decorator = findDecorator(DecoratorKind.ExternalJs, decoratorNodes)) {\n          this.error(\n            DiagnosticCode.Decorator_0_is_not_valid_here,\n            decorator.range, \"external.js\"\n          );\n        }\n      }\n\n      // compile body in this function's context\n      let previousFlow = this.currentFlow;\n      let flow = instance.flow;\n      this.currentFlow = flow;\n      let stmts = new Array<ExpressionRef>();\n\n      if (!this.compileFunctionBody(instance, stmts)) {\n        stmts.push(module.unreachable());\n      }\n\n      this.currentFlow = previousFlow;\n\n      // create the function\n      funcRef = module.addFunction(\n        instance.internalName,\n        signature.paramRefs,\n        signature.resultRefs,\n        typesToRefs(instance.getNonParameterLocalTypes()),\n        module.flatten(stmts, instance.signature.returnType.toRef())\n      );\n\n    // imported function\n    } else if (instance.is(CommonFlags.Ambient)) {\n      mangleImportName(instance, declarationNode); // TODO: check for duplicates\n      this.program.markModuleImport(mangleImportName_moduleName, mangleImportName_elementName, instance);\n      module.addFunctionImport(\n        instance.internalName,\n        mangleImportName_moduleName,\n        mangleImportName_elementName,\n        signature.paramRefs,\n        signature.resultRefs\n      );\n      funcRef = module.getFunction(instance.internalName);\n      if (!this.desiresExportRuntime) {\n        let thisType = signature.thisType;\n        if (\n          thisType && liftRequiresExportRuntime(thisType) ||\n          lowerRequiresExportRuntime(signature.returnType)\n        ) {\n          this.desiresExportRuntime = true;\n        } else {\n          let parameterTypes = signature.parameterTypes;\n          for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n            if (liftRequiresExportRuntime(parameterTypes[i])) {\n              this.desiresExportRuntime = true;\n              break;\n            }\n          }\n        }\n      }\n\n    // abstract or interface function\n    } else if (instance.is(CommonFlags.Abstract) || instance.parent.kind == ElementKind.Interface) {\n      funcRef = module.addFunction(\n        instance.internalName,\n        signature.paramRefs,\n        signature.resultRefs,\n        null,\n        module.unreachable()\n      );\n\n    } else {\n      // built-in field accessor?\n      if (instance.isAny(CommonFlags.Get | CommonFlags.Set)) {\n        let propertyName = instance.declaration.name.text;\n        let propertyParent = assert(instance.parent.getMember(propertyName));\n        assert(propertyParent.kind == ElementKind.PropertyPrototype);\n        let propertyInstance = (<PropertyPrototype>propertyParent).instance;\n        if (propertyInstance && propertyInstance.isField) {\n          funcRef = instance.is(CommonFlags.Get)\n            ? this.makeBuiltinFieldGetter(propertyInstance)\n            : this.makeBuiltinFieldSetter(propertyInstance);\n          assert(instance.is(CommonFlags.Compiled));\n        }\n      }\n      if (!funcRef) {\n        this.error(\n          DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,\n          instance.identifierNode.range\n        );\n        instance.set(CommonFlags.Errored);\n      }\n    }\n\n    if (instance.is(CommonFlags.Ambient) || instance.is(CommonFlags.Export)) {\n      // Verify and print warn if signature has v128 type for imported or exported functions\n      let hasVectorValueOperands = signature.hasVectorValueOperands;\n      if (hasVectorValueOperands) {\n        let range: Range;\n        let fnTypeNode = instance.prototype.functionTypeNode;\n        if (signature.returnType == Type.v128) {\n          range = fnTypeNode.returnType.range;\n        } else {\n          let firstIndex = signature.getVectorValueOperandIndices()[0];\n          range = fnTypeNode.parameters[firstIndex].range;\n        }\n        this.warning(\n          DiagnosticCode.Exchange_of_0_values_is_not_supported_by_all_embeddings,\n          range, \"v128\"\n        );\n      }\n    }\n\n    instance.finalize(module, funcRef);\n    this.currentType = previousType;\n    pendingElements.delete(instance);\n    return true;\n  }\n\n  /** Compiles the body of a function within the specified flow. */\n  private compileFunctionBody(\n    /** Function to compile. */\n    instance: Function,\n    /** Target array of statements also being returned. Creates a new array if omitted. */\n    stmts: ExpressionRef[]\n  ): bool {\n    let module = this.module;\n    let bodyNode = assert(instance.prototype.bodyNode);\n    let returnType = instance.signature.returnType;\n    let flow = this.currentFlow;\n    let thisLocal = instance.signature.thisType\n      ? assert(flow.lookupLocal(CommonNames.this_))\n      : null;\n    let bodyStartIndex = stmts.length;\n\n    // compile statements\n    if (bodyNode.kind == NodeKind.Block) {\n      stmts = this.compileStatements((<BlockStatement>bodyNode).statements, stmts);\n    } else {\n      // must be an expression statement if not a block\n      assert(bodyNode.kind == NodeKind.Expression);\n\n      // must be an arrow function\n      assert(instance.prototype.arrowKind);\n\n      // none of the following can be an arrow function\n      assert(!instance.isAny(CommonFlags.Constructor | CommonFlags.Get | CommonFlags.Set));\n\n      let expr = this.compileExpression((<ExpressionStatement>bodyNode).expression, returnType, Constraints.ConvImplicit);\n      if (!flow.canOverflow(expr, returnType)) flow.set(FlowFlags.ReturnsWrapped);\n      if (flow.isNonnull(expr, returnType)) flow.set(FlowFlags.ReturnsNonNull);\n\n      if (!stmts) stmts = [ expr ];\n      else stmts.push(expr);\n\n      if (!flow.is(FlowFlags.Terminates)) {\n        if (!flow.canOverflow(expr, returnType)) flow.set(FlowFlags.ReturnsWrapped);\n        if (flow.isNonnull(expr, returnType)) flow.set(FlowFlags.ReturnsNonNull);\n        flow.set(FlowFlags.Returns | FlowFlags.Terminates);\n      }\n    }\n\n    // Make constructors return their instance pointer, and prepend a conditional\n    // allocation if any code path accesses `this`.\n    if (instance.is(CommonFlags.Constructor)) {\n      assert(instance.is(CommonFlags.Instance));\n      thisLocal = assert(thisLocal);\n      let parent = assert(instance.parent);\n      assert(parent.kind == ElementKind.Class);\n      let classInstance = <Class>parent;\n\n      if (flow.isAny(FlowFlags.AccessesThis | FlowFlags.ConditionallyAccessesThis) || !flow.is(FlowFlags.Terminates)) {\n\n        // Allocate `this` if not a super call, and initialize fields\n        let allocStmts = new Array<ExpressionRef>();\n        allocStmts.push(\n          this.makeConditionalAllocation(classInstance, thisLocal.index)\n        );\n        this.makeFieldInitializationInConstructor(classInstance, allocStmts);\n\n        // Insert right before the body\n        for (let i = stmts.length - 1; i >= bodyStartIndex; --i) {\n          stmts[i + 1] = stmts[i];\n        }\n        stmts[bodyStartIndex] = module.flatten(allocStmts, TypeRef.None);\n\n        // Just prepended allocation is dropped when returning non-'this'\n        if (flow.is(FlowFlags.MayReturnNonThis)) {\n          if (this.options.pedantic) {\n            this.pedantic(\n              DiagnosticCode.Explicitly_returning_constructor_drops_this_allocation,\n              instance.identifierNode.range\n            );\n          }\n        }\n      }\n\n      // Returning something else than 'this' would break 'super()' calls\n      if (flow.is(FlowFlags.MayReturnNonThis) && !classInstance.hasDecorator(DecoratorFlags.Final)) {\n        this.error(\n          DiagnosticCode.A_class_with_a_constructor_explicitly_returning_something_else_than_this_must_be_final,\n          classInstance.identifierNode.range\n        );\n      }\n\n      // Implicitly return `this` if the flow falls through\n      if (!flow.is(FlowFlags.Terminates)) {\n        stmts.push(\n          module.local_get(thisLocal.index, thisLocal.type.toRef())\n        );\n        flow.set(FlowFlags.Returns | FlowFlags.ReturnsNonNull | FlowFlags.Terminates);\n      }\n\n      // check that super has been called if this is a derived class\n      if (classInstance.base && !classInstance.prototype.implicitlyExtendsObject && !flow.is(FlowFlags.CallsSuper)) {\n        this.error(\n          DiagnosticCode.Constructors_for_derived_classes_must_contain_a_super_call,\n          instance.prototype.declaration.range\n        );\n      }\n\n    // if this is a normal function, make sure that all branches terminate\n    } else if (returnType != Type.void && !flow.is(FlowFlags.Terminates)) {\n      this.error(\n        DiagnosticCode.A_function_whose_declared_type_is_not_void_must_return_a_value,\n        instance.prototype.functionTypeNode.returnType.range\n      );\n      return false; // not recoverable\n    }\n\n    return true;\n  }\n\n  /** Makes a built-in getter of a property that is a field. */\n  private makeBuiltinFieldGetter(property: Property): FunctionRef {\n    let getterInstance = assert(property.getterInstance);\n    let module = this.module;\n    let valueType = property.type;\n    let valueTypeRef = valueType.toRef();\n    let thisTypeRef = this.options.sizeTypeRef;\n    getterInstance.set(CommonFlags.Compiled);\n    let body = module.load(valueType.byteSize, valueType.isSignedIntegerValue,\n      module.local_get(0, thisTypeRef),\n      valueTypeRef, property.memoryOffset\n    );\n    let flowBefore = this.currentFlow;\n    let flow = getterInstance.flow;\n    this.currentFlow = flow;\n    if (property.is(CommonFlags.DefinitelyAssigned) && valueType.isReference && !valueType.isNullableReference) {\n      body = this.makeRuntimeNonNullCheck(body, valueType, getterInstance.identifierNode);\n    }\n    this.currentFlow = flowBefore;\n    return module.addFunction(\n      getterInstance.internalName,\n      thisTypeRef,\n      valueTypeRef,\n      typesToRefs(getterInstance.getNonParameterLocalTypes()),\n      body\n    );\n  }\n\n  /** Makes a built-in setter of a property that is a field. */\n  private makeBuiltinFieldSetter(property: Property): FunctionRef {\n    let setterInstance = assert(property.setterInstance);\n    let module = this.module;\n    let valueType = property.type;\n    let thisTypeRef = this.options.sizeTypeRef;\n    let valueTypeRef = valueType.toRef();\n    // void(this.field = value)\n    let bodyExpr = module.store(valueType.byteSize,\n      module.local_get(0, thisTypeRef),\n      module.local_get(1, valueTypeRef),\n      valueTypeRef, property.memoryOffset\n    );\n    if (valueType.isManaged) {\n      let parent = setterInstance.parent;\n      assert(parent.kind == ElementKind.Class);\n      if ((<Class>parent).type.isManaged) {\n        let linkInstance = this.program.linkInstance;\n        this.compileFunction(linkInstance);\n        bodyExpr = module.block(null, [\n          bodyExpr,\n          module.call(linkInstance.internalName, [\n            module.local_get(0, thisTypeRef),\n            module.local_get(1, valueTypeRef),\n            module.i32(0)\n          ], TypeRef.None)\n        ], TypeRef.None);\n      }\n    }\n    setterInstance.set(CommonFlags.Compiled);\n    return module.addFunction(\n      setterInstance.internalName,\n      createType([ thisTypeRef, valueTypeRef ]),\n      TypeRef.None,\n      null,\n      bodyExpr\n    );\n  }\n\n  // === Memory ===================================================================================\n\n  /** Adds a static memory segment with the specified data. */\n  addAlignedMemorySegment(buffer: Uint8Array, alignment: i32 = 16): MemorySegment {\n    assert(isPowerOf2(alignment));\n    let memoryOffset = i64_align(this.memoryOffset, alignment);\n    let segment = new MemorySegment(buffer, memoryOffset);\n    this.memorySegments.push(segment);\n    this.memoryOffset = i64_add(memoryOffset, i64_new(buffer.length));\n    return segment;\n  }\n\n  /** Adds a static memory segment representing a runtime object. */\n  addRuntimeMemorySegment(buffer: Uint8Array): MemorySegment {\n    let memoryOffset = this.program.computeBlockStart64(this.memoryOffset);\n    let segment = new MemorySegment(buffer, memoryOffset);\n    this.memorySegments.push(segment);\n    this.memoryOffset = i64_add(memoryOffset, i64_new(buffer.length));\n    return segment;\n  }\n\n  /** Ensures that a string exists in static memory and returns a pointer expression. Deduplicates. */\n  ensureStaticString(stringValue: string): ExpressionRef {\n    let ptr = this.ensureStaticStringPtr(stringValue);\n    this.currentType = this.program.stringInstance.type;\n    return this.module.usize(ptr);\n  }\n\n  /** Ensures that a string exists in static memory and returns a pointer to it. Deduplicates. */\n  ensureStaticStringPtr(stringValue: string): i64 {\n    let program = this.program;\n    let totalOverhead = program.totalOverhead;\n    let stringInstance = assert(program.stringInstance);\n    let stringSegment: MemorySegment;\n    let segments = this.stringSegments;\n    if (segments.has(stringValue)) {\n      stringSegment = assert(segments.get(stringValue)); // reuse\n    } else {\n      let len = stringValue.length;\n      let buf = stringInstance.createBuffer(len << 1);\n      for (let i = 0; i < len; ++i) {\n        writeI16(stringValue.charCodeAt(i), buf, totalOverhead + (i << 1));\n      }\n      stringSegment = this.addRuntimeMemorySegment(buf);\n      segments.set(stringValue, stringSegment);\n    }\n    let stringOffset = i64_add(stringSegment.offset, i64_new(totalOverhead));\n    let staticGcObjectOffsets = this.staticGcObjectOffsets;\n    if (staticGcObjectOffsets.has(i64_high(stringOffset))) {\n      assert(staticGcObjectOffsets.get(i64_high(stringOffset))).add(i64_low(stringOffset));\n    } else {\n      let s = new Set<i32>();\n      s.add(i64_low(stringOffset));\n      staticGcObjectOffsets.set(i64_high(stringOffset), s);\n    }\n    return stringOffset;\n  }\n\n  /** Writes a series of static values of the specified type to a buffer. */\n  writeStaticBuffer(buf: Uint8Array, pos: i32, elementType: Type, values: ExpressionRef[]): i32 {\n    let length = values.length;\n    let byteSize = elementType.byteSize;\n    let elementTypeRef = elementType.toRef();\n    switch (<u32>elementTypeRef) {\n      case <u32>TypeRef.I32: {\n        switch (byteSize) {\n          case 1: {\n            for (let i = 0; i < length; ++i) {\n              let value = values[i];\n              assert(getExpressionType(value) == elementTypeRef);\n              assert(getExpressionId(value) == ExpressionId.Const);\n              writeI8(getConstValueI32(value), buf, pos);\n              pos += 1;\n            }\n            break;\n          }\n          case 2: {\n            for (let i = 0; i < length; ++i) {\n              let value = values[i];\n              assert(getExpressionType(value) == elementTypeRef);\n              assert(getExpressionId(value) == ExpressionId.Const);\n              writeI16(getConstValueI32(value), buf, pos);\n              pos += 2;\n            }\n            break;\n          }\n          case 4: {\n            for (let i = 0; i < length; ++i) {\n              let value = values[i];\n              assert(getExpressionType(value) == elementTypeRef);\n              assert(getExpressionId(value) == ExpressionId.Const);\n              writeI32(getConstValueI32(value), buf, pos);\n              pos += 4;\n            }\n            break;\n          }\n          default: assert(false);\n        }\n        break;\n      }\n      case <u32>TypeRef.I64: {\n        for (let i = 0; i < length; ++i) {\n          let value = values[i];\n          assert(getExpressionType(value) == elementTypeRef);\n          assert(getExpressionId(value) == ExpressionId.Const);\n          writeI64(i64_new(getConstValueI64Low(value), getConstValueI64High(value)), buf, pos);\n          pos += 8;\n        }\n        break;\n      }\n      case <u32>TypeRef.F32: {\n        for (let i = 0; i < length; ++i) {\n          let value = values[i];\n          assert(getExpressionType(value) == elementTypeRef);\n          assert(getExpressionId(value) == ExpressionId.Const);\n          writeF32(getConstValueF32(value), buf, pos);\n          pos += 4;\n        }\n        break;\n      }\n      case <u32>TypeRef.F64: {\n        for (let i = 0; i < length; ++i) {\n          let value = values[i];\n          assert(getExpressionType(value) == elementTypeRef);\n          assert(getExpressionId(value) == ExpressionId.Const);\n          writeF64(getConstValueF64(value), buf, pos);\n          pos += 8;\n        }\n        break;\n      }\n      case <u32>TypeRef.V128: {\n        for (let i = 0; i < length; ++i) {\n          let value = values[i];\n          assert(getExpressionType(value) == elementTypeRef);\n          assert(getExpressionId(value) == ExpressionId.Const);\n          writeV128(getConstValueV128(value), buf, pos);\n          pos += 16;\n        }\n        break;\n      }\n      case <u32>TypeRef.None: {\n        // nothing to write\n        break;\n      }\n      default: assert(false);\n    }\n    return pos;\n  }\n\n  /** Adds a buffer to static memory and returns the created segment. */\n  addStaticBuffer(elementType: Type, values: ExpressionRef[], id: u32 = this.program.arrayBufferInstance.id): MemorySegment {\n    let program = this.program;\n    let arrayBufferInstance = program.arrayBufferInstance;\n    let buf = arrayBufferInstance.createBuffer(values.length * elementType.byteSize);\n    this.program.OBJECTInstance.writeField(\"rtId\", id, buf, 0); // use specified rtId\n    this.writeStaticBuffer(buf, program.totalOverhead, elementType, values);\n    return this.addRuntimeMemorySegment(buf);\n  }\n\n  /** Adds an array header to static memory and returns the created segment. */\n  private addStaticArrayHeader(\n    elementType: Type,\n    bufferSegment: MemorySegment,\n    /** Optional array instance override. */\n    arrayInstance: Class | null = null\n  ): MemorySegment {\n    let program = this.program;\n    if (!arrayInstance) {\n      arrayInstance = assert(this.resolver.resolveClass(this.program.arrayPrototype, [ elementType ]));\n    }\n    let bufferLength = readI32(bufferSegment.buffer, program.OBJECTInstance.offsetof(\"rtSize\"));\n    let arrayLength = i32(bufferLength / elementType.byteSize);\n    let bufferAddress = i64_add(bufferSegment.offset, i64_new(program.totalOverhead));\n    let buf = arrayInstance.createBuffer();\n    assert(arrayInstance.writeField(\"buffer\", bufferAddress, buf));\n    assert(arrayInstance.writeField(\"dataStart\", bufferAddress, buf));\n    assert(arrayInstance.writeField(\"byteLength\", bufferLength, buf));\n    assert(arrayInstance.writeField(\"length_\", arrayLength, buf));\n    return this.addRuntimeMemorySegment(buf);\n  }\n\n  // === Table ====================================================================================\n\n  /** Ensures that a runtime counterpart of the specified function exists and returns its address. */\n  ensureRuntimeFunction(instance: Function): i64 {\n    assert(instance.is(CommonFlags.Compiled) && !instance.is(CommonFlags.Stub));\n    let program = this.program;\n    let memorySegment = instance.memorySegment;\n    if (!memorySegment) {\n\n      // Add to the function table\n      let functionTable = this.functionTable;\n      let tableBase = this.options.tableBase;\n      if (!tableBase) tableBase = 1; // leave first elem blank\n      let index = tableBase + functionTable.length;\n      functionTable.push(instance);\n\n      // Create runtime function\n      let rtInstance = assert(this.resolver.resolveClass(program.functionPrototype, [ instance.type ]));\n      let buf = rtInstance.createBuffer();\n      assert(rtInstance.writeField(\"_index\", index, buf));\n      assert(rtInstance.writeField(\"_env\", 0, buf));\n      instance.memorySegment = memorySegment = this.addRuntimeMemorySegment(buf);\n    }\n    return i64_add(memorySegment.offset, i64_new(program.totalOverhead));\n  }\n\n  // === Statements ===============================================================================\n\n  /** Compiles a top level statement (incl. function declarations etc.) to the specified body. */\n  compileTopLevelStatement(statement: Statement, body: ExpressionRef[]): void {\n    switch (statement.kind) {\n      case NodeKind.ClassDeclaration: {\n        let memberStatements = (<ClassDeclaration>statement).members;\n        for (let i = 0, k = memberStatements.length; i < k; ++i) {\n          this.compileTopLevelStatement(memberStatements[i], body);\n        }\n        break;\n      }\n      case NodeKind.EnumDeclaration: {\n        let element = this.program.getElementByDeclaration(<EnumDeclaration>statement);\n        if (element) {\n          assert(element.kind == ElementKind.Enum);\n          if (!element.hasDecorator(DecoratorFlags.Lazy)) this.compileEnum(<Enum>element);\n        }\n        break;\n      }\n      case NodeKind.NamespaceDeclaration: {\n        let declaration = <NamespaceDeclaration>statement;\n        let element = this.program.getElementByDeclaration(declaration);\n        if (element) {\n          // any potential merged element\n          let previousParent = this.currentParent;\n          this.currentParent = element;\n          let memberStatements = declaration.members;\n          for (let i = 0, k = memberStatements.length; i < k; ++i) {\n            this.compileTopLevelStatement(memberStatements[i], body);\n          }\n          this.currentParent = previousParent;\n        }\n        break;\n      }\n      case NodeKind.Variable: {\n        let declarations = (<VariableStatement>statement).declarations;\n        for (let i = 0, k = declarations.length; i < k; ++i) {\n          let element = this.program.getElementByDeclaration(declarations[i]);\n          if (element) {\n            assert(element.kind == ElementKind.Global);\n            if (\n              !element.is(CommonFlags.Ambient) && // delay imports\n              !element.hasDecorator(DecoratorFlags.Lazy)\n            ) this.compileGlobal(<Global>element);\n          }\n        }\n        break;\n      }\n      case NodeKind.FieldDeclaration: {\n        let element = this.program.getElementByDeclaration(<FieldDeclaration>statement);\n        if (element && element.kind == ElementKind.Global) { // static\n          if (!element.hasDecorator(DecoratorFlags.Lazy)) this.compileGlobal(<Global>element);\n        }\n        break;\n      }\n      case NodeKind.Export: {\n        let exportStatement = <ExportStatement>statement;\n        let internalPath = exportStatement.internalPath;\n        if (internalPath != null) {\n          this.compileFileByPath(internalPath, assert(exportStatement.path));\n        }\n        break;\n      }\n      case NodeKind.ExportDefault: {\n        this.compileTopLevelStatement((<ExportDefaultStatement>statement).declaration, body);\n        break;\n      }\n      case NodeKind.Import: {\n        let importStatement = <ImportStatement>statement;\n        this.compileFileByPath(importStatement.internalPath, importStatement.path);\n        break;\n      }\n      case NodeKind.FunctionDeclaration:\n      case NodeKind.MethodDeclaration:\n      case NodeKind.InterfaceDeclaration:\n      case NodeKind.IndexSignature:\n      case NodeKind.TypeDeclaration: break;\n      default: { // otherwise a top-level statement that is part of the start function's body\n        let stmt = this.compileStatement(statement);\n        if (getExpressionId(stmt) != ExpressionId.Nop) body.push(stmt);\n        break;\n      }\n    }\n  }\n\n  /** Compiles a statement. */\n  compileStatement(\n    /** Statement to compile. */\n    statement: Statement\n  ): ExpressionRef {\n    let module = this.module;\n    let stmt: ExpressionRef;\n    switch (statement.kind) {\n      case NodeKind.Block: {\n        stmt = this.compileBlockStatement(<BlockStatement>statement);\n        break;\n      }\n      case NodeKind.Break: {\n        stmt = this.compileBreakStatement(<BreakStatement>statement);\n        break;\n      }\n      case NodeKind.Continue: {\n        stmt = this.compileContinueStatement(<ContinueStatement>statement);\n        break;\n      }\n      case NodeKind.Do: {\n        stmt = this.compileDoStatement(<DoStatement>statement);\n        break;\n      }\n      case NodeKind.Empty: {\n        stmt = this.compileEmptyStatement(<EmptyStatement>statement);\n        break;\n      }\n      case NodeKind.Expression: {\n        stmt = this.compileExpressionStatement(<ExpressionStatement>statement);\n        break;\n      }\n      case NodeKind.For: {\n        stmt = this.compileForStatement(<ForStatement>statement);\n        break;\n      }\n      case NodeKind.ForOf: {\n        stmt = this.compileForOfStatement(<ForOfStatement>statement);\n        break;\n      }\n      case NodeKind.If: {\n        stmt = this.compileIfStatement(<IfStatement>statement);\n        break;\n      }\n      case NodeKind.Return: {\n        stmt = this.compileReturnStatement(<ReturnStatement>statement);\n        break;\n      }\n      case NodeKind.Switch: {\n        stmt = this.compileSwitchStatement(<SwitchStatement>statement);\n        break;\n      }\n      case NodeKind.Throw: {\n        stmt = this.compileThrowStatement(<ThrowStatement>statement);\n        break;\n      }\n      case NodeKind.Try: {\n        stmt = this.compileTryStatement(<TryStatement>statement);\n        break;\n      }\n      case NodeKind.Variable: {\n        stmt = this.compileVariableStatement(<VariableStatement>statement);\n        if (!stmt) stmt = module.nop();\n        break;\n      }\n      case NodeKind.Void: {\n        stmt = this.compileVoidStatement(<VoidStatement>statement);\n        break;\n      }\n      case NodeKind.While: {\n        stmt = this.compileWhileStatement(<WhileStatement>statement);\n        break;\n      }\n      case NodeKind.TypeDeclaration: {\n        stmt = this.compileTypeDeclaration(<TypeDeclaration>statement);\n        break;\n      }\n      case NodeKind.Module: {\n        stmt = module.nop();\n        break;\n      }\n      default: {\n        assert(false);\n        stmt = module.unreachable();\n      }\n    }\n    if (this.options.sourceMap) this.addDebugLocation(stmt, statement.range);\n    return stmt;\n  }\n\n  /** Compiles a series of statements. */\n  compileStatements(\n    /** Statements to compile. */\n    statements: Statement[],\n    /** Statements to append to. Also returned, created if omitted. */\n    stmts: ExpressionRef[] | null = null\n  ): ExpressionRef[] {\n    let numStatements = statements.length;\n    if (!stmts) {\n      stmts = new Array<ExpressionRef>(numStatements);\n      stmts.length = 0;\n    }\n    let flow = this.currentFlow;\n    for (let i = 0; i < numStatements; ++i) {\n      let stmt = this.compileStatement(statements[i]);\n      switch (getExpressionId(stmt)) {\n        case ExpressionId.Block: {\n          if (!getBlockName(stmt)) {\n            for (let j: Index = 0, k = getBlockChildCount(stmt); j < k; ++j) stmts.push(getBlockChildAt(stmt, j));\n            break;\n          }\n          // fall-through\n        }\n        default: stmts.push(stmt);\n        case ExpressionId.Nop:\n      }\n      if (flow.isAny(FlowFlags.Terminates | FlowFlags.Breaks)) break;\n    }\n    return stmts;\n  }\n\n  private compileBlockStatement(\n    statement: BlockStatement\n  ): ExpressionRef {\n    let statements = statement.statements;\n    let outerFlow = this.currentFlow;\n    let innerFlow = outerFlow.fork();\n    this.currentFlow = innerFlow;\n\n    let stmts = this.compileStatements(statements);\n    outerFlow.inherit(innerFlow);\n    this.currentFlow = outerFlow;\n    return this.module.flatten(stmts);\n  }\n\n  private compileTypeDeclaration(statement: TypeDeclaration): ExpressionRef {\n    let flow = this.currentFlow;\n    let name = statement.name.text;\n    let existedTypeAlias = flow.lookupScopedTypeAlias(name);\n    if (existedTypeAlias) {\n      this.errorRelated(\n        DiagnosticCode.Duplicate_identifier_0,\n        statement.range,\n        existedTypeAlias.declaration.range,\n        name\n      );\n      return this.module.unreachable();\n    }\n    let element = new TypeDefinition(name, flow.sourceFunction, statement, DecoratorFlags.None);\n    flow.addScopedTypeAlias(name, element);\n    return this.module.nop();\n  }\n\n  private compileBreakStatement(\n    statement: BreakStatement\n  ): ExpressionRef {\n    let module = this.module;\n    let labelNode = statement.label;\n    if (labelNode) {\n      this.error(\n        DiagnosticCode.Not_implemented_0,\n        labelNode.range,\n        \"Break label\"\n      );\n      return module.unreachable();\n    }\n    let flow = this.currentFlow;\n    let breakLabel = flow.breakLabel;\n    if (breakLabel == null) {\n      this.error(\n        DiagnosticCode.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement,\n        statement.range\n      );\n      return module.unreachable();\n    }\n    flow.set(FlowFlags.Breaks);\n    return module.br(breakLabel);\n  }\n\n  private compileContinueStatement(\n    statement: ContinueStatement\n  ): ExpressionRef {\n    let module = this.module;\n    let label = statement.label;\n    if (label) {\n      this.error(\n        DiagnosticCode.Not_implemented_0,\n        label.range,\n        \"Continue label\"\n      );\n      return module.unreachable();\n    }\n    // Check if 'continue' is allowed here\n    let flow = this.currentFlow;\n    let continueLabel = flow.continueLabel;\n    if (continueLabel == null) {\n      this.error(\n        DiagnosticCode.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement,\n        statement.range\n      );\n      return module.unreachable();\n    }\n    flow.set(FlowFlags.Continues | FlowFlags.Terminates);\n    return module.br(continueLabel);\n  }\n\n  private compileDoStatement(\n    /** Statement to compile. */\n    statement: DoStatement\n  ): ExpressionRef {\n    return this.doCompileDoStatement(statement);\n  }\n\n  private doCompileDoStatement(\n    /** Statement to compile. */\n    statement: DoStatement\n  ): ExpressionRef {\n    let module = this.module;\n    let outerFlow = this.currentFlow;\n    let numLocalsBefore = outerFlow.targetFunction.localsByIndex.length;\n\n    // (block $break\n    //  (loop $loop\n    //   (?block $continue\n    //    (body)\n    //   )\n    //   (br_if $loop (condition))\n    //  )\n    // )\n\n    // Cases of interest:\n    // * If the body never falls through or continues, the condition never executes\n    // * If the condition is always true and body never breaks, overall flow terminates\n    // * If the body terminates with a continue, condition is still reached\n\n    // Compile the body (always executes)\n    let flow = outerFlow.fork(/* resetBreakContext */ true);\n    let label = flow.pushControlFlowLabel();\n    let breakLabel = `do-break|${label}`;\n    flow.breakLabel = breakLabel;\n    let continueLabel = `do-continue|${label}`;\n    flow.continueLabel = continueLabel;\n    let loopLabel = `do-loop|${label}`;\n    this.currentFlow = flow;\n    let bodyStmts = new Array<ExpressionRef>();\n    let body = statement.body;\n    if (body.kind == NodeKind.Block) {\n      this.compileStatements((<BlockStatement>body).statements, bodyStmts);\n    } else {\n      bodyStmts.push(this.compileStatement(body));\n    }\n    flow.popControlFlowLabel(label);\n\n    let possiblyContinues = flow.isAny(FlowFlags.Continues | FlowFlags.ConditionallyContinues);\n    let possiblyBreaks = flow.isAny(FlowFlags.Breaks | FlowFlags.ConditionallyBreaks);\n    let possiblyFallsThrough = !flow.isAny(FlowFlags.Terminates | FlowFlags.Breaks);\n\n    // Shortcut if the condition is never reached\n    if (!possiblyFallsThrough && !possiblyContinues) {\n      bodyStmts.push(\n        module.unreachable()\n      );\n      outerFlow.inherit(flow);\n\n      // If the body also never breaks, the overall flow terminates\n      if (!possiblyBreaks) {\n        outerFlow.set(FlowFlags.Terminates);\n      }\n\n    // Otherwise compile and evaluate the condition (from here on always executes)\n    } else {\n      let condExpr = this.compileExpression(statement.condition, Type.bool);\n      let condExprTrueish = this.makeIsTrueish(condExpr, this.currentType, statement.condition);\n      let condKind = this.evaluateCondition(condExprTrueish);\n\n      // Detect if local flags are incompatible before and after looping, and\n      // if so recompile by unifying local flags between iterations. Note that\n      // this may be necessary multiple times where locals depend on each other.\n      let possiblyLoops = condKind != ConditionKind.False && (possiblyContinues || possiblyFallsThrough);\n      if (possiblyLoops && outerFlow.resetIfNeedsRecompile(flow.forkThen(condExpr), numLocalsBefore)) {\n        this.currentFlow = outerFlow;\n        return this.doCompileDoStatement(statement);\n      }\n\n      if (possiblyContinues) {\n        bodyStmts[0] = module.block(continueLabel, bodyStmts);\n        bodyStmts.length = 1;\n        flow.unset(FlowFlags.Terminates); // Continue breaks to condition\n      }\n      bodyStmts.push(\n        module.br(loopLabel,\n          condExprTrueish\n        )\n      );\n      outerFlow.inherit(flow);\n\n      // Terminate if the condition is always true and body never breaks\n      if (condKind == ConditionKind.True && !possiblyBreaks) {\n        outerFlow.set(FlowFlags.Terminates);\n      }\n    }\n\n    // Finalize and leave everything else to the optimizer\n    this.currentFlow = outerFlow;\n    let expr = module.loop(loopLabel,\n      module.flatten(bodyStmts)\n    );\n    if (possiblyBreaks) {\n      expr = module.block(breakLabel, [\n        expr\n      ]);\n    }\n    if (outerFlow.is(FlowFlags.Terminates)) {\n      expr = module.block(null, [ expr, module.unreachable() ]);\n    }\n    return expr;\n  }\n\n  private compileEmptyStatement(\n    statement: EmptyStatement\n  ): ExpressionRef {\n    return this.module.nop();\n  }\n\n  private compileExpressionStatement(\n    statement: ExpressionStatement\n  ): ExpressionRef {\n    return this.compileExpression(statement.expression, Type.void, Constraints.ConvImplicit);\n  }\n\n  private compileForStatement(\n    /** Statement to compile. */\n    statement: ForStatement\n  ): ExpressionRef {\n    return this.doCompileForStatement(statement);\n  }\n\n  private doCompileForStatement(\n    /** Statement to compile. */\n    statement: ForStatement\n  ): ExpressionRef {\n    let module = this.module;\n    let outerFlow = this.currentFlow;\n    let numLocalsBefore = outerFlow.targetFunction.localsByIndex.length;\n\n    // (initializer)          \u2514\u25BA\u2510 flow\n    // (?block $break           \u2502 (initializer)\n    //  (?loop $loop          \u250C\u25C4\u2524 (condition) shortcut if false \u25C4\u2510\n    //   (if (condition)        \u251C\u25BA\u2510 bodyFlow                     \u2502\n    //    (then                 \u2502 \u2502 (body)                       \u2502\n    //     (?block $continue    \u2502 \u2502 if loops: (incrementor) \u2500\u2500\u2500\u2500\u2500\u2518\n    //      (body)              \u2502 \u2502           recompile body?\n    //     )                    \u251C\u25C4\u2518    \n    //     (incrementor)      \u250C\u25C4\u2518\n    //     (br $loop)\n    //    )\n    //   )\n    //  )\n    // )\n\n    // Compile initializer if present. The initializer might introduce scoped\n    // locals bound to the for statement, so create a new flow early.\n    let flow = outerFlow.fork();\n    this.currentFlow = flow;\n    let stmts = new Array<ExpressionRef>();\n    let initializer = statement.initializer;\n    if (initializer) {\n      assert(\n        initializer.kind == NodeKind.Expression ||\n        initializer.kind == NodeKind.Variable\n      );\n      stmts.push(this.compileStatement(initializer));\n    }\n\n    // Precompute the condition if present, or default to `true`\n    let condExpr: ExpressionRef;\n    let condExprTrueish: ExpressionRef;\n    let condKind: ConditionKind;\n    let condition = statement.condition;\n    if (condition) {\n      condExpr = this.compileExpression(condition, Type.bool);\n      condExprTrueish = this.makeIsTrueish(condExpr, this.currentType, condition);\n      condKind = this.evaluateCondition(condExprTrueish);\n\n      // Shortcut if condition is always false (body never executes)\n      if (condKind == ConditionKind.False) {\n        stmts.push(\n          module.drop(condExprTrueish)\n        );\n        outerFlow.inherit(flow);\n        this.currentFlow = outerFlow;\n        return module.flatten(stmts);\n      }\n    } else {\n      condExpr = module.i32(1);\n      condExprTrueish = condExpr;\n      condKind = ConditionKind.True;\n    }\n    // From here on condition is either true or unknown\n\n    // Compile the body assuming the condition turned out true\n    let bodyFlow = flow.forkThen(condExpr, /* newBreakContext */ true);\n    let label = bodyFlow.pushControlFlowLabel();\n    let breakLabel = `for-break${label}`;\n    bodyFlow.breakLabel = breakLabel;\n    let continueLabel = `for-continue|${label}`;\n    bodyFlow.continueLabel = continueLabel;\n    let loopLabel = `for-loop|${label}`;\n    this.currentFlow = bodyFlow;\n    let bodyStmts = new Array<ExpressionRef>();\n    let body = statement.body;\n    if (body.kind == NodeKind.Block) {\n      this.compileStatements((<BlockStatement>body).statements, bodyStmts);\n    } else {\n      bodyStmts.push(this.compileStatement(body));\n    }\n    bodyFlow.popControlFlowLabel(label);\n    bodyFlow.breakLabel = null;\n    bodyFlow.continueLabel = null;\n\n    let possiblyFallsThrough = !bodyFlow.isAny(FlowFlags.Terminates | FlowFlags.Breaks);\n    let possiblyContinues = bodyFlow.isAny(FlowFlags.Continues | FlowFlags.ConditionallyContinues);\n    let possiblyBreaks = bodyFlow.isAny(FlowFlags.Breaks | FlowFlags.ConditionallyBreaks);\n\n    if (possiblyContinues) {\n      bodyStmts[0] = module.block(continueLabel, bodyStmts);\n      bodyStmts.length = 1;\n    }\n\n    if (condKind == ConditionKind.True) {\n      // Body executes at least once\n      flow.inherit(bodyFlow);\n    } else {\n      // Otherwise executes conditionally\n      flow.mergeBranch(bodyFlow);\n    }\n\n    // Compile the incrementor if it possibly executes\n    let possiblyLoops = possiblyContinues || possiblyFallsThrough;\n    if (possiblyLoops) {\n      let incrementor = statement.incrementor;\n      if (incrementor) {\n        this.currentFlow = flow;\n        bodyStmts.push(\n          this.compileExpression(incrementor, Type.void, Constraints.ConvImplicit | Constraints.WillDrop)\n        );\n      }\n      bodyStmts.push(\n        module.br(loopLabel)\n      );\n\n      // Detect if local flags are incompatible before and after looping, and if\n      // so recompile by unifying local flags between iterations. Note that this\n      // may be necessary multiple times where locals depend on each other.\n      if (outerFlow.resetIfNeedsRecompile(bodyFlow.forkThen(condExpr), numLocalsBefore)) {\n        this.currentFlow = outerFlow;\n        return this.doCompileForStatement(statement);\n      }\n    }\n\n\n    // Finalize\n    outerFlow.inherit(flow);\n    this.currentFlow = outerFlow;\n    let expr = module.if(condExprTrueish,\n      module.flatten(bodyStmts)\n    );\n    if (possiblyLoops) {\n      expr = module.loop(loopLabel, expr);\n    }\n    if (possiblyBreaks) {\n      expr = module.block(breakLabel, [ expr ]);\n    }\n    stmts.push(expr);\n    if (outerFlow.is(FlowFlags.Terminates)) {\n      stmts.push(module.unreachable());\n    }\n    return module.flatten(stmts);\n  }\n\n  private compileForOfStatement(\n    statement: ForOfStatement\n  ): ExpressionRef {\n    this.error(\n      DiagnosticCode.Not_implemented_0,\n      statement.range,\n      \"Iterators\"\n    );\n    return this.module.unreachable();\n  }\n\n  private compileIfStatement(\n    statement: IfStatement\n  ): ExpressionRef {\n    let module = this.module;\n    let ifTrue = statement.ifTrue;\n    let ifFalse = statement.ifFalse;\n\n    // (if (condition)\n    //  (then (ifTrue))\n    //  (?else (ifFalse))\n    // )\n\n    // Cases of interest:\n    // * If the condition is always true or false, the other branch is eliminated\n    // * If both then and else terminate, the overall flow does as well\n    // * Without an else, when then terminates, follow-up flow acts like an else\n\n    // Precompute the condition (always executes)\n    let condExpr = this.compileExpression(statement.condition, Type.bool);\n    let condExprTrueish = this.makeIsTrueish(\n      condExpr,\n      this.currentType,\n      statement.condition\n    );\n    let condKind = this.evaluateCondition(condExprTrueish);\n\n    // Shortcut if the condition is constant\n    switch (condKind) {\n      case ConditionKind.True: {\n        return module.block(null, [\n          module.drop(condExprTrueish),\n          this.compileStatement(ifTrue)\n        ]);\n      }\n      case ConditionKind.False: {\n        return ifFalse\n          ? module.block(null, [\n              module.drop(condExprTrueish),\n              this.compileStatement(ifFalse)\n            ])\n          : module.drop(condExprTrueish);\n      }\n    }\n\n    // From here on condition is always unknown\n\n    let flow = this.currentFlow;\n\n    // Compile ifTrue assuming the condition turned out true\n    let thenStmts = new Array<ExpressionRef>();\n    let thenFlow = flow.forkThen(condExpr);\n    this.currentFlow = thenFlow;\n    if (ifTrue.kind == NodeKind.Block) {\n      this.compileStatements((<BlockStatement>ifTrue).statements, thenStmts);\n    } else {\n      thenStmts.push(this.compileStatement(ifTrue));\n    }\n    this.currentFlow = flow;\n\n    // Compile ifFalse assuming the condition turned out false, if present\n    let elseFlow = flow.forkElse(condExpr);\n    if (ifFalse) {\n      this.currentFlow = elseFlow;\n      let elseStmts = new Array<ExpressionRef>();\n      if (ifFalse.kind == NodeKind.Block) {\n        this.compileStatements((<BlockStatement>ifFalse).statements, elseStmts);\n      } else {\n        elseStmts.push(this.compileStatement(ifFalse));\n      }\n      flow.inheritAlternatives(thenFlow, elseFlow); // terminates if both do\n      this.currentFlow = flow;\n      return module.if(condExprTrueish,\n        module.flatten(thenStmts),\n        module.flatten(elseStmts)\n      );\n    } else {\n      if (thenFlow.isAny(FlowFlags.Terminates | FlowFlags.Breaks)) {\n        // Only getting past if condition was false (acts like else)\n        flow.inherit(elseFlow);\n        flow.mergeSideEffects(thenFlow);\n      } else {\n        // Otherwise getting past conditionally\n        flow.inheritAlternatives(thenFlow, elseFlow);\n      }\n      this.currentFlow = flow;\n      return module.if(condExprTrueish,\n        module.flatten(thenStmts)\n      );\n    }\n  }\n\n  private compileReturnStatement(\n    statement: ReturnStatement\n  ): ExpressionRef {\n    let module = this.module;\n    let expr: ExpressionRef = 0;\n    let flow = this.currentFlow;\n    let returnType = flow.returnType;\n\n    let valueExpression = statement.value;\n    if (valueExpression) {\n      let constraints = Constraints.ConvImplicit;\n      if (flow.sourceFunction.is(CommonFlags.ModuleExport)) constraints |= Constraints.MustWrap;\n\n      expr = this.compileExpression(valueExpression, returnType, constraints);\n      if (!flow.canOverflow(expr, returnType)) flow.set(FlowFlags.ReturnsWrapped);\n      if (flow.isNonnull(expr, returnType)) flow.set(FlowFlags.ReturnsNonNull);\n      if (flow.sourceFunction.is(CommonFlags.Constructor) && valueExpression.kind != NodeKind.This) {\n        flow.set(FlowFlags.MayReturnNonThis);\n      }\n    } else if (returnType != Type.void) {\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        statement.range, \"void\", returnType.toString()\n      );\n      this.currentType = returnType;\n      return module.unreachable();\n    }\n\n    // Remember that this flow returns\n    flow.set(FlowFlags.Returns | FlowFlags.Terminates);\n\n    // Handle inline return\n    if (flow.isInline) {\n      let inlineReturnLabel = assert(flow.inlineReturnLabel);\n      return expr\n        ? this.currentType == Type.void\n          ? module.block(null, [ expr, module.br(inlineReturnLabel) ])\n          : module.br(inlineReturnLabel, 0, expr)\n        : module.br(inlineReturnLabel);\n    }\n\n    // Otherwise emit a normal return\n    return expr\n      ? this.currentType == Type.void\n        ? module.block(null, [ expr, module.return() ])\n        : module.return(expr)\n      : module.return();\n  }\n\n  private compileSwitchStatement(\n    statement: SwitchStatement\n  ): ExpressionRef {\n    let module = this.module;\n    let cases = statement.cases;\n    let numCases = cases.length;\n\n    // Compile the condition (always executes)\n    let condExpr = this.compileExpression(statement.condition, Type.auto);\n    let condType = this.currentType;\n    \n    // Shortcut if there are no cases\n    if (!numCases) return module.drop(condExpr);\n    \n    // Assign the condition to a temporary local as we compare it multiple times\n    let outerFlow = this.currentFlow;\n    let tempLocal = outerFlow.getTempLocal(condType);\n    let tempLocalIndex = tempLocal.index;\n    let breaks = new Array<ExpressionRef>(1 + numCases);\n    breaks[0] = module.local_set(tempLocalIndex, condExpr, condType.isManaged);\n    \n    // Make one br_if per labeled case and leave it to Binaryen to optimize the\n    // sequence of br_ifs to a br_table according to optimization levels\n    let breakIndex = 1;\n    let defaultIndex = -1;\n    let label = outerFlow.pushControlFlowLabel();\n    for (let i = 0; i < numCases; ++i) {\n      let case_ = cases[i];\n      if (case_.isDefault) {\n        defaultIndex = i;\n        continue;\n      }\n      \n      // Compile the equality expression for this case\n      const left = statement.condition;\n      const leftExpr = module.local_get(tempLocalIndex, condType.toRef());\n      const leftType = condType;\n      const right = case_.label!;\n      const rightExpr = this.compileExpression(assert(case_.label), condType, Constraints.ConvImplicit);\n      const rightType = this.currentType;\n      const equalityExpr = this.compileCommutativeCompareBinaryExpressionFromParts(\n        Token.Equals_Equals,\n        left, leftExpr, leftType,\n        right, rightExpr, rightType,\n        condType,\n        statement\n      );\n      \n      // Add it to the list of breaks\n      breaks[breakIndex++] = module.br(`case${i}|${label}`, equalityExpr);\n    }\n\n    // If there is a default case, break to it, otherwise break out of the switch\n    breaks[breakIndex] = module.br(defaultIndex >= 0\n      ? `case${defaultIndex}|${label}`\n      : `break|${label}`\n    );\n\n    // Nest the case blocks in order, to be targeted by the br_if sequence\n    let currentBlock = module.block(`case0|${label}`, breaks, TypeRef.None);\n    let fallThroughFlow: Flow | null = null;\n    let breakingFlowAlternatives: Flow | null = null;\n    for (let i = 0; i < numCases; ++i) {\n      let case_ = cases[i];\n      let statements = case_.statements;\n      let numStatements = statements.length;\n\n      // Can get here by matching the case or possibly by fall-through\n      let innerFlow = outerFlow.fork(/* newBreakContext */ true, /* newContinueContext */ false);\n      if (fallThroughFlow) innerFlow.mergeBranch(fallThroughFlow);\n      this.currentFlow = innerFlow;\n      let breakLabel = `break|${label}`;\n      innerFlow.breakLabel = breakLabel;\n\n      let isLast = i == numCases - 1;\n      let nextLabel = isLast ? breakLabel : `case${i + 1}|${label}`;\n      let stmts = new Array<ExpressionRef>(1 + numStatements);\n      stmts[0] = currentBlock;\n      let count = 1;\n      let possiblyFallsThrough = true;\n      for (let j = 0; j < numStatements; ++j) {\n        let stmt = this.compileStatement(statements[j]);\n        if (getExpressionId(stmt) != ExpressionId.Nop) {\n          stmts[count++] = stmt;\n        }\n        if (innerFlow.isAny(FlowFlags.Terminates | FlowFlags.Breaks)) {\n          possiblyFallsThrough = false;\n          break;\n        }\n      }\n      stmts.length = count;\n      fallThroughFlow = possiblyFallsThrough ? innerFlow : null;\n      let possiblyBreaks = innerFlow.isAny(FlowFlags.Breaks | FlowFlags.ConditionallyBreaks);\n      innerFlow.unset(FlowFlags.Breaks | FlowFlags.ConditionallyBreaks); // clear\n\n      // Combine all alternatives that merge again with outer flow\n      if (possiblyBreaks || (isLast && possiblyFallsThrough)) {\n        if (breakingFlowAlternatives) breakingFlowAlternatives.inheritAlternatives(breakingFlowAlternatives, innerFlow);\n        else breakingFlowAlternatives = innerFlow;\n\n      // Otherwise just merge the effects of a non-merging branch\n      } else if (!possiblyFallsThrough) {\n        outerFlow.mergeSideEffects(innerFlow);\n      }\n\n      this.currentFlow = outerFlow;\n      currentBlock = module.block(nextLabel, stmts, TypeRef.None); // must be a labeled block\n    }\n    outerFlow.popControlFlowLabel(label);\n\n    // If the switch has a default, we only get past through any breaking flow\n    if (defaultIndex >= 0) {\n      if (breakingFlowAlternatives) outerFlow.inherit(breakingFlowAlternatives);\n      else outerFlow.set(FlowFlags.Terminates);\n\n    // Otherwise either none or any breaking flow can get past conditionally\n    } else if (breakingFlowAlternatives) {\n      outerFlow.mergeBranch(breakingFlowAlternatives);\n    }\n\n    this.currentFlow = outerFlow;\n    return currentBlock;\n  }\n\n  private compileThrowStatement(\n    statement: ThrowStatement\n  ): ExpressionRef {\n    // TODO: requires exception-handling spec.\n    let flow = this.currentFlow;\n\n    // Remember that this branch throws\n    flow.set(FlowFlags.Throws | FlowFlags.Terminates);\n\n    let stmts = new Array<ExpressionRef>();\n    let value = statement.value;\n    let message: Expression | null = null;\n    if (value.kind == NodeKind.New) {\n      let newArgs = (<NewExpression>value).args;\n      if (newArgs.length) message = newArgs[0]; // FIXME: naively assumes type string\n    }\n    stmts.push(\n      this.makeAbort(message, statement)\n    );\n    return this.module.flatten(stmts);\n  }\n\n  private compileTryStatement(\n    statement: TryStatement\n  ): ExpressionRef {\n    // TODO: can't yet support something like: try { return ... } finally { ... }\n    // worthwhile to investigate lowering returns to block results (here)?\n    this.error(\n      DiagnosticCode.Not_implemented_0,\n      statement.range,\n      \"Exceptions\"\n    );\n    return this.module.unreachable();\n  }\n\n  /** Compiles a variable statement. Returns `0` if an initializer is not necessary. */\n  private compileVariableStatement(\n    statement: VariableStatement\n  ): ExpressionRef {\n    let module = this.module;\n    let declarations = statement.declarations;\n    let numDeclarations = declarations.length;\n    let flow = this.currentFlow;\n    let initializers = new Array<ExpressionRef>();\n    let resolver = this.resolver;\n\n    for (let i = 0; i < numDeclarations; ++i) {\n      let declaration = declarations[i];\n      let name = declaration.name.text;\n      let type: Type | null = null;\n      let initExpr: ExpressionRef = 0;\n      let initType: Type | null = null;\n\n      if (declaration.is(CommonFlags.DefinitelyAssigned)) {\n        this.warning(\n          DiagnosticCode.Definitive_assignment_has_no_effect_on_local_variables,\n          declaration.name.range\n        );\n      }\n\n      // Resolve type if annotated\n      let typeNode = declaration.type;\n      let initializerNode = declaration.initializer;\n      if (typeNode) {\n        type = resolver.resolveType( // reports\n          typeNode, flow,\n          flow.sourceFunction,\n          cloneMap(flow.contextualTypeArguments)\n        );\n        if (!type) continue;\n        this.program.checkTypeSupported(type, typeNode);\n\n        if (initializerNode) {\n          let pendingElements = this.pendingElements;\n          let dummy = flow.addScopedDummyLocal(name, type, statement); // pending dummy\n          pendingElements.add(dummy);\n          initExpr = this.compileExpression(initializerNode, type, // reports\n            Constraints.ConvImplicit\n          );\n          initType = this.currentType;\n          pendingElements.delete(dummy);\n          flow.freeScopedDummyLocal(name);\n        }\n\n      // Otherwise infer type from initializer\n      } else if (initializerNode) {\n        let pendingElements = this.pendingElements;\n        let temp = flow.addScopedDummyLocal(name, Type.auto, statement); // pending dummy\n        pendingElements.add(temp);\n        initExpr = this.compileExpression(initializerNode, Type.auto); // reports\n        initType = this.currentType;\n        pendingElements.delete(temp);\n        flow.freeScopedDummyLocal(name);\n\n        if (this.currentType == Type.void) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            declaration.range, this.currentType.toString(), \"<auto>\"\n          );\n          continue;\n        }\n        type = initType;\n\n      // Error if there's neither a type nor an initializer\n      } else {\n        this.error(\n          DiagnosticCode.Type_expected,\n          declaration.name.range.atEnd\n        );\n        continue;\n      }\n\n      // Handle constants, and try to inline if value is static\n      let isConst = declaration.is(CommonFlags.Const);\n      let isStatic = false;\n      if (isConst) {\n        if (initExpr) {\n          let precomp = module.runExpression(initExpr, ExpressionRunnerFlags.PreserveSideeffects);\n          if (precomp) {\n            initExpr = precomp; // always use precomputed initExpr\n            let local: Local | null = null;\n            switch (<u32>getExpressionType(initExpr)) {\n              case <u32>TypeRef.I32: {\n                local = new Local(name, -1, type, flow.targetFunction);\n                local.setConstantIntegerValue(\n                  i64_new(\n                    getConstValueI32(initExpr),\n                    0\n                  ),\n                  type\n                );\n                break;\n              }\n              case <u32>TypeRef.I64: {\n                local = new Local(name, -1, type, flow.targetFunction);\n                local.setConstantIntegerValue(\n                  i64_new(\n                    getConstValueI64Low(initExpr),\n                    getConstValueI64High(initExpr)\n                  ),\n                  type\n                );\n                break;\n              }\n              case <u32>TypeRef.F32: {\n                local = new Local(name, -1, type, flow.targetFunction);\n                local.setConstantFloatValue(<f64>getConstValueF32(initExpr), type);\n                break;\n              }\n              case <u32>TypeRef.F64: {\n                local = new Local(name, -1, type, flow.targetFunction);\n                local.setConstantFloatValue(getConstValueF64(initExpr), type);\n                break;\n              }\n            }\n            if (local) {\n              // Add as a dummy local that doesn't actually exist in WebAssembly\n              let scopedLocals = flow.scopedLocals;\n              if (!scopedLocals) flow.scopedLocals = scopedLocals = new Map();\n              else if (scopedLocals.has(name)) {\n                let existing = assert(scopedLocals.get(name));\n                this.errorRelated(\n                  DiagnosticCode.Duplicate_identifier_0,\n                  declaration.name.range,\n                  existing.declaration.name.range,\n                  name\n                );\n                return this.module.unreachable();\n              }\n              scopedLocals.set(name, local);\n              isStatic = true;\n            }\n          }\n        } else {\n          this.error(\n            DiagnosticCode._const_declarations_must_be_initialized,\n            declaration.range\n          );\n        }\n      }\n\n      // Otherwise compile as mutable\n      if (!isStatic) {\n        let local: Local;\n        if (\n          declaration.isAny(CommonFlags.Let | CommonFlags.Const) ||\n          flow.isInline\n        ) { // here: not top-level\n          let existingLocal = flow.getScopedLocal(name);\n          if (existingLocal) {\n            if (!existingLocal.declaration.range.source.isNative) {\n              this.errorRelated(\n                DiagnosticCode.Duplicate_identifier_0,\n                declaration.name.range,\n                existingLocal.declaration.name.range,\n                name\n              );\n            } else { // scoped locals are shared temps that don't track declarations\n              this.error(\n                DiagnosticCode.Duplicate_identifier_0,\n                declaration.name.range, name\n              );\n            }\n            local = existingLocal;\n          } else {\n            local = flow.addScopedLocal(name, type);\n          }\n          if (isConst) flow.setLocalFlag(local.index, LocalFlags.Constant);\n        } else {\n          let existing = flow.lookupLocal(name);\n          if (existing) {\n            this.errorRelated(\n              DiagnosticCode.Duplicate_identifier_0,\n              declaration.name.range,\n              existing.declaration.name.range,\n              name\n            );\n            continue;\n          }\n          local = flow.targetFunction.addLocal(type, name, declaration);\n          flow.unsetLocalFlag(local.index, ~0);\n          if (isConst) flow.setLocalFlag(local.index, LocalFlags.Constant);\n        }\n        if (initExpr) {\n          initializers.push(\n            this.makeLocalAssignment(local, initExpr, initType ? initType : type, false)\n          );\n        } else {\n          // no need to assign zero\n          if (local.type.isShortIntegerValue) {\n            flow.setLocalFlag(local.index, LocalFlags.Wrapped);\n          }\n        }\n      }\n    }\n    this.currentType = Type.void;\n    return initializers.length == 0\n      ? 0\n      : module.flatten(initializers);\n  }\n\n  private compileVoidStatement(\n    statement: VoidStatement\n  ): ExpressionRef {\n    return this.compileExpression(statement.expression, Type.void,\n      Constraints.ConvExplicit | Constraints.WillDrop\n    );\n  }\n\n  private compileWhileStatement(\n    /** Statement to compile. */\n    statement: WhileStatement\n  ): ExpressionRef {\n    return this.doCompileWhileStatement(statement);\n  }\n\n  private doCompileWhileStatement(\n    /** Statement to compile. */\n    statement: WhileStatement\n  ): ExpressionRef {\n    let module = this.module;\n    let outerFlow = this.currentFlow;\n    let numLocalsBefore = outerFlow.targetFunction.localsByIndex.length;\n\n    // (block $break\n    //  (loop $continue\n    //   (if (condition)\n    //    (then\n    //     (body)\n    //     (br $continue)\n    //    )\n    //   )\n    //  )\n\n    // Cases of interest:\n    // * If the condition is always false, eliminate the body as it never runs\n    // * If the condition is always true and the body never breaks, terminate\n    // * If the body runs but always terminates, continue as if condition was false\n\n    // Compile and evaluate the condition (always executes)\n    let condExpr = this.compileExpression(statement.condition, Type.bool);\n    let condExprTrueish = this.makeIsTrueish(condExpr, this.currentType, statement.condition);\n    let condKind = this.evaluateCondition(condExprTrueish);\n\n    // Shortcut if condition is always false (body never runs)\n    if (condKind == ConditionKind.False) {\n      return module.drop(condExprTrueish);\n    }\n\n    // Compile the body assuming the condition turned out true\n    let thenFlow = outerFlow.forkThen(condExpr, /* newBreakContext */ true);\n    let label = thenFlow.pushControlFlowLabel();\n    let breakLabel = `while-break|${label}`;\n    thenFlow.breakLabel = breakLabel;\n    let continueLabel = `while-continue|${label}`;\n    thenFlow.continueLabel = continueLabel;\n    this.currentFlow = thenFlow;\n    let bodyStmts = new Array<ExpressionRef>();\n    let body = statement.body;\n    if (body.kind == NodeKind.Block) {\n      this.compileStatements((<BlockStatement>body).statements, bodyStmts);\n    } else {\n      bodyStmts.push(this.compileStatement(body));\n    }\n    bodyStmts.push(\n      module.br(continueLabel)\n    );\n    thenFlow.popControlFlowLabel(label);\n\n    let possiblyContinues = thenFlow.isAny(FlowFlags.Continues | FlowFlags.ConditionallyContinues);\n    let possiblyBreaks = thenFlow.isAny(FlowFlags.Breaks | FlowFlags.ConditionallyBreaks);\n    let possiblyFallsThrough = !thenFlow.isAny(FlowFlags.Terminates | FlowFlags.Breaks);\n\n    // Detect if local flags are incompatible before and after looping, and\n    // if so recompile by unifying local flags between iterations. Note that\n    // this may be necessary multiple times where locals depend on each other.\n    let possiblyLoops = possiblyContinues || possiblyFallsThrough;\n    if (possiblyLoops && outerFlow.resetIfNeedsRecompile(thenFlow, numLocalsBefore)) {\n      this.currentFlow = outerFlow;\n      return this.doCompileWhileStatement(statement);\n    }\n\n    // If the condition is always true, the body's effects always happen\n    let alwaysTerminates = false;\n    if (condKind == ConditionKind.True) {\n      outerFlow.inherit(thenFlow);\n\n      // If the body also never breaks, the overall flow terminates\n      if (!possiblyBreaks) {\n        alwaysTerminates = true;\n        outerFlow.set(FlowFlags.Terminates);\n      }\n\n    // Otherwise loop conditionally\n    } else {\n      let elseFlow = outerFlow.forkElse(condExpr);\n      if (!possiblyFallsThrough && !possiblyBreaks) {\n        // Only getting past if condition was false\n        outerFlow.inherit(elseFlow);\n        outerFlow.mergeSideEffects(thenFlow);\n      } else {\n        // Otherwise getting past conditionally\n        outerFlow.inheritAlternatives(thenFlow, elseFlow);\n      }\n    }\n\n    // Finalize and leave everything else to the optimizer\n    this.currentFlow = outerFlow;\n    let stmts: ExpressionRef[] = [\n      module.loop(continueLabel,\n        module.if(condExprTrueish,\n          module.flatten(bodyStmts)\n        )\n      )\n    ];\n    if (alwaysTerminates) stmts.push(module.unreachable());\n    return module.block(breakLabel, stmts);\n  }\n\n  // === Expressions ==============================================================================\n\n  /** Compiles the value of an inlined constant element. */\n  compileInlineConstant(\n    element: VariableLikeElement,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    assert(element.is(CommonFlags.Inlined | CommonFlags.Resolved));\n    let type = element.type;\n    this.currentType = type;\n    switch (type.kind) {\n      case TypeKind.Bool: {\n        return this.module.i32(\n          element.constantValueKind == ConstantValueKind.Integer\n            // @ts-ignore\n            ? <i32>i64_ne(element.constantIntegerValue, i64_zero)\n            : 0\n        );\n      }\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        let shift = type.computeSmallIntegerShift(Type.i32);\n        return this.module.i32(\n          element.constantValueKind == ConstantValueKind.Integer\n            ? i64_low(element.constantIntegerValue) << shift >> shift\n            : 0\n        ); // recognized by canOverflow\n      }\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        let mask = element.type.computeSmallIntegerMask(Type.i32);\n        return this.module.i32(\n          element.constantValueKind == ConstantValueKind.Integer\n            ? i64_low(element.constantIntegerValue) & mask\n            : 0\n        ); // recognized by canOverflow\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return this.module.i32(\n          element.constantValueKind == ConstantValueKind.Integer\n            ? i64_low(element.constantIntegerValue)\n            : 0\n        );\n      }\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        if (!element.program.options.isWasm64) {\n          return this.module.i32(\n            element.constantValueKind == ConstantValueKind.Integer\n              ? i64_low(element.constantIntegerValue)\n              : 0\n          );\n        }\n        // fall-through\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return element.constantValueKind == ConstantValueKind.Integer\n          ? this.module.i64(\n              i64_low(element.constantIntegerValue),\n              i64_high(element.constantIntegerValue)\n            )\n          : this.module.i64(0);\n      }\n      case TypeKind.F64: {\n        // monkey-patch for converting built-in floats to f32 implicitly\n        if (!(element.hasDecorator(DecoratorFlags.Builtin) && contextualType == Type.f32)) {\n          return this.module.f64(element.constantFloatValue);\n        }\n        // otherwise fall-through: basically precomputes f32.demote/f64 of NaN / Infinity\n        this.currentType = Type.f32;\n      }\n      case TypeKind.F32: {\n        return this.module.f32(<f32>element.constantFloatValue);\n      }\n      default: {\n        assert(false);\n        return this.module.unreachable();\n      }\n    }\n  }\n\n  compileExpression(\n    expression: Expression,\n    contextualType: Type,\n    constraints: Constraints = Constraints.None\n  ): ExpressionRef {\n    while (expression.kind == NodeKind.Parenthesized) { // skip\n      expression = (<ParenthesizedExpression>expression).expression;\n    }\n    this.currentType = contextualType;\n    if (contextualType == Type.void) constraints |= Constraints.WillDrop;\n    let expr: ExpressionRef;\n    switch (expression.kind) {\n      case NodeKind.Assertion: {\n        expr = this.compileAssertionExpression(<AssertionExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.Binary: {\n        expr = this.compileBinaryExpression(<BinaryExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.Call: {\n        expr = this.compileCallExpression(<CallExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.Comma: {\n        expr = this.compileCommaExpression(<CommaExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.ElementAccess: {\n        expr = this.compileElementAccessExpression(<ElementAccessExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.Function: {\n        expr = this.compileFunctionExpression(<FunctionExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.Identifier:\n      case NodeKind.False:\n      case NodeKind.Null:\n      case NodeKind.This:\n      case NodeKind.Super:\n      case NodeKind.True: {\n        expr = this.compileIdentifierExpression(<IdentifierExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.InstanceOf: {\n        expr = this.compileInstanceOfExpression(<InstanceOfExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.Literal: {\n        expr = this.compileLiteralExpression(<LiteralExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.New: {\n        expr = this.compileNewExpression(<NewExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.PropertyAccess: {\n        expr = this.compilePropertyAccessExpression(<PropertyAccessExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.Ternary: {\n        expr = this.compileTernaryExpression(<TernaryExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.UnaryPostfix: {\n        expr = this.compileUnaryPostfixExpression(<UnaryPostfixExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.UnaryPrefix: {\n        expr = this.compileUnaryPrefixExpression(<UnaryPrefixExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.Compiled: {\n        let compiled = <CompiledExpression>expression;\n        expr = compiled.expr;\n        this.currentType = compiled.type;\n        break;\n      }\n      case NodeKind.Class: {\n        // TODO: compile as class expression\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          expression.range,\n          \"Block-scoped class declarations or expressions\"\n        );\n        expr = this.module.unreachable();\n        break;\n      }\n      default: {\n        assert(false);\n        expr = this.module.unreachable();\n      }\n    }\n    // ensure conversion and wrapping in case the respective function doesn't on its own\n    let currentType = this.currentType;\n    let wrap = (constraints & Constraints.MustWrap) != 0;\n    if (currentType != contextualType.nonNullableType) { // allow assigning non-nullable to nullable\n      if (constraints & Constraints.ConvExplicit) {\n        expr = this.convertExpression(expr, currentType, contextualType, true, expression);\n        this.currentType = currentType = contextualType;\n      } else if (constraints & Constraints.ConvImplicit) {\n        expr = this.convertExpression(expr, currentType, contextualType, false, expression);\n        this.currentType = currentType = contextualType;\n      }\n    }\n    if (wrap) expr = this.ensureSmallIntegerWrap(expr, currentType);\n    // debug location is added here so the caller doesn't have to. means: compilation of an expression\n    // must go through this function, with the respective per-kind functions not being used directly.\n    if (this.options.sourceMap) this.addDebugLocation(expr, expression.range);\n    return expr;\n  }\n\n  /** Converts an expression's result from one type to another. */\n  convertExpression(\n    expr: ExpressionRef,\n    /** Original type. */\n    fromType: Type,\n    /** New type. */\n    toType: Type,\n    /** Whether the conversion is explicit. */\n    explicit: bool,\n    /** Report node. */\n    reportNode: Node\n  ): ExpressionRef {\n    let module = this.module;\n\n    if (fromType.kind == TypeKind.Void) {\n      if (toType.kind == TypeKind.Void) {\n        // void to void: Can happen as a result of a foregoing error. Since we\n        // have an `expr` here that is already supposed to be void, return it.\n        return expr;\n      }\n      // void to any\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        reportNode.range, fromType.toString(), toType.toString()\n      );\n      return module.unreachable();\n    }\n\n    // any to void\n    if (toType.kind == TypeKind.Void) return module.drop(expr);\n\n    // reference involved\n    if (fromType.isReference || toType.isReference) {\n      if (this.currentFlow.isNonnull(expr, fromType)) {\n        fromType = fromType.nonNullableType;\n      } else if (explicit && fromType.isNullableReference && !toType.isNullableReference) {\n        // explicit conversion from nullable to non-nullable requires a runtime\n        // check here because nonnull state above already didn't know better\n        if (!this.options.noAssert) {\n          expr = this.makeRuntimeNonNullCheck(expr, fromType, reportNode);\n        }\n        fromType = fromType.nonNullableType;\n      }\n      if (fromType.isAssignableTo(toType)) { // upcast or same\n        assert(toType.isExternalReference || fromType.kind == toType.kind);\n        this.currentType = toType;\n        return expr;\n      }\n      if (explicit && toType.nonNullableType.isAssignableTo(fromType)) { // downcast\n        // <Cat | null>(<Animal>maybeCat)\n        if (toType.isExternalReference) {\n          this.error(\n            DiagnosticCode.Not_implemented_0,\n            reportNode.range,\n            \"ref.cast\"\n          );\n          this.currentType = toType;\n          return module.unreachable();\n        }\n        assert(fromType.kind == toType.kind);\n        if (!this.options.noAssert) {\n          expr = this.makeRuntimeDowncastCheck(expr, fromType, toType, reportNode);\n        }\n        this.currentType = toType;\n        return expr;\n      }\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        reportNode.range, fromType.toString(), toType.toString()\n      );\n      this.currentType = toType;\n      return module.unreachable();\n    }\n\n    // not dealing with references from here on\n    assert(!fromType.isReference && !toType.isReference);\n\n    // Early return if we have same types\n    if (toType.kind == fromType.kind) {\n      this.currentType = toType;\n      return expr;\n    }\n\n    // v128 to any / any to v128\n    // except v128 to bool\n    //\n    // NOTE:In case we would have more conversions to and from v128 type it's better\n    // to make these checks more individual and integrate in below flow.\n    if (\n      !toType.isBooleanValue &&\n      (toType.isVectorValue || fromType.isVectorValue)\n    ) {\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        reportNode.range, fromType.toString(), toType.toString()\n      );\n      return module.unreachable();\n    }\n\n    if (!fromType.isAssignableTo(toType)) {\n      if (!explicit) {\n        this.error(\n          DiagnosticCode.Conversion_from_type_0_to_1_requires_an_explicit_cast,\n          reportNode.range, fromType.toString(), toType.toString()\n        ); // recoverable\n      }\n    }\n\n    if (fromType.isFloatValue) {\n\n      // float to float\n      if (toType.isFloatValue) {\n        if (fromType.kind == TypeKind.F32) {\n\n          // f32 to f64\n          if (toType.kind == TypeKind.F64) {\n            expr = module.unary(UnaryOp.PromoteF32ToF64, expr);\n          }\n\n          // otherwise f32 to f32\n\n        // f64 to f32\n        } else if (toType.kind == TypeKind.F32) {\n          expr = module.unary(UnaryOp.DemoteF64ToF32, expr);\n        }\n\n        // otherwise f64 to f64\n\n      // float to int\n      } else if (toType.isIntegerValue) {\n\n        // f32 to int\n        if (fromType.kind == TypeKind.F32) {\n          if (toType.isBooleanValue) {\n            expr = this.makeIsTrueish(expr, Type.f32, reportNode);\n          } else if (toType.isSignedIntegerValue) {\n            let saturating = this.options.hasFeature(Feature.NontrappingF2I);\n            if (toType.isLongIntegerValue) {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF32ToI64 : UnaryOp.TruncF32ToI64, expr);\n            } else {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF32ToI32 : UnaryOp.TruncF32ToI32, expr);\n            }\n          } else {\n            let saturating = this.options.hasFeature(Feature.NontrappingF2I);\n            if (toType.isLongIntegerValue) {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF32ToU64 : UnaryOp.TruncF32ToU64, expr);\n            } else {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF32ToU32 : UnaryOp.TruncF32ToU32, expr);\n            }\n          }\n\n        // f64 to int\n        } else {\n          if (toType.isBooleanValue) {\n            expr = this.makeIsTrueish(expr, Type.f64, reportNode);\n          } else if (toType.isSignedIntegerValue) {\n            let saturating = this.options.hasFeature(Feature.NontrappingF2I);\n            if (toType.isLongIntegerValue) {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF64ToI64 : UnaryOp.TruncF64ToI64, expr);\n            } else {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF64ToI32 : UnaryOp.TruncF64ToI32, expr);\n            }\n          } else {\n            let saturating = this.options.hasFeature(Feature.NontrappingF2I);\n            if (toType.isLongIntegerValue) {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF64ToU64 : UnaryOp.TruncF64ToU64, expr);\n            } else {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF64ToU32 : UnaryOp.TruncF64ToU32, expr);\n            }\n          }\n        }\n\n      // float to void\n      } else {\n        assert(toType.flags == TypeFlags.None, \"void type expected\");\n        expr = module.drop(expr);\n      }\n\n    // int to float\n    } else if (fromType.isIntegerValue && toType.isFloatValue) {\n      // Clear extra bits.\n      expr = this.ensureSmallIntegerWrap(expr, fromType);\n      let op: UnaryOp;\n      // int to f32\n      if (toType.kind == TypeKind.F32) {\n        if (fromType.isLongIntegerValue) {\n          if (fromType.isSignedIntegerValue) op = UnaryOp.ConvertI64ToF32;\n          else op = UnaryOp.ConvertU64ToF32;\n        } else {\n          if (fromType.isSignedIntegerValue) op = UnaryOp.ConvertI32ToF32;\n          else op = UnaryOp.ConvertU32ToF32;\n        }\n      // int to f64\n      } else {\n        if (fromType.isLongIntegerValue) {\n          if (fromType.isSignedIntegerValue) op = UnaryOp.ConvertI64ToF64;\n          else op = UnaryOp.ConvertU64ToF64;\n        } else {\n          if (fromType.isSignedIntegerValue) op = UnaryOp.ConvertI32ToF64;\n          else op = UnaryOp.ConvertU32ToF64;\n        }\n      }\n      expr = module.unary(op, expr);\n\n    // v128 to bool\n    } else if (fromType == Type.v128 && toType.isBooleanValue) {\n      expr = this.makeIsTrueish(expr, Type.v128, reportNode);\n\n    // int to int\n    } else {\n      // i64 to ...\n      if (fromType.isLongIntegerValue) {\n\n        // i64 to i32 or smaller\n        if (toType.isBooleanValue) {\n          expr = module.binary(BinaryOp.NeI64, expr, module.i64(0));\n        } else if (!toType.isLongIntegerValue) {\n          expr = module.unary(UnaryOp.WrapI64ToI32, expr); // discards upper bits\n        }\n\n      // i32 or smaller to i64\n      } else if (toType.isLongIntegerValue) {\n        expr = module.unary(\n          fromType.isSignedIntegerValue ? UnaryOp.ExtendI32ToI64 : UnaryOp.ExtendU32ToU64,\n          this.ensureSmallIntegerWrap(expr, fromType) // must clear garbage bits\n        );\n\n      // i32 to i32\n      } else {\n        // small i32 to ...\n        if (fromType.isShortIntegerValue) {\n          // small i32 to larger i32\n          if (fromType.size < toType.size) {\n            expr = this.ensureSmallIntegerWrap(expr, fromType); // must clear garbage bits\n          }\n        // same size\n        } else {\n          if (!explicit && !this.options.isWasm64 && fromType.isVaryingIntegerValue && !toType.isVaryingIntegerValue) {\n            this.warning(\n              DiagnosticCode.Conversion_from_type_0_to_1_will_require_an_explicit_cast_when_switching_between_32_64_bit,\n              reportNode.range, fromType.toString(), toType.toString()\n            );\n          }\n        }\n      }\n    }\n\n    this.currentType = toType;\n    return expr;\n  }\n\n  private compileAssertionExpression(\n    expression: AssertionExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let inheritedConstraints = constraints & ~(Constraints.ConvImplicit | Constraints.ConvExplicit);\n    switch (expression.assertionKind) {\n      case AssertionKind.Prefix:\n      case AssertionKind.As: {\n        let flow = this.currentFlow;\n        let toType = this.resolver.resolveType( // reports\n          assert(expression.toType), flow,\n          flow.sourceFunction,\n          cloneMap(flow.contextualTypeArguments)\n        );\n        if (!toType) return this.module.unreachable();\n        return this.compileExpression(expression.expression, toType, inheritedConstraints | Constraints.ConvExplicit);\n      }\n      case AssertionKind.NonNull: {\n        assert(!expression.toType);\n        let expr = this.compileExpression(expression.expression, contextualType.exceptVoid, inheritedConstraints);\n        let type = this.currentType;\n        if (this.currentFlow.isNonnull(expr, type)) {\n          this.info(\n            DiagnosticCode.Expression_is_never_null,\n            expression.expression.range\n          );\n        } else if (!this.options.noAssert) {\n          expr = this.makeRuntimeNonNullCheck(expr, type, expression);\n        }\n        this.currentType = type.nonNullableType;\n        return expr;\n      }\n      case AssertionKind.Const: {\n        // TODO: decide on the layout of ReadonlyArray first\n        // let operand = expression.expression;\n        // if (operand.kind == NodeKind.Literal && (<LiteralExpression>operand).literalKind == LiteralKind.Array) {\n        //   let element = this.resolver.lookupExpression(expression /* ! */, this.currentFlow, contextualType);\n        //   if (!element) return this.module.unreachable();\n        //   if (element.kind == ElementKind.Class) {\n        //     let arrayInstance = <Class>element;\n        //     if (arrayInstance.extends(this.program.readonlyArrayPrototype)) {\n        //       return this.compileStaticArrayLiteral(<ArrayLiteralExpression>operand, arrayInstance.type, constraints);\n        //     }\n        //   }\n        // }\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          expression.range,\n          \"Const assertion\"\n        );\n        return this.module.unreachable();\n      }\n      default: assert(false);\n    }\n    return this.module.unreachable();\n  }\n\n  private f32ModInstance: Function | null = null;\n  private f64ModInstance: Function | null = null;\n  private f32PowInstance: Function | null = null;\n  private f64PowInstance: Function | null = null;\n  private i32PowInstance: Function | null = null;\n  private i64PowInstance: Function | null = null;\n\n  /** compile `==` `===` `!=` `!==` BinaryExpression */\n  private compileCommutativeCompareBinaryExpression(\n    expression: BinaryExpression,\n    contextualType: Type,\n  ): ExpressionRef {\n    \n    const left = expression.left;\n    const leftExpr = this.compileExpression(left, contextualType);\n    const leftType = this.currentType;\n\n    const right = expression.right;\n    const rightExpr = this.compileExpression(right, leftType);\n    const rightType = this.currentType;\n\n    return this.compileCommutativeCompareBinaryExpressionFromParts(\n      expression.operator,\n      left, leftExpr, leftType,\n      right, rightExpr, rightType,\n      contextualType,\n      expression\n    );\n  }\n\n  /** \n   * compile `==` `===` `!=` `!==` BinaryExpression, from previously compiled left and right expressions.\n   * \n   * This is split from `compileCommutativeCompareBinaryExpression` so that the logic can be reused\n   * for switch cases in `compileSwitchStatement`, where the left expression only should be compiled once.\n   */\n  private compileCommutativeCompareBinaryExpressionFromParts(\n    operator: Token,\n    left: Expression,\n    leftExpr: ExpressionRef,\n    leftType: Type,\n    right: Expression,\n    rightExpr: ExpressionRef,\n    rightType: Type,\n    contextualType: Type,\n    reportNode: Node\n  ): ExpressionRef {\n\n    let module = this.module;\n    let operatorString = operatorTokenToString(operator);\n    \n    // check operator overload\n    const operatorKind = OperatorKind.fromBinaryToken(operator);\n    const leftOverload = leftType.lookupOverload(operatorKind, this.program);\n    const rightOverload = rightType.lookupOverload(operatorKind, this.program);\n    if (leftOverload && rightOverload && leftOverload != rightOverload) {\n      this.error(\n        DiagnosticCode.Ambiguous_operator_overload_0_conflicting_overloads_1_and_2,\n        reportNode.range, \n        operatorString,\n        leftOverload.internalName,\n        rightOverload.internalName\n      );\n      this.currentType = contextualType;\n      return module.unreachable();\n    }\n    if (leftOverload) {\n      return this.compileCommutativeBinaryOverload(\n        leftOverload,\n        left, leftExpr, leftType,\n        right, rightExpr, rightType,\n        reportNode\n      );\n    }\n    if (rightOverload) {\n      return this.compileCommutativeBinaryOverload(\n        rightOverload,\n        right, rightExpr, rightType,\n        left, leftExpr, leftType,\n        reportNode\n      );\n    }\n    const signednessIsRelevant = false;\n    const commonType = Type.commonType(leftType, rightType, contextualType, signednessIsRelevant);\n    if (!commonType) {\n      this.error(\n        DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n        reportNode.range,\n        operatorString,\n        leftType.toString(),\n        rightType.toString()\n      );\n      this.currentType = contextualType;\n      return module.unreachable();\n    }\n\n    if (commonType.isFloatValue) {\n      if (isConstExpressionNaN(module, rightExpr) || isConstExpressionNaN(module, leftExpr)) {\n        this.warning(\n          DiagnosticCode._NaN_does_not_compare_equal_to_any_other_value_including_itself_Use_isNaN_x_instead,\n          reportNode.range\n        );\n      }\n      if (isConstNegZero(rightExpr) || isConstNegZero(leftExpr)) {\n        this.warning(\n          DiagnosticCode.Comparison_with_0_0_is_sign_insensitive_Use_Object_is_x_0_0_if_the_sign_matters,\n          reportNode.range\n        );\n      }\n    }\n\n    leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n    leftType = commonType;\n    rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n    rightType = commonType;\n\n    this.currentType = Type.bool;\n    switch (operator) {\n      case Token.Equals_Equals_Equals:\n      case Token.Equals_Equals:\n        return this.makeEq(leftExpr, rightExpr, commonType, reportNode);\n      case Token.Exclamation_Equals_Equals:\n      case Token.Exclamation_Equals:\n        return this.makeNe(leftExpr, rightExpr, commonType, reportNode);\n      default:\n        assert(false);\n        return module.unreachable();\n    }\n  }\n\n  /** compile `>` `>=` `<` `<=` BinaryExpression */\n  private compileNonCommutativeCompareBinaryExpression(\n    expression: BinaryExpression,\n    contextualType: Type,\n  ): ExpressionRef {\n    let module = this.module;\n    let left = expression.left;\n    let right = expression.right;\n    let leftExpr: ExpressionRef;\n    let leftType: Type;\n    let rightExpr: ExpressionRef;\n    let rightType: Type;\n    let commonType: Type | null;\n    let operator = expression.operator;\n    let operatorString = operatorTokenToString(operator);\n\n    leftExpr = this.compileExpression(left, contextualType);\n    leftType = this.currentType;\n    \n    // check operator overload\n    const operatorKind = OperatorKind.fromBinaryToken(operator);\n    const leftOverload = leftType.lookupOverload(operatorKind, this.program);\n    if (leftOverload) return this.compileBinaryOverload(leftOverload, left, leftExpr, leftType, right, expression);\n\n    rightExpr = this.compileExpression(right, leftType);\n    rightType = this.currentType;\n\n    const signednessIsRelevant = true;\n    commonType = Type.commonType(leftType, rightType, contextualType, signednessIsRelevant);\n    if (!commonType || !commonType.isNumericValue) {\n      this.error(\n        DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n        expression.range,\n        operatorString,\n        leftType.toString(),\n        rightType.toString()\n      );\n      this.currentType = contextualType;\n      return module.unreachable();\n    }\n\n    leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n    leftType = commonType;\n    rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n    rightType = commonType;\n\n    this.currentType = Type.bool;\n    switch (operator) {\n      case Token.LessThan:\n        return this.makeLt(leftExpr, rightExpr, commonType);\n      case Token.GreaterThan:\n        return this.makeGt(leftExpr, rightExpr, commonType);\n      case Token.LessThan_Equals:\n        return this.makeLe(leftExpr, rightExpr, commonType);\n      case Token.GreaterThan_Equals:\n        return this.makeGe(leftExpr, rightExpr, commonType);\n      default:\n        assert(false);\n        return module.unreachable();\n    }\n  }\n\n  private compileBinaryExpression(\n    expression: BinaryExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let module = this.module;\n    let left = expression.left;\n    let right = expression.right;\n\n    let leftExpr: ExpressionRef;\n    let leftType: Type;\n    let rightExpr: ExpressionRef;\n    let rightType: Type;\n    let commonType: Type | null;\n\n    let expr: ExpressionRef;\n    let compound = false;\n\n    let operator = expression.operator;\n    switch (operator) {\n      case Token.LessThan:\n      case Token.GreaterThan:\n      case Token.LessThan_Equals:\n      case Token.GreaterThan_Equals:{\n        return this.compileNonCommutativeCompareBinaryExpression(expression, contextualType);\n      }\n      case Token.Equals_Equals_Equals:\n      case Token.Equals_Equals: \n      case Token.Exclamation_Equals_Equals:\n      case Token.Exclamation_Equals: {\n        return this.compileCommutativeCompareBinaryExpression(expression, contextualType);\n      }\n      case Token.Equals: {\n        return this.compileAssignment(left, right, contextualType);\n      }\n      case Token.Plus_Equals: compound = true;\n      case Token.Plus: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Add);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"+\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonType(leftType, rightType, contextualType);\n          if (!commonType || !commonType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"+\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeAdd(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.Minus_Equals: compound = true;\n      case Token.Minus: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Sub);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"-\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonType(leftType, rightType, contextualType);\n          if (!commonType || !leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"-\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeSub(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.Asterisk_Equals: compound = true;\n      case Token.Asterisk: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Mul);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"*\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonType(leftType, rightType, contextualType);\n          if (!commonType || !commonType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"*\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeMul(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.Asterisk_Asterisk_Equals: compound = true;\n      case Token.Asterisk_Asterisk: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Pow);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"**\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonType(leftType, rightType, contextualType);\n          if (!commonType || !commonType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"**\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makePow(leftExpr, rightExpr, commonType, expression);\n        break;\n      }\n      case Token.Slash_Equals: compound = true;\n      case Token.Slash: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Div);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"/\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonType(leftType, rightType, contextualType);\n          if (!commonType || !commonType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"/\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeDiv(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.Percent_Equals: compound = true;\n      case Token.Percent: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Rem);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"%\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonType(leftType, rightType, contextualType);\n          if (!commonType || !commonType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"%\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeRem(leftExpr, rightExpr, commonType, expression);\n        break;\n      }\n      case Token.LessThan_LessThan_Equals: compound = true;\n      case Token.LessThan_LessThan: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BitwiseShl);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n        if (!leftType.isIntegerValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"<<\", leftType.toString()\n          );\n          return module.unreachable();\n        }\n        rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n        rightType = this.currentType;\n\n        expr = this.makeShl(leftExpr, rightExpr, rightType);\n        break;\n      }\n      case Token.GreaterThan_GreaterThan_Equals: compound = true;\n      case Token.GreaterThan_GreaterThan: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BitwiseShr);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n        if (!leftType.isIntegerValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \">>\", leftType.toString()\n          );\n          return this.module.unreachable();\n        }\n\n        rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n        rightType = this.currentType;\n\n        expr = this.makeShr(leftExpr, rightExpr, rightType);\n        break;\n      }\n      case Token.GreaterThan_GreaterThan_GreaterThan_Equals: compound = true;\n      case Token.GreaterThan_GreaterThan_GreaterThan: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BitwiseShrU);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n        if (!leftType.isIntegerValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \">>>\", leftType.toString()\n          );\n          return module.unreachable();\n        }\n        rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n        rightType = this.currentType;\n\n        expr = this.makeShru(leftExpr, rightExpr, rightType);\n        break;\n      }\n      case Token.Ampersand_Equals: compound = true;\n      case Token.Ampersand: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BitwiseAnd);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"&\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonType(leftType, rightType, contextualType);\n          if (!commonType || !commonType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"&\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeAnd(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.Bar_Equals: compound = true;\n      case Token.Bar: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BitwiseOr);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"|\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonType(leftType, rightType, contextualType);\n          if (!commonType || !commonType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"|\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeOr(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.Caret_Equals: compound = true;\n      case Token.Caret: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BitwiseXor);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"^\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonType(leftType, rightType, contextualType);\n          if (!commonType || !commonType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"^\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeXor(leftExpr, rightExpr, commonType);\n        break;\n      }\n\n      // logical (no overloading)\n\n      case Token.Ampersand_Ampersand: { // left && right -> (t = left) ? right : t\n        let flow = this.currentFlow;\n        let inheritedConstraints = constraints & Constraints.MustWrap;\n        leftExpr = this.compileExpression(left, contextualType.exceptVoid, inheritedConstraints);\n        leftType = this.currentType;\n\n        let rightFlow = flow.forkThen(leftExpr);\n        this.currentFlow = rightFlow;\n\n        // simplify if only interested in true or false\n        if (contextualType == Type.bool || contextualType == Type.void) {\n          leftExpr = this.makeIsTrueish(leftExpr, leftType, left);\n\n          // shortcut if lhs is always false\n          let condKind = this.evaluateCondition(leftExpr);\n          if (condKind == ConditionKind.False) {\n            expr = leftExpr;\n            // RHS is not compiled\n          } else {\n            rightExpr = this.compileExpression(right, leftType, inheritedConstraints);\n            rightType = this.currentType;\n            rightExpr = this.makeIsTrueish(rightExpr, rightType, right);\n\n            // simplify if lhs is always true\n            if (condKind == ConditionKind.True) {\n              expr = rightExpr;\n              flow.inherit(rightFlow); // true && RHS -> RHS always executes\n            } else {\n              expr = module.if(leftExpr, rightExpr, module.i32(0));\n              flow.mergeBranch(rightFlow); // LHS && RHS -> RHS conditionally executes\n              flow.noteThen(expr, rightFlow); // LHS && RHS == true -> RHS always executes\n            }\n          }\n          this.currentFlow = flow;\n          this.currentType = Type.bool;\n\n        } else {\n          rightExpr = this.compileExpression(right, leftType, inheritedConstraints);\n          rightType = this.currentType;\n          commonType = Type.commonType(leftType, rightType, contextualType);\n          if (!commonType) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"&&\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n\n          // This is sometimes needed to make the left trivial\n          let leftPrecompExpr = module.runExpression(leftExpr, ExpressionRunnerFlags.PreserveSideeffects);\n          if (leftPrecompExpr) leftExpr = leftPrecompExpr;\n\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n\n          let condExpr = this.makeIsTrueish(leftExpr, this.currentType, left);\n          let condKind = this.evaluateCondition(condExpr);\n\n          if (condKind != ConditionKind.Unknown) {\n            // simplify if left is a constant\n            expr = condKind == ConditionKind.True\n              ? rightExpr\n              : leftExpr;\n          } else if (expr = module.tryCopyTrivialExpression(leftExpr)) {\n            // simplify if copying left is trivial\n            expr = module.if(\n              condExpr,\n              rightExpr,\n              expr\n            );\n          } else {\n            // if not possible, tee left to a temp\n            let tempLocal = flow.getTempLocal(leftType);\n            if (!flow.canOverflow(leftExpr, leftType)) flow.setLocalFlag(tempLocal.index, LocalFlags.Wrapped);\n            if (flow.isNonnull(leftExpr, leftType)) flow.setLocalFlag(tempLocal.index, LocalFlags.NonNull);\n            expr = module.if(\n              this.makeIsTrueish(module.local_tee(tempLocal.index, leftExpr, leftType.isManaged), leftType, left),\n              rightExpr,\n              module.local_get(tempLocal.index, leftType.toRef())\n            );\n          }\n          flow.mergeBranch(rightFlow); // LHS && RHS -> RHS conditionally executes\n          flow.noteThen(expr, rightFlow); // LHS && RHS == true -> RHS always executes\n          this.currentFlow = flow;\n          this.currentType = commonType;\n        }\n        break;\n      }\n      case Token.Bar_Bar: { // left || right -> ((t = left) ? t : right)\n        let flow = this.currentFlow;\n        let inheritedConstraints = constraints & Constraints.MustWrap;\n        leftExpr = this.compileExpression(left, contextualType.exceptVoid, inheritedConstraints);\n        leftType = this.currentType;\n\n        let rightFlow = flow.forkElse(leftExpr);\n        this.currentFlow = rightFlow;\n\n        // simplify if only interested in true or false\n        if (contextualType == Type.bool || contextualType == Type.void) {\n          leftExpr = this.makeIsTrueish(leftExpr, leftType, left);\n\n          // shortcut if lhs is always true\n          let condKind = this.evaluateCondition(leftExpr);\n          if (condKind == ConditionKind.True) {\n            expr = leftExpr;\n            // RHS is not compiled\n          } else {\n            rightExpr = this.compileExpression(right, leftType, inheritedConstraints);\n            rightType = this.currentType;\n            rightExpr = this.makeIsTrueish(rightExpr, rightType, right);\n\n            // simplify if lhs is always false\n            if (condKind == ConditionKind.False) {\n              expr = rightExpr;\n              flow.inherit(rightFlow); // false || RHS -> RHS always executes\n            } else {\n              expr = module.if(leftExpr, module.i32(1), rightExpr);\n              flow.mergeBranch(rightFlow); // LHS || RHS -> RHS conditionally executes\n              flow.noteElse(expr, rightFlow); // LHS || RHS == false -> RHS always executes\n            }\n          }\n          this.currentFlow = flow;\n          this.currentType = Type.bool;\n\n        } else {\n          rightExpr = this.compileExpression(right, leftType, inheritedConstraints);\n          rightType = this.currentType;\n          commonType = Type.commonType(leftType, rightType, contextualType);\n          if (!commonType) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"||\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          let possiblyNull = leftType.is(TypeFlags.Nullable) && rightType.is(TypeFlags.Nullable);\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n\n          // This is sometimes needed to make the left trivial\n          let leftPrecompExpr = module.runExpression(leftExpr, ExpressionRunnerFlags.PreserveSideeffects);\n          if (leftPrecompExpr) leftExpr = leftPrecompExpr;\n\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n\n          let condExpr = this.makeIsTrueish(leftExpr, this.currentType, left);\n          let condKind = this.evaluateCondition(condExpr);\n\n          if (condKind != ConditionKind.Unknown) {\n            // simplify if left is a constant\n            expr = condKind == ConditionKind.True\n              ? leftExpr\n              : rightExpr;\n          } else if (expr = module.tryCopyTrivialExpression(leftExpr)) {\n            // otherwise, simplify if copying left is trivial\n            expr = module.if(\n              condExpr,\n              expr,\n              rightExpr\n            );\n          } else {\n            // if not possible, tee left to a temp. local\n            let temp = flow.getTempLocal(leftType);\n            let tempIndex = temp.index;\n            if (!flow.canOverflow(leftExpr, leftType)) flow.setLocalFlag(tempIndex, LocalFlags.Wrapped);\n            if (flow.isNonnull(leftExpr, leftType)) flow.setLocalFlag(tempIndex, LocalFlags.NonNull);\n            expr = module.if(\n              this.makeIsTrueish(module.local_tee(tempIndex, leftExpr, leftType.isManaged), leftType, left),\n              module.local_get(tempIndex, leftType.toRef()),\n              rightExpr\n            );\n          }\n          flow.mergeBranch(rightFlow); // LHS || RHS -> RHS conditionally executes\n          flow.noteElse(expr, rightFlow); // LHS || RHS == false -> RHS always executes\n          this.currentFlow = flow;\n          this.currentType = possiblyNull\n            ? commonType\n            : commonType.nonNullableType;\n        }\n        break;\n      }\n      case Token.In: {\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          expression.range, \"'in' operator\"\n        );\n        this.currentType = Type.bool;\n        return module.unreachable();\n      }\n      default: {\n        assert(false);\n        expr = this.module.unreachable();\n        break;\n      }\n    }\n    if (!compound) return expr;\n    let resolver = this.resolver;\n    let target = resolver.lookupExpression(left, this.currentFlow);\n    if (!target) return module.unreachable();\n    let targetType = resolver.getTypeOfElement(target);\n    if (!targetType) targetType = Type.void;\n    if (!this.currentType.isStrictlyAssignableTo(targetType)) {\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        expression.range, this.currentType.toString(), targetType.toString()\n      );\n      return module.unreachable();\n    }\n    return this.makeAssignment(\n      target,\n      expr,\n      this.currentType,\n      right,\n      resolver.currentThisExpression,\n      resolver.currentElementExpression,\n      contextualType != Type.void\n    );\n  }\n\n  makeLt(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits and signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.LtI32, leftExpr, rightExpr);\n      case TypeKind.I64: return module.binary(BinaryOp.LtI64, leftExpr, rightExpr);\n      case TypeKind.Isize: return module.binary(BinaryOp.LtISize, leftExpr, rightExpr);\n      case TypeKind.Bool:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: return module.binary(BinaryOp.LtU32, leftExpr, rightExpr);\n      case TypeKind.U64: return module.binary(BinaryOp.LtU64, leftExpr, rightExpr);\n      case TypeKind.Usize: return module.binary(BinaryOp.LtUSize, leftExpr, rightExpr);\n      case TypeKind.F32: return module.binary(BinaryOp.LtF32, leftExpr, rightExpr);\n      case TypeKind.F64: return module.binary(BinaryOp.LtF64, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeGt(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits and signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.GtI32, leftExpr, rightExpr);\n      case TypeKind.I64: return module.binary(BinaryOp.GtI64, leftExpr, rightExpr);\n      case TypeKind.Isize: return module.binary(BinaryOp.GtISize, leftExpr, rightExpr);\n      case TypeKind.Bool:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: return module.binary(BinaryOp.GtU32, leftExpr, rightExpr);\n      case TypeKind.U64: return module.binary(BinaryOp.GtU64, leftExpr, rightExpr);\n      case TypeKind.Usize: return module.binary(BinaryOp.GtUSize, leftExpr, rightExpr);\n      case TypeKind.F32: return module.binary(BinaryOp.GtF32, leftExpr, rightExpr);\n      case TypeKind.F64: return module.binary(BinaryOp.GtF64, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeLe(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits and signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.LeI32, leftExpr, rightExpr);\n      case TypeKind.I64: return module.binary(BinaryOp.LeI64, leftExpr, rightExpr);\n      case TypeKind.Isize: return module.binary(BinaryOp.LeISize, leftExpr, rightExpr);\n      case TypeKind.Bool:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: return module.binary(BinaryOp.LeU32, leftExpr, rightExpr);\n      case TypeKind.U64: return module.binary(BinaryOp.LeU64, leftExpr, rightExpr);\n      case TypeKind.Usize: return module.binary(BinaryOp.LeUSize, leftExpr, rightExpr);\n      case TypeKind.F32: return module.binary(BinaryOp.LeF32, leftExpr, rightExpr);\n      case TypeKind.F64: return module.binary(BinaryOp.LeF64, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeGe(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits and signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.GeI32, leftExpr, rightExpr);\n      case TypeKind.I64: return module.binary(BinaryOp.GeI64, leftExpr, rightExpr);\n      case TypeKind.Isize: return module.binary(BinaryOp.GeISize, leftExpr, rightExpr);\n      case TypeKind.Bool:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: return module.binary(BinaryOp.GeU32, leftExpr, rightExpr);\n      case TypeKind.U64: return module.binary(BinaryOp.GeU64, leftExpr, rightExpr);\n      case TypeKind.Usize: return module.binary(BinaryOp.GeUSize, leftExpr, rightExpr);\n      case TypeKind.F32: return module.binary(BinaryOp.GeF32, leftExpr, rightExpr);\n      case TypeKind.F64: return module.binary(BinaryOp.GeF64, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeEq(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    // Cares about garbage bits\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.EqI32, leftExpr, rightExpr);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.EqI64, leftExpr, rightExpr);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.EqSize, leftExpr, rightExpr);\n      case TypeKind.F32: return module.binary(BinaryOp.EqF32, leftExpr, rightExpr);\n      case TypeKind.F64: return module.binary(BinaryOp.EqF64, leftExpr, rightExpr);\n      case TypeKind.V128: {\n        return module.unary(UnaryOp.AllTrueI8x16,\n          module.binary(BinaryOp.EqI8x16, leftExpr, rightExpr)\n        );\n      }\n      case TypeKind.Eq:\n      case TypeKind.Struct:\n      case TypeKind.Array:\n      case TypeKind.I31: return module.ref_eq(leftExpr, rightExpr);\n      case TypeKind.String: return module.string_eq(leftExpr, rightExpr);\n      case TypeKind.StringviewWTF8:\n      case TypeKind.StringviewWTF16:\n      case TypeKind.StringviewIter:\n      case TypeKind.Func:\n      case TypeKind.Extern:\n      case TypeKind.Any: {\n        this.error(\n          DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n          reportNode.range,\n          \"ref.eq\",\n          type.toString()\n        );\n        return module.unreachable();\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeNe(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    // Cares about garbage bits\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.NeI32, leftExpr, rightExpr);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.NeI64, leftExpr, rightExpr);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.NeSize, leftExpr, rightExpr);\n      case TypeKind.F32: return module.binary(BinaryOp.NeF32, leftExpr, rightExpr);\n      case TypeKind.F64: return module.binary(BinaryOp.NeF64, leftExpr, rightExpr);\n      case TypeKind.V128: {\n        return module.unary(UnaryOp.AnyTrueV128,\n          module.binary(BinaryOp.NeI8x16, leftExpr, rightExpr)\n        );\n      }\n      case TypeKind.Eq:\n      case TypeKind.Struct:\n      case TypeKind.Array:\n      case TypeKind.I31: {\n        return module.unary(UnaryOp.EqzI32,\n          module.ref_eq(leftExpr, rightExpr)\n        );\n      }\n      case TypeKind.String: {\n        return module.unary(UnaryOp.EqzI32,\n          module.string_eq(leftExpr, rightExpr)\n        );\n      }\n      case TypeKind.StringviewWTF8:\n      case TypeKind.StringviewWTF16:\n      case TypeKind.StringviewIter:\n      case TypeKind.Func:\n      case TypeKind.Extern:\n      case TypeKind.Any: {\n        this.error(\n          DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n          reportNode.range,\n          \"ref.eq\",\n          type.toString()\n        );\n        return module.unreachable();\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeAdd(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.AddI32, leftExpr, rightExpr);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.AddI64, leftExpr, rightExpr);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.AddSize, leftExpr, rightExpr);\n      case TypeKind.F32: return module.binary(BinaryOp.AddF32, leftExpr, rightExpr);\n      case TypeKind.F64: return module.binary(BinaryOp.AddF64, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeSub(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.SubI32, leftExpr, rightExpr);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.SubI64, leftExpr, rightExpr);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.SubSize, leftExpr, rightExpr);\n      case TypeKind.F32: return module.binary(BinaryOp.SubF32, leftExpr, rightExpr);\n      case TypeKind.F64: return module.binary(BinaryOp.SubF64, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeMul(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.MulI32, leftExpr, rightExpr);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.MulI64, leftExpr, rightExpr);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.MulSize, leftExpr, rightExpr);\n      case TypeKind.F32: return module.binary(BinaryOp.MulF32, leftExpr, rightExpr);\n      case TypeKind.F64: return module.binary(BinaryOp.MulF64, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makePow(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    // Cares about garbage bits\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool: {\n        return module.select(\n          module.i32(1),\n          module.binary(BinaryOp.EqI32, rightExpr, module.i32(0)),\n          leftExpr\n        );\n      }\n      case TypeKind.I8:\n      case TypeKind.U8:\n      case TypeKind.I16:\n      case TypeKind.U16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        if (this.options.willOptimize) {\n          // Precompute power if LHS and RHS constants\n          // TODO: move this optimization to AIR\n          if (\n            getExpressionId(leftExpr)  == ExpressionId.Const &&\n            getExpressionId(rightExpr) == ExpressionId.Const\n          ) {\n            let leftValue  = getConstValueI32(leftExpr);\n            let rightValue = getConstValueI32(rightExpr);\n            this.currentType = type;\n            return module.i32(i64_low(i64_pow(\n              i64_new(leftValue),\n              i64_new(rightValue)\n            )));\n          }\n        }\n        let instance = this.i32PowInstance;\n        if (!instance) {\n          let prototype = this.program.lookup(CommonNames.ipow32);\n          if (!prototype) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"ipow32\"\n            );\n            return module.unreachable();\n          }\n          assert(prototype.kind == ElementKind.FunctionPrototype);\n          this.i32PowInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        let expr = this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n        if (type.size < 32) {\n          // TODO: this is necessary because i32PowInstance is generic, and deals with 32-bit integers,\n          // so its flow does not indicate whether returned SMIs are wrapped. worth to avoid?\n          expr = this.ensureSmallIntegerWrap(expr, type);\n        }\n        return expr;\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        if (this.options.willOptimize) {\n          // Precompute power if LHS and RHS constants\n          // TODO: move this optimization to AIR\n          if (\n            getExpressionId(leftExpr) == ExpressionId.Const &&\n            getExpressionId(rightExpr) == ExpressionId.Const\n          ) {\n            let leftValue = i64_new(getConstValueI64Low(leftExpr), getConstValueI64High(leftExpr));\n            let rightValue = i64_new(getConstValueI64Low(rightExpr), getConstValueI64High(rightExpr));\n            let result = i64_pow(leftValue, rightValue);\n            this.currentType = type;\n            return module.i64(i64_low(result), i64_high(result));\n          }\n        }\n        let instance = this.i64PowInstance;\n        if (!instance) {\n          let prototype = this.program.lookup(CommonNames.ipow64);\n          if (!prototype) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"ipow64\"\n            );\n            return module.unreachable();\n          }\n          assert(prototype.kind == ElementKind.FunctionPrototype);\n          this.i64PowInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        let isWasm64 = this.options.isWasm64;\n        if (this.options.willOptimize) {\n          // Precompute power if LHS and RHS constants\n          // TODO: move this optimization to AIR\n          if (\n            getExpressionId(leftExpr) == ExpressionId.Const &&\n            getExpressionId(rightExpr) == ExpressionId.Const\n          ) {\n            if (isWasm64) {\n              let leftValue  = i64_new(getConstValueI64Low(leftExpr), getConstValueI64High(leftExpr));\n              let rightValue = i64_new(getConstValueI64Low(rightExpr), getConstValueI64High(rightExpr));\n              let result = i64_pow(leftValue, rightValue);\n              this.currentType = type;\n              return module.i64(i64_low(result), i64_high(result));\n            } else {\n              let leftValue  = getConstValueI32(leftExpr);\n              let rightValue = getConstValueI32(rightExpr);\n              this.currentType = type;\n              return module.i32(i64_low(i64_pow(\n                i64_new(leftValue),\n                i64_new(rightValue)\n              )));\n            }\n          }\n        }\n        let instance = isWasm64\n          ? this.i64PowInstance\n          : this.i32PowInstance;\n        if (!instance) {\n          let prototype = this.program.lookup(isWasm64\n            ? CommonNames.ipow64\n            : CommonNames.ipow32\n          );\n          if (!prototype) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, isWasm64 ? \"ipow64\" : \"ipow32\"\n            );\n            return module.unreachable();\n          }\n          assert(prototype.kind == ElementKind.FunctionPrototype);\n          instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n          if (isWasm64) {\n            this.i64PowInstance = instance;\n          } else {\n            this.i32PowInstance = instance;\n          }\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n      case TypeKind.F32: {\n        if (this.options.willOptimize) {\n          // Precompute power if LHS and RHS constants\n          // TODO: move this optimization to AIR\n          if (\n            getExpressionId(leftExpr)  == ExpressionId.Const &&\n            getExpressionId(rightExpr) == ExpressionId.Const\n          ) {\n            let leftValue  = getConstValueF32(leftExpr);\n            let rightValue = getConstValueF32(rightExpr);\n            this.currentType = type;\n            return module.f32(f32(accuratePow64(leftValue, rightValue)));\n          }\n        }\n        let instance = this.f32PowInstance;\n        if (!instance) {\n          let namespace = this.program.lookup(CommonNames.Mathf);\n          if (!namespace) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Mathf\"\n            );\n            return module.unreachable();\n          }\n          let prototype = namespace.getMember(CommonNames.pow);\n          if (!prototype) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Mathf.pow\"\n            );\n            return module.unreachable();\n          }\n          assert(prototype.kind == ElementKind.FunctionPrototype);\n          this.f32PowInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n      // Math.pow otherwise (result is f64)\n      case TypeKind.F64: {\n        if (this.options.willOptimize) {\n          // Precompute power if LHS and RHS constants\n          // TODO: move this optimization to AIR\n          if (\n            getExpressionId(leftExpr)  == ExpressionId.Const &&\n            getExpressionId(rightExpr) == ExpressionId.Const\n          ) {\n            let leftValue  = getConstValueF64(leftExpr);\n            let rightValue = getConstValueF64(rightExpr);\n            this.currentType = type;\n            return module.f64(accuratePow64(leftValue, rightValue));\n          }\n        }\n        let instance = this.f64PowInstance;\n        if (!instance) {\n          let namespace = this.program.lookup(CommonNames.Math);\n          if (!namespace) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Math\"\n            );\n            return module.unreachable();\n          }\n          let prototype = namespace.getMember(CommonNames.pow);\n          if (!prototype) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Math.pow\"\n            );\n            return module.unreachable();\n          }\n          assert(prototype.kind == ElementKind.FunctionPrototype);\n          this.f64PowInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeDiv(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits and signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.DivI32, leftExpr, rightExpr);\n      case TypeKind.I64: return module.binary(BinaryOp.DivI64, leftExpr, rightExpr);\n      case TypeKind.Isize: return module.binary(BinaryOp.DivISize, leftExpr, rightExpr);\n      case TypeKind.Bool:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: return module.binary(BinaryOp.DivU32, leftExpr, rightExpr);\n      case TypeKind.U64: return module.binary(BinaryOp.DivU64, leftExpr, rightExpr);\n      case TypeKind.Usize: return module.binary(BinaryOp.DivUSize, leftExpr, rightExpr);\n      case TypeKind.F32: return module.binary(BinaryOp.DivF32, leftExpr, rightExpr);\n      case TypeKind.F64: return module.binary(BinaryOp.DivF64, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeRem(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    // Cares about garbage bits and signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.RemI32, leftExpr, rightExpr);\n      case TypeKind.I64: return module.binary(BinaryOp.RemI64, leftExpr, rightExpr);\n      case TypeKind.Isize: return module.binary(BinaryOp.RemISize, leftExpr, rightExpr);\n      case TypeKind.Bool:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: return module.binary(BinaryOp.RemU32, leftExpr, rightExpr);\n      case TypeKind.U64: return module.binary(BinaryOp.RemU64, leftExpr, rightExpr);\n      case TypeKind.Usize: return module.binary(BinaryOp.RemUSize, leftExpr, rightExpr);\n      case TypeKind.F32: {\n        let instance = this.f32ModInstance;\n        if (!instance) {\n          let namespace = this.program.lookup(CommonNames.Mathf);\n          if (!namespace) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Mathf\"\n            );\n            return module.unreachable();\n          }\n          let prototype = namespace.getMember(CommonNames.mod);\n          if (!prototype) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Mathf.mod\"\n            );\n            return module.unreachable();\n          }\n          assert(prototype.kind == ElementKind.FunctionPrototype);\n          this.f32ModInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n      case TypeKind.F64: {\n        let instance = this.f64ModInstance;\n        if (!instance) {\n          let namespace = this.program.lookup(CommonNames.Math);\n          if (!namespace) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Math\"\n            );\n            return module.unreachable();\n          }\n          let prototype = namespace.getMember(CommonNames.mod);\n          if (!prototype) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Math.mod\"\n            );\n            return module.unreachable();\n          }\n          assert(prototype.kind == ElementKind.FunctionPrototype);\n          this.f64ModInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeShl(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits on the RHS, but only for types smaller than 5 bits\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool: return leftExpr;\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        // leftExpr << (rightExpr & (7|15))\n        return module.binary(\n          BinaryOp.ShlI32,\n          leftExpr,\n          module.binary(\n            BinaryOp.AndI32,\n            rightExpr,\n            module.i32(type.size - 1)\n          )\n        );\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.ShlI32, leftExpr, rightExpr);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.ShlI64, leftExpr, rightExpr);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.ShlSize, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeShr(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits on the LHS, but on the RHS only for types smaller than 5 bits,\n    // and signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool: return leftExpr;\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        // leftExpr >> (rightExpr & (7|15))\n        return module.binary(\n          BinaryOp.ShrI32,\n          this.ensureSmallIntegerWrap(leftExpr, type),\n          module.binary(\n            BinaryOp.AndI32,\n            rightExpr,\n            module.i32(type.size - 1)\n          )\n        );\n      }\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        // leftExpr >>> (rightExpr & (7|15))\n        return module.binary(\n          BinaryOp.ShrU32,\n          this.ensureSmallIntegerWrap(leftExpr, type),\n          module.binary(\n            BinaryOp.AndI32,\n            rightExpr,\n            module.i32(type.size - 1)\n          )\n        );\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.ShrI32, leftExpr, rightExpr);\n      case TypeKind.I64: return module.binary(BinaryOp.ShrI64, leftExpr, rightExpr);\n      case TypeKind.Isize: return module.binary(BinaryOp.ShrISize, leftExpr, rightExpr);\n      case TypeKind.U32: return module.binary(BinaryOp.ShrU32, leftExpr, rightExpr);\n      case TypeKind.U64: return module.binary(BinaryOp.ShrU64, leftExpr, rightExpr);\n      case TypeKind.Usize: return module.binary(BinaryOp.ShrUSize, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeShru(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits on the LHS, but on the RHS only for types smaller than 5 bits\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool: return leftExpr;\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        // leftExpr >>> (rightExpr & (7|15))\n        return module.binary(\n          BinaryOp.ShrU32,\n          this.ensureSmallIntegerWrap(leftExpr, type),\n          module.binary(\n            BinaryOp.AndI32,\n            rightExpr,\n            module.i32(type.size - 1)\n          )\n        );\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.ShrU32, leftExpr, rightExpr);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.ShrU64, leftExpr, rightExpr);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.ShrUSize, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeAnd(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32: return module.binary(BinaryOp.AndI32, leftExpr, rightExpr);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.AndI64, leftExpr, rightExpr);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.AndSize, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeOr(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: return module.binary(BinaryOp.OrI32, leftExpr, rightExpr);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.OrI32, leftExpr, rightExpr);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.OrI64, leftExpr, rightExpr);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.OrSize, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeXor(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: return module.binary(BinaryOp.XorI32, leftExpr, rightExpr);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.XorI32, leftExpr, rightExpr);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.XorI64, leftExpr, rightExpr);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.XorSize, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  private compileUnaryOverload(\n    operatorInstance: Function,\n    value: Expression,\n    valueExpr: ExpressionRef,\n    reportNode: Node\n  ): ExpressionRef {\n    // FIXME: see comment in compileBinaryOverload below why recompiling on type mismatch\n    // is a bad idea currently. so this assumes that the type matches.\n    return this.makeCallDirect(operatorInstance, [ valueExpr ], reportNode, false);\n  }\n\n  private compileBinaryOverload(\n    operatorInstance: Function,\n    left: Expression,\n    leftExpr: ExpressionRef,\n    leftType: Type,\n    right: Expression,\n    reportNode: Node\n  ): ExpressionRef {\n    let rightType: Type;\n    let signature = operatorInstance.signature;\n    let parameterTypes = signature.parameterTypes;\n    if (operatorInstance.is(CommonFlags.Instance)) {\n      leftExpr = this.convertExpression(leftExpr, leftType, assert(signature.thisType), false, left);\n      rightType = parameterTypes[0];\n    } else {\n      leftExpr = this.convertExpression(leftExpr, leftType, parameterTypes[0], false, left);\n      rightType = parameterTypes[1];\n    }\n    let rightExpr = this.compileExpression(right, rightType, Constraints.ConvImplicit);\n    return this.makeCallDirect(operatorInstance, [ leftExpr, rightExpr ], reportNode);\n  }\n\n\n  private compileCommutativeBinaryOverload(\n    operatorInstance: Function,\n    first: Expression,\n    firstExpr: ExpressionRef,\n    firstType: Type,\n    second: Expression,\n    secondExpr: ExpressionRef,\n    secondType: Type,\n    reportNode: Node\n  ): ExpressionRef {\n    let signature = operatorInstance.signature;\n    let parameterTypes = signature.parameterTypes;\n    if (operatorInstance.is(CommonFlags.Instance)) {\n      firstExpr = this.convertExpression(firstExpr, firstType, assert(signature.thisType), false, first);\n      secondExpr = this.convertExpression(secondExpr, secondType, parameterTypes[0], false, second);\n    } else {\n      firstExpr = this.convertExpression(firstExpr, firstType, parameterTypes[0], false, first);\n      secondExpr = this.convertExpression(secondExpr, secondType, parameterTypes[1], false, second);\n    }\n    return this.makeCallDirect(operatorInstance, [ firstExpr, secondExpr ], reportNode);\n  }\n\n  private compileAssignment(\n    expression: Expression,\n    valueExpression: Expression,\n    contextualType: Type\n  ): ExpressionRef {\n    let program = this.program;\n    let resolver = program.resolver;\n    let flow = this.currentFlow;\n    let target = resolver.lookupExpression(expression, flow); // reports\n    if (!target) return this.module.unreachable();\n    let thisExpression = resolver.currentThisExpression;\n    let elementExpression = resolver.currentElementExpression;\n\n    // to compile just the value, we need to know the target's type\n    let targetType: Type;\n    switch (target.kind) {\n      case ElementKind.Global:\n      case ElementKind.Local: {\n        if (target.kind == ElementKind.Global) {\n          if (!this.compileGlobalLazy(<Global>target, expression)) {\n            return this.module.unreachable();\n          }\n        } else if (!(<Local>target).declaredByFlow(flow)) {\n          // TODO: closures\n          this.error(\n            DiagnosticCode.Not_implemented_0,\n            expression.range,\n            \"Closures\"\n          );\n          return this.module.unreachable();\n        }\n        if (this.pendingElements.has(target)) {\n          this.error(\n            DiagnosticCode.Variable_0_used_before_its_declaration,\n            expression.range,\n            target.internalName\n          );\n          return this.module.unreachable();\n        }\n        targetType = (<VariableLikeElement>target).type;\n        if (target.hasDecorator(DecoratorFlags.Unsafe)) this.checkUnsafe(expression);\n        break;\n      }\n      case ElementKind.PropertyPrototype: {\n        let propertyPrototype = <PropertyPrototype>target;\n        let propertyInstance = resolver.resolveProperty(propertyPrototype);\n        if (!propertyInstance) return this.module.unreachable();\n        target = propertyInstance;\n        // fall-through\n      }\n      case ElementKind.Property: {\n        let propertyInstance = <Property>target;\n        if (propertyInstance.isField) {\n          if (this.pendingElements.has(target)) {\n            this.error(\n              DiagnosticCode.Variable_0_used_before_its_declaration,\n              expression.range,\n              target.internalName\n            );\n            return this.module.unreachable();\n          }\n        }\n        let setterInstance = propertyInstance.setterInstance;\n        if (!setterInstance) {\n          this.error(\n            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n            expression.range, propertyInstance.internalName\n          );\n          return this.module.unreachable();\n        }\n        assert(setterInstance.signature.parameterTypes.length == 1); // parser must guarantee this\n        targetType = setterInstance.signature.parameterTypes[0];\n        if (setterInstance.hasDecorator(DecoratorFlags.Unsafe)) this.checkUnsafe(expression);\n        break;\n      }\n      case ElementKind.IndexSignature: {\n        let parent = (<IndexSignature>target).parent;\n        assert(parent.kind == ElementKind.Class);\n        let classInstance = <Class>parent;\n        let isUnchecked = flow.is(FlowFlags.UncheckedContext);\n        let indexedSet = classInstance.lookupOverload(OperatorKind.IndexedSet, isUnchecked);\n        if (!indexedSet) {\n          let indexedGet = classInstance.lookupOverload(OperatorKind.IndexedGet, isUnchecked);\n          if (!indexedGet) {\n            this.error(\n              DiagnosticCode.Index_signature_is_missing_in_type_0,\n              expression.range, classInstance.internalName\n            );\n          } else {\n            this.error(\n              DiagnosticCode.Index_signature_in_type_0_only_permits_reading,\n              expression.range, classInstance.internalName\n            );\n          }\n          return this.module.unreachable();\n        }\n        let parameterTypes = indexedSet.signature.parameterTypes;\n\n        assert(parameterTypes.length == 2); // parser must guarantee this\n        targetType = parameterTypes[1];     // 2nd parameter is the element\n\n        if (indexedSet.hasDecorator(DecoratorFlags.Unsafe)) this.checkUnsafe(expression);\n        if (!isUnchecked && this.options.pedantic) {\n          this.pedantic(\n            DiagnosticCode.Indexed_access_may_involve_bounds_checking,\n            expression.range\n          );\n        }\n        break;\n      }\n      default: {\n        this.error(\n          DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n          expression.range, target.internalName\n        );\n        return this.module.unreachable();\n      }\n    }\n\n    // compile the value and do the assignment\n    assert(targetType != Type.void);\n    let valueExpr = this.compileExpression(valueExpression, targetType);\n    let valueType = this.currentType;\n    if (targetType.isNullableReference && this.currentFlow.isNonnull(valueExpr, valueType)) targetType = targetType.nonNullableType;\n    return this.makeAssignment(\n      target,\n      this.convertExpression(valueExpr, valueType, targetType, false, valueExpression),\n      targetType,\n      valueExpression,\n      thisExpression,\n      elementExpression,\n      contextualType != Type.void\n    );\n  }\n\n  /** Makes an assignment expression or block, assigning a value to a target. */\n  makeAssignment(\n    /** Target element, e.g. a Local. */\n    target: Element,\n    /** Value expression that has been compiled in a previous step already. */\n    valueExpr: ExpressionRef,\n    /** Value expression type. */\n    valueType: Type,\n    /** Expression reference. Has already been compiled to `valueExpr`. */\n    valueExpression: Expression,\n    /** `this` expression reference if a field or property set. */\n    thisExpression: Expression | null,\n    /** Index expression reference if an indexed set. */\n    indexExpression: Expression | null,\n    /** Whether to tee the value. */\n    tee: bool\n  ): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n\n    switch (target.kind) {\n      case ElementKind.Local: {\n        let local = <Local>target;\n        if (flow.isLocalFlag(local.index, LocalFlags.Constant, true)) {\n          this.error(\n            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n            valueExpression.range, target.internalName\n          );\n          this.currentType = tee ? local.type : Type.void;\n          return module.unreachable();\n        }\n        return this.makeLocalAssignment(local, valueExpr, valueType, tee);\n      }\n      case ElementKind.Global: {\n        let global = <Global>target;\n        if (!this.compileGlobalLazy(global, valueExpression)) {\n          return module.unreachable();\n        }\n        if (target.isAny(CommonFlags.Const | CommonFlags.Readonly)) {\n          this.error(\n            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n            valueExpression.range,\n            target.internalName\n          );\n          this.currentType = tee ? global.type : Type.void;\n          return module.unreachable();\n        }\n        return this.makeGlobalAssignment(global, valueExpr, valueType, tee);\n      }\n      case ElementKind.PropertyPrototype: {\n        let propertyInstance = this.resolver.resolveProperty(<PropertyPrototype>target);\n        if (!propertyInstance) return module.unreachable();\n        target = propertyInstance;\n        // fall-through\n      }\n      case ElementKind.Property: {\n        let propertyInstance = <Property>target;\n        if (propertyInstance.isField) {\n          // Cannot assign to readonly fields except in constructors if there's no initializer\n          let isConstructor = flow.sourceFunction.is(CommonFlags.Constructor);\n          if (propertyInstance.is(CommonFlags.Readonly)) {\n            let initializerNode = propertyInstance.initializerNode;\n            if (!isConstructor || initializerNode) {\n              this.error(\n                DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n                valueExpression.range, propertyInstance.internalName\n              );\n              return module.unreachable();\n            }\n          }\n          // Mark initialized fields in constructors\n          thisExpression = assert(thisExpression);\n          if (isConstructor && thisExpression.kind == NodeKind.This) {\n            flow.setThisFieldFlag(propertyInstance, FieldFlags.Initialized);\n          }\n        }\n        let setterInstance = propertyInstance.setterInstance;\n        if (!setterInstance) {\n          this.error(\n            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n            valueExpression.range, target.internalName\n          );\n          return module.unreachable();\n        }\n        assert(setterInstance.signature.parameterTypes.length == 1);\n        assert(setterInstance.signature.returnType == Type.void);\n        if (propertyInstance.is(CommonFlags.Instance)) {\n          let thisType = assert(setterInstance.signature.thisType);\n          let thisExpr = this.compileExpression(\n            assert(thisExpression),\n            thisType,\n            Constraints.ConvImplicit | Constraints.IsThis\n          );\n          if (!tee) return this.makeCallDirect(setterInstance, [ thisExpr, valueExpr ], valueExpression);\n          let tempLocal = flow.getTempLocal(valueType);\n          let valueTypeRef = valueType.toRef();\n          let ret = module.block(null, [\n            this.makeCallDirect(setterInstance, [\n              thisExpr,\n              module.local_tee(tempLocal.index, valueExpr, valueType.isManaged, valueTypeRef)\n            ], valueExpression),\n            module.local_get(tempLocal.index, valueTypeRef),\n          ], valueTypeRef);\n          this.currentType = valueType;\n          return ret;\n        } else {\n          if (!tee) return this.makeCallDirect(setterInstance, [ valueExpr ], valueExpression);\n          let tempLocal = flow.getTempLocal(valueType);\n          let valueTypeRef = valueType.toRef();\n          let ret = module.block(null, [\n            this.makeCallDirect(setterInstance, [\n              module.local_tee(tempLocal.index, valueExpr, valueType.isManaged, valueTypeRef),\n            ], valueExpression),\n            module.local_get(tempLocal.index, valueTypeRef),\n          ], valueTypeRef);\n          this.currentType = valueType;\n          return ret;\n        }\n      }\n      case ElementKind.IndexSignature: {\n        let indexSignature = <IndexSignature>target;\n        let parent = indexSignature.parent;\n        assert(parent.kind == ElementKind.Class);\n        let classInstance = <Class>parent;\n        assert(classInstance.kind == ElementKind.Class);\n        let isUnchecked = flow.is(FlowFlags.UncheckedContext);\n        let getterInstance = classInstance.lookupOverload(OperatorKind.IndexedGet, isUnchecked);\n        if (!getterInstance) {\n          this.error(\n            DiagnosticCode.Index_signature_is_missing_in_type_0,\n            valueExpression.range, classInstance.internalName\n          );\n          return module.unreachable();\n        }\n        let setterInstance = classInstance.lookupOverload(OperatorKind.IndexedSet, isUnchecked);\n        if (!setterInstance) {\n          this.error(\n            DiagnosticCode.Index_signature_in_type_0_only_permits_reading,\n            valueExpression.range, classInstance.internalName\n          );\n          this.currentType = tee ? getterInstance.signature.returnType : Type.void;\n          return module.unreachable();\n        }\n        assert(setterInstance.signature.parameterTypes.length == 2);\n        let thisType = classInstance.type;\n        let thisExpr = this.compileExpression(\n          assert(thisExpression),\n          thisType,\n          Constraints.ConvImplicit | Constraints.IsThis\n        );\n        let setterIndexType = setterInstance.signature.parameterTypes[0];\n        let getterIndexType = getterInstance.signature.parameterTypes[0];\n        if (!setterIndexType.equals(getterIndexType)) {\n          this.errorRelated(\n            DiagnosticCode.Index_signature_accessors_in_type_0_differ_in_types,\n            getterInstance.identifierAndSignatureRange,\n            setterInstance.identifierAndSignatureRange,\n            classInstance.internalName,\n          );\n          this.currentType = tee ? getterInstance.signature.returnType : Type.void;\n          return module.unreachable();\n        }\n        let elementExpr = this.compileExpression(assert(indexExpression), setterIndexType, Constraints.ConvImplicit);\n        let elementType = this.currentType;\n        if (tee) {\n          let tempTarget = flow.getTempLocal(thisType);\n          let tempElement = flow.getTempLocal(elementType);\n          let returnType = getterInstance.signature.returnType;\n          let ret = module.block(null, [\n            this.makeCallDirect(setterInstance, [\n              module.local_tee(tempTarget.index, thisExpr, thisType.isManaged),\n              module.local_tee(tempElement.index, elementExpr, elementType.isManaged),\n              valueExpr\n            ], valueExpression),\n            this.makeCallDirect(getterInstance, [\n              module.local_get(tempTarget.index, tempTarget.type.toRef()),\n              module.local_get(tempElement.index, tempElement.type.toRef())\n            ], valueExpression)\n          ], returnType.toRef());\n          return ret;\n        } else {\n          return this.makeCallDirect(setterInstance, [\n            thisExpr,\n            elementExpr,\n            valueExpr\n          ], valueExpression);\n        }\n      }\n      default: {\n        this.error(\n          DiagnosticCode.The_target_of_an_assignment_must_be_a_variable_or_a_property_access,\n          valueExpression.range\n        );\n      }\n    }\n    return module.unreachable();\n  }\n\n  /** Makes an assignment to a local, keeping track of wrap and null states. */\n  private makeLocalAssignment(\n    /** Local to assign to. */\n    local: Local,\n    /** Value to assign. */\n    valueExpr: ExpressionRef,\n    /** Value type. */\n    valueType: Type,\n    /** Whether to tee the value. */\n    tee: bool\n  ): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n    let type = local.type;\n    assert(type != Type.void);\n    let localIndex = local.index;\n\n    if (type.isNullableReference) {\n      if (!valueType.isNullableReference || flow.isNonnull(valueExpr, type)) flow.setLocalFlag(localIndex, LocalFlags.NonNull);\n      else flow.unsetLocalFlag(localIndex, LocalFlags.NonNull);\n    }\n    flow.setLocalFlag(localIndex, LocalFlags.Initialized);\n    if (type.isShortIntegerValue) {\n      if (!flow.canOverflow(valueExpr, type)) flow.setLocalFlag(localIndex, LocalFlags.Wrapped);\n      else flow.unsetLocalFlag(localIndex, LocalFlags.Wrapped);\n    }\n    if (tee) { // local = value\n      this.currentType = type;\n      return module.local_tee(localIndex, valueExpr, type.isManaged);\n    } else { // void(local = value)\n      this.currentType = Type.void;\n      return module.local_set(localIndex, valueExpr, type.isManaged);\n    }\n  }\n\n  /** Makes an assignment to a global. */\n  private makeGlobalAssignment(\n    /** The global variable to assign to. */\n    global: VariableLikeElement,\n    /** The value to assign. */\n    valueExpr: ExpressionRef,\n    /** The type of the value to assign. */\n    valueType: Type,\n    /** Whether to tee the value. */\n    tee: bool\n  ): ExpressionRef {\n    let module = this.module;\n    let type = global.type;\n    assert(type != Type.void);\n    let typeRef = type.toRef();\n\n    valueExpr = this.ensureSmallIntegerWrap(valueExpr, type); // globals must be wrapped\n    if (tee) { // (global = value), global\n      this.currentType = type;\n      return module.block(null, [\n        module.global_set(global.internalName, valueExpr),\n        module.global_get(global.internalName, typeRef) // known to be assigned now\n      ], typeRef);\n    } else { // global = value\n      this.currentType = Type.void;\n      return module.global_set(global.internalName,\n        valueExpr\n      );\n    }\n  }\n\n  /** Compiles a call expression according to the specified context. */\n  private compileCallExpression(\n    /** Call expression to compile. */\n    expression: CallExpression,\n    /** Contextual type indicating the return type the caller expects, if any. */\n    contextualType: Type,\n    /** Constraints indicating contextual conditions. */\n    constraints: Constraints\n  ): ExpressionRef {\n\n    let module = this.module;\n    let flow = this.currentFlow;\n\n    // handle call to super\n    if (expression.expression.kind == NodeKind.Super) {\n      let flow = this.currentFlow;\n      let sourceFunction = flow.sourceFunction;\n      if (!sourceFunction.is(CommonFlags.Constructor)) {\n        this.error(\n          DiagnosticCode.Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors,\n          expression.range\n        );\n        return module.unreachable();\n      }\n\n      let parent = assert(sourceFunction.parent);\n      assert(parent.kind == ElementKind.Class);\n      let classInstance = <Class>parent;\n      let baseClassInstance = classInstance.base;\n      if (!baseClassInstance || classInstance.prototype.implicitlyExtendsObject) {\n        this.error(\n          DiagnosticCode._super_can_only_be_referenced_in_a_derived_class,\n          expression.expression.range\n        );\n        return module.unreachable();\n      }\n      let thisLocal = assert(flow.lookupLocal(CommonNames.this_));\n      let sizeTypeRef = this.options.sizeTypeRef;\n\n      let baseCtorInstance = this.ensureConstructor(baseClassInstance, expression);\n      this.checkFieldInitialization(baseClassInstance, expression);\n      let superCall = this.compileCallDirect(\n        baseCtorInstance,\n        expression.args,\n        expression,\n        module.local_get(thisLocal.index, sizeTypeRef)\n      );\n\n      // check that super had been called before accessing `this`\n      if (flow.isAny(\n        FlowFlags.AccessesThis |\n        FlowFlags.ConditionallyAccessesThis\n      )) {\n        this.error(\n          DiagnosticCode._super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class,\n          expression.range\n        );\n        return module.unreachable();\n      }\n      flow.set(FlowFlags.AccessesThis | FlowFlags.CallsSuper);\n      this.currentType = Type.void;\n      return module.local_set(thisLocal.index, superCall, classInstance.type.isManaged);\n    }\n\n    // otherwise resolve normally\n    let target = this.resolver.lookupExpression(expression.expression, flow); // reports\n    if (!target) return module.unreachable();\n    let thisExpression = this.resolver.currentThisExpression;\n\n    // handle direct call\n    switch (target.kind) {\n      case ElementKind.FunctionPrototype: {\n        let functionPrototype = <FunctionPrototype>target;\n        if (functionPrototype.hasDecorator(DecoratorFlags.Builtin)) {\n          // builtins handle present respectively omitted type arguments on their own\n          return this.compileCallExpressionBuiltin(functionPrototype, expression, contextualType);\n        }\n        let functionInstance = this.resolver.maybeInferCall(expression, functionPrototype, flow);\n        if (!functionInstance) return this.module.unreachable();\n        target = functionInstance;\n        // fall-through\n      }\n      case ElementKind.Function: {\n        let functionInstance = <Function>target;\n        let thisArg: ExpressionRef = 0;\n        if (functionInstance.is(CommonFlags.Instance)) {\n          thisArg = this.compileExpression(\n            assert(thisExpression),\n            assert(functionInstance.signature.thisType),\n            Constraints.ConvImplicit | Constraints.IsThis\n          );\n        }\n        return this.compileCallDirect(\n          functionInstance,\n          expression.args,\n          expression,\n          thisArg,\n          constraints\n        );\n      }\n    }\n\n    // handle indirect call\n    let functionArg = this.compileExpression(expression.expression, Type.auto);\n    let signature = this.currentType.getSignature();\n    if (signature) {\n      return this.compileCallIndirect(\n        signature,\n        functionArg,\n        expression.args,\n        expression,\n        0,\n        contextualType == Type.void\n      );\n    }\n    this.error(\n      DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\n      expression.range, this.currentType.toString()\n    );\n    if (target.kind == ElementKind.PropertyPrototype) {\n      let getterPrototype = (<PropertyPrototype>target).getterPrototype;\n      if (getterPrototype) {\n        this.infoRelated(\n          DiagnosticCode.This_expression_is_not_callable_because_it_is_a_get_accessor_Did_you_mean_to_use_it_without,\n          expression.range, getterPrototype.identifierNode.range\n        );\n      }\n    }\n    return module.unreachable();\n  }\n\n  /** Compiles the given arguments like a call expression according to the specified context. */\n  private compileCallExpressionLike(\n    /** Called expression. */\n    expression: Expression,\n    /** Call type arguments. */\n    typeArguments: TypeNode[] | null,\n    /** Call arguments. */\n    args: Expression[],\n    /** Diagnostic range. */\n    range: Range,\n    /** Contextual type indicating the return type the caller expects, if any. */\n    contextualType: Type,\n    /** Constraints indicating contextual conditions. */\n    constraints: Constraints = Constraints.None\n  ): ExpressionRef {\n    // Desugaring like this can happen many times. Let's cache the intermediate allocation.\n    let call = this._reusableCallExpression;\n    if (call) {\n      call.expression = expression;\n      call.typeArguments = typeArguments;\n      call.args = args;\n      call.range = range;\n    } else {\n      this._reusableCallExpression = call = Node.createCallExpression(expression, typeArguments, args, range);\n    }\n    return this.compileCallExpression(call, contextualType, constraints);\n  }\n  private _reusableCallExpression: CallExpression | null = null;\n\n  private compileCallExpressionBuiltin(\n    prototype: FunctionPrototype,\n    expression: CallExpression,\n    contextualType: Type\n  ): ExpressionRef {\n    if (prototype.hasDecorator(DecoratorFlags.Unsafe)) this.checkUnsafe(expression);\n\n    let typeArguments: Type[] | null = null;\n\n    // builtins handle omitted type arguments on their own. if present, however, resolve them here\n    // and pass them to the builtin, even if it's still up to the builtin how to handle them.\n    let typeParameterNodes = prototype.typeParameterNodes;\n    let typeArgumentNodes = expression.typeArguments;\n    if (expression.typeArguments) {\n      if (!prototype.is(CommonFlags.Generic)) {\n        this.error(\n          DiagnosticCode.Type_0_is_not_generic,\n          expression.range, prototype.internalName\n        );\n      }\n      typeArguments = this.resolver.resolveTypeArguments(\n        assert(typeParameterNodes),\n        typeArgumentNodes,\n        this.currentFlow,\n        this.currentFlow.sourceFunction.parent,\n        cloneMap(this.currentFlow.contextualTypeArguments), // don't update\n        expression\n      );\n    }\n    let callee = expression.expression;\n    let ctx = new BuiltinFunctionContext(\n      this,\n      prototype,\n      typeArguments,\n      expression.args,\n      callee.kind == NodeKind.PropertyAccess\n        ? (<PropertyAccessExpression>callee).expression\n        : null,\n      contextualType,\n      expression,\n      false\n    );\n    let internalName: string;\n    if (prototype.is(CommonFlags.Instance)) {\n      // omit generic name components, e.g. in `Function<...>#call`\n      let parent = assert(prototype.getBoundClassOrInterface());\n      internalName = `${parent.prototype.internalName}#${prototype.name}`;\n    } else {\n      internalName = prototype.internalName;\n    }\n    assert(builtinFunctions.has(internalName)); // checked earlier\n    let fn = assert(builtinFunctions.get(internalName));\n    return fn(ctx);\n  }\n\n  /**\n   * Checks that a call with the given number as arguments can be performed according to the\n   * specified signature.\n   */\n  checkCallSignature(\n    signature: Signature,\n    numArguments: i32,\n    hasThis: bool,\n    reportNode: Node\n  ): bool {\n\n    // cannot call an instance method without a `this` argument (TODO: `.call`?)\n    let thisType = signature.thisType;\n    if (hasThis != (thisType != null)) {\n      this.error(\n        DiagnosticCode.The_this_types_of_each_signature_are_incompatible,\n        reportNode.range\n      );\n      return false;\n    }\n\n    let hasRest = signature.hasRest;\n    let minimum = signature.requiredParameters;\n    let maximum = signature.parameterTypes.length;\n\n    // must at least be called with required arguments\n    if (numArguments < minimum) {\n      this.error(\n        minimum < maximum\n          ? DiagnosticCode.Expected_at_least_0_arguments_but_got_1\n          : DiagnosticCode.Expected_0_arguments_but_got_1,\n        reportNode.range, minimum.toString(), numArguments.toString()\n      );\n      return false;\n    }\n\n    // must not be called with more than the maximum arguments\n    if (numArguments > maximum && !hasRest) {\n      this.error(\n        DiagnosticCode.Expected_0_arguments_but_got_1,\n        reportNode.range, maximum.toString(), numArguments.toString()\n      );\n      return false;\n    }\n\n    return true;\n  }\n\n  /** Checks that an unsafe expression is allowed. */\n  private checkUnsafe(reportNode: Node, relatedReportNode: Node | null = null): void {\n    // Library files may always use unsafe features\n    if (this.options.noUnsafe && !reportNode.range.source.isLibrary) {\n      if (relatedReportNode) {\n        this.errorRelated(\n          DiagnosticCode.Operation_is_unsafe,\n          reportNode.range, relatedReportNode.range\n        );\n      } else {\n        this.error(\n          DiagnosticCode.Operation_is_unsafe,\n          reportNode.range\n        );\n      }\n    }\n  }\n\n  private adjustArgumentsForRestParams(\n    argumentExpressions: Expression[],\n    signature: Signature,\n    reportNode: Node\n  ) : Expression[] {\n\n    // if no rest args, return the original args\n    if (!signature.hasRest) {\n      return argumentExpressions;\n    }\n\n    // if there are fewer args than params, then the rest args were not provided\n    // so return the original args\n    const numArguments = argumentExpressions.length;\n    const numParams = signature.parameterTypes.length;\n    if (numArguments < numParams) {\n      return argumentExpressions;\n    }\n      \n    // make an array literal expression from the rest args\n    let elements = argumentExpressions.slice(numParams - 1);\n    let range = new Range(elements[0].range.start, elements[elements.length - 1].range.end);\n    range.source = reportNode.range.source;\n    let arrExpr = new ArrayLiteralExpression(elements, range);\n    \n    // return the original args, but replace the rest args with the array\n    const exprs = argumentExpressions.slice(0, numParams - 1);\n    exprs.push(arrExpr);\n    return exprs;\n  }\n\n  /** Compiles a direct call to a concrete function. */\n  compileCallDirect(\n    instance: Function,\n    argumentExpressions: Expression[],\n    reportNode: Node,\n    thisArg: ExpressionRef = 0,\n    constraints: Constraints = Constraints.None\n  ): ExpressionRef {\n    let numArguments = argumentExpressions.length;\n    let signature = instance.signature;\n    if (!this.checkCallSignature( // reports\n      signature,\n      numArguments,\n      thisArg != 0,\n      reportNode\n    )) {\n      this.currentType = signature.returnType;\n      return this.module.unreachable();\n    }\n    if (instance.hasDecorator(DecoratorFlags.Unsafe)) this.checkUnsafe(reportNode);\n\n    argumentExpressions = this.adjustArgumentsForRestParams(argumentExpressions, signature, reportNode);\n    numArguments = argumentExpressions.length;\n\n    // handle call on `this` in constructors\n    let sourceFunction = this.currentFlow.sourceFunction;\n    if (sourceFunction.is(CommonFlags.Constructor) && reportNode.isAccessOnThis) {\n      let parent = sourceFunction.parent;\n      assert(parent.kind == ElementKind.Class);\n      this.checkFieldInitialization(<Class>parent, reportNode);\n    }\n\n    // Inline if explicitly requested\n    let inlineRequested = instance.hasDecorator(DecoratorFlags.Inline) || this.currentFlow.is(FlowFlags.InlineContext);\n    if (inlineRequested && (!instance.is(CommonFlags.Overridden) || reportNode.isAccessOnSuper)) {\n      assert(!instance.is(CommonFlags.Stub)); // doesn't make sense\n      let inlineStack = this.inlineStack;\n      if (inlineStack.includes(instance)) {\n        this.warning(\n          DiagnosticCode.Function_0_cannot_be_inlined_into_itself,\n          reportNode.range, instance.internalName\n        );\n      } else {\n        let parameterTypes = signature.parameterTypes;\n        assert(numArguments <= parameterTypes.length);\n        // compile argument expressions *before* pushing to the inline stack\n        // otherwise, the arguments may not be inlined, e.g. `abc(abc(123))`\n        let args = new Array<ExpressionRef>(numArguments);\n        for (let i = 0; i < numArguments; ++i) {\n          args[i] = this.compileExpression(argumentExpressions[i], parameterTypes[i], Constraints.ConvImplicit);\n        }\n        // make the inlined call\n        inlineStack.push(instance);\n        let expr = this.makeCallInline(instance, args, thisArg, (constraints & Constraints.WillDrop) != 0);\n        inlineStack.pop();\n        return expr;\n      }\n    }\n\n    // Otherwise compile to just a call\n    let numArgumentsInclThis = thisArg ? numArguments + 1 : numArguments;\n    let operands = new Array<ExpressionRef>(numArgumentsInclThis);\n    let index = 0;\n    if (thisArg) {\n      operands[0] = thisArg;\n      index = 1;\n    }\n    let parameterTypes = signature.parameterTypes;\n    for (let i = 0; i < numArguments; ++i, ++index) {\n      let paramType = parameterTypes[i];\n      let paramExpr = this.compileExpression(argumentExpressions[i], paramType, Constraints.ConvImplicit);\n      operands[index] = paramExpr;\n    }\n    assert(index == numArgumentsInclThis);\n    return this.makeCallDirect(instance, operands, reportNode, (constraints & Constraints.WillDrop) != 0);\n  }\n\n  makeCallInline(\n    instance: Function,\n    operands: ExpressionRef[] | null,\n    thisArg: ExpressionRef = 0,\n    immediatelyDropped: bool = false\n  ): ExpressionRef {\n    let module = this.module;\n    let numArguments = operands ? operands.length : 0;\n    let signature = instance.signature;\n    let parameterTypes = signature.parameterTypes;\n    let numParameters = parameterTypes.length;\n\n    // Create a new inline flow and use it to compile the function as a block\n    let previousFlow = this.currentFlow;\n    let flow = Flow.createInline(previousFlow.targetFunction, instance);\n    let body = [];\n\n    if (thisArg) {\n      let parent = assert(instance.parent);\n      assert(parent.kind == ElementKind.Class);\n      let classInstance = <Class>parent;\n      let thisType = assert(instance.signature.thisType);\n      let thisLocal = flow.addScopedLocal(CommonNames.this_, thisType);\n      body.push(\n        module.local_set(thisLocal.index, thisArg, thisType.isManaged)\n      );\n      flow.setLocalFlag(thisLocal.index, LocalFlags.Initialized);\n      let base = classInstance.base;\n      if (base) flow.addScopedAlias(CommonNames.super_, base.type, thisLocal.index);\n    } else {\n      assert(!instance.signature.thisType);\n    }\n    for (let i = 0; i < numArguments; ++i) {\n      let paramExpr = operands![i];\n      let paramType = parameterTypes[i];\n      let argumentLocal = flow.addScopedLocal(instance.getParameterName(i), paramType);\n      // inlining is aware of wrap/nonnull states:\n      if (!previousFlow.canOverflow(paramExpr, paramType)) flow.setLocalFlag(argumentLocal.index, LocalFlags.Wrapped);\n      if (flow.isNonnull(paramExpr, paramType)) flow.setLocalFlag(argumentLocal.index, LocalFlags.NonNull);\n      body.push(\n        module.local_set(argumentLocal.index, paramExpr, paramType.isManaged)\n      );\n      flow.setLocalFlag(argumentLocal.index, LocalFlags.Initialized);\n    }\n\n    // Compile omitted arguments with final argument locals blocked. Doesn't need to take care of\n    // side-effects within earlier expressions because these already happened on set.\n    this.currentFlow = flow;\n    let isConstructor = instance.is(CommonFlags.Constructor);\n    if (isConstructor) flow.set(FlowFlags.CtorParamContext);\n    for (let i = numArguments; i < numParameters; ++i) {\n      let initType = parameterTypes[i];\n      let initExpr = this.compileExpression(\n        assert(instance.prototype.functionTypeNode.parameters[i].initializer),\n        initType,\n        Constraints.ConvImplicit\n      );\n      let argumentLocal = flow.addScopedLocal(instance.getParameterName(i), initType);\n      body.push(\n        this.makeLocalAssignment(argumentLocal, initExpr, initType, false)\n      );\n    }\n    flow.unset(FlowFlags.CtorParamContext);\n\n    // Compile the called function's body in the scope of the inlined flow\n    this.compileFunctionBody(instance, body);\n\n    // If a constructor, perform field init checks on its flow directly\n    if (isConstructor) {\n      let parent = instance.parent;\n      assert(parent.kind == ElementKind.Class);\n      this.checkFieldInitializationInFlow(<Class>parent, flow);\n    }\n\n    // Free any new scoped locals and reset to the original flow\n    let returnType = flow.returnType;\n    this.currentFlow = previousFlow;\n\n    // Create an outer block that we can break to when returning a value out of order\n    this.currentType = returnType;\n    return module.block(flow.inlineReturnLabel, body, returnType.toRef());\n  }\n\n  /** Makes sure that the arguments length helper global is present. */\n  ensureArgumentsLength(): string {\n    let name = BuiltinNames.argumentsLength;\n    if (!this.builtinArgumentsLength) {\n      let module = this.module;\n      this.builtinArgumentsLength = module.addGlobal(name, TypeRef.I32, true, module.i32(0));\n    }\n    return name;\n  }\n\n  /** Ensures compilation of the varargs stub for the specified function. */\n  ensureVarargsStub(original: Function): Function {\n    // A varargs stub is a function called with omitted arguments being zeroed,\n    // reading the `argumentsLength` helper global to decide which initializers\n    // to inject before calling the original function. It is typically attempted\n    // to circumvent the varargs stub where possible, for example where omitted\n    // arguments are constants and can be inlined into the original call.\n    let stub = original.varargsStub;\n    if (stub) return stub;\n\n    let originalSignature = original.signature;\n    let originalParameterTypes = originalSignature.parameterTypes;\n    let originalParameterDeclarations = original.prototype.functionTypeNode.parameters;\n    let returnType = originalSignature.returnType;\n    let isInstance = original.is(CommonFlags.Instance);\n\n    // arguments excl. `this`, operands incl. `this`\n    let minArguments = originalSignature.requiredParameters;\n    let minOperands = minArguments;\n    let maxArguments = originalParameterTypes.length;\n    let maxOperands = maxArguments;\n    if (isInstance) {\n      ++minOperands;\n      ++maxOperands;\n    }\n    let numOptional = assert(maxOperands - minOperands);\n\n    let forwardedOperands = new Array<ExpressionRef>(minOperands);\n    let operandIndex = 0;\n    let stmts = new Array<ExpressionRef>();\n\n    // forward `this` if applicable\n    let module = this.module;\n    let thisType = originalSignature.thisType;\n    if (thisType) {\n      forwardedOperands[0] = module.local_get(0, thisType.toRef());\n      operandIndex = 1;\n    }\n\n    // forward required arguments\n    for (let i = 0; i < minArguments; ++i, ++operandIndex) {\n      let paramType = originalParameterTypes[i];\n      forwardedOperands[operandIndex] = module.local_get(operandIndex, paramType.toRef());\n    }\n    assert(operandIndex == minOperands);\n\n    // create the varargs stub\n    stub = original.newStub(\"varargs\", maxArguments);\n\n    original.varargsStub = stub;\n\n    // compile initializers of omitted arguments in the scope of the stub,\n    // accounting for additional locals and a proper `this` context.\n    let previousFlow = this.currentFlow;\n    let flow = stub.flow;\n    if (original.is(CommonFlags.Constructor)) flow.set(FlowFlags.CtorParamContext);\n    this.currentFlow = flow;\n\n    // create a br_table switching over the number of optional parameters provided\n    let numNames = numOptional + 1; // incl. outer block\n    let names = new Array<string>(numNames);\n    let ofN = `of${numOptional}`;\n    for (let i = 0; i < numNames; ++i) {\n      names[i] = `${i}${ofN}`;\n    }\n    let argumentsLength = this.ensureArgumentsLength();\n    let table = module.block(names[0], [\n      module.block(\"outOfRange\", [\n        module.switch(names, \"outOfRange\",\n          // condition is number of provided optional arguments, so subtract required arguments\n          minArguments\n            ? module.binary(\n                BinaryOp.SubI32,\n                module.global_get(argumentsLength, TypeRef.I32),\n                module.i32(minArguments)\n              )\n            : module.global_get(argumentsLength, TypeRef.I32)\n        )\n      ]),\n      module.unreachable()\n    ]);\n    for (let i = 0; i < numOptional; ++i, ++operandIndex) {\n      let type = originalParameterTypes[minArguments + i];\n      let declaration = originalParameterDeclarations[minArguments + i];\n      let initializer = declaration.initializer;\n      let initExpr: ExpressionRef;\n      if (declaration.parameterKind === ParameterKind.Rest) {\n        const arrExpr = new ArrayLiteralExpression([], declaration.range.atEnd);       \n        initExpr = this.compileArrayLiteral(arrExpr, type, Constraints.ConvExplicit);\n        initExpr = module.local_set(operandIndex, initExpr, type.isManaged);        \n      } else if (initializer) {\n        initExpr = this.compileExpression(\n          initializer,\n          type,\n          Constraints.ConvImplicit\n        );\n        initExpr = module.local_set(operandIndex, initExpr, type.isManaged);\n      } else {\n        this.error(\n          DiagnosticCode.Optional_parameter_must_have_an_initializer,\n          declaration.range\n        );\n        initExpr = module.unreachable();\n      }\n      table = module.block(names[i + 1], [\n        table,\n        initExpr,\n      ]);\n      forwardedOperands[operandIndex] = module.local_get(operandIndex, type.toRef());\n    }\n    assert(operandIndex == maxOperands);\n\n    stmts.push(\n      table\n    );\n    stmts.push(\n      // assume this will always succeed (can just use name as the reportNode)\n      this.makeCallDirect(original, forwardedOperands, original.declaration.name)\n    );\n    this.currentFlow = previousFlow;\n\n    let funcRef = module.addFunction(\n      stub.internalName,\n      stub.signature.paramRefs,\n      stub.signature.resultRefs,\n      typesToRefs(stub.getNonParameterLocalTypes()),\n      module.flatten(stmts, returnType.toRef())\n    );\n    stub.set(CommonFlags.Compiled);\n    stub.finalize(module, funcRef);\n    return stub;\n  }\n\n  /** Ensures compilation of the override stub for the specified function. */\n  ensureOverrideStub(original: Function): Function {\n    // An override stub is a function redirecting virtual calls to the actual\n    // override targeted by the call. It utilizes varargs stubs where necessary\n    // and as such has the same semantics as one. Here, we only make sure that\n    // a placeholder exist, with actual code being generated as a finalization\n    // step once module compilation is otherwise complete.\n    let stub = original.overrideStub;\n    if (stub) return stub;\n    stub = original.newStub(\"override\");\n    original.overrideStub = stub;\n    let module = this.module;\n    stub.ref = module.addFunction(\n      stub.internalName,\n      stub.signature.paramRefs,\n      stub.signature.resultRefs,\n      null,\n      module.unreachable()\n    );\n    this.overrideStubs.add(original);\n    return stub;\n  }\n\n  /** Finalizes the override stub of the specified function. */\n  private finalizeOverrideStub(instance: Function): void {\n    let stub = this.ensureOverrideStub(instance);\n    if (stub.is(CommonFlags.Compiled)) return;\n\n    assert(instance.parent.kind == ElementKind.Class || instance.parent.kind == ElementKind.Interface);\n    let module = this.module;\n    let usizeType = this.options.usizeType;\n    let sizeTypeRef = usizeType.toRef();\n    let parameterTypes = instance.signature.parameterTypes;\n    let returnType = instance.signature.returnType;\n    let numParameters = parameterTypes.length;\n    let tempIndex = 1 + parameterTypes.length; // incl. `this`\n\n    // Switch over this's rtId and map it to the respective overload\n    let builder = new SwitchBuilder(this.module,\n      module.load(4, false,\n        module.binary(\n          sizeTypeRef == TypeRef.I64\n            ? BinaryOp.SubI64\n            : BinaryOp.SubI32,\n          module.local_get(0, sizeTypeRef),\n          sizeTypeRef == TypeRef.I64\n            ? module.i64(8) // rtId offset = -8\n            : module.i32(8)\n        ),\n        TypeRef.I32\n      )\n    );\n    let overrideInstances = this.resolver.resolveOverrides(instance);\n    if (overrideInstances) {\n      let mostRecentInheritanceMapping = new Map<Class, Class>();\n      for (let i = 0, k = overrideInstances.length; i < k; ++i) {\n        let overrideInstance = overrideInstances[i];\n        if (!overrideInstance.is(CommonFlags.Compiled)) continue; // errored\n\n        let overrideSignature = overrideInstance.signature;\n        let originalSignature = instance.signature;\n\n        if (!overrideSignature.isAssignableTo(originalSignature, true)) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            overrideInstance.identifierNode.range, overrideSignature.toString(), originalSignature.toString()\n          );\n          continue;\n        }\n        // TODO: additional optional parameters are not permitted by `isAssignableTo` yet\n        let overrideParameterTypes = overrideSignature.parameterTypes;\n        let overrideNumParameters = overrideParameterTypes.length;\n        let paramExprs = new Array<ExpressionRef>(1 + overrideNumParameters);\n        paramExprs[0] = module.local_get(0, sizeTypeRef); // this\n        for (let n = 1; n <= numParameters; ++n) {\n          paramExprs[n] = module.local_get(n, parameterTypes[n - 1].toRef());\n        }\n        let needsVarargsStub = false;\n        for (let n = numParameters; n < overrideNumParameters; ++n) {\n          // TODO: inline constant initializers and skip varargs stub\n          paramExprs[1 + n] = this.makeZero(overrideParameterTypes[n]);\n          needsVarargsStub = true;\n        }\n        let calledName = needsVarargsStub\n          ? this.ensureVarargsStub(overrideInstance).internalName\n          : overrideInstance.internalName;\n        let returnTypeRef = overrideSignature.returnType.toRef();\n        let stmts = new Array<ExpressionRef>();\n        if (needsVarargsStub) {\n          // Safe to prepend since paramExprs are local.get's\n          stmts.push(module.global_set(this.ensureArgumentsLength(), module.i32(numParameters)));\n        }\n        if (returnType == Type.void) {\n          stmts.push(\n            module.call(calledName, paramExprs, returnTypeRef)\n          );\n          stmts.push(\n            module.return()\n          );\n        } else {\n          stmts.push(\n            module.return(\n              module.call(calledName, paramExprs, returnTypeRef)\n            )\n          );\n        }\n        let classInstance = assert(overrideInstance.getBoundClassOrInterface());\n        builder.addCase(classInstance.id, stmts);\n        // Also alias each extender inheriting this exact overload\n        let extenders = classInstance.extenders;\n        if (extenders) {\n          for (let _values = Set_values(extenders), i = 0, k = _values.length; i < k; ++i) {\n            let extender = _values[i];\n            let instanceMembers = extender.prototype.instanceMembers;\n            if (instanceMembers && instanceMembers.has(instance.declaration.name.text)) {\n              continue; // skip those not inheriting\n            }\n            if (\n              !mostRecentInheritanceMapping.has(extender) ||\n              !assert(mostRecentInheritanceMapping.get(extender)).extends(classInstance)\n            ) {\n              mostRecentInheritanceMapping.set(extender, classInstance);\n              builder.addOrReplaceCase(extender.id, stmts);\n            }\n          }\n        }\n      }\n    }\n\n    // Call the original function if no other id matches and the method is not\n    // abstract or part of an interface. Note that doing so will not catch an\n    // invalid id, but can reduce code size significantly since we also don't\n    // have to add branches for extenders inheriting the original function.\n    let body: ExpressionRef;\n    let instanceClass = instance.getBoundClassOrInterface();\n    if (!instance.is(CommonFlags.Abstract) && !(instanceClass && instanceClass.kind == ElementKind.Interface)) {\n      let paramExprs = new Array<ExpressionRef>(numParameters);\n      paramExprs[0] = module.local_get(0, sizeTypeRef); // this\n      for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n        paramExprs[1 + i] = module.local_get(1 + i, parameterTypes[i].toRef());\n      }\n      body = module.call(instance.internalName, paramExprs, returnType.toRef());\n\n    // Otherwise trap\n    } else {\n      body = module.unreachable();\n    }\n\n    // Create the stub function\n    let ref = stub.ref;\n    if (ref) module.removeFunction(stub.internalName);\n    stub.ref = module.addFunction(\n      stub.internalName,\n      stub.signature.paramRefs,\n      stub.signature.resultRefs,\n      [ TypeRef.I32 ],\n      module.block(null, [\n        builder.render(tempIndex),\n        body\n      ], returnType.toRef())\n    );\n    stub.set(CommonFlags.Compiled);\n  }\n\n  private needToStack(expr: ExpressionRef): bool {\n    const precomp = this.module.runExpression(expr, ExpressionRunnerFlags.Default);\n    // cannot precompute, so must go to stack\n    if (precomp == 0) return true;\n    const value = getConstValueInteger(precomp, this.options.isWasm64);\n    // zero constant doesn't need to go to stack\n    if (i64_eq(value, i64_zero)) return false;\n    // static GC objects doesn't need to go to stack\n    let staticGcObjectOffsets = this.staticGcObjectOffsets;\n    if (staticGcObjectOffsets.has(i64_high(value))) {\n      if (assert(staticGcObjectOffsets.get(i64_high(value))).has(i64_low(value))) return false;\n    }\n    return true;\n  }\n\n  /** Marks managed call operands for the shadow stack. */\n  private operandsTostack(signature: Signature, operands: ExpressionRef[]): void {\n    if (!this.options.stackSize) return;\n    let module = this.module;\n    let operandIndex = 0;\n    let thisType = signature.thisType;\n    if (thisType) {\n      if (thisType.isManaged) {\n        let operand = operands[0];\n        if (this.needToStack(operand)) {\n          operands[operandIndex] = module.tostack(operand);\n        }\n      }\n      ++operandIndex;\n    }\n    let parameterIndex = 0;\n    let parameterTypes = signature.parameterTypes;\n    assert(parameterTypes.length >= operands.length - operandIndex);\n    while (operandIndex < operands.length) {\n      let paramType = parameterTypes[parameterIndex];\n      if (paramType.isManaged) {\n        let operand = operands[operandIndex];\n        if (this.needToStack(operand)) {\n          operands[operandIndex] = module.tostack(operand);\n        }\n      }\n      ++operandIndex;\n      ++parameterIndex;\n    }\n  }\n\n  /** Creates a direct call to the specified function. */\n  makeCallDirect(\n    instance: Function,\n    operands: ExpressionRef[] | null,\n    reportNode: Node,\n    immediatelyDropped: bool = false\n  ): ExpressionRef {\n    if (instance.hasDecorator(DecoratorFlags.Inline)) {\n      if (!instance.is(CommonFlags.Overridden)) {\n        assert(!instance.is(CommonFlags.Stub)); // doesn't make sense\n        let inlineStack = this.inlineStack;\n        if (inlineStack.includes(instance)) {\n          this.warning(\n            DiagnosticCode.Function_0_cannot_be_inlined_into_itself,\n            reportNode.range, instance.internalName\n          );\n        } else {\n          inlineStack.push(instance);\n          let expr: ExpressionRef;\n          if (instance.is(CommonFlags.Instance)) {\n            let theOperands = assert(operands);\n            assert(theOperands.length);\n            expr = this.makeCallInline(instance, theOperands.slice(1), theOperands[0], immediatelyDropped);\n          } else {\n            expr = this.makeCallInline(instance, operands, 0, immediatelyDropped);\n          }\n          inlineStack.pop();\n          return expr;\n        }\n      } else {\n        this.warning(\n          DiagnosticCode.Function_0_is_virtual_and_will_not_be_inlined,\n          reportNode.range, instance.internalName\n        );\n      }\n    }\n    let module = this.module;\n    let numOperands = operands ? operands.length : 0;\n    let numArguments = numOperands;\n    let minArguments = instance.signature.requiredParameters;\n    let minOperands = minArguments;\n    let parameterTypes = instance.signature.parameterTypes;\n    let maxArguments = parameterTypes.length;\n    let maxOperands = maxArguments;\n    if (instance.is(CommonFlags.Instance)) {\n      ++minOperands;\n      ++maxOperands;\n      --numArguments;\n    }\n    assert(numOperands >= minOperands);\n\n    if (!this.compileFunction(instance)) return module.unreachable();\n    let returnType = instance.signature.returnType;\n\n    // fill up omitted arguments with their initializers, if constant, otherwise with zeroes.\n    if (numOperands < maxOperands) {\n      if (!operands) {\n        operands = new Array(maxOperands);\n        operands.length = 0;\n      }\n      let parameterNodes = instance.prototype.functionTypeNode.parameters;\n      assert(parameterNodes.length == parameterTypes.length);\n      let allOptionalsAreConstant = true;\n      for (let i = numArguments; i < maxArguments; ++i) {\n        let initializer = parameterNodes[i].initializer;\n        if (initializer) {\n          if (initializer.compilesToConst) {\n            operands.push(this.compileExpression(\n              initializer,\n              parameterTypes[i],\n              Constraints.ConvImplicit\n            ));\n            continue;\n          }\n          let resolved = this.resolver.lookupExpression(initializer, instance.flow, parameterTypes[i], ReportMode.Swallow);\n          if (resolved && resolved.kind == ElementKind.Global) {\n            let global = <Global>resolved;\n            if (this.compileGlobalLazy(global, initializer) && global.is(CommonFlags.Inlined)) {\n              operands.push(\n                this.compileInlineConstant(global, parameterTypes[i], Constraints.ConvImplicit)\n              );\n              continue;\n            }\n          }\n        }\n        operands.push(this.makeZero(parameterTypes[i]));\n        allOptionalsAreConstant = false;\n      }\n      if (!allOptionalsAreConstant && !instance.is(CommonFlags.ModuleImport)) {\n        let original = instance;\n        instance = this.ensureVarargsStub(instance);\n        if (!this.compileFunction(instance)) return module.unreachable();\n        instance.flow.flags = original.flow.flags;\n        let returnTypeRef = returnType.toRef();\n        // We know the last operand is optional and omitted, so inject setting\n        // ~argumentsLength into that operand, which is always safe.\n        let lastOperand = operands[maxOperands - 1];\n        assert(!(getSideEffects(lastOperand, module.ref) & SideEffects.WritesGlobal));\n        let lastOperandType = parameterTypes[maxArguments - 1];\n        operands[maxOperands - 1] = module.block(null, [\n          module.global_set(this.ensureArgumentsLength(), module.i32(numArguments)),\n          lastOperand\n        ], lastOperandType.toRef());\n        this.operandsTostack(instance.signature, operands);\n        let expr = module.call(instance.internalName, operands, returnTypeRef);\n        if (returnType != Type.void && immediatelyDropped) {\n          expr = module.drop(expr);\n          this.currentType = Type.void;\n        } else {\n          this.currentType = returnType;\n        }\n        return expr;\n      }\n    }\n\n    // Call the override stub if the function has overloads\n    if (instance.is(CommonFlags.Overridden) && !reportNode.isAccessOnSuper) {\n      instance = this.ensureOverrideStub(instance);\n    }\n\n    if (operands) this.operandsTostack(instance.signature, operands);\n    let expr = module.call(instance.internalName, operands, returnType.toRef());\n    this.currentType = returnType;\n    return expr;\n  }\n\n  /** Compiles an indirect call to a first-class function. */\n  compileCallIndirect(\n    signature: Signature,\n    functionArg: ExpressionRef,\n    argumentExpressions: Expression[],\n    reportNode: Node,\n    thisArg: ExpressionRef = 0,\n    immediatelyDropped: bool = false\n  ): ExpressionRef {\n    let numArguments = argumentExpressions.length;\n\n    if (!this.checkCallSignature( // reports\n      signature,\n      numArguments,\n      thisArg != 0,\n      reportNode\n    )) {\n      return this.module.unreachable();\n    }\n\n    argumentExpressions = this.adjustArgumentsForRestParams(argumentExpressions, signature, reportNode);\n    numArguments = argumentExpressions.length;\n\n    let numArgumentsInclThis = thisArg ? numArguments + 1 : numArguments;\n    let operands = new Array<ExpressionRef>(numArgumentsInclThis);\n    let index = 0;\n    if (thisArg) {\n      operands[0] = thisArg;\n      index = 1;\n    }\n    let parameterTypes = signature.parameterTypes;\n    for (let i = 0; i < numArguments; ++i, ++index) {\n      operands[index] = this.compileExpression(argumentExpressions[i], parameterTypes[i],\n        Constraints.ConvImplicit\n      );\n    }\n    assert(index == numArgumentsInclThis);\n    return this.makeCallIndirect(signature, functionArg, reportNode, operands, immediatelyDropped);\n  }\n\n  /** Creates an indirect call to a first-class function. */\n  makeCallIndirect(\n    signature: Signature,\n    functionArg: ExpressionRef,\n    reportNode: Node,\n    operands: ExpressionRef[] | null = null,\n    immediatelyDropped: bool = false,\n  ): ExpressionRef {\n    let module = this.module;\n    let numOperands = operands ? operands.length : 0;\n    let numArguments = numOperands;\n    let minArguments = signature.requiredParameters;\n    let minOperands = minArguments;\n    let parameterTypes = signature.parameterTypes;\n    let returnType = signature.returnType;\n    let maxArguments = parameterTypes.length;\n    let maxOperands = maxArguments;\n    if (signature.thisType) {\n      ++minOperands;\n      ++maxOperands;\n      --numArguments;\n    }\n    assert(numOperands >= minOperands);\n\n    // fill up omitted arguments with zeroes\n    if (numOperands < maxOperands) {\n      if (!operands) {\n        operands = new Array(maxOperands);\n        operands.length = 0;\n      }\n      let parameterTypes = signature.parameterTypes;\n      for (let i = numArguments; i < maxArguments; ++i) {\n        operands.push(this.makeZero(parameterTypes[i]));\n      }\n    }\n\n    // We might be calling a varargs stub here, even if all operands have been\n    // provided, so we must set `argumentsLength` in any case. Inject setting it\n    // into the index argument, which becomes executed last after any operands.\n    let argumentsLength = this.ensureArgumentsLength();\n    let sizeTypeRef = this.options.sizeTypeRef;\n    if (getSideEffects(functionArg, module.ref) & SideEffects.WritesGlobal) {\n      let flow = this.currentFlow;\n      let temp = flow.getTempLocal(this.options.usizeType);\n      let tempIndex = temp.index;\n      functionArg = module.block(null, [\n        module.local_set(tempIndex, functionArg, true), // Function\n        module.global_set(argumentsLength, module.i32(numArguments)),\n        module.local_get(tempIndex, sizeTypeRef)\n      ], sizeTypeRef);\n    } else { // simplify\n      functionArg = module.block(null, [\n        module.global_set(argumentsLength, module.i32(numArguments)),\n        functionArg\n      ], sizeTypeRef);\n    }\n    if (operands) this.operandsTostack(signature, operands);\n    let expr = module.call_indirect(\n      null, // TODO: handle multiple tables\n      module.load(4, false, functionArg, TypeRef.I32), // ._index\n      operands,\n      signature.paramRefs,\n      signature.resultRefs\n    );\n    this.currentType = returnType;\n    return expr;\n  }\n\n  private compileCommaExpression(\n    expression: CommaExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let expressions = expression.expressions;\n    let numExpressions = expressions.length;\n    let exprs = new Array<ExpressionRef>(numExpressions--);\n    for (let i = 0; i < numExpressions; ++i) {\n      exprs[i] = this.compileExpression(expressions[i], Type.void, // drop all except last\n        Constraints.ConvImplicit | Constraints.WillDrop\n      );\n    }\n    exprs[numExpressions] = this.compileExpression(expressions[numExpressions], contextualType, constraints);\n    return this.module.flatten(exprs, this.currentType.toRef());\n  }\n\n  private compileElementAccessExpression(\n    expression: ElementAccessExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let module = this.module;\n    let targetExpression = expression.expression;\n    let targetType = this.resolver.resolveExpression(targetExpression, this.currentFlow); // reports\n    if (targetType) {\n      let classReference = targetType.getClassOrWrapper(this.program);\n      if (classReference) {\n        let isUnchecked = this.currentFlow.is(FlowFlags.UncheckedContext);\n        let indexedGet = classReference.lookupOverload(OperatorKind.IndexedGet, isUnchecked);\n        if (indexedGet) {\n          let thisType = assert(indexedGet.signature.thisType);\n          let thisArg = this.compileExpression(targetExpression, thisType,\n            Constraints.ConvImplicit\n          );\n          if (!isUnchecked && this.options.pedantic) {\n            this.pedantic(\n              DiagnosticCode.Indexed_access_may_involve_bounds_checking,\n              expression.range\n            );\n          }\n          return this.compileCallDirect(indexedGet, [\n            expression.elementExpression\n          ], expression, thisArg, constraints);\n        }\n      }\n      this.error(\n        DiagnosticCode.Index_signature_is_missing_in_type_0,\n        expression.expression.range, targetType.toString()\n      );\n    }\n    return module.unreachable();\n  }\n\n  private compileFunctionExpression(\n    expression: FunctionExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let declaration = expression.declaration.clone(); // generic contexts can have multiple\n    assert(!declaration.typeParameters); // function expression cannot be generic\n    let flow = this.currentFlow;\n    let sourceFunction = flow.sourceFunction;\n    let isNamed = declaration.name.text.length > 0;\n    let isSemanticallyAnonymous = !isNamed || contextualType != Type.void;\n    let prototype = new FunctionPrototype(\n      isSemanticallyAnonymous\n        ? `${isNamed ? declaration.name.text : \"anonymous\"}|${sourceFunction.nextAnonymousId++}`\n        : declaration.name.text,\n      sourceFunction,\n      declaration,\n      DecoratorFlags.None\n    );\n    let instance: Function | null;\n    let contextualTypeArguments = cloneMap(flow.contextualTypeArguments);\n    let module = this.module;\n\n    // compile according to context. this differs from a normal function in that omitted parameter\n    // and return types can be inferred and omitted arguments can be replaced with dummies.\n    let contextualSignature = contextualType.signatureReference;\n    if (contextualSignature) {\n      let signatureNode = prototype.functionTypeNode;\n      let parameterNodes = signatureNode.parameters;\n      let numPresentParameters = parameterNodes.length;\n\n      // must not require more than the maximum number of parameters\n      let parameterTypes = contextualSignature.parameterTypes;\n      let numParameters = parameterTypes.length;\n      if (numPresentParameters > numParameters) {\n        this.error(\n          DiagnosticCode.Expected_0_arguments_but_got_1,\n          expression.range, numParameters.toString(), numPresentParameters.toString()\n        );\n        return module.unreachable();\n      }\n\n      // check non-omitted parameter types\n      for (let i = 0; i < numPresentParameters; ++i) {\n        let parameterNode = parameterNodes[i];\n        if (!isTypeOmitted(parameterNode.type)) {\n          let resolvedType = this.resolver.resolveType(\n            parameterNode.type, flow,\n            sourceFunction.parent,\n            contextualTypeArguments\n          );\n          if (!resolvedType) return module.unreachable();\n          if (!parameterTypes[i].isStrictlyAssignableTo(resolvedType)) {\n            this.error(\n              DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n              parameterNode.range, parameterTypes[i].toString(), resolvedType.toString()\n            );\n            return module.unreachable();\n          }\n        }\n        // any unused parameters are inherited but ignored\n      }\n\n      // check non-omitted return type\n      let returnType = contextualSignature.returnType;\n      if (!isTypeOmitted(signatureNode.returnType)) {\n        let resolvedType = this.resolver.resolveType(\n          signatureNode.returnType, flow,\n          sourceFunction.parent,\n          contextualTypeArguments\n        );\n        if (!resolvedType) return module.unreachable();\n        if (\n          returnType == Type.void\n            ? resolvedType != Type.void\n            : !resolvedType.isStrictlyAssignableTo(returnType)\n        ) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            signatureNode.returnType.range, resolvedType.toString(), returnType.toString()\n          );\n          return module.unreachable();\n        }\n      }\n\n      // check explicit this type\n      let thisType = contextualSignature.thisType;\n      let thisTypeNode = signatureNode.explicitThisType;\n      if (thisTypeNode) {\n        if (!thisType) {\n          this.error(\n            DiagnosticCode._this_cannot_be_referenced_in_current_location,\n            thisTypeNode.range\n          );\n          return module.unreachable();\n        }\n        let resolvedType = this.resolver.resolveType(\n          thisTypeNode, flow,\n          sourceFunction.parent,\n          contextualTypeArguments\n        );\n        if (!resolvedType) return module.unreachable();\n        if (!thisType.isStrictlyAssignableTo(resolvedType)) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            thisTypeNode.range, thisType.toString(), resolvedType.toString()\n          );\n          return module.unreachable();\n        }\n      }\n\n      let signature = Signature.create(this.program, parameterTypes, returnType, thisType, numParameters);\n      instance = new Function(\n        prototype.name,\n        prototype,\n        null,\n        signature,\n        contextualTypeArguments\n      );\n      instance.flow.outer = flow;\n      let worked = this.compileFunction(instance);\n      this.currentType = contextualSignature.type;\n      if (!worked) return module.unreachable();\n\n    // otherwise compile like a normal function\n    } else {\n      instance = this.resolver.resolveFunction(prototype, null, contextualTypeArguments);\n      if (!instance) return this.module.unreachable();\n      instance.flow.outer = flow;\n      let worked = this.compileFunction(instance);\n      this.currentType = instance.signature.type;\n      if (!worked) return module.unreachable();\n    }\n\n    let offset = this.ensureRuntimeFunction(instance); // reports\n    let expr = this.options.isWasm64\n      ? module.i64(i64_low(offset), i64_high(offset))\n      : module.i32(i64_low(offset));\n\n    // add a constant local referring to the function if applicable\n    if (!isSemanticallyAnonymous) {\n      let fname = instance.name;\n      let existingLocal = flow.getScopedLocal(fname);\n      if (existingLocal) {\n        if (!existingLocal.declaration.range.source.isNative) {\n          this.errorRelated(\n            DiagnosticCode.Duplicate_identifier_0,\n            declaration.name.range,\n            existingLocal.declaration.name.range,\n            fname\n          );\n        } else { // scoped locals are shared temps that don't track declarations\n          this.error(\n            DiagnosticCode.Duplicate_identifier_0,\n            declaration.name.range, fname\n          );\n        }\n      } else {\n        let ftype = instance.type;\n        let local = flow.addScopedLocal(instance.name, ftype);\n        flow.setLocalFlag(local.index, LocalFlags.Constant | LocalFlags.Initialized);\n        expr = module.local_tee(local.index, expr, ftype.isManaged);\n      }\n    }\n\n    return expr;\n  }\n\n  /** Makes sure the enclosing source file of the specified expression has been compiled. */\n  private maybeCompileEnclosingSource(expression: Expression): void {\n    let internalPath = expression.range.source.internalPath;\n    let filesByName = this.program.filesByName;\n    assert(filesByName.has(internalPath));\n    let enclosingFile = assert(filesByName.get(internalPath));\n    if (!enclosingFile.is(CommonFlags.Compiled)) {\n      this.compileFileByPath(internalPath, expression);\n    }\n  }\n\n  private compileIdentifierExpression(\n    expression: IdentifierExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n    let sourceFunction = flow.sourceFunction;\n\n    // check special keywords first\n    switch (expression.kind) {\n      case NodeKind.Null: {\n        let options = this.options;\n        if (contextualType.isReference) {\n          let classReference = contextualType.getClass();\n          if (classReference) {\n            this.currentType = classReference.type.asNullable();\n            return options.isWasm64 ? module.i64(0) : module.i32(0);\n          }\n          let signatureReference = contextualType.getSignature();\n          if (signatureReference) {\n            this.currentType = signatureReference.type.asNullable();\n            return options.isWasm64 ? module.i64(0) : module.i32(0);\n          }\n          return this.makeZero(contextualType);\n        }\n        this.currentType = options.usizeType;\n        this.warning(\n          DiagnosticCode.Expression_resolves_to_unusual_type_0,\n          expression.range, this.currentType.toString()\n        );\n        return options.isWasm64\n          ? module.i64(0)\n          : module.i32(0);\n      }\n      case NodeKind.True: {\n        this.currentType = Type.bool;\n        return module.i32(1);\n      }\n      case NodeKind.False: {\n        this.currentType = Type.bool;\n        return module.i32(0);\n      }\n      case NodeKind.This: {\n        let thisType = sourceFunction.signature.thisType;\n        if (!thisType) {\n          this.error(\n            DiagnosticCode._this_cannot_be_referenced_in_current_location,\n            expression.range\n          );\n          this.currentType = this.options.usizeType;\n          return module.unreachable();\n        }\n        if (sourceFunction.is(CommonFlags.Constructor)) {\n          if (flow.is(FlowFlags.CtorParamContext)) {\n            this.error(\n              DiagnosticCode._this_cannot_be_referenced_in_constructor_arguments,\n              expression.range\n            );\n          }\n          if (!(constraints & Constraints.IsThis)) {\n            let parent = sourceFunction.parent;\n            assert(parent.kind == ElementKind.Class);\n            this.checkFieldInitialization(<Class>parent, expression);\n          }\n        }\n        let thisLocal = assert(flow.lookupLocal(CommonNames.this_));\n        flow.set(FlowFlags.AccessesThis);\n        this.currentType = thisType;\n        return module.local_get(thisLocal.index, thisType.toRef());\n      }\n      case NodeKind.Super: {\n        if (sourceFunction.is(CommonFlags.Constructor)) {\n          if (flow.is(FlowFlags.CtorParamContext)) {\n            this.error(\n              DiagnosticCode._super_cannot_be_referenced_in_constructor_arguments,\n              expression.range\n            );\n          } else if (!flow.is(FlowFlags.CallsSuper)) {\n            // TS1034 in the parser effectively limits this to property accesses\n            this.error(\n              DiagnosticCode._super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class,\n              expression.range\n            );\n          }\n        }\n        if (flow.isInline) {\n          let scopedThis = flow.lookupLocal(CommonNames.this_);\n          if (scopedThis) {\n            let scopedThisClass = assert(scopedThis.type.getClass());\n            let base = scopedThisClass.base;\n            if (base) {\n              this.currentType = base.type;\n              return module.local_get(scopedThis.index, base.type.toRef());\n            }\n          }\n        }\n        if (sourceFunction.is(CommonFlags.Instance)) {\n          let parent = assert(sourceFunction.parent);\n          assert(parent.kind == ElementKind.Class);\n          let classInstance = <Class>parent;\n          let baseClassInstance = classInstance.base;\n          if (baseClassInstance) {\n            let superType = baseClassInstance.type;\n            this.currentType = superType;\n            return module.local_get(0, superType.toRef());\n          }\n        }\n        this.error(\n          DiagnosticCode._super_can_only_be_referenced_in_a_derived_class,\n          expression.range\n        );\n        this.currentType = this.options.usizeType;\n        return module.unreachable();\n      }\n    }\n\n    this.maybeCompileEnclosingSource(expression);\n\n    // otherwise resolve\n    let currentParent = this.currentParent;\n    if (!currentParent) currentParent = sourceFunction;\n    let target = this.resolver.lookupIdentifierExpression( // reports\n      expression,\n      flow,\n      currentParent\n    );\n    if (!target) {\n      // make a guess to avoid assertions in calling code\n      if (this.currentType == Type.void) this.currentType = Type.i32;\n      return module.unreachable();\n    }\n\n    switch (target.kind) {\n      case ElementKind.Local: {\n        let local = <Local>target;\n        let localType = local.type;\n        assert(localType != Type.void);\n        if (this.pendingElements.has(local)) {\n          this.error(\n            DiagnosticCode.Variable_0_used_before_its_declaration,\n            expression.range,\n            local.internalName\n          );\n          this.currentType = localType;\n          return module.unreachable();\n        }\n        if (local.is(CommonFlags.Inlined)) {\n          return this.compileInlineConstant(local, contextualType, constraints);\n        }\n        let localIndex = local.index;\n        if (!flow.isLocalFlag(localIndex, LocalFlags.Initialized)) {\n          this.error(\n            DiagnosticCode.Variable_0_is_used_before_being_assigned,\n            expression.range, local.name\n          );\n        }\n        assert(localIndex >= 0);\n        let isNonNull = flow.isLocalFlag(localIndex, LocalFlags.NonNull, false);\n        if (localType.isNullableReference && isNonNull && (!localType.isExternalReference || this.options.hasFeature(Feature.GC))) {\n          this.currentType = localType.nonNullableType;\n        } else {\n          this.currentType = localType;\n        }\n\n        if (!local.declaredByFlow(flow)) {\n          // TODO: closures\n          this.error(\n            DiagnosticCode.Not_implemented_0,\n            expression.range,\n            \"Closures\"\n          );\n          return module.unreachable();\n        }\n        let expr = module.local_get(localIndex, localType.toRef());\n        if (isNonNull && localType.isNullableExternalReference && this.options.hasFeature(Feature.GC)) {\n          // If the local's type is nullable, but its value is known to be non-null, propagate\n          // non-nullability info to Binaryen. Only applicable if GC is enabled, since without\n          // GC, here incl. typed function references, there is no nullability dimension.\n          expr = module.ref_as_nonnull(expr);\n        }\n        return expr;\n      }\n      case ElementKind.Global: {\n        let global = <Global>target;\n        if (!this.compileGlobalLazy(global, expression)) {\n          return module.unreachable();\n        }\n        let globalType = global.type;\n        if (this.pendingElements.has(global)) {\n          this.error(\n            DiagnosticCode.Variable_0_used_before_its_declaration,\n            expression.range,\n            global.internalName\n          );\n          this.currentType = globalType;\n          return module.unreachable();\n        }\n        assert(globalType != Type.void);\n        if (global.hasDecorator(DecoratorFlags.Builtin)) {\n          return this.compileIdentifierExpressionBuiltin(global, expression, contextualType);\n        }\n        if (global.is(CommonFlags.Inlined)) {\n          return this.compileInlineConstant(global, contextualType, constraints);\n        }\n        let expr = module.global_get(global.internalName, globalType.toRef());\n        if (global.is(CommonFlags.DefinitelyAssigned) && globalType.isReference && !globalType.isNullableReference) {\n          expr = this.makeRuntimeNonNullCheck(expr, globalType, expression);\n        }\n        this.currentType = globalType;\n        return expr;\n      }\n      case ElementKind.EnumValue: { // here: if referenced from within the same enum\n        let enumValue = <EnumValue>target;\n        if (!target.is(CommonFlags.Compiled)) {\n          this.error(\n            DiagnosticCode.A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums,\n            expression.range\n          );\n          this.currentType = Type.i32;\n          return module.unreachable();\n        }\n        this.currentType = Type.i32;\n        if (enumValue.is(CommonFlags.Inlined)) {\n          assert(enumValue.constantValueKind == ConstantValueKind.Integer);\n          return module.i32(i64_low(enumValue.constantIntegerValue));\n        }\n        return module.global_get(enumValue.internalName, TypeRef.I32);\n      }\n      case ElementKind.FunctionPrototype: {\n        let functionPrototype = <FunctionPrototype>target;\n        let typeParameterNodes = functionPrototype.typeParameterNodes;\n\n        if (typeParameterNodes && typeParameterNodes.length != 0) {\n          this.error(\n            DiagnosticCode.Type_argument_expected,\n            expression.range\n          );\n          break; // also diagnose 'not a value at runtime'\n        }\n\n        let functionInstance = this.resolver.resolveFunction(\n          functionPrototype,\n          null,\n          cloneMap(flow.contextualTypeArguments)\n        );\n        if (!functionInstance || !this.compileFunction(functionInstance)) return module.unreachable();\n        if (functionInstance.hasDecorator(DecoratorFlags.Builtin)) {\n          this.error(\n            DiagnosticCode.Not_implemented_0,\n            expression.range, \"First-class built-ins\"\n          );\n          this.currentType = functionInstance.type;\n          return module.unreachable();\n        }\n        if (contextualType.isExternalReference) {\n          // TODO: Concrete function types currently map to first class functions implemented in\n          // linear memory (on top of `usize`), leaving only generic `funcref` for use here. In the\n          // future, once functions become Wasm GC objects, the actual signature type can be used.\n          this.currentType = Type.func;\n          return module.ref_func(functionInstance.internalName, ensureType(functionInstance.type));\n        }\n        let offset = this.ensureRuntimeFunction(functionInstance);\n        this.currentType = functionInstance.signature.type;\n        return this.options.isWasm64\n          ? module.i64(i64_low(offset), i64_high(offset))\n          : module.i32(i64_low(offset));\n      }\n    }\n    this.error(\n      DiagnosticCode.Expression_does_not_compile_to_a_value_at_runtime,\n      expression.range\n    );\n    return module.unreachable();\n  }\n\n  private compileIdentifierExpressionBuiltin(\n    element: VariableLikeElement,\n    expression: IdentifierExpression,\n    contextualType: Type\n  ): ExpressionRef {\n    if (element.hasDecorator(DecoratorFlags.Unsafe)) this.checkUnsafe(expression, element.identifierNode);\n    let internalName = element.internalName;\n    assert(builtinVariables_onAccess.has(internalName)); // checked earlier\n    let fn = assert(builtinVariables_onAccess.get(internalName));\n    return fn(new BuiltinVariableContext(\n      this,\n      element,\n      contextualType,\n      expression\n    ));\n  }\n\n  private compileInstanceOfExpression(\n    expression: InstanceOfExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let flow = this.currentFlow;\n    let isType = expression.isType;\n\n    // Mimic `instanceof CLASS`\n    if (isType.kind == NodeKind.NamedType) {\n      let namedType = <NamedTypeNode>isType;\n      if (!(namedType.isNullable || namedType.hasTypeArguments)) {\n        let element = this.resolver.resolveTypeName(namedType.name, flow, flow.sourceFunction, ReportMode.Swallow);\n        if (element && element.kind == ElementKind.ClassPrototype) {\n          let prototype = <ClassPrototype>element;\n          if (prototype.is(CommonFlags.Generic)) {\n            return this.makeInstanceofClass(expression, prototype);\n          }\n        }\n      }\n    }\n\n    // Fall back to `instanceof TYPE`\n    let expectedType = this.resolver.resolveType(\n      expression.isType, flow,\n      flow.sourceFunction,\n      cloneMap(flow.contextualTypeArguments)\n    );\n    if (!expectedType) {\n      this.currentType = Type.bool;\n      return this.module.unreachable();\n    }\n    return this.makeInstanceofType(expression, expectedType);\n  }\n\n  private makeInstanceofType(expression: InstanceOfExpression, expectedType: Type): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n    let expr = this.compileExpression(expression.expression, expectedType);\n    let actualType = this.currentType;\n    this.currentType = Type.bool;\n\n    // instanceof <value> - must be exact\n    if (expectedType.isValue) {\n      return module.maybeDropCondition(expr, module.i32(actualType == expectedType ? 1 : 0));\n    }\n\n    // <value> instanceof <nonValue> - always false\n    if (actualType.isValue) {\n      return module.maybeDropCondition(expr, module.i32(0));\n    }\n\n    // both LHS and RHS are references now\n    let sizeTypeRef = actualType.toRef();\n\n    // <nullable> instanceof <nonNullable> - LHS must be != 0\n    if (actualType.isNullableReference && !expectedType.isNullableReference) {\n\n      // same or upcast - check statically\n      if (actualType.nonNullableType.isAssignableTo(expectedType)) {\n        return module.binary(\n          sizeTypeRef == TypeRef.I64\n            ? BinaryOp.NeI64\n            : BinaryOp.NeI32,\n          expr,\n          this.makeZero(actualType)\n        );\n      }\n\n      // potential downcast - check dynamically\n      if (actualType.nonNullableType.hasSubtypeAssignableTo(expectedType)) {\n        if (!(actualType.isUnmanaged || expectedType.isUnmanaged)) {\n          if (this.options.pedantic) {\n            this.pedantic(\n              DiagnosticCode.Expression_compiles_to_a_dynamic_check_at_runtime,\n              expression.range\n            );\n          }\n          let temp = flow.getTempLocal(actualType);\n          let tempIndex = temp.index;\n          return module.if(\n            module.unary(\n              sizeTypeRef == TypeRef.I64\n                ? UnaryOp.EqzI64\n                : UnaryOp.EqzI32,\n              module.local_tee(tempIndex, expr, actualType.isManaged),\n            ),\n            module.i32(0),\n            module.call(this.prepareInstanceOf(expectedType.classReference!), [\n              module.local_get(tempIndex, sizeTypeRef)\n            ], TypeRef.I32)\n          );\n        } else {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \"instanceof\", actualType.toString(), expectedType.toString()\n          );\n        }\n      }\n\n    // either none or both nullable\n    } else {\n\n      // same or upcast - check statically\n      if (actualType.isAssignableTo(expectedType)) {\n        return module.maybeDropCondition(expr, module.i32(1));\n      }\n\n      // potential downcast - check dynamically\n      if (actualType.hasSubtypeAssignableTo(expectedType)) {\n        if (!(actualType.isUnmanaged || expectedType.isUnmanaged)) {\n          let temp = flow.getTempLocal(actualType);\n          let tempIndex = temp.index;\n          return module.if(\n            module.unary(\n              sizeTypeRef == TypeRef.I64\n                ? UnaryOp.EqzI64\n                : UnaryOp.EqzI32,\n              module.local_tee(tempIndex, expr, actualType.isManaged),\n            ),\n            module.i32(0),\n            module.call(this.prepareInstanceOf(expectedType.classReference!), [\n              module.local_get(tempIndex, sizeTypeRef)\n            ], TypeRef.I32)\n          );\n        } else {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \"instanceof\", actualType.toString(), expectedType.toString()\n          );\n        }\n      }\n    }\n\n    // false\n    return module.maybeDropCondition(expr, module.i32(0));\n  }\n\n  /** Prepares the instanceof helper for the given class or interface instance. */\n  private prepareInstanceOf(instance: Class): string {\n    let name = `~instanceof|${instance.internalName}`;\n    let pending = this.pendingInstanceOf;\n    if (pending.has(instance)) return assert(pending.get(instance));\n    pending.set(instance, name);\n    let module = this.module;\n    module.addFunction(name, this.options.sizeTypeRef, TypeRef.I32, null,\n      module.unreachable()\n    );\n    return name;\n  }\n\n  /** Finalizes the instanceof helper of the given class or interface instance. */\n  private finalizeInstanceOf(\n    /** Class to finalize the helper for. */\n    instance: Class,\n    /** Name of the helper function. */\n    name: string\n  ): void {\n    let program = this.program;\n    let module = this.module;\n    let sizeType = this.options.sizeTypeRef;\n    let stmts = new Array<ExpressionRef>();\n    // (block $is_instance\n    //  (local.set $1 (i32.load (...))) ;; class id\n    //  (br_if $is_instance (i32.eq (local.get $1) (ID)))\n    //  ...\n    //  (return (i32.const 0))\n    // )\n    // (i32.const 1)\n    stmts.push(\n      module.local_set(1,\n        module.load(4, false,\n          module.binary(\n            sizeType == TypeRef.I64\n              ? BinaryOp.SubI64\n              : BinaryOp.SubI32,\n            module.local_get(0, sizeType),\n            module.i32(\n              program.totalOverhead - program.OBJECTInstance.offsetof(\"rtId\")\n            )\n          ),\n          TypeRef.I32\n        ), false // managedness is irrelevant here, isn't interrupted\n      )\n    );\n    let allInstances: Set<Class> | null;\n    if (instance.isInterface) {\n      allInstances = instance.implementers;\n    } else {\n      allInstances = new Set();\n      allInstances.add(instance);\n      let extenders = instance.extenders;\n      if (extenders) {\n        for (let _values = Set_values(extenders), i = 0, k = _values.length; i < k; ++i) {\n          let extender = _values[i];\n          allInstances.add(extender);\n        }\n      }\n    }\n    if (allInstances) {\n      for (let _values = Set_values(allInstances), i = 0, k = _values.length; i < k; ++i) {\n        let instance = _values[i];\n        stmts.push(\n          module.br(\"is_instance\",\n            module.binary(BinaryOp.EqI32,\n              module.local_get(1, TypeRef.I32),\n              module.i32(instance.id)\n            )\n          )\n        );\n      }\n    }\n    stmts.push(\n      module.return(\n        module.i32(0)\n      )\n    );\n    stmts[0] = module.block(\"is_instance\", stmts, TypeRef.None);\n    stmts.length = 1;\n    stmts.push(\n      module.i32(1)\n    ); \n    module.removeFunction(name);\n    module.addFunction(name, sizeType, TypeRef.I32, [ TypeRef.I32 ], module.block(null, stmts, TypeRef.I32));\n  }\n\n  private makeInstanceofClass(expression: InstanceOfExpression, prototype: ClassPrototype): ExpressionRef {\n    let module = this.module;\n    let expr = this.compileExpression(expression.expression, Type.auto);\n    let actualType = this.currentType;\n    let sizeTypeRef = actualType.toRef();\n\n    this.currentType = Type.bool;\n\n    // exclusively interested in class references here\n    let classReference = actualType.getClass();\n    if (classReference) {\n\n      // static check\n      if (classReference.extendsPrototype(prototype)) {\n\n        // <nullable> instanceof <PROTOTYPE> - LHS must be != 0\n        if (actualType.isNullableReference) {\n          return module.binary(\n            sizeTypeRef == TypeRef.I64\n              ? BinaryOp.NeI64\n              : BinaryOp.NeI32,\n            expr,\n            this.makeZero(actualType)\n          );\n\n        // <nonNullable> is just `true`\n        } else {\n          return module.maybeDropCondition(expr, module.i32(1));\n        }\n\n      // dynamic check against all possible concrete ids\n      } else if (prototype.extends(classReference.prototype)) {\n        let flow = this.currentFlow;\n        let temp = flow.getTempLocal(actualType);\n        let tempIndex = temp.index;\n        // !(t = expr) ? 0 : anyinstanceof(t)\n        return module.if(\n          module.unary(\n            sizeTypeRef == TypeRef.I64\n              ? UnaryOp.EqzI64\n              : UnaryOp.EqzI32,\n            module.local_tee(tempIndex, expr, actualType.isManaged),\n          ),\n          module.i32(0),\n          module.call(this.prepareAnyInstanceOf(prototype), [\n            module.local_get(tempIndex, sizeTypeRef)\n          ], TypeRef.I32)\n        );\n      }\n    }\n\n    // false\n    return module.maybeDropCondition(expr, module.i32(0));\n  }\n\n  /** Prepares the instanceof helper for the given class or interface prototype. */\n  private prepareAnyInstanceOf(prototype: ClassPrototype): string {\n    let name = `~anyinstanceof|${prototype.internalName}`;\n    let pending = this.pendingInstanceOf;\n    if (pending.has(prototype)) return assert(pending.get(prototype));\n    pending.set(prototype, name);\n    let module = this.module;\n    module.addFunction(name, this.options.sizeTypeRef, TypeRef.I32, null,\n      module.unreachable()\n    );\n    return name;\n  }\n\n  /** Finalizes the instanceof helper of the given class prototype. */\n  private finalizeAnyInstanceOf(prototype: ClassPrototype, name: string): void {\n    let module = this.module;\n    let sizeType = this.options.sizeTypeRef;\n    let stmts = new Array<ExpressionRef>();\n    let instances = prototype.instances;\n    // (block $is_instance\n    //  (local.set $1 (i32.load(...)))\n    //  (br_if $is_instance (i32.eq (local.get $1) (ID))\n    //  ...\n    //  (return (i32.const 0))\n    // )\n    // (i32.const 1)\n    if (instances) {\n      let program = this.program;\n      stmts.push(\n        module.local_set(1,\n          module.load(4, false,\n            module.binary(\n              sizeType == TypeRef.I64\n                ? BinaryOp.SubI64\n                : BinaryOp.SubI32,\n              module.local_get(0, sizeType),\n              module.i32(\n                program.totalOverhead - program.OBJECTInstance.offsetof(\"rtId\")\n              )\n            ),\n            TypeRef.I32\n          ), false // managedness is irrelevant here, isn't interrupted\n        )\n      );\n      let allInstances = new Set<Class>();\n      for (let _values = Map_values(instances), i = 0, k = _values.length; i < k; ++i) {\n        let instance = _values[i];\n        if (instance.isInterface) {\n          let implementers = instance.implementers;\n          if (implementers) {\n            for (let _values = Set_values(implementers), i = 0, k = _values.length; i < k; ++i) {\n              let implementer = _values[i];\n              allInstances.add(implementer);\n            }\n          }\n        } else {\n          allInstances.add(instance);\n          let extenders = instance.extenders;\n          if (extenders) {\n            for (let _values = Set_values(extenders), i = 0, k = _values.length; i < k; ++i) {\n              let extender = _values[i];\n              allInstances.add(extender);\n            }\n          }\n        }\n      }\n      for (let _values = Set_values(allInstances), i = 0, k = _values.length; i < k; ++i) {\n        let instance = _values[i];\n        stmts.push(\n          module.br(\"is_instance\",\n            module.binary(BinaryOp.EqI32,\n              module.local_get(1, TypeRef.I32),\n              module.i32(instance.id)\n            )\n          )\n        );\n      }\n    }\n    stmts.push(\n      module.return(\n        module.i32(0)\n      )\n    );\n    stmts[0] = module.block(\"is_instance\", stmts, TypeRef.None);\n    stmts.length = 1;\n    stmts.push(\n      module.i32(1)\n    );\n    module.removeFunction(name);\n    module.addFunction(name, sizeType, TypeRef.I32, [ TypeRef.I32 ], module.block(null, stmts, TypeRef.I32));\n  }\n\n  private compileLiteralExpression(\n    expression: LiteralExpression,\n    contextualType: Type,\n    constraints: Constraints,\n    implicitlyNegate: bool = false\n  ): ExpressionRef {\n    let module = this.module;\n    switch (expression.literalKind) {\n      case LiteralKind.Array: {\n        assert(!implicitlyNegate);\n        return this.compileArrayLiteral(\n          <ArrayLiteralExpression>expression,\n          contextualType,\n          constraints\n        );\n      }\n      case LiteralKind.Float: {\n        let floatValue = (<FloatLiteralExpression>expression).value;\n        if (implicitlyNegate) {\n          floatValue = -floatValue;\n        }\n        if (contextualType == Type.f32) {\n          return module.f32(<f32>floatValue);\n        }\n        this.currentType = Type.f64;\n        return module.f64(floatValue);\n      }\n      case LiteralKind.Integer: {\n        let expr = <IntegerLiteralExpression>expression;\n        let type = this.resolver.determineIntegerLiteralType(expr, implicitlyNegate, contextualType);\n        this.currentType = type;\n        let intValue = expr.value;\n        let sign = 1.0; // should multiply for float literals\n        if (implicitlyNegate) {\n          if (type.isFloatValue) {\n            sign = -1.0;\n          } else {\n            intValue = i64_neg(intValue);\n          }\n        }\n        switch (type.kind) {\n          case TypeKind.Isize: if (!this.options.isWasm64) return module.i32(i64_low(intValue));\n          case TypeKind.I64: return module.i64(i64_low(intValue), i64_high(intValue));\n          case TypeKind.Usize: if (!this.options.isWasm64) return module.i32(i64_low(intValue));\n          case TypeKind.U64: return module.i64(i64_low(intValue), i64_high(intValue));\n          case TypeKind.F32: return module.f32(<f32>sign * i64_to_f32(intValue));\n          case TypeKind.F64: return module.f64(sign * i64_to_f64(intValue));\n          default: return module.i32(i64_low(intValue));\n        }\n      }\n      case LiteralKind.String: {\n        assert(!implicitlyNegate);\n        return this.compileStringLiteral(<StringLiteralExpression>expression, constraints);\n      }\n      case LiteralKind.Template: {\n        assert(!implicitlyNegate);\n        return this.compileTemplateLiteral(<TemplateLiteralExpression>expression, constraints);\n      }\n      case LiteralKind.Object: {\n        assert(!implicitlyNegate);\n        return this.compileObjectLiteral(<ObjectLiteralExpression>expression, contextualType);\n      }\n      case LiteralKind.RegExp: {\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          expression.range,\n          \"Regular expressions\"\n        );\n        this.currentType = contextualType;\n        return module.unreachable();\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  private compileStringLiteral(\n    expression: StringLiteralExpression,\n    constraints: Constraints\n  ): ExpressionRef {\n    return this.ensureStaticString(expression.value);\n  }\n\n  private compileTemplateLiteral(\n    expression: TemplateLiteralExpression,\n    constraints: Constraints\n  ): ExpressionRef {\n    let tag = expression.tag;\n    let parts = expression.parts;\n    let numParts = parts.length;\n    let expressions = expression.expressions;\n    let numExpressions = expressions.length;\n    assert(numExpressions == numParts - 1);\n\n    let module = this.module;\n    let stringInstance = this.program.stringInstance;\n    let stringType = stringInstance.type;\n\n    if (!tag) {\n      // Shortcut if just a (multi-line) string\n      if (numParts == 1) {\n        return this.ensureStaticString(parts[0]);\n      }\n\n      // Shortcut for `${expr}`, `<prefix>${expr}`, `${expr}<suffix>`\n      if (numParts == 2) {\n        let expression = expressions[0];\n        let lhsLen = parts[0].length;\n        let rhsLen = parts[1].length;\n        // Shortcut for `${expr}`  ->   expr.toString()\n        if (!lhsLen && !rhsLen) {\n          return this.makeToString(\n            this.compileExpression(expression, stringType),\n            this.currentType, expression\n          );\n        }\n        // Shortcuts for\n        // `<prefix>${expr}`  ->  \"<prefix>\" + expr.toString()\n        // `${expr}<suffix>`  ->  expr.toString() + \"<suffix>\"\n        let hasPrefix = lhsLen != 0;\n        // @ts-ignore: cast\n        if (hasPrefix ^ (rhsLen != 0)) {\n          let lhs: ExpressionRef;\n          let rhs: ExpressionRef;\n          let expr = this.makeToString(\n            this.compileExpression(expression, stringType),\n            this.currentType, expression\n          );\n          if (hasPrefix) {\n            lhs = this.ensureStaticString(parts[0]);\n            rhs = expr;\n          } else {\n            // suffix\n            lhs = expr;\n            rhs = this.ensureStaticString(parts[1]);\n          }\n          let concatMethod = assert(stringInstance.getMethod(\"concat\"));\n          return this.makeCallDirect(concatMethod, [ lhs, rhs ], expression);\n        }\n      }\n\n      // Shortcut for `${exprA}${exprB}`  ->  exprA.toString() + exprB.toString()\n      if (numParts == 3 && !parts[0].length && !parts[1].length && !parts[2].length) {\n        let exprA = expressions[0];\n        let exprB = expressions[1];\n\n        let lhs = this.makeToString(\n          this.compileExpression(exprA, stringType),\n          this.currentType, exprA\n        );\n        let rhs = this.makeToString(\n          this.compileExpression(exprB, stringType),\n          this.currentType, exprB\n        );\n        let concatMethod = assert(stringInstance.getMethod(\"concat\"));\n        return this.makeCallDirect(concatMethod, [ lhs, rhs ], expression);\n      }\n\n      // Compile to a `StaticArray<string>#join(\"\") in the general case\n      let expressionPositions = new Array<i32>(numExpressions);\n      let values = new Array<usize>();\n      if (parts[0].length > 0) values.push(this.ensureStaticString(parts[0]));\n      for (let i = 1; i < numParts; ++i) {\n        expressionPositions[i - 1] = values.length;\n        values.push(module.usize(0));\n        if (parts[i].length > 0) values.push(this.ensureStaticString(parts[i]));\n      }\n      let arrayInstance = assert(this.resolver.resolveClass(this.program.staticArrayPrototype, [ stringType ]));\n      let segment = this.addStaticBuffer(stringType, values, arrayInstance.id);\n      this.program.OBJECTInstance.writeField(\"gcInfo\", 3, segment.buffer, 0); // use transparent gcinfo\n      let offset = i64_add(segment.offset, i64_new(this.program.totalOverhead));\n      let joinInstance = assert(arrayInstance.getMethod(\"join\"));\n      let indexedSetInstance = assert(arrayInstance.lookupOverload(OperatorKind.IndexedSet, true));\n      let stmts = new Array<ExpressionRef>(2 * numExpressions + 1);\n      // Use one local per toString'ed subexpression, since otherwise recursion on the same\n      // static array would overwrite already prepared parts. Avoids a temporary array.\n      let temps = new Array<Local>(numExpressions);\n      let flow = this.currentFlow;\n      for (let i = 0; i < numExpressions; ++i) {\n        let expression = expressions[i];\n        let temp = flow.getTempLocal(stringType);\n        temps[i] = temp;\n        stmts[i] = module.local_set(temp.index,\n          this.makeToString(\n            this.compileExpression(expression, stringType),\n            this.currentType, expression\n          ),\n          true\n        );\n      }\n      // Populate the static array with the toString'ed subexpressions and call .join(\"\")\n      for (let i = 0; i < numExpressions; ++i) {\n        stmts[numExpressions + i] = this.makeCallDirect(indexedSetInstance, [\n          module.usize(offset),\n          module.i32(expressionPositions[i]),\n          module.local_get(temps[i].index, stringType.toRef())\n        ], expression);\n      }\n      stmts[2 * numExpressions] = this.makeCallDirect(joinInstance, [\n        module.usize(offset),\n        this.ensureStaticString(\"\")\n      ], expression);\n      return module.flatten(stmts, stringType.toRef());\n    }\n\n    // Try to find out whether the template function takes a full-blown TemplateStringsArray or if\n    // it is sufficient to compile to a normal array. While technically incorrect, this allows us\n    // to avoid generating unnecessary static data that is not explicitly signaled to be used.\n    let tsaArrayInstance = this.program.templateStringsArrayInstance;\n    let arrayInstance = tsaArrayInstance;\n    let target = this.resolver.lookupExpression(tag, this.currentFlow, Type.auto, ReportMode.Swallow);\n    if (target) {\n      switch (target.kind) {\n        case ElementKind.FunctionPrototype: {\n          let instance = this.resolver.resolveFunction(\n            <FunctionPrototype>target,\n            null,\n            new Map(),\n            ReportMode.Swallow\n          );\n          if (!instance) break;\n          target = instance;\n          // fall-through\n        }\n        case ElementKind.Function: {\n          let instance = <Function>target;\n          let parameterTypes = instance.signature.parameterTypes;\n          if (parameterTypes.length) {\n            let first = parameterTypes[0].getClass();\n            if (first && !first.extendsPrototype(tsaArrayInstance.prototype)) {\n              arrayInstance = assert(this.resolver.resolveClass(this.program.arrayPrototype, [ stringType ]));\n            }\n          }\n          break;\n        }\n      }\n    }\n\n    // Compile to a call to the tag function\n    let rawParts = expression.rawParts;\n    assert(rawParts.length == numParts);\n    let partExprs = new Array<ExpressionRef>(numParts);\n    for (let i = 0; i < numParts; ++i) {\n      partExprs[i] = this.ensureStaticString(parts[i]);\n    }\n    let arraySegment: MemorySegment;\n    if (arrayInstance == tsaArrayInstance) {\n      let rawExprs = new Array<ExpressionRef>(numParts);\n      for (let i = 0; i < numParts; ++i) {\n        rawExprs[i] = this.ensureStaticString(rawParts[i]);\n      }\n      arraySegment = this.addStaticArrayHeader(stringType,\n        this.addStaticBuffer(this.options.usizeType, partExprs),\n        arrayInstance\n      );\n      let rawHeaderSegment = this.addStaticArrayHeader(stringType,\n        this.addStaticBuffer(this.options.usizeType, rawExprs)\n      );\n      arrayInstance.writeField(\"raw\",\n        i64_add(rawHeaderSegment.offset, i64_new(this.program.totalOverhead)),\n        arraySegment.buffer\n      );\n    } else {\n      arraySegment = this.addStaticArrayHeader(stringType,\n        this.addStaticBuffer(this.options.usizeType, partExprs),\n        arrayInstance\n      );\n    }\n\n    // Desugar to compileCallExpression\n    let args = expressions.slice();\n    args.unshift(\n      Node.createCompiledExpression(\n        module.usize(i64_add(arraySegment.offset, i64_new(this.program.totalOverhead))),\n        arrayInstance.type,\n        Source.native.range\n      )\n    );\n    // TODO: Requires ReadonlyArray to be safe\n    this.error(\n      DiagnosticCode.Not_implemented_0,\n      expression.range, \"Tagged template literals\"\n    );\n    return this.compileCallExpressionLike(tag, null, args, expression.range, stringType);\n  }\n\n  private compileArrayLiteral(\n    expression: ArrayLiteralExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n    let program = this.program;\n\n    // handle static arrays\n    let contextualClass = contextualType.getClass();\n    if (contextualClass && contextualClass.extendsPrototype(program.staticArrayPrototype)) {\n      return this.compileStaticArrayLiteral(expression, contextualType, constraints);\n    }\n\n    // handle normal arrays\n    let element = this.resolver.lookupExpression(expression, flow, this.currentType);\n    if (!element) return module.unreachable();\n    assert(element.kind == ElementKind.Class);\n    let arrayInstance = <Class>element;\n    let arrayType = arrayInstance.type;\n    let elementType = arrayInstance.getTypeArgumentsTo(program.arrayPrototype)![0];\n\n    // block those here so compiling expressions doesn't conflict\n    let tempThis = flow.getTempLocal(this.options.usizeType);\n\n    // compile value expressions and find out whether all are constant\n    let expressions = expression.elementExpressions;\n    let length = expressions.length;\n    let values = new Array<ExpressionRef>(length);\n    let isStatic = !elementType.isExternalReference;\n    for (let i = 0; i < length; ++i) {\n      let elementExpression = expressions[i];\n      if (elementExpression.kind != NodeKind.Omitted) {\n        let expr = this.compileExpression(<Expression>elementExpression, elementType, Constraints.ConvImplicit);\n        if (getExpressionType(expr) != elementType.toRef()) {\n          isStatic = false;\n        } else {\n          let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n          if (precomp) {\n            expr = precomp;\n          } else {\n            isStatic = false;\n          }\n        }\n        values[i] = expr;\n      } else {\n        values[i] = this.makeZero(elementType);\n      }\n    }\n\n    // if the array is static, make a static arraybuffer segment\n    if (isStatic) {\n      let totalOverhead = program.totalOverhead;\n      let bufferSegment = this.addStaticBuffer(elementType, values);\n      let bufferAddress = i64_add(bufferSegment.offset, i64_new(totalOverhead));\n\n      // make both the buffer and array header static if assigned to a global. this can't be done\n      // if inside of a function because each invocation must create a new array reference then.\n      if (constraints & Constraints.PreferStatic) {\n        let arraySegment = this.addStaticArrayHeader(elementType, bufferSegment);\n        let arrayAddress = i64_add(arraySegment.offset, i64_new(totalOverhead));\n        this.currentType = arrayType;\n        return program.options.isWasm64\n          ? this.module.i64(i64_low(arrayAddress), i64_high(arrayAddress))\n          : this.module.i32(i64_low(arrayAddress));\n\n      // otherwise allocate a new array header and make it wrap a copy of the static buffer\n      } else {\n        return this.makeNewArray(arrayInstance, length, bufferAddress, expression);\n      }\n    }\n\n    // otherwise compile an explicit instantiation with indexed sets\n    let indexedSet = arrayInstance.lookupOverload(OperatorKind.IndexedSet, true);\n    if (!indexedSet) {\n      this.error(\n        DiagnosticCode.Index_signature_in_type_0_only_permits_reading,\n        expression.range, arrayInstance.internalName\n      );\n      this.currentType = arrayType;\n      return module.unreachable();\n    }\n    let arrayTypeRef = arrayType.toRef();\n\n    let stmts = new Array<ExpressionRef>();\n    // tempThis = __newArray(length, alignLog2, classId, source = 0)\n    stmts.push(\n      module.local_set(tempThis.index,\n        this.makeNewArray(arrayInstance, length, i64_new(0), expression),\n        arrayType.isManaged\n      )\n    );\n    // tempData = tempThis.dataStart\n    let dataStartMember = assert(arrayInstance.getMember(\"dataStart\"));\n    assert(dataStartMember.kind == ElementKind.PropertyPrototype);\n    // is a field, so should have been resolved during class finalization\n    let dataStartProperty = (<PropertyPrototype>dataStartMember).instance;\n    if (!dataStartProperty) return module.unreachable();\n    assert(dataStartProperty.isField && dataStartProperty.memoryOffset >= 0);\n    for (let i = 0; i < length; ++i) {\n      // this[i] = value\n      stmts.push(\n        module.call(indexedSet.internalName, [\n          module.local_get(tempThis.index, arrayTypeRef),\n          module.i32(i),\n          values[i]\n        ], TypeRef.None)\n      );\n    }\n    // -> tempThis\n    stmts.push(\n      module.local_get(tempThis.index, arrayTypeRef)\n    );\n    if (length) this.compileFunction(indexedSet);\n    this.currentType = arrayType;\n    return module.flatten(stmts, arrayTypeRef);\n  }\n\n  /** Makes a new array instance from a static buffer segment. */\n  private makeNewArray(\n    /** Concrete array class. */\n    arrayInstance: Class,\n    /** Length of the array. */\n    length: i32,\n    /** Source address to copy from. Array is zeroed if `0`. */\n    source: i64,\n    /** Report node. */\n    reportNode: Node\n  ): ExpressionRef {\n    let program = this.program;\n    let module = this.module;\n    assert(!arrayInstance.extendsPrototype(program.staticArrayPrototype));\n    let elementType = arrayInstance.getArrayValueType(); // asserts\n\n    // __newArray(length, alignLog2, classId, staticBuffer)\n    let expr = this.makeCallDirect(program.newArrayInstance, [\n      module.i32(length),\n      program.options.isWasm64\n        ? module.i64(elementType.alignLog2)\n        : module.i32(elementType.alignLog2),\n      module.i32(arrayInstance.id),\n      program.options.isWasm64\n        ? module.i64(i64_low(source), i64_high(source))\n        : module.i32(i64_low(source))\n    ], reportNode);\n    this.currentType = arrayInstance.type;\n    return expr;\n  }\n\n  /** Compiles a special `fixed` array literal. */\n  private compileStaticArrayLiteral(\n    expression: ArrayLiteralExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n    let program = this.program;\n\n    // make sure this method is only called with a valid contextualType\n    let arrayInstance = assert(contextualType.getClass());\n    let arrayType = arrayInstance.type;\n    let typeArguments = assert(arrayInstance.getTypeArgumentsTo(program.staticArrayPrototype));\n    let elementType = typeArguments[0];\n\n    // block those here so compiling expressions doesn't conflict\n    let tempThis = flow.getTempLocal(this.options.usizeType);\n\n    // compile value expressions and check if all are compile-time constants\n    let expressions = expression.elementExpressions;\n    let length = expressions.length;\n    let values = new Array<ExpressionRef>(length);\n    let isStatic = !elementType.isExternalReference;\n    for (let i = 0; i < length; ++i) {\n      let elementExpression = expressions[i];\n      if (elementExpression.kind != NodeKind.Omitted) {\n        let expr = this.compileExpression(elementExpression, elementType, Constraints.ConvImplicit);\n        let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n        if (precomp) {\n          expr = precomp;\n        } else {\n          isStatic = false;\n        }\n        values[i] = expr;\n      } else {\n        values[i] = this.makeZero(elementType);\n      }\n    }\n\n    let isWasm64 = this.options.isWasm64;\n    let bufferSize = values.length << elementType.alignLog2;\n\n    // if the array is static, make a static arraybuffer segment\n    if (isStatic) {\n      let bufferSegment = this.addStaticBuffer(elementType, values, arrayInstance.id);\n      let bufferAddress = i64_add(bufferSegment.offset, i64_new(program.totalOverhead));\n\n      // return the static buffer directly if assigned to a global\n      if (constraints & Constraints.PreferStatic) {\n        let expr = this.options.isWasm64\n          ? module.i64(i64_low(bufferAddress), i64_high(bufferAddress))\n          : module.i32(i64_low(bufferAddress));\n        this.currentType = arrayType;\n        return expr;\n\n      // otherwise allocate a new chunk of memory and return a copy of the buffer\n      } else {\n        // __newBuffer(bufferSize, id, buffer)\n        let expr = this.makeCallDirect(program.newBufferInstance, [\n          isWasm64\n            ? module.i64(bufferSize)\n            : module.i32(bufferSize),\n          module.i32(arrayInstance.id),\n          isWasm64\n            ? module.i64(i64_low(bufferAddress), i64_high(bufferAddress))\n            : module.i32(i64_low(bufferAddress))\n        ], expression);\n        this.currentType = arrayType;\n        return expr;\n      }\n    }\n\n    // otherwise compile an explicit instantiation with indexed sets\n    let indexedSet = arrayInstance.lookupOverload(OperatorKind.IndexedSet, true);\n    if (!indexedSet) {\n      this.error(\n        DiagnosticCode.Index_signature_in_type_0_only_permits_reading,\n        expression.range, arrayInstance.internalName\n      );\n      this.currentType = arrayType;\n      return module.unreachable();\n    }\n    let arrayTypeRef = arrayType.toRef();\n\n    let stmts = new Array<ExpressionRef>();\n    // tempThis = __newBuffer(bufferSize, classId)\n    stmts.push(\n      module.local_set(tempThis.index,\n        this.makeCallDirect(program.newBufferInstance, [\n          isWasm64\n            ? module.i64(bufferSize)\n            : module.i32(bufferSize),\n          module.i32(arrayInstance.id)\n        ], expression),\n        arrayType.isManaged\n      )\n    );\n    for (let i = 0; i < length; ++i) {\n      // array[i] = value\n      stmts.push(\n        module.call(indexedSet.internalName, [\n          module.local_get(tempThis.index, arrayTypeRef),\n          module.i32(i),\n          values[i]\n        ], TypeRef.None)\n      );\n    }\n    // -> tempThis\n    stmts.push(\n      module.local_get(tempThis.index, arrayTypeRef)\n    );\n    if (length) this.compileFunction(indexedSet);\n    this.currentType = arrayType;\n    return module.flatten(stmts, arrayTypeRef);\n  }\n\n  private compileObjectLiteral(expression: ObjectLiteralExpression, contextualType: Type): ExpressionRef {\n    let module = this.module;\n\n    // Check that contextual type is a class (TODO: hidden class for interfaces?)\n    let classReference = contextualType.getClass();\n    if (!classReference) {\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        expression.range, \"<object>\", contextualType.toString()\n      );\n      return module.unreachable();\n    }\n    let classType = classReference.type;\n    this.currentType = classType.nonNullableType;\n    if (classReference.kind == ElementKind.Interface) {\n      this.error(\n        DiagnosticCode.Not_implemented_0,\n        expression.range, \"Interface hidden classes\"\n      );\n      return module.unreachable();\n    }\n    if (classReference.is(CommonFlags.Abstract)) {\n      this.error(\n        DiagnosticCode.Cannot_create_an_instance_of_an_abstract_class,\n        expression.range\n      );\n      return module.unreachable();\n    }\n\n    // Check that the class is compatible with object literals\n    let ctorPrototype = classReference.prototype.constructorPrototype;\n    if (ctorPrototype) {\n      this.errorRelated(\n        DiagnosticCode.Class_0_cannot_declare_a_constructor_when_instantiated_from_an_object_literal,\n        expression.range, ctorPrototype.identifierNode.range, classType.toString()\n      );\n      return module.unreachable();\n    }\n\n    let isManaged = classType.isManaged;\n    if (!isManaged) {\n      this.checkUnsafe(expression, findDecorator(DecoratorKind.Unmanaged, classReference.decoratorNodes));\n    }\n\n    // check and compile field values\n    let names = expression.names;\n    let numNames = names.length;\n    let values = expression.values;\n    let members = classReference.members;\n    let hasErrors = false;\n    let exprs = new Array<ExpressionRef>();\n    let flow = this.currentFlow;\n    let tempLocal = flow.getTempLocal(classType);\n    let classTypeRef = classType.toRef();\n    assert(numNames == values.length);\n\n    // Assume all class fields will be omitted, and add them to our omitted list\n    let omittedFields = new Set<Property>();\n    if (members) {\n      for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n        let memberKey = _keys[i];\n        let member = assert(members.get(memberKey));\n        if (member && member.kind == ElementKind.PropertyPrototype) {\n          // only interested in fields (resolved during class finalization)\n          let property = (<PropertyPrototype>member).instance;\n          if (property && property.isField) {\n            omittedFields.add(property); // incl. private/protected\n          }\n        }\n      }\n    }\n\n    // Iterate through the members defined in our expression\n    let deferredProperties = new Array<Property>();\n    for (let i = 0; i < numNames; ++i) {\n      let memberName = names[i].text;\n      let member = classReference.getMember(memberName);\n      if (!member || member.kind != ElementKind.PropertyPrototype) {\n        this.error(\n          DiagnosticCode.Property_0_does_not_exist_on_type_1,\n          names[i].range, memberName, classType.toString()\n        );\n        hasErrors = true;\n        continue;\n      }\n      if (member.is(CommonFlags.Private)) {\n        this.error(\n          DiagnosticCode.Property_0_is_private_and_only_accessible_within_class_1,\n          names[i].range, memberName, classType.toString()\n        );\n        hasErrors = true;\n        continue;\n      }\n      if (member.is(CommonFlags.Protected)) {\n        this.error(\n          DiagnosticCode.Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses,\n          names[i].range, memberName, classType.toString()\n        );\n        hasErrors = true;\n        continue;\n      }\n      let propertyInstance = this.resolver.resolveProperty(<PropertyPrototype>member);\n      if (!propertyInstance) continue;\n      let setterInstance = propertyInstance.setterInstance;\n      if (!setterInstance) {\n        this.error(\n          DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n          names[i].range, memberName, classType.toString()\n        );\n        hasErrors = true;\n        continue;\n      }\n\n      // This member is no longer omitted, so delete from our omitted fields\n      omittedFields.delete(propertyInstance);\n\n      // Defer real properties to be set after fields are initialized\n      if (!propertyInstance.isField) {\n        deferredProperties.push(propertyInstance);\n        continue;\n      }\n\n      let propertyType = propertyInstance.type;\n      let expr = this.makeCallDirect(setterInstance, [\n        module.local_get(tempLocal.index, classTypeRef),\n        this.compileExpression(values[i], propertyType, Constraints.ConvImplicit),\n      ], setterInstance.identifierNode, true);\n      if (this.currentType != Type.void) { // in case\n        expr = module.drop(expr);\n      }\n      exprs.push(expr);\n    }\n\n    // Call deferred real property setters after\n    for (let i = 0, k = deferredProperties.length; i < k; ++i) {\n      let propertyInstance = deferredProperties[i];\n      let setterInstance = assert(propertyInstance.setterInstance);\n      exprs.push(\n        this.makeCallDirect(setterInstance, [\n          module.local_get(tempLocal.index, classTypeRef),\n          this.compileExpression(values[i], propertyInstance.type, Constraints.ConvImplicit)\n        ], setterInstance.identifierNode)\n      );\n    }\n\n    this.currentType = classType.nonNullableType;\n    if (hasErrors) return module.unreachable();\n\n    // Check remaining omitted fields\n    for (let _values = Set_values(omittedFields), j = 0, l = _values.length; j < l; ++j) {\n      let propertyInstance = _values[j];\n      assert(propertyInstance.isField);\n      let propertyType = propertyInstance.type;\n\n      if (propertyInstance.initializerNode) {\n        continue; // set by generated ctor\n      }\n\n      if (propertyType.isReference) {\n        if (!propertyType.isNullableReference) {\n          this.error(\n            DiagnosticCode.Property_0_is_missing_in_type_1_but_required_in_type_2,\n            expression.range, propertyInstance.name, \"<object>\", classType.toString()\n          );\n          hasErrors = true;\n          continue;\n        }\n      }\n\n      switch (propertyType.kind) {\n        // Number Types (and Number alias types)\n        case TypeKind.Bool:\n        case TypeKind.I8:\n        case TypeKind.I16:\n        case TypeKind.I32:\n        case TypeKind.I64:\n        case TypeKind.Isize:\n        case TypeKind.U8:\n        case TypeKind.U16:\n        case TypeKind.U32:\n        case TypeKind.U64:\n        case TypeKind.Usize:\n        case TypeKind.F32:\n        case TypeKind.F64: {\n          // Can store zeroes directly (no need to __link)\n          exprs.push(\n            module.store(\n              propertyType.byteSize,\n              module.local_get(tempLocal.index, classTypeRef),\n              this.makeZero(propertyType),\n              propertyType.toRef(),\n              propertyInstance.memoryOffset\n            )\n          );\n          continue;\n        }\n      }\n\n      // Otherwise error\n      this.error(\n        DiagnosticCode.Property_0_is_missing_in_type_1_but_required_in_type_2,\n        expression.range, propertyInstance.name, \"<object>\", classType.toString()\n      );\n      hasErrors = true;\n    }\n    if (hasErrors) return module.unreachable();\n\n    // generate the default constructor\n    let ctor = this.ensureConstructor(classReference, expression);\n    // note that this is not checking field initialization within the ctor, but\n    // instead checks conditions above with provided fields taken into account.\n\n    // allocate a new instance first and assign 'this' to the temp. local\n    exprs.unshift(\n      module.local_set(tempLocal.index,\n        this.compileInstantiate(ctor, [], Constraints.None, expression),\n        classType.isManaged\n      )\n    );\n\n    // once all field values have been set, return 'this'\n    exprs.push(\n      module.local_get(tempLocal.index, classTypeRef)\n    );\n\n    this.currentType = classType.nonNullableType;\n    return module.flatten(exprs, classTypeRef);\n  }\n\n  private compileNewExpression(\n    expression: NewExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n\n    // obtain the class being instantiated\n    let target = this.resolver.resolveTypeName(expression.typeName, flow, flow.sourceFunction);\n    if (!target) return module.unreachable();\n    if (target.kind != ElementKind.ClassPrototype) {\n      this.error(\n        DiagnosticCode.This_expression_is_not_constructable,\n        expression.typeName.range\n      );\n      return this.module.unreachable();\n    }\n    if (target.is(CommonFlags.Abstract)) {\n      this.error(\n        DiagnosticCode.Cannot_create_an_instance_of_an_abstract_class,\n        expression.typeName.range\n      );\n      return this.module.unreachable();\n    }\n    let classPrototype = <ClassPrototype>target;\n    let classInstance: Class | null = null;\n    let typeArguments = expression.typeArguments;\n    let classReference: Class | null;\n    if (\n      !typeArguments &&\n      (classReference = contextualType.classReference) &&\n      classReference.prototype == classPrototype &&\n      classReference.is(CommonFlags.Generic)\n    ) {\n      // e.g. `arr: Array<T> = new Array()`\n      classInstance = this.resolver.resolveClass(\n        classPrototype,\n        classReference.typeArguments,\n        cloneMap(flow.contextualTypeArguments)\n      );\n    } else {\n      classInstance = this.resolver.resolveClassInclTypeArguments(\n        classPrototype,\n        typeArguments,\n        flow,\n        flow.sourceFunction.parent, // relative to caller\n        cloneMap(flow.contextualTypeArguments),\n        expression\n      );\n    }\n    if (!classInstance) return module.unreachable();\n    if (contextualType == Type.void) constraints |= Constraints.WillDrop;\n    let ctor = this.ensureConstructor(classInstance, expression);\n    if (!ctor.hasDecorator(DecoratorFlags.Inline)) {\n      // Inlined ctors haven't been compiled yet and are checked upon inline\n      // compilation of their body instead.\n      this.checkFieldInitialization(classInstance, expression);\n    }\n    return this.compileInstantiate(ctor, expression.args, constraints, expression);\n  }\n\n  /** Gets the compiled constructor of the specified class or generates one if none is present. */\n  ensureConstructor(\n    /** Class wanting a constructor. */\n    classInstance: Class,\n    /** Report node. */\n    reportNode: Node\n  ): Function {\n    let instance = classInstance.constructorInstance;\n    if (instance) {\n      // shortcut if already compiled\n      if (instance.is(CommonFlags.Compiled)) return instance;\n      // do not attempt to compile if inlined anyway\n      if (!instance.hasDecorator(DecoratorFlags.Inline)) this.compileFunction(instance);\n    } else {\n      // clone base constructor if a derived class. note that we cannot just\n      // call the base ctor since the derived class may have additional fields.\n      let baseClass = classInstance.base;\n      let contextualTypeArguments = cloneMap(classInstance.contextualTypeArguments);\n      if (baseClass) {\n        let baseCtor = this.ensureConstructor(baseClass, reportNode);\n        this.checkFieldInitialization(baseClass, reportNode);\n        instance = new Function(\n          CommonNames.constructor,\n          new FunctionPrototype(\n            CommonNames.constructor,\n            classInstance,\n            // declaration is important, i.e. to access optional parameter initializers\n            (<FunctionDeclaration>baseCtor.declaration).clone()\n          ),\n          null,\n          Signature.create(\n            this.program,\n            baseCtor.signature.parameterTypes,\n            classInstance.type,\n            classInstance.type,\n            baseCtor.signature.requiredParameters,\n            baseCtor.signature.hasRest\n          ),\n          contextualTypeArguments\n        );\n\n      // otherwise make a default constructor\n      } else {\n        instance = new Function(\n          CommonNames.constructor,\n          new FunctionPrototype(\n            CommonNames.constructor,\n            classInstance, // bound\n            this.program.makeNativeFunctionDeclaration(CommonNames.constructor,\n              CommonFlags.Instance | CommonFlags.Constructor\n            )\n          ),\n          null,\n          Signature.create(this.program, [], classInstance.type, classInstance.type),\n          contextualTypeArguments\n        );\n      }\n\n      instance.set(CommonFlags.Compiled);\n      instance.prototype.setResolvedInstance(\"\", instance);\n      if (classInstance.is(CommonFlags.ModuleExport)) {\n        instance.set(CommonFlags.ModuleExport);\n      }\n      classInstance.constructorInstance = instance;\n      let members = classInstance.members;\n      if (!members) classInstance.members = members = new Map();\n      members.set(CommonNames.constructor, instance.prototype);\n\n      let previousFlow = this.currentFlow;\n      let flow = instance.flow;\n      this.currentFlow = flow;\n\n      // generate body\n      let signature = instance.signature;\n      let module = this.module;\n      let sizeTypeRef = this.options.sizeTypeRef;\n      let stmts = new Array<ExpressionRef>();\n\n      // {\n      //   this = <COND_ALLOC>\n      //   IF_DERIVED: this = super(this, ...args)\n      //   this.a = X\n      //   this.b = Y\n      //   return this\n      // }\n      stmts.push(\n        this.makeConditionalAllocation(classInstance, 0)\n      );\n      if (baseClass) {\n        let parameterTypes = signature.parameterTypes;\n        let numParameters = parameterTypes.length;\n        let operands = new Array<ExpressionRef>(1 + numParameters);\n        operands[0] = module.local_get(0, sizeTypeRef);\n        for (let i = 1; i <= numParameters; ++i) {\n          operands[i] = module.local_get(i, parameterTypes[i - 1].toRef());\n        }\n        stmts.push(\n          module.local_set(0,\n            this.makeCallDirect(assert(baseClass.constructorInstance), operands, reportNode, false),\n            baseClass.type.isManaged\n          )\n        );\n      }\n      this.makeFieldInitializationInConstructor(classInstance, stmts);\n      stmts.push(\n        module.local_get(0, sizeTypeRef)\n      );\n      this.currentFlow = previousFlow;\n\n      // make the function\n      let locals = instance.localsByIndex;\n      let varTypes = new Array<TypeRef>(); // of temp. vars added while compiling initializers\n      let numOperands = 1 + signature.parameterTypes.length;\n      let numLocals = locals.length;\n      if (numLocals > numOperands) {\n        for (let i = numOperands; i < numLocals; ++i) varTypes.push(locals[i].type.toRef());\n      }\n      let funcRef = module.addFunction(\n        instance.internalName,\n        signature.paramRefs,\n        signature.resultRefs,\n        varTypes,\n        module.flatten(stmts, sizeTypeRef)\n      );\n      instance.finalize(module, funcRef);\n    }\n\n    return instance;\n  }\n\n  /** Checks that all class fields have been initialized. */\n  checkFieldInitialization(classInstance: Class, relatedNode: Node | null = null): void {\n    if (classInstance.didCheckFieldInitialization) return;\n    classInstance.didCheckFieldInitialization = true;\n    let ctor = assert(classInstance.constructorInstance);\n    this.checkFieldInitializationInFlow(classInstance, ctor.flow, relatedNode);\n  }\n\n  /** Checks that all class fields have been initialized in the specified flow. */\n  checkFieldInitializationInFlow(classInstance: Class, flow: Flow, relatedNode: Node | null = null): void {\n    let members = classInstance.members;\n    if (members) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let element = _values[i];\n        if (element.kind != ElementKind.PropertyPrototype || element.parent != classInstance) continue;\n        // only interested in fields (resolved during class finalization)\n        let property = (<PropertyPrototype>element).instance;\n        if (!property || !property.isField) continue;\n        if (!property.initializerNode && !flow.isThisFieldFlag(property, FieldFlags.Initialized)) {\n          if (!property.is(CommonFlags.DefinitelyAssigned)) {\n            if (relatedNode) {\n              this.errorRelated(\n                DiagnosticCode.Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned,\n                property.declaration.name.range,\n                relatedNode.range,\n                property.internalName\n              );\n            } else {\n              this.error(\n                DiagnosticCode.Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned,\n                property.declaration.name.range,\n                property.internalName\n              );\n            }\n          }\n        } else if (property.is(CommonFlags.DefinitelyAssigned)) {\n          if (property.type.isReference) {\n            this.warning( // involves a runtime check\n              DiagnosticCode.Property_0_is_always_assigned_before_being_used,\n              property.identifierNode.range,\n              property.internalName\n            );\n          } else {\n            this.pedantic( // is a nop anyway\n              DiagnosticCode.Unnecessary_definite_assignment,\n              property.identifierNode.range\n            );\n          }\n        }\n      }\n    }\n  }\n\n  compileInstantiate(\n    /** Constructor to call. */\n    ctorInstance: Function,\n    /** Constructor arguments. */\n    argumentExpressions: Expression[],\n    /** Contextual flags. */\n    constraints: Constraints,\n    /** Node to report on. */\n    reportNode: Node\n  ): ExpressionRef {\n    assert(ctorInstance.is(CommonFlags.Constructor));\n    let parent = ctorInstance.parent;\n    assert(parent.kind == ElementKind.Class);\n    let classInstance = <Class>parent;\n    if (classInstance.type.isUnmanaged || ctorInstance.hasDecorator(DecoratorFlags.Unsafe)) this.checkUnsafe(reportNode);\n    let expr = this.compileCallDirect(\n      ctorInstance,\n      argumentExpressions,\n      reportNode,\n      this.makeZero(this.options.usizeType),\n      constraints\n    );\n    if (getExpressionType(expr) != TypeRef.None) { // possibly WILL_DROP\n      this.currentType = classInstance.type; // important because a super ctor could be called\n    }\n    return expr;\n  }\n\n  private compilePropertyAccessExpression(\n    expression: PropertyAccessExpression,\n    ctxType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n\n    this.maybeCompileEnclosingSource(expression);\n\n    let resolver = this.resolver;\n    let target = resolver.lookupExpression(expression, flow, ctxType); // reports\n    if (!target) return module.unreachable();\n    let thisExpression = resolver.currentThisExpression;\n    if (target.hasDecorator(DecoratorFlags.Unsafe)) this.checkUnsafe(expression);\n\n    switch (target.kind) {\n      case ElementKind.Global: { // static field\n        let global = <Global>target;\n        if (!this.compileGlobalLazy(global, expression)) {\n          return module.unreachable();\n        }\n        let globalType = global.type;\n        assert(globalType != Type.void);\n        if (this.pendingElements.has(global)) {\n          this.error(\n            DiagnosticCode.Variable_0_used_before_its_declaration,\n            expression.range,\n            global.internalName\n          );\n          this.currentType = globalType;\n          return module.unreachable();\n        }\n        if (global.is(CommonFlags.Inlined)) {\n          return this.compileInlineConstant(global, ctxType, constraints);\n        }\n        let expr = module.global_get(global.internalName, globalType.toRef());\n        if (global.is(CommonFlags.DefinitelyAssigned) && globalType.isReference && !globalType.isNullableReference) {\n          expr = this.makeRuntimeNonNullCheck(expr, globalType, expression);\n        }\n        this.currentType = globalType;\n        return expr;\n      }\n      case ElementKind.EnumValue: { // enum value\n        let enumValue = <EnumValue>target;\n        let parent = assert(enumValue.parent);\n        assert(parent.kind == ElementKind.Enum);\n        let parentEnum = <Enum>parent;\n        if (!this.compileEnum(parentEnum)) {\n          this.currentType = Type.i32;\n          return this.module.unreachable();\n        }\n        this.currentType = Type.i32;\n        if (enumValue.is(CommonFlags.Inlined)) {\n          assert(enumValue.constantValueKind == ConstantValueKind.Integer);\n          return this.compileInlineConstant(enumValue, ctxType, constraints);\n        }\n        assert(enumValue.type == Type.i32);\n        return module.global_get(enumValue.internalName, TypeRef.I32);\n      }\n      case ElementKind.PropertyPrototype: {\n        let propertyPrototype = <PropertyPrototype>target;\n        let propertyInstance = this.resolver.resolveProperty(propertyPrototype);\n        if (!propertyInstance) return module.unreachable();\n        target = propertyInstance;\n        // fall-through\n      }\n      case ElementKind.Property: {\n        let propertyInstance = <Property>target;\n        if (propertyInstance.isField) {\n          if (\n            flow.sourceFunction.is(CommonFlags.Constructor) &&\n            assert(thisExpression).kind == NodeKind.This &&\n            !flow.isThisFieldFlag(propertyInstance, FieldFlags.Initialized) &&\n            !propertyInstance.is(CommonFlags.DefinitelyAssigned)\n          ) {\n            this.errorRelated(\n              DiagnosticCode.Property_0_is_used_before_being_assigned,\n              expression.range,\n              propertyInstance.identifierNode.range,\n              propertyInstance.internalName\n            );\n          }\n        }\n        let getterInstance = propertyInstance.getterInstance;\n        if (!getterInstance) return module.unreachable(); // failed earlier\n        let thisArg: ExpressionRef = 0;\n        if (getterInstance.is(CommonFlags.Instance)) {\n          thisArg = this.compileExpression(\n            assert(thisExpression),\n            assert(getterInstance.signature.thisType),\n            Constraints.ConvImplicit | Constraints.IsThis\n          );\n        }\n        return this.compileCallDirect(getterInstance, [], expression, thisArg);\n      }\n      case ElementKind.FunctionPrototype: {\n        let functionPrototype = <FunctionPrototype>target;\n        let typeParameterNodes = functionPrototype.typeParameterNodes;\n\n        if (typeParameterNodes && typeParameterNodes.length != 0) {\n          this.error(\n            DiagnosticCode.Type_argument_expected,\n            expression.range\n          );\n          break; // also diagnose 'not a value at runtime'\n        }\n\n        let functionInstance = this.resolver.resolveFunction(functionPrototype, null);\n        if (!functionInstance) return module.unreachable();\n        if (!this.compileFunction(functionInstance)) return module.unreachable();\n        this.currentType = functionInstance.type;\n\n        if (functionInstance.hasDecorator(DecoratorFlags.Builtin)) {\n          this.error(\n            DiagnosticCode.Not_implemented_0,\n            expression.range, \"First-class built-ins\"\n          );\n          return module.unreachable();\n        }\n\n        let offset = this.ensureRuntimeFunction(functionInstance);\n        return this.options.isWasm64\n          ? module.i64(i64_low(offset), i64_high(offset))\n          : module.i32(i64_low(offset));\n      }\n    }\n    this.error(\n      DiagnosticCode.Expression_does_not_compile_to_a_value_at_runtime,\n      expression.range\n    );\n    return this.module.unreachable();\n  }\n\n  private compileTernaryExpression(\n    expression: TernaryExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let module = this.module;\n    let ifThen = expression.ifThen;\n    let ifElse = expression.ifElse;\n\n    let condExpr = this.compileExpression(expression.condition, Type.bool);\n    let condExprTrueish = this.makeIsTrueish(condExpr, this.currentType, expression.condition);\n    // Try to eliminate unnecesssary branches if the condition is constant\n    // FIXME: skips common denominator, inconsistently picking branch type\n    let condKind = this.evaluateCondition(condExprTrueish);\n    if (condKind == ConditionKind.True) {\n      return module.maybeDropCondition(condExprTrueish, this.compileExpression(ifThen, contextualType));\n    }\n    if (condKind == ConditionKind.False) {\n      return module.maybeDropCondition(condExprTrueish, this.compileExpression(ifElse, contextualType));\n    }\n\n    let outerFlow = this.currentFlow;\n    let ifThenFlow = outerFlow.forkThen(condExpr);\n    this.currentFlow = ifThenFlow;\n    let ifThenExpr = this.compileExpression(ifThen, contextualType);\n    let ifThenType = this.currentType;\n\n    let ifElseFlow = outerFlow.forkElse(condExpr);\n    this.currentFlow = ifElseFlow;\n    let ifElseExpr = this.compileExpression(ifElse, contextualType == Type.auto ? ifThenType : contextualType);\n    let ifElseType = this.currentType;\n\n    if (contextualType == Type.void) { // values, including type mismatch, are irrelevant\n      if (ifThenType != Type.void) {\n        ifThenExpr = module.drop(ifThenExpr);\n        ifThenType = Type.void;\n      }\n      if (ifElseType != Type.void) {\n        ifElseExpr = module.drop(ifElseExpr);\n        ifElseType = Type.void;\n      }\n      this.currentType = Type.void;\n    } else {\n      let commonType = Type.commonType(ifThenType, ifElseType, contextualType);\n      if (!commonType) {\n        this.error(\n          DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n          ifElse.range, ifElseType.toString(), ifThenType.toString()\n        );\n        this.currentType = contextualType;\n        return module.unreachable();\n      }\n      ifThenExpr = this.convertExpression(ifThenExpr, ifThenType, commonType, false, ifThen);\n      ifThenType = commonType;\n      ifElseExpr = this.convertExpression(ifElseExpr, ifElseType, commonType, false, ifElse);\n      ifElseType = commonType;\n      this.currentType = commonType;\n    }\n\n    outerFlow.inheritAlternatives(ifThenFlow, ifElseFlow);\n    this.currentFlow = outerFlow;\n\n    return module.if(condExprTrueish, ifThenExpr, ifElseExpr);\n  }\n\n  private compileUnaryPostfixExpression(\n    expression: UnaryPostfixExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n\n    // make a getter for the expression (also obtains the type)\n    let getValue = this.compileExpression( // reports\n      expression.operand,\n      contextualType.exceptVoid,\n      Constraints.None\n    );\n\n    // if the value isn't dropped, a temp. local is required to remember the original value,\n    // except if a static overload is found, which reverses the use of a temp. (see below)\n    let tempLocal: Local | null = null;\n    if (contextualType != Type.void) {\n      tempLocal = flow.getTempLocal(this.currentType);\n      getValue = module.local_tee(\n        tempLocal.index,\n        getValue,\n        this.currentType.isManaged\n      );\n    }\n\n    let expr: ExpressionRef;\n\n    switch (expression.operator) {\n      case Token.Plus_Plus: {\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.PostfixInc);\n          if (overload) {\n            let isInstance = overload.is(CommonFlags.Instance);\n            if (tempLocal && !isInstance) { // revert: static overload simply returns\n              getValue = getLocalSetValue(getValue);\n              tempLocal = null;\n            }\n            expr = this.compileUnaryOverload(overload, expression.operand, getValue, expression);\n            if (isInstance) break;\n            return expr; // here\n          }\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"++\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        switch (this.currentType.kind) {\n          case TypeKind.Bool:\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32: {\n            expr = module.binary(\n              BinaryOp.AddI32,\n              getValue,\n              module.i32(1)\n            );\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(\n              BinaryOp.AddI64,\n              getValue,\n              module.i64(1)\n            );\n            break;\n          }\n          case TypeKind.Isize:\n          case TypeKind.Usize: {\n            expr = module.binary(\n              BinaryOp.AddSize,\n              getValue,\n              this.makeOne(this.currentType)\n            );\n            break;\n          }\n          case TypeKind.F32: {\n            expr = module.binary(\n              BinaryOp.AddF32,\n              getValue,\n              module.f32(1)\n            );\n            break;\n          }\n          case TypeKind.F64: {\n            expr = module.binary(\n              BinaryOp.AddF64,\n              getValue,\n              module.f64(1)\n            );\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"++\", this.currentType.toString()\n            );\n            return module.unreachable();\n          }\n        }\n        break;\n      }\n      case Token.Minus_Minus: {\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.PostfixDec);\n          if (overload) {\n            let isInstance = overload.is(CommonFlags.Instance);\n            if (tempLocal && !isInstance) { // revert: static overload simply returns\n              getValue = getLocalSetValue(getValue);\n              tempLocal = null;\n            }\n            expr = this.compileUnaryOverload(overload, expression.operand, getValue, expression);\n            if (overload.is(CommonFlags.Instance)) break;\n            return expr; // here\n          }\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"--\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        switch (this.currentType.kind) {\n          case TypeKind.Bool:\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32: {\n            expr = module.binary(\n              BinaryOp.SubI32,\n              getValue,\n              module.i32(1)\n            );\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(\n              BinaryOp.SubI64,\n              getValue,\n              module.i64(1)\n            );\n            break;\n          }\n          case TypeKind.Isize:\n          case TypeKind.Usize: {\n            expr = module.binary(\n              BinaryOp.SubSize,\n              getValue,\n              this.makeOne(this.currentType)\n            );\n            break;\n          }\n          case TypeKind.F32: {\n            expr = module.binary(\n              BinaryOp.SubF32,\n              getValue,\n              module.f32(1)\n            );\n            break;\n          }\n          case TypeKind.F64: {\n            expr = module.binary(\n              BinaryOp.SubF64,\n              getValue,\n              module.f64(1)\n            );\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"--\", this.currentType.toString()\n            );\n            return module.unreachable();\n          }\n        }\n        break;\n      }\n      default: {\n        assert(false);\n        return module.unreachable();\n      }\n    }\n\n    let resolver = this.resolver;\n    let target = resolver.lookupExpression(expression.operand, flow); // reports\n    if (!target) {\n      return module.unreachable();\n    }\n\n    // simplify if dropped anyway\n    if (!tempLocal) {\n      return this.makeAssignment(\n        target,\n        expr,\n        this.currentType,\n        expression.operand,\n        resolver.currentThisExpression,\n        resolver.currentElementExpression,\n        false\n      );\n    }\n\n    // otherwise use the temp. local for the intermediate value (always possibly overflows)\n    let setValue = this.makeAssignment(\n      target,\n      expr, // includes a tee of getValue to tempLocal\n      this.currentType,\n      expression.operand,\n      resolver.currentThisExpression,\n      resolver.currentElementExpression,\n      false\n    );\n\n    this.currentType = tempLocal.type;\n    let typeRef = tempLocal.type.toRef();\n\n    return module.block(null, [\n      setValue,\n      module.local_get(tempLocal.index, typeRef)\n    ], typeRef); // result of 'x++' / 'x--' might overflow\n  }\n\n  private compileUnaryPrefixExpression(\n    expression: UnaryPrefixExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let module = this.module;\n    let compound = false;\n    let expr: ExpressionRef;\n\n    switch (expression.operator) {\n      case Token.Plus: {\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType.exceptVoid,\n          Constraints.None\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Plus);\n          if (overload) return this.compileUnaryOverload(overload, expression.operand, expr, expression);\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"+\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        // nop\n        break;\n      }\n      case Token.Minus: {\n        let operand = expression.operand;\n        if (operand.isNumericLiteral) {\n          // implicitly negate integer and float literals. also enables proper checking of literal ranges.\n          expr = this.compileLiteralExpression(<LiteralExpression>operand, contextualType, Constraints.None, true);\n          // compileExpression normally does this:\n          if (this.options.sourceMap) this.addDebugLocation(expr, expression.range);\n          break;\n        }\n\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType.exceptVoid,\n          Constraints.None\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Minus);\n          if (overload) return this.compileUnaryOverload(overload, expression.operand, expr, expression);\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"-\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        switch (this.currentType.kind) {\n          case TypeKind.Bool:\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32: {\n            expr = module.binary(BinaryOp.SubI32, module.i32(0), expr);\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(BinaryOp.SubI64, module.i64(0), expr);\n            break;\n          }\n          case TypeKind.Isize:\n          case TypeKind.Usize: {\n            expr = module.binary(\n              BinaryOp.SubSize,\n              this.makeZero(this.currentType),\n              expr\n            );\n            break;\n          }\n          case TypeKind.F32: {\n            expr = module.unary(UnaryOp.NegF32, expr);\n            break;\n          }\n          case TypeKind.F64: {\n            expr = module.unary(UnaryOp.NegF64, expr);\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"-\", this.currentType.toString()\n            );\n            expr = module.unreachable();\n          }\n        }\n        break;\n      }\n      case Token.Plus_Plus: {\n        compound = true;\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType.exceptVoid,\n          Constraints.None\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.PrefixInc);\n          if (overload) {\n            expr = this.compileUnaryOverload(overload, expression.operand, expr, expression);\n            if (overload.is(CommonFlags.Instance)) break; // re-assign\n            return expr; // skip re-assign\n          }\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"++\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        switch (this.currentType.kind) {\n          case TypeKind.Bool:\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32: {\n            expr = module.binary(BinaryOp.AddI32, expr, this.module.i32(1));\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(BinaryOp.AddI64, expr, module.i64(1));\n            break;\n          }\n          case TypeKind.Isize:\n          case TypeKind.Usize: {\n            expr = module.binary(\n              BinaryOp.AddSize,\n              expr,\n              this.makeOne(this.currentType)\n            );\n            break;\n          }\n          case TypeKind.F32: {\n            expr = module.binary(BinaryOp.AddF32, expr, module.f32(1));\n            break;\n          }\n          case TypeKind.F64: {\n            expr = module.binary(BinaryOp.AddF64, expr, module.f64(1));\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"++\", this.currentType.toString()\n            );\n            expr = module.unreachable();\n          }\n        }\n        break;\n      }\n      case Token.Minus_Minus: {\n        compound = true;\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType.exceptVoid,\n          Constraints.None\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.PrefixDec);\n          if (overload) {\n            expr = this.compileUnaryOverload(overload, expression.operand, expr, expression);\n            if (overload.is(CommonFlags.Instance)) break; // re-assign\n            return expr; // skip re-assign\n          }\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"--\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        switch (this.currentType.kind) {\n          case TypeKind.Bool:\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32: {\n            expr = module.binary(BinaryOp.SubI32, expr, module.i32(1));\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(BinaryOp.SubI64, expr, module.i64(1));\n            break;\n          }\n          case TypeKind.Isize:\n          case TypeKind.Usize: {\n            expr = module.binary(\n              BinaryOp.SubSize,\n              expr,\n              this.makeOne(this.currentType)\n            );\n            break;\n          }\n          case TypeKind.F32: {\n            expr = module.binary(BinaryOp.SubF32, expr, module.f32(1));\n            break;\n          }\n          case TypeKind.F64: {\n            expr = module.binary(BinaryOp.SubF64, expr, module.f64(1));\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"--\", this.currentType.toString()\n            );\n            expr = module.unreachable();\n          }\n        }\n        break;\n      }\n      case Token.Exclamation: {\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType.exceptVoid,\n          Constraints.None\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Not);\n          if (overload) return this.compileUnaryOverload(overload, expression.operand, expr, expression);\n          // fall back to compare by value\n        }\n\n        expr = module.unary(UnaryOp.EqzI32, this.makeIsTrueish(expr, this.currentType, expression.operand));\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.Tilde: {\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType == Type.void\n            ? Type.i32\n            : contextualType.isFloatValue\n              ? Type.i64\n              : contextualType,\n          Constraints.None\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BitwiseNot);\n          if (overload) return this.compileUnaryOverload(overload, expression.operand, expr, expression);\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"~\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        expr = this.convertExpression(expr, this.currentType, this.currentType.intType, false, expression.operand);\n\n        switch (this.currentType.kind) {\n          case TypeKind.Bool:\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32: {\n            expr = module.binary(BinaryOp.XorI32, expr, module.i32(-1));\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(BinaryOp.XorI64, expr, module.i64(-1, -1));\n            break;\n          }\n          case TypeKind.Isize:\n          case TypeKind.Usize: {\n            expr = module.binary(\n              BinaryOp.XorSize,\n              expr,\n              this.makeNegOne(this.currentType)\n            );\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"~\", this.currentType.toString()\n            );\n            expr = module.unreachable();\n          }\n        }\n        break;\n      }\n      case Token.TypeOf: {\n        return this.compileTypeof(expression, contextualType, constraints);\n      }\n      case Token.Dot_Dot_Dot: {\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          expression.range, \"Spread operator\"\n        );\n        return module.unreachable();\n      }\n      default: {\n        assert(false);\n        return module.unreachable();\n      }\n    }\n    if (!compound) return expr;\n    let resolver = this.resolver;\n    let target = resolver.lookupExpression(expression.operand, this.currentFlow);\n    if (!target) return module.unreachable();\n    return this.makeAssignment(\n      target,\n      expr,\n      this.currentType,\n      expression.operand,\n      resolver.currentThisExpression,\n      resolver.currentElementExpression,\n      contextualType != Type.void\n    );\n  }\n\n  private compileTypeof(\n    expression: UnaryPrefixExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let operand = expression.operand;\n    let expr: ExpressionRef = 0;\n    let stringInstance = this.program.stringInstance;\n    let typeString: string;\n    if (operand.kind == NodeKind.Null) {\n      typeString = \"object\"; // special since `null` without type context is usize\n    } else {\n      let element = this.resolver.lookupExpression(operand, this.currentFlow, Type.auto, ReportMode.Swallow);\n      if (!element) {\n        switch (operand.kind) {\n          case NodeKind.Identifier: break; // ignore error: typeof doesntExist -> undefined\n          case NodeKind.PropertyAccess:\n          case NodeKind.ElementAccess: {\n            operand = operand.kind == NodeKind.PropertyAccess\n              ? (<PropertyAccessExpression>operand).expression\n              : (<ElementAccessExpression>operand).expression;\n            let targetType = this.resolver.resolveExpression(operand, this.currentFlow, Type.auto, ReportMode.Report);\n            if (!targetType) { // access on non-object\n              this.currentType = stringInstance.type;\n              return this.module.unreachable();\n            }\n            // fall-through\n          }\n          default: {\n            expr = this.compileExpression(operand, Type.auto); // may trigger an error\n            expr = this.convertExpression(expr, this.currentType, Type.void, true, operand);\n          }\n        }\n        typeString = \"undefined\";\n      } else {\n        switch (element.kind) {\n          case ElementKind.ClassPrototype:\n          case ElementKind.Namespace:\n          case ElementKind.Enum: {\n            typeString = \"object\";\n            break;\n          }\n          case ElementKind.FunctionPrototype: {\n            typeString = \"function\";\n            break;\n          }\n          default: {\n            expr = this.compileExpression(operand, Type.auto);\n            let type = this.currentType;\n            expr = this.convertExpression(expr, type, Type.void, true, operand);\n            if (type.isReference) {\n              let signatureReference = type.getSignature();\n              if (signatureReference) {\n                typeString = \"function\";\n              } else {\n                let classReference = type.getClass();\n                if (classReference) {\n                  if (classReference.prototype == stringInstance.prototype) {\n                    typeString = \"string\";\n                  } else {\n                    typeString = \"object\";\n                  }\n                } else {\n                  typeString = \"externref\"; // TODO?\n                }\n              }\n            } else if (type == Type.bool) {\n              typeString = \"boolean\";\n            } else if (type.isNumericValue) {\n              typeString = \"number\";\n            } else {\n              typeString = \"undefined\"; // failed to compile?\n            }\n            break;\n          }\n        }\n      }\n    }\n    this.currentType = stringInstance.type;\n    return expr\n      ? this.module.block(null, [ expr, this.ensureStaticString(typeString) ], this.options.sizeTypeRef)\n      : this.ensureStaticString(typeString);\n  }\n\n  /** Makes sure that a 32-bit integer value is wrapped to a valid value of the specified type. */\n  ensureSmallIntegerWrap(expr: ExpressionRef, type: Type): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n    switch (type.kind) {\n      case TypeKind.Bool: {\n        if (flow.canOverflow(expr, type)) {\n          // bool is special in that it compares to 0 instead of masking with 0x1\n          expr = module.binary(BinaryOp.NeI32,\n            expr,\n            module.i32(0)\n          );\n        }\n        break;\n      }\n      case TypeKind.I8: {\n        if (flow.canOverflow(expr, type)) {\n          expr = this.options.hasFeature(Feature.SignExtension)\n            ? module.unary(UnaryOp.Extend8I32, expr)\n            : module.binary(BinaryOp.ShrI32,\n                module.binary(BinaryOp.ShlI32,\n                  expr,\n                  module.i32(24)\n                ),\n                module.i32(24)\n              );\n        }\n        break;\n      }\n      case TypeKind.I16: {\n        if (flow.canOverflow(expr, type)) {\n          expr = this.options.hasFeature(Feature.SignExtension)\n            ? module.unary(UnaryOp.Extend16I32, expr)\n            : module.binary(BinaryOp.ShrI32,\n                module.binary(BinaryOp.ShlI32,\n                  expr,\n                  module.i32(16)\n                ),\n                module.i32(16)\n              );\n        }\n        break;\n      }\n      case TypeKind.U8: {\n        if (flow.canOverflow(expr, type)) {\n          expr = module.binary(BinaryOp.AndI32,\n            expr,\n            module.i32(0xff)\n          );\n        }\n        break;\n      }\n      case TypeKind.U16: {\n        if (flow.canOverflow(expr, type)) {\n          expr = module.binary(BinaryOp.AndI32,\n            expr,\n            module.i32(0xffff)\n          );\n        }\n        break;\n      }\n    }\n    return expr;\n  }\n\n  /** Adds the debug location of the specified expression at the specified range to the source map. */\n  addDebugLocation(expr: ExpressionRef, range: Range): void {\n    let targetFunction = this.currentFlow.targetFunction;\n    let source = range.source;\n    if (source.debugInfoIndex < 0) source.debugInfoIndex = this.module.addDebugInfoFile(source.normalizedPath);\n    // It's possible that an `expr` is seen multiple times, for example when\n    // first adding debug information for an inner expression and later on for\n    // an expression supposedly wrapping it, where the wrapping became a noop.\n    targetFunction.debugLocations.set(expr, range);\n  }\n\n  /** Checks whether a particular function signature is supported. */\n  checkSignatureSupported(signature: Signature, reportNode: FunctionTypeNode): bool {\n    let supported = true;\n    let explicitThisType = reportNode.explicitThisType;\n    if (explicitThisType) {\n      if (!this.program.checkTypeSupported(assert(signature.thisType), explicitThisType)) {\n        supported = false;\n      }\n    }\n    let parameterTypes = signature.parameterTypes;\n    let parameterNodes = reportNode.parameters;\n    for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n      let parameterReportNode: Node;\n      if (parameterNodes.length > i) parameterReportNode = parameterNodes[i];\n      else parameterReportNode = reportNode;\n      if (!this.program.checkTypeSupported(parameterTypes[i], parameterReportNode)) {\n        supported = false;\n      }\n    }\n    if (!this.program.checkTypeSupported(signature.returnType, reportNode.returnType)) {\n      supported = false;\n    }\n    return supported;\n  }\n\n  /** Evaluates a boolean condition, determining whether it is TRUE, FALSE or UNKNOWN. */\n  evaluateCondition(expr: ExpressionRef): ConditionKind {\n    let type = getExpressionType(expr);\n    if (type == TypeRef.Unreachable)\n      return ConditionKind.Unknown;\n\n    assert(type == TypeRef.I32);\n    let module = this.module;\n    let evaled = module.runExpression(expr, ExpressionRunnerFlags.Default);\n    if (evaled) {\n      return getConstValueI32(evaled)\n        ? ConditionKind.True\n        : ConditionKind.False;\n    }\n    return ConditionKind.Unknown;\n  }\n\n  // === Specialized code generation ==============================================================\n\n  /** Makes a constant zero of the specified type. */\n  makeZero(type: Type): ExpressionRef {\n    let module = this.module;\n    switch (type.kind) {\n      default: assert(false);\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32: return module.i32(0);\n      case TypeKind.Isize:\n      case TypeKind.Usize: if (type.size != 64) return module.i32(0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.i64(0);\n      case TypeKind.F32: return module.f32(0);\n      case TypeKind.F64: return module.f64(0);\n      case TypeKind.V128: return module.v128(v128_zero);\n      case TypeKind.Func:\n      case TypeKind.Extern:\n      case TypeKind.Any:\n      case TypeKind.Eq:\n      case TypeKind.Struct:\n      case TypeKind.Array:\n      case TypeKind.String:\n      case TypeKind.StringviewWTF8:\n      case TypeKind.StringviewWTF16:\n      case TypeKind.StringviewIter: {\n        if (type.is(TypeFlags.Nullable)) return module.ref_null(type.toRef());\n        assert(false); // TODO: check that refs are nullable in callers?\n        return module.unreachable();\n      }\n      case TypeKind.I31: {\n        if (type.is(TypeFlags.Nullable)) return module.ref_null(type.toRef());\n        return module.i31_new(module.i32(0));\n      }\n    }\n  }\n\n  /** Makes a constant one of the specified type. */\n  makeOne(type: Type): ExpressionRef {\n    let module = this.module;\n    switch (type.kind) {\n      default: assert(false);\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32: return module.i32(1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: if (type.size != 64) return module.i32(1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.i64(1);\n      case TypeKind.F32: return module.f32(1);\n      case TypeKind.F64: return module.f64(1);\n      case TypeKind.I31: return module.i31_new(module.i32(1));\n    }\n  }\n\n  /** Makes a constant negative one of the specified type. */\n  makeNegOne(type: Type): ExpressionRef {\n    let module = this.module;\n    switch (type.kind) {\n      default: assert(false);\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32: return module.i32(-1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: if (type.size != 64) return module.i32(-1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.i64(-1, -1);\n      case TypeKind.F32: return module.f32(-1);\n      case TypeKind.F64: return module.f64(-1);\n      case TypeKind.V128: return module.v128(v128_ones);\n      case TypeKind.I31: return module.i31_new(module.i32(-1));\n    }\n  }\n\n  /** Creates a comparison whether an expression is 'true' in a broader sense. */\n  makeIsTrueish(expr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        expr = this.ensureSmallIntegerWrap(expr, type);\n        // fall-through\n      }\n      case TypeKind.Bool: // not a mask, just != 0\n      case TypeKind.I32:\n      case TypeKind.U32: return expr;\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.NeI64, expr, module.i64(0));\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return type.size == 64\n          ? module.binary(BinaryOp.NeI64, expr, module.i64(0))\n          : expr;\n      }\n      case TypeKind.F32: {\n        let options = this.options;\n        if (\n          options.shrinkLevelHint > 1 &&\n          options.hasFeature(Feature.NontrappingF2I)\n        ) {\n          // Use more compact but slower 5-byte (3 bytes in best case) approach\n          // !!(i32.trunc_sat_f32_u(f32.ceil(f32.abs(x))))\n          return module.unary(UnaryOp.EqzI32,\n            module.unary(UnaryOp.EqzI32,\n              module.unary(UnaryOp.TruncSatF32ToU32,\n                module.unary(UnaryOp.CeilF32,\n                  module.unary(UnaryOp.AbsF32, expr)\n                )\n              )\n            )\n          );\n        } else {\n          // 0 < abs(bitCast(x)) <= bitCast(Infinity) or\n          // (reinterpret<u32>(x) & 0x7FFFFFFF) - 1 <= 0x7F800000 - 1\n          //\n          // and finally:\n          // (reinterpret<u32>(x) << 1) - (1 << 1) <= ((0x7F800000 - 1) << 1)\n          return module.binary(BinaryOp.LeU32,\n            module.binary(BinaryOp.SubI32,\n              module.binary(BinaryOp.ShlI32,\n                module.unary(UnaryOp.ReinterpretF32ToI32, expr),\n                module.i32(1)\n              ),\n              module.i32(2) // 1 << 1\n            ),\n            module.i32(0xFEFFFFFE) // (0x7F800000 - 1) << 1\n          );\n        }\n      }\n      case TypeKind.F64: {\n        let options = this.options;\n        if (\n          options.shrinkLevelHint > 1 &&\n          options.hasFeature(Feature.NontrappingF2I)\n        ) {\n          // Use more compact but slower 5-byte (3 bytes in best case) approach\n          // !!(i32.trunc_sat_f64_u(f64.ceil(f64.abs(x))))\n          return module.unary(UnaryOp.EqzI32,\n            module.unary(UnaryOp.EqzI32,\n              module.unary(UnaryOp.TruncSatF64ToU32,\n                module.unary(UnaryOp.CeilF64,\n                  module.unary(UnaryOp.AbsF64, expr)\n                )\n              )\n            )\n          );\n        } else {\n          // 0 < abs(bitCast(x)) <= bitCast(Infinity) or\n          // (reinterpret<u64>(x) & 0x7FFFFFFFFFFFFFFF) - 1 <= 0x7FF0000000000000 - 1\n          //\n          // and finally:\n          // (reinterpret<u64>(x) << 1) - (1 << 1) <= ((0x7FF0000000000000 - 1) << 1)\n          return module.binary(BinaryOp.LeU64,\n            module.binary(BinaryOp.SubI64,\n              module.binary(BinaryOp.ShlI64,\n                module.unary(UnaryOp.ReinterpretF64ToI64, expr),\n                module.i64(1)\n              ),\n              module.i64(2) // 1 << 1\n            ),\n            module.i64(0xFFFFFFFE, 0xFFDFFFFF) // (0x7FF0000000000000 - 1) << 1\n          );\n        }\n      }\n      case TypeKind.V128: {\n        return module.unary(UnaryOp.AnyTrueV128, expr);\n      }\n      case TypeKind.Func:\n      case TypeKind.Extern:\n      case TypeKind.Any:\n      case TypeKind.Eq:\n      case TypeKind.Struct:\n      case TypeKind.Array:\n      case TypeKind.I31:\n      case TypeKind.String:\n      case TypeKind.StringviewWTF8:\n      case TypeKind.StringviewWTF16:\n      case TypeKind.StringviewIter: {\n        // Needs to be true (i.e. not zero) when the ref is _not_ null,\n        // which means `ref.is_null` returns false (i.e. zero).\n        return module.unary(UnaryOp.EqzI32, module.ref_is_null(expr));\n      }\n      case TypeKind.Void:\n      default: {\n        this.error(\n          DiagnosticCode.An_expression_of_type_0_cannot_be_tested_for_truthiness,\n          reportNode.range, type.toString()\n        );\n        return module.i32(0);\n      }\n    }\n  }\n\n  /** Makes a string conversion of the given expression. */\n  makeToString(expr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    let module = this.module;\n    let stringType = this.program.stringInstance.type;\n    if (type == stringType) {\n      return expr;\n    }\n    let classType = type.getClassOrWrapper(this.program);\n    if (classType) {\n      let toStringInstance = classType.getMethod(\"toString\");\n      if (toStringInstance) {\n        let toStringSignature = toStringInstance.signature;\n        if (!this.checkCallSignature( // reports\n          toStringSignature,\n          0,\n          true,\n          reportNode\n        )) {\n          this.currentType = stringType;\n          return module.unreachable();\n        }\n        if (!type.isStrictlyAssignableTo(assert(toStringSignature.thisType))) {\n          if (!type.is(TypeFlags.Nullable)) {\n            this.errorRelated(\n              DiagnosticCode.The_this_types_of_each_signature_are_incompatible,\n              reportNode.range, toStringInstance.identifierAndSignatureRange\n            );\n            this.currentType = stringType;\n            return module.unreachable();\n          }\n\n          // Attempt to retry on the non-nullable form of the type, wrapped in a ternary:\n          // `expr ? expr.toString() : \"null\"`\n          const tempLocal = this.currentFlow.getTempLocal(type);\n          return module.if(\n            module.local_tee(tempLocal.index, expr, type.isManaged),\n            this.makeToString(\n              module.local_get(tempLocal.index, type.toRef()),\n              type.nonNullableType,\n              reportNode\n            ),\n            this.ensureStaticString(\"null\")\n          );\n        }\n        let toStringReturnType = toStringSignature.returnType;\n        if (!toStringReturnType.isStrictlyAssignableTo(stringType)) {\n          this.errorRelated(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            reportNode.range, toStringInstance.identifierAndSignatureRange, toStringReturnType.toString(), stringType.toString()\n          );\n          this.currentType = stringType;\n          return module.unreachable();\n        }\n        return this.makeCallDirect(toStringInstance, [ expr ], reportNode);\n      }\n    }\n    this.error(\n      DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n      reportNode.range, type.toString(), stringType.toString()\n    );\n    this.currentType = stringType;\n    return module.unreachable();\n  }\n\n  /** Makes an allocation suitable to hold the data of an instance of the given class. */\n  makeAllocation(\n    classInstance: Class\n  ): ExpressionRef {\n    let program = this.program;\n    assert(classInstance.program == program);\n    let module = this.module;\n    let options = this.options;\n    this.currentType = classInstance.type;\n    if (classInstance.hasDecorator(DecoratorFlags.Unmanaged)) {\n      let allocInstance = program.allocInstance;\n      this.compileFunction(allocInstance);\n      return module.call(allocInstance.internalName, [\n        options.isWasm64\n          ? module.i64(classInstance.nextMemoryOffset)\n          : module.i32(classInstance.nextMemoryOffset)\n      ], options.sizeTypeRef);\n    } else {\n      let newInstance = program.newInstance;\n      this.compileFunction(newInstance);\n      return module.call(newInstance.internalName, [\n        options.isWasm64\n          ? module.i64(classInstance.nextMemoryOffset)\n          : module.i32(classInstance.nextMemoryOffset),\n        module.i32(classInstance.id)\n      ], options.sizeTypeRef);\n    }\n  }\n\n  /** Makes a conditional allocation where `this` might not have been initialized yet. */\n  makeConditionalAllocation(\n    classInstance: Class,\n    thisIndex: i32\n  ): ExpressionRef {\n    let module = this.module;\n    let classType = classInstance.type;\n    let classTypeRef = classType.toRef();\n    assert(classTypeRef == this.options.sizeTypeRef);\n    return module.if(\n      module.unary(classTypeRef == TypeRef.I64 ? UnaryOp.EqzI64 : UnaryOp.EqzI32,\n        module.local_get(thisIndex, classTypeRef)\n      ),\n      module.local_set(thisIndex,\n        this.makeAllocation(classInstance),\n        classInstance.type.isManaged\n      )\n    );\n  }\n\n  /** Makes the initializers for a class's fields within the constructor. */\n  makeFieldInitializationInConstructor(\n    /** Class being initialized. */\n    classInstance: Class,\n    /** Statements to append to also being returned. Created if omitted. */\n    stmts: ExpressionRef[] = []\n  ): ExpressionRef[] {\n    let members = classInstance.members;\n    if (!members) return stmts;\n\n    let module = this.module;\n    let flow = this.currentFlow;\n    let isInline = flow.isInline;\n    let thisLocalIndex = isInline ? flow.lookupLocal(CommonNames.this_)!.index : 0;\n    let sizeTypeRef = this.options.sizeTypeRef;\n    let nonParameterFields: Property[] | null = null;\n\n    // TODO: for (let member of members.values()) {\n    for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n      let member = unchecked(_values[i]);\n      if (member.kind != ElementKind.PropertyPrototype) continue;\n      // only interested in fields (resolved during class finalization)\n      let property = (<PropertyPrototype>member).instance;\n      if (!property || !property.isField || property.getBoundClassOrInterface() != classInstance) continue;\n      assert(!property.isAny(CommonFlags.Const));\n      let fieldPrototype = property.prototype;\n      let parameterIndex = fieldPrototype.parameterIndex;\n\n      // Defer non-parameter fields until parameter fields are initialized\n      if (parameterIndex < 0) {\n        if (!nonParameterFields) nonParameterFields = new Array();\n        nonParameterFields.push(property);\n        continue;\n      }\n\n      // Initialize constructor parameter field\n      let fieldType = property.type;\n      let fieldTypeRef = fieldType.toRef();\n      assert(!fieldPrototype.initializerNode);\n      let setterInstance = assert(property.setterInstance);\n      let expr = this.makeCallDirect(setterInstance, [\n        module.local_get(thisLocalIndex, sizeTypeRef),\n        module.local_get(\n          isInline\n            ? flow.lookupLocal(property.name)!.index\n            : 1 + parameterIndex, // `this` is local 0\n          fieldTypeRef\n        )\n      ], setterInstance.identifierNode, true);\n      if (this.currentType != Type.void) { // in case\n        expr = module.drop(expr);\n      }\n      stmts.push(expr);\n    }\n\n    // Initialize deferred non-parameter fields\n    if (nonParameterFields) {\n      for (let i = 0, k = nonParameterFields.length; i < k; ++i) {\n        let field = unchecked(nonParameterFields[i]);\n        let fieldType = field.type;\n        let fieldPrototype = field.prototype;\n        let initializerNode = fieldPrototype.initializerNode;\n        assert(fieldPrototype.parameterIndex < 0);\n        let setterInstance = assert(field.setterInstance);\n        let expr = this.makeCallDirect(setterInstance, [\n          module.local_get(thisLocalIndex, sizeTypeRef),\n          initializerNode // use initializer if present, otherwise initialize with zero\n            ? this.compileExpression(initializerNode, fieldType, Constraints.ConvImplicit)\n            : this.makeZero(fieldType)\n        ], field.identifierNode, true);\n        if (this.currentType != Type.void) { // in case\n          expr = module.drop(expr);\n        }\n        stmts.push(expr);\n      }\n    }\n\n    this.currentType = Type.void;\n    return stmts;\n  }\n\n  /** Makes a call to `abort`, if present, otherwise creates a trap. */\n  makeAbort(\n    /** Message argument of type string, if any. */\n    message: Expression | null,\n    /** Code location to report when aborting. */\n    codeLocation: Node\n  ): ExpressionRef {\n    let program = this.program;\n    let abortInstance = program.abortInstance;\n    if (!abortInstance || !this.compileFunction(abortInstance)) return this.module.unreachable();\n\n    let stringInstance = program.stringInstance;\n    let messageArg: ExpressionRef;\n    if (message) {\n      messageArg = this.compileExpression(message, stringInstance.type, Constraints.ConvImplicit);\n    } else {\n      messageArg = this.makeZero(stringInstance.type);\n    }\n\n    return this.makeStaticAbort(messageArg, codeLocation);\n  }\n\n  /** Makes a call to `abort`, if present, otherwise creates a trap. */\n  makeStaticAbort(\n    /** Message argument of type string. May be zero. */\n    messageExpr: ExpressionRef,\n    /** Code location to report when aborting. */\n    codeLocation: Node\n  ): ExpressionRef {\n    let program = this.program;\n    let module = this.module;\n    let abortInstance = program.abortInstance;\n    if (!abortInstance || !this.compileFunction(abortInstance)) return module.unreachable();\n\n    let filenameExpr = this.ensureStaticString(codeLocation.range.source.normalizedPath);\n    let range = codeLocation.range;\n    let source = range.source;\n    return module.block(null, [\n      module.call(\n        abortInstance.internalName, [\n          messageExpr,\n          filenameExpr,\n          module.i32(source.lineAt(range.start)),\n          module.i32(source.columnAt())\n        ],\n        TypeRef.None\n      ),\n      module.unreachable()\n    ]);\n  }\n\n  /** Makes a runtime non-null check, e.g. on `<Type>possiblyNull` or `possiblyNull!`. */\n  makeRuntimeNonNullCheck(\n    /** Expression being checked. */\n    expr: ExpressionRef,\n    /** Type of the expression. */\n    type: Type,\n    /** Report node. */\n    reportNode: Node\n  ): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n    let temp = flow.getTempLocal(type);\n    let tempIndex = temp.index;\n    if (!flow.canOverflow(expr, type)) flow.setLocalFlag(tempIndex, LocalFlags.Wrapped);\n    flow.setLocalFlag(tempIndex, LocalFlags.NonNull);\n\n    let staticAbortCallExpr = this.makeStaticAbort(\n      this.ensureStaticString(\"Unexpected 'null' (not assigned or failed cast)\"),\n      reportNode\n    ); // TODO: throw\n\n    if (type.isExternalReference) {\n      let nonNullExpr = module.local_get(tempIndex, type.toRef());\n      if (this.options.hasFeature(Feature.GC)) {\n        nonNullExpr = module.ref_as_nonnull(nonNullExpr);\n      }\n      expr = module.if(\n        module.ref_is_null(\n          module.local_tee(tempIndex, expr, false)\n        ),\n        staticAbortCallExpr,\n        nonNullExpr\n      );\n    } else {\n      expr = module.if(\n        module.local_tee(tempIndex, expr, type.isManaged),\n        module.local_get(tempIndex, type.toRef()),\n        staticAbortCallExpr\n      );\n    }\n    this.currentType = type.nonNullableType;\n    return expr;\n  }\n\n  /** Makes a runtime downcast check, e.g. on `<Child>parent`. */\n  makeRuntimeDowncastCheck(\n    /** Expression being downcast. */\n    expr: ExpressionRef,\n    /** Type of the expression. */\n    type: Type,\n    /** Type casting to. */\n    toType: Type,\n    /** Report node. */\n    reportNode: Node\n  ): ExpressionRef {\n    assert(toType.isReference && toType.nonNullableType.isAssignableTo(type));\n    let module = this.module;\n    let flow = this.currentFlow;\n    let temp = flow.getTempLocal(type);\n    let tempIndex = temp.index;\n\n    let staticAbortCallExpr = this.makeStaticAbort(\n      this.ensureStaticString(\"invalid downcast\"),\n      reportNode\n    ); // TODO: throw\n\n    if (!toType.isNullableReference || flow.isNonnull(expr, type)) {\n      // Simplify if the value cannot be `null`. If toType is non-nullable, a\n      // null-check would have been emitted separately so is not necessary here.\n      // instanceof(t = expr) ? t : abort()\n      expr = module.if(\n        module.call(this.prepareInstanceOf(toType.classReference!), [\n          module.local_tee(tempIndex, expr, type.isManaged)\n        ], TypeRef.I32),\n        module.local_get(tempIndex, type.toRef()),\n        staticAbortCallExpr\n      );\n    } else {\n      // !(t = expr) ? 0 : instanceof(t) ? t : abort()\n      expr = module.if(\n        module.unary(\n          UnaryOp.EqzI32,\n          module.local_tee(tempIndex, expr, type.isManaged)\n        ),\n        module.usize(0),\n        module.if(\n          module.call(this.prepareInstanceOf(toType.classReference!), [\n            module.local_get(tempIndex, type.toRef()),\n          ], TypeRef.I32),\n          module.local_get(tempIndex, type.toRef()),\n          staticAbortCallExpr\n        )\n      );\n    }\n    this.currentType = toType;\n    return expr;\n  }\n}\n\n// helpers\n\nfunction mangleImportName(\n  element: Element,\n  declaration: DeclarationStatement\n): void {\n  // by default, use the file name as the module name\n  mangleImportName_moduleName = declaration.range.source.simplePath;\n  // and the internal name of the element within that file as the element name\n  mangleImportName_elementName = mangleInternalName(\n    element.name, element.parent, element.is(CommonFlags.Instance), true\n  );\n  // override module name if a `module` statement is present\n  let overriddenModuleName = declaration.overriddenModuleName;\n  if (overriddenModuleName) mangleImportName_moduleName = overriddenModuleName;\n\n  if (!element.hasDecorator(DecoratorFlags.External)) return;\n\n  let program = element.program;\n  let decorator = assert(findDecorator(DecoratorKind.External, declaration.decorators));\n  let args = decorator.args;\n  if (args && args.length > 0) {\n    let arg = args[0];\n    // if one argument is given, override just the element name\n    // if two arguments are given, override both module and element name\n    if (arg.isLiteralKind(LiteralKind.String)) {\n      mangleImportName_elementName = (<StringLiteralExpression>arg).value;\n      if (args.length >= 2) {\n        arg = args[1];\n        if (arg.isLiteralKind(LiteralKind.String)) {\n          mangleImportName_moduleName = mangleImportName_elementName;\n          mangleImportName_elementName = (<StringLiteralExpression>arg).value;\n          if (args.length > 2) {\n            program.error(\n              DiagnosticCode.Expected_0_arguments_but_got_1,\n              decorator.range, \"2\", args.length.toString()\n            );\n          }\n        } else {\n          program.error(\n            DiagnosticCode.String_literal_expected,\n            arg.range\n          );\n        }\n      }\n    } else {\n      program.error(\n        DiagnosticCode.String_literal_expected,\n        arg.range\n      );\n    }\n  } else {\n    program.error(\n      DiagnosticCode.Expected_at_least_0_arguments_but_got_1,\n      decorator.range, \"1\", \"0\"\n    );\n  }\n}\n", "import {\n  Source\n} from \"../ast\";\n\nimport {\n  CommonFlags\n} from \"../common\";\n\nimport {\n  Global,\n  Program,\n  Function,\n  Class,\n  Interface,\n  Enum,\n  ElementKind,\n  Element,\n  PropertyPrototype\n} from \"../program\";\n\nimport {\n  Type,\n  TypeFlags\n} from \"../types\";\n\nimport {\n  CharCode,\n  escapeString,\n  indent, isIdentifier\n} from \"../util\";\n\nimport {\n  ExportsWalker\n} from \"./util\";\n\n/** A TypeScript definitions builder. */\nexport class TSDBuilder extends ExportsWalker {\n\n  /** Builds TypeScript definitions for the specified program. */\n  static build(program: Program, esm: bool = true): string {\n    return new TSDBuilder(program, esm).build();\n  }\n\n  private esm: bool;\n  private sb: string[] = [];\n  private indentLevel: i32 = 0;\n  private seenObjectTypes: Map<Class,string> = new Map();\n  private deferredTypings: string[] = new Array();\n\n  /** Constructs a new TypeScript definitions builder. */\n  constructor(program: Program, esm: bool, includePrivate: bool = false) {\n    super(program, includePrivate);\n    this.esm = esm;\n  }\n\n  visitGlobal(name: string, element: Global): void {\n    let sb = this.sb;\n    let type = element.type;\n    let tsType = this.toTypeScriptType(type, Mode.EXPORT);\n    indent(sb, this.indentLevel);\n    sb.push(\"/** \");\n    sb.push(element.internalName);\n    sb.push(\" */\\n\");\n    indent(sb, this.indentLevel);\n    sb.push(\"export \");\n    if (this.esm) sb.push(\"declare \");\n    sb.push(\"const \");\n    sb.push(name);\n    sb.push(\": {\\n\");\n    indent(sb, ++this.indentLevel);\n    sb.push(\"/** @type `\");\n    sb.push(type.toString());\n    sb.push(\"` */\\n\");\n    indent(sb, this.indentLevel);\n    sb.push(\"get value(): \");\n    sb.push(tsType);\n    if (!element.is(CommonFlags.Const)) {\n      sb.push(\";\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(\"set value(value: \");\n      sb.push(tsType);\n      sb.push(\");\\n\");\n    } else {\n      sb.push(\"\\n\");\n    }\n    indent(sb, --this.indentLevel);\n    sb.push(\"};\\n\");\n  }\n\n  visitEnum(name: string, element: Enum): void {\n    let sb = this.sb;\n    indent(sb, this.indentLevel);\n    sb.push(\"/** \");\n    sb.push(element.internalName);\n    sb.push(\" */\\n\");\n    indent(sb, this.indentLevel++);\n    sb.push(\"export \");\n    if (this.esm) sb.push(\"declare \");\n    sb.push(\"enum \");\n    sb.push(name);\n    sb.push(\" {\\n\");\n    let members = element.members;\n    if (members) {\n      // TODO: for (let [memberName, member] of members) {\n      for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n        let memberName = unchecked(_keys[i]);\n        let member = assert(members.get(memberName));\n        if (member.kind != ElementKind.EnumValue) continue;\n        indent(sb, this.indentLevel);\n        sb.push(\"/** @type `i32` */\\n\");\n        indent(sb, this.indentLevel);\n        sb.push(memberName);\n        sb.push(\",\\n\");\n      }\n    }\n    indent(sb, --this.indentLevel);\n    sb.push(\"}\\n\");\n  }\n\n  visitFunction(name: string, element: Function): void {\n    let sb = this.sb;\n    let signature = element.signature;\n    indent(sb, this.indentLevel);\n    sb.push(\"/**\\n\");\n    indent(sb, this.indentLevel);\n    sb.push(\" * \");\n    sb.push(element.internalName);\n    sb.push(\"\\n\");\n    let parameterTypes = signature.parameterTypes;\n    let numParameters = parameterTypes.length;\n    for (let i = 0; i < numParameters; ++i) {\n      indent(sb, this.indentLevel);\n      sb.push(\" * @param \");\n      sb.push(element.getParameterName(i));\n      sb.push(\" `\");\n      sb.push(parameterTypes[i].toString());\n      sb.push(\"`\\n\");\n    }\n    let returnType = signature.returnType;\n    if (returnType != Type.void) {\n      indent(sb, this.indentLevel);\n      sb.push(\" * @returns `\");\n      sb.push(returnType.toString());\n      sb.push(\"`\\n\");\n    }\n    indent(sb, this.indentLevel);\n    sb.push(\" */\\n\");\n    indent(sb, this.indentLevel);\n    sb.push(\"export \");\n    if (this.esm) sb.push(\"declare \");\n    sb.push(\"function \");\n    sb.push(name);\n    sb.push(\"(\");\n    let requiredParameters = signature.requiredParameters;\n    for (let i = 0; i < numParameters; ++i) {\n      if (i) sb.push(\", \");\n      sb.push(element.getParameterName(i));\n      if (i >= requiredParameters) sb.push(\"?\");\n      sb.push(\": \");\n      sb.push(this.toTypeScriptType(parameterTypes[i], Mode.IMPORT));\n    }\n    sb.push(\"): \");\n    sb.push(this.toTypeScriptType(returnType, Mode.EXPORT));\n    sb.push(\";\\n\");\n  }\n\n  visitClass(name: string, element: Class): void {\n    // not implemented\n  }\n\n  visitInterface(name: string, element: Interface): void {\n    // not implemented\n  }\n\n  visitNamespace(name: string, element: Element): void {\n    // not implemented\n  }\n\n  visitAlias(name: string, element: Element, originalName: string): void {\n    // not implemented\n  }\n\n  build(): string {\n    let sb = this.sb;\n    if (!this.esm) {\n      sb.push(\"declare namespace __AdaptedExports {\\n\");\n      ++this.indentLevel;\n    }\n    if (this.program.options.exportMemory) {\n      indent(sb, this.indentLevel);\n      sb.push(\"/** Exported memory */\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(`export ${this.esm ? \"declare \" : \"\"}const memory: WebAssembly.Memory;\\n`);\n    }\n    if (this.program.options.exportTable) {\n      indent(sb, this.indentLevel);\n      sb.push(\"/** Exported table */\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(`export ${this.esm ? \"declare \" : \"\"}const table: WebAssembly.Table;\\n`);\n    }\n    if (this.program.options.exportRuntime) {\n      indent(sb, this.indentLevel);\n      sb.push(\"// Exported runtime interface\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(`export ${this.esm ? \"declare \" : \"\"}function __new(size: number, id: number): number;\\n`);\n      indent(sb, this.indentLevel);\n      sb.push(`export ${this.esm ? \"declare \" : \"\"}function __pin(ptr: number): number;\\n`);\n      indent(sb, this.indentLevel);\n      sb.push(`export ${this.esm ? \"declare \" : \"\"}function __unpin(ptr: number): void;\\n`);\n      indent(sb, this.indentLevel);\n      sb.push(`export ${this.esm ? \"declare \" : \"\"}function __collect(): void;\\n`);\n      indent(sb, this.indentLevel);\n      sb.push(`export ${this.esm ? \"declare \" : \"\"}const __rtti_base: number;\\n`);\n    }\n    this.walk();\n    if (!this.esm) {\n      --this.indentLevel;\n      sb.push(\"}\\n\");\n    }\n    let deferredTypes = this.deferredTypings;\n    for (let i = 0, k = deferredTypes.length; i < k; ++i) {\n      sb.push(deferredTypes[i]);\n    }\n    if (!this.esm) {\n      sb.push(\"/** Instantiates the compiled WebAssembly module with the given imports. */\\n\");\n      sb.push(\"export declare function instantiate(module: WebAssembly.Module, imports: {\\n\");\n      let moduleImports = this.program.moduleImports;\n      for (let _keys = Map_keys(moduleImports), i = 0, k = _keys.length; i < k; ++i) {\n        let moduleName = _keys[i];\n        sb.push(\"  \");\n        if (isIdentifier(moduleName)) {\n          sb.push(moduleName);\n        } else {\n          sb.push(\"\\\"\");\n          sb.push(escapeString(moduleName, CharCode.DoubleQuote));\n          sb.push(\"\\\"\");\n        }\n        sb.push(\": unknown,\\n\");\n      }\n      sb.push(\"}): Promise<typeof __AdaptedExports>;\\n\");\n    }\n    return sb.join(\"\");\n  }\n\n  isPlainObject(clazz: Class): bool {\n    // A plain object does not inherit and does not have a constructor or private properties\n    if (clazz.base && !clazz.prototype.implicitlyExtendsObject) return false;\n    let members = clazz.members;\n    if (members) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let member = _values[i];\n        if (member.isAny(CommonFlags.Private | CommonFlags.Protected)) return false;\n        if (member.is(CommonFlags.Constructor)) {\n          // a generated constructor is ok\n          if (member.declaration.range != Source.native.range) return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  toTypeScriptType(type: Type, mode: Mode): string {\n    if (type.isInternalReference) {\n      const sb = new Array<string>();\n      const clazz = assert(type.getClassOrWrapper(this.program));\n      if (clazz.extendsPrototype(this.program.arrayBufferInstance.prototype)) {\n        sb.push(\"ArrayBuffer\");\n      } else if (clazz.extendsPrototype(this.program.stringInstance.prototype)) {\n        sb.push(\"string\");\n      } else if (clazz.extendsPrototype(this.program.arrayPrototype)) {\n        const valueType = clazz.getArrayValueType();\n        sb.push(\"Array<\");\n        sb.push(this.toTypeScriptType(valueType, mode));\n        sb.push(\">\");\n      } else if (clazz.extendsPrototype(this.program.staticArrayPrototype)) {\n        const valueType = clazz.getArrayValueType();\n        sb.push(\"ArrayLike<\");\n        sb.push(this.toTypeScriptType(valueType, mode));\n        sb.push(\">\");\n      } else if (clazz.extendsPrototype(this.program.arrayBufferViewInstance.prototype)) {\n        const valueType = clazz.getArrayValueType();\n        if (valueType == Type.i8) {\n          sb.push(\"Int8Array\");\n        } else if (valueType == Type.u8) {\n          if (clazz.extendsPrototype(this.program.uint8ClampedArrayPrototype)) {\n            sb.push(\"Uint8ClampedArray\");\n          } else {\n            sb.push(\"Uint8Array\");\n          }\n        } else if (valueType == Type.i16) {\n          sb.push(\"Int16Array\");\n        } else if (valueType == Type.u16) {\n          sb.push(\"Uint16Array\");\n        } else if (valueType == Type.i32) {\n          sb.push(\"Int32Array\");\n        } else if (valueType == Type.u32) {\n          sb.push(\"Uint32Array\");\n        } else if (valueType == Type.i64) {\n          sb.push(\"BigInt64Array\");\n        } else if (valueType == Type.u64) {\n          sb.push(\"BigUint64Array\");\n        } else if (valueType == Type.f32) {\n          sb.push(\"Float32Array\");\n        } else if (valueType == Type.f64) {\n          sb.push(\"Float64Array\");\n        } else {\n          sb.push(\"unknown\");\n        }\n      } else {\n        let seenObjectTypes = this.seenObjectTypes;\n        let typeName: string;\n        if (seenObjectTypes.has(clazz)) {\n          typeName = assert(seenObjectTypes.get(clazz));\n          sb.push(typeName);\n          if (this.isPlainObject(clazz)) {\n            sb.push(mode == Mode.EXPORT ? \"<never>\" : \"<undefined>\");\n          }\n        } else {\n          let isPlain = this.isPlainObject(clazz);\n          typeName = `${isPlain ? \"__Record\" : \"__Internref\"}${clazz.id}`;\n          sb.push(typeName);\n          seenObjectTypes.set(clazz, typeName);\n          if (isPlain) {\n            sb.push(mode == Mode.EXPORT ? \"<never>\" : \"<undefined>\");\n            this.deferredTypings.push(this.makeRecordType(clazz, mode));\n          } else {\n            this.deferredTypings.push(this.makeInternrefType(clazz));\n          }\n        }\n      }\n      if (type.is(TypeFlags.Nullable)) {\n        sb.push(\" | null\");\n      }\n      return sb.join(\"\");\n    } else {\n      if (type == Type.bool) {\n        return \"boolean\";\n      }\n      if (type == Type.void) {\n        return \"void\";\n      }\n      if (type.isNumericValue) {\n        if (type.isLongIntegerValue) {\n          return \"bigint\";\n        }\n        return \"number\";\n      }\n    }\n    return \"unknown\";\n  }\n\n  makeRecordType(clazz: Class, mode: Mode): string {\n    let sb = new Array<string>();\n    let members = clazz.members;\n    sb.push(\"/** \");\n    sb.push(clazz.internalName);\n    sb.push(\" */\\ndeclare interface __Record\");\n    sb.push(clazz.id.toString());\n    sb.push(\"<TOmittable> {\\n\");\n    if (members) {\n      for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n        let memberName = _keys[i];\n        let member = assert(members.get(memberName));\n        if (member.kind != ElementKind.PropertyPrototype) continue;\n        let property = (<PropertyPrototype>member).instance; // resolved during class finalization\n        if (!property || !property.isField) continue;\n        sb.push(\"  /** @type `\");\n        sb.push(property.type.toString());\n        sb.push(\"` */\\n  \");\n        sb.push(property.name);\n        sb.push(\": \");\n        sb.push(this.toTypeScriptType(property.type, mode));\n        if (this.fieldAcceptsUndefined(property.type)) {\n          sb.push(\" | TOmittable\");\n        }\n        sb.push(\";\\n\");\n      }\n    }\n    sb.push(\"}\\n\");\n    return sb.join(\"\");\n  }\n\n  fieldAcceptsUndefined(type: Type): bool {\n    if (type.isInternalReference) {\n      return type.is(TypeFlags.Nullable);\n    }\n    return true;\n  }\n\n  makeInternrefType(clazz: Class): string {\n    let sb = new Array<string>();\n    sb.push(\"/** \");\n    sb.push(clazz.internalName);\n    sb.push(\" */\\n\");\n    sb.push(\"declare class __Internref\");\n    sb.push(clazz.id.toString());\n    sb.push(\" extends Number {\\n\");\n    let base: Class | null = clazz;\n    do {\n      sb.push(\"  private __nominal\");\n      sb.push(base.id.toString());\n      sb.push(\": symbol;\\n\");\n      base = base.base;\n    } while (base);\n    sb.push(\"}\\n\");\n    return sb.join(\"\");\n  }\n}\n\n// Helpers\n\nenum Mode {\n  IMPORT,\n  EXPORT\n}\n", "/**\n * @fileoverview The C-like and re-exported public compiler interface.\n *\n * The intended way to consume the compiler sources is to import this\n * file, which again exports all relevant functions, classes and constants\n * as a flat namespace.\n *\n * Note though that the compiler sources are written in \"portable\n * AssemblyScript\" that can be compiled to both JavaScript with tsc and\n * to WebAssembly with asc, and as such require additional glue code\n * depending on the target.\n *\n * When compiling to JavaScript `glue/js/index.js` must be included.\n * When compiling to WebAssembly `glue/wasm/index.ts` must be included.\n */\n\nimport {\n  Target,\n  Runtime,\n  Feature\n} from \"./common\";\n\nimport {\n  Compiler,\n  Options,\n  UncheckedBehavior,\n  defaultFeatures\n} from \"./compiler\";\n\nimport {\n  TSDBuilder,\n  JSBuilder\n} from \"./bindings\";\n\nimport {\n  Range,\n  DiagnosticMessage,\n  DiagnosticCategory,\n  formatDiagnosticMessage\n} from \"./diagnostics\";\n\nimport { Module } from \"./module\";\nimport { Program } from \"./program\";\nimport { Source } from \"./ast\";\n\n// Options\n\n/** Creates a new set of compiler options. */\nexport function newOptions(): Options {\n  return new Options();\n}\n\n/** Sets the `target` option. */\nexport function setTarget(options: Options, target: Target): void {\n  options.target = target;\n}\n\nexport function setRuntime(options: Options, runtime: Runtime): void {\n  options.runtime = runtime;\n}\n\n/** Sets the `noAssert` option. */\nexport function setNoAssert(options: Options, noAssert: bool): void {\n  options.noAssert = noAssert;\n}\n\n/** Sets the `exportMemory` option. */\nexport function setExportMemory(options: Options, exportMemory: bool): void {\n  options.exportMemory = exportMemory;\n}\n\n/** Sets the `importMemory` option. */\nexport function setImportMemory(options: Options, importMemory: bool): void {\n  options.importMemory = importMemory;\n}\n\n/** Sets the `initialMemory` option. */\nexport function setInitialMemory(options: Options, initialMemory: u32): void {\n  options.initialMemory = initialMemory;\n}\n\n/** Sets the `maximumMemory` option. */\nexport function setMaximumMemory(options: Options, maximumMemory: u32): void {\n  options.maximumMemory = maximumMemory;\n}\n\n/** Sets the `sharedMemory` option. */\nexport function setSharedMemory(options: Options, sharedMemory: bool): void {\n  options.sharedMemory = sharedMemory;\n}\n\n/** Sets the `importTable` option. */\nexport function setImportTable(options: Options, importTable: bool): void {\n  options.importTable = importTable;\n}\n\n/** Sets the `exportTable` option. */\nexport function setExportTable(options: Options, exportTable: bool): void {\n  options.exportTable = exportTable;\n}\n\n/** Sets the `sourceMap` option. */\nexport function setSourceMap(options: Options, sourceMap: bool): void {\n  options.sourceMap = sourceMap;\n}\n\n/** Sets the `uncheckedBehavior` option. */\nexport function setUncheckedBehavior(options: Options, uncheckedBehavior: UncheckedBehavior): void {\n  options.uncheckedBehavior = uncheckedBehavior;\n}\n\n/** Sets the `memoryBase` option. */\nexport function setMemoryBase(options: Options, memoryBase: u32): void {\n  options.memoryBase = memoryBase;\n}\n\n/** Sets the `tableBase` option. */\nexport function setTableBase(options: Options, tableBase: u32): void {\n  options.tableBase = tableBase;\n}\n\n/** Adds a 'globalAliases' value. */\nexport function addGlobalAlias(options: Options, alias: string, name: string): void {\n  let globalAliases = options.globalAliases;\n  if (!globalAliases) options.globalAliases = globalAliases = new Map();\n  globalAliases.set(alias, name);\n}\n\n/** Removes a 'globalAliases' value. */\nexport function removeGlobalAlias(options: Options, alias: string): void {\n  let globalAliases = options.globalAliases;\n  if (globalAliases) globalAliases.delete(alias);\n}\n\n/** Sets the `exportStart` option. */\nexport function setExportStart(options: Options, exportStart: string | null): void {\n  options.exportStart = exportStart;\n}\n\n/** Sets the `noUnsafe` option. */\nexport function setNoUnsafe(options: Options, noUnsafe: bool): void {\n  options.noUnsafe = noUnsafe;\n}\n\n/** Sets the `lowMemoryLimit` option. */\nexport function setLowMemoryLimit(options: Options, lowMemoryLimit: i32): void {\n  options.lowMemoryLimit = lowMemoryLimit;\n}\n\n/** Sets the `exportRuntime` option. */\nexport function setExportRuntime(options: Options, exportRuntime: bool): void {\n  options.exportRuntime = exportRuntime;\n}\n\n/** Default stack size. */\nexport const DEFAULT_STACK_SIZE = 32768;\n\n/** Sets the `stackSize` option. */\nexport function setStackSize(options: Options, stackSize: i32): void {\n  options.stackSize = stackSize;\n}\n\n/** Sets the bundle semantic version. */\nexport function setBundleVersion(\n  options: Options,\n  bundleMajorVersion: i32,\n  bundleMinorVersion: i32,\n  bundlePatchVersion: i32,\n): void {\n  options.bundleMajorVersion = bundleMajorVersion;\n  options.bundleMinorVersion = bundleMinorVersion;\n  options.bundlePatchVersion = bundlePatchVersion;\n}\n\n/** Sign extension operations. */\nexport const FEATURE_SIGN_EXTENSION = Feature.SignExtension;\n/** Mutable global imports and exports. */\nexport const FEATURE_MUTABLE_GLOBALS = Feature.MutableGlobals;\n/** Non-trapping float to int conversion operations. */\nexport const FEATURE_NONTRAPPING_F2I = Feature.NontrappingF2I;\n/** Bulk memory operations. */\nexport const FEATURE_BULK_MEMORY = Feature.BulkMemory;\n/** SIMD types and operations. */\nexport const FEATURE_SIMD = Feature.Simd;\n/** Threading and atomic operations. */\nexport const FEATURE_THREADS = Feature.Threads;\n/** Exception handling operations. */\nexport const FEATURE_EXCEPTION_HANDLING = Feature.ExceptionHandling;\n/** Tail call operations. */\nexport const FEATURE_TAIL_CALLS = Feature.TailCalls;\n/** Reference types. */\nexport const FEATURE_REFERENCE_TYPES = Feature.ReferenceTypes;\n/** Multi value types. */\nexport const FEATURE_MULTI_VALUE = Feature.MultiValue;\n/** Garbage collection. */\nexport const FEATURE_GC = Feature.GC;\n/** Memory64. */\nexport const FEATURE_MEMORY64 = Feature.Memory64;\n/** Relaxed SIMD. */\nexport const FEATURE_RELAXED_SIMD = Feature.RelaxedSimd;\n/** Extended const expressions. */\nexport const FEATURE_EXTENDED_CONST = Feature.ExtendedConst;\n/** String references. */\nexport const FEATURE_STRINGREF = Feature.Stringref;\n/** All features. */\nexport const FEATURES_ALL = Feature.All;\n/** Default features. */\nexport const FEATURES_DEFAULT = defaultFeatures;\n\n/** Sets whether a specific feature is enabled. */\nexport function setFeature(options: Options, feature: Feature, on: bool): void {\n  options.setFeature(feature, on);\n}\n\n/** Gives the compiler a hint at the optimize levels that will be used later on. */\nexport function setOptimizeLevelHints(options: Options, optimizeLevel: i32, shrinkLevel: i32): void {\n  options.optimizeLevelHint = optimizeLevel;\n  options.shrinkLevelHint = shrinkLevel;\n}\n\n/** Gives the compiler a hint of the emitted module's basename. */\nexport function setBasenameHint(options: Options, basename: string): void {\n  options.basenameHint = basename;\n}\n\n/** Gives the compiler a hint that bindings will be generated. */\nexport function setBindingsHint(options: Options, bindings: bool): void {\n  options.bindingsHint = bindings;\n}\n\n/** Sets the `pedantic` option. */\nexport function setPedantic(options: Options, pedantic: bool): void {\n  options.pedantic = pedantic;\n}\n\nexport function setDebugInfo(options: Options, debug: bool): void {\n  options.debugInfo = debug;\n}\n\n// Program\n\n/** Creates a new Program. */\nexport function newProgram(options: Options): Program {\n  return new Program(options);\n}\n\n/** Obtains the next diagnostic message. Returns `null` once complete. */\nexport function nextDiagnostic(program: Program): DiagnosticMessage | null {\n  return program.diagnosticsOffset < program.diagnostics.length\n    ? program.diagnostics[program.diagnosticsOffset++]\n    : null;\n}\n\n/** Obtains the source of the given file. */\nexport function getSource(program: Program, internalPath: string): string | null {\n  return program.getSource(internalPath);\n}\n\n/** Formats a diagnostic message to a string. */\nexport { formatDiagnosticMessage as formatDiagnostic };\n\n/** Gets the code of a diagnostic message. */\nexport function getDiagnosticCode(diagnostic: DiagnosticMessage): i32 {\n  return diagnostic.code;\n}\n\n/** Gets the category of a diagnostic message. */\nexport function getDiagnosticCategory(diagnostic: DiagnosticMessage): DiagnosticCategory {\n  return diagnostic.category;\n}\n\n/** Gets the textual message of a diagnostic message. */\nexport function getDiagnosticMessage(diagnostic: DiagnosticMessage): string {\n  return diagnostic.message;\n}\n\n/** Gets the primary range, if any, of a diagnostic message. */\nexport function getDiagnosticRange(diagnostic: DiagnosticMessage): Range | null {\n  return diagnostic.range;\n}\n\n/** Gets the related range, if any, of a diagnostic message. */\nexport function getDiagnosticRelatedRange(diagnostic: DiagnosticMessage): Range | null {\n  return diagnostic.relatedRange;\n}\n\n/** Gets a range's start offset. */\nexport function getRangeStart(range: Range): i32 {\n  return range.start;\n}\n\n/** Gets a range's end offsset. */\nexport function getRangeEnd(range: Range): i32 {\n  return range.end;\n}\n\n/** Gets a range's relevant source. */\nexport function getRangeSource(range: Range): Source {\n  return range.source;\n}\n\n/** Gets a source's normalized path. */\nexport function getSourceNormalizedPath(source: Source): string {\n  return source.normalizedPath;\n}\n\n/** Tests whether a diagnostic is informatory. */\nexport function isInfo(message: DiagnosticMessage): bool {\n  return message.category == DiagnosticCategory.Info;\n}\n\n/** Tests whether a diagnostic is a warning. */\nexport function isWarning(message: DiagnosticMessage): bool {\n  return message.category == DiagnosticCategory.Warning;\n}\n\n/** Tests whether a diagnostic is an error. */\nexport function isError(message: DiagnosticMessage): bool {\n  return message.category == DiagnosticCategory.Error;\n}\n\n// Parser\n\n/** Parses a source file. If `parser` has been omitted a new one is created. */\nexport function parse(\n  /** Program reference. */\n  program: Program,\n  /** Source text of the file, or `null` to indicate not found. */\n  text: string | null,\n  /** Normalized path of the file. */\n  path: string,\n  /** Whether this is an entry file. */\n  isEntry: bool = false\n): void {\n  program.parser.parseFile(text, path, isEntry);\n}\n\n/** Obtains the next required file's path. Returns `null` once complete. */\nexport function nextFile(program: Program): string | null {\n  return program.parser.nextFile();\n}\n\n/** Obtains the path of the dependee of a given imported file. */\nexport function getDependee(program: Program, file: string): string | null {\n  return program.parser.getDependee(file);\n}\n\n// Compiler\n\n/** Initializes the program pre-emptively for transform hooks. */\nexport function initializeProgram(program: Program): void {\n  program.initialize();\n}\n\n/** Compiles the parsed sources to a module. */\nexport function compile(program: Program): Module {\n  program.parser.finish();\n  return new Compiler(program).compile();\n}\n\n/** Builds TypeScript definitions for the specified program. */\nexport function buildTSD(program: Program, esm: bool): string {\n  return TSDBuilder.build(program, esm);\n}\n\n/** Builds JavaScript glue code for the specified program. */\nexport function buildJS(program: Program, esm: bool): string {\n  return JSBuilder.build(program, esm);\n}\n\n/** Gets the Binaryen module reference of a module. */\nexport function getBinaryenModuleRef(module: Module): usize {\n  return module.ref;\n}\n\n/** Validates a module. */\nexport function validate(module: Module): bool {\n  return module.validate();\n}\n\n/** Optimizes a module. */\nexport function optimize(\n  module: Module,\n  optimizeLevel: i32,\n  shrinkLevel: i32,\n  debugInfo: bool = false,\n  zeroFilledMemory: bool = false\n): void {\n  module.optimize(optimizeLevel, shrinkLevel, debugInfo, zeroFilledMemory);\n}\n", "/**\n * @fileoverview Abstract Syntax Tree extras.\n *\n * Provides serialization of the AssemblyScript AST back to it source form.\n *\n * @license Apache-2.0\n */\n\nimport {\n  Node,\n  NodeKind,\n  Source,\n  ArrowKind,\n\n  TypeNode,\n  NamedTypeNode,\n  FunctionTypeNode,\n  TypeName,\n  TypeParameterNode,\n\n  Expression,\n  IdentifierExpression,\n  LiteralExpression,\n  LiteralKind,\n  FloatLiteralExpression,\n  IntegerLiteralExpression,\n  StringLiteralExpression,\n  TemplateLiteralExpression,\n  RegexpLiteralExpression,\n  ArrayLiteralExpression,\n  AssertionExpression,\n  AssertionKind,\n  BinaryExpression,\n  CallExpression,\n  CommaExpression,\n  ElementAccessExpression,\n  FunctionExpression,\n  NewExpression,\n  ParenthesizedExpression,\n  PropertyAccessExpression,\n  TernaryExpression,\n  UnaryPostfixExpression,\n  UnaryExpression,\n  UnaryPrefixExpression,\n  ClassExpression,\n  ObjectLiteralExpression,\n\n  BlockStatement,\n  BreakStatement,\n  ContinueStatement,\n  DoStatement,\n  EmptyStatement,\n  ExportImportStatement,\n  ExportStatement,\n  ExportDefaultStatement,\n  ExpressionStatement,\n  ForStatement,\n  ForOfStatement,\n  IfStatement,\n  ImportStatement,\n  InstanceOfExpression,\n  ReturnStatement,\n  SwitchStatement,\n  ThrowStatement,\n  TryStatement,\n  VariableStatement,\n  WhileStatement,\n  ModuleDeclaration,\n\n  DeclarationStatement,\n  ClassDeclaration,\n  EnumDeclaration,\n  EnumValueDeclaration,\n  FieldDeclaration,\n  FunctionDeclaration,\n  ImportDeclaration,\n  InterfaceDeclaration,\n  MethodDeclaration,\n  NamespaceDeclaration,\n  TypeDeclaration,\n  VariableDeclaration,\n\n  DecoratorNode,\n  ParameterNode,\n  ParameterKind,\n  ExportMember,\n  SwitchCase,\n  IndexSignatureNode,\n\n  isTypeOmitted\n} from \"../ast\";\n\nimport {\n  operatorTokenToString\n} from \"../tokenizer\";\n\nimport {\n  CharCode,\n  indent,\n  escapeString\n} from \"../util\";\n\nimport {\n  CommonFlags\n} from \"../common\";\n\n/** An AST builder. */\nexport class ASTBuilder {\n\n  /** Rebuilds the textual source from the specified AST, as far as possible. */\n  static build(node: Node): string {\n    let builder = new ASTBuilder();\n    builder.visitNode(node);\n    return builder.finish();\n  }\n\n  private sb: string[] = [];\n  private indentLevel: i32 = 0;\n\n  visitNode(node: Node): void {\n    switch (node.kind) {\n      case NodeKind.Source: {\n        this.visitSource(<Source>node);\n        break;\n      }\n\n      // types\n\n      case NodeKind.NamedType: {\n        this.visitNamedTypeNode(<NamedTypeNode>node);\n        break;\n      }\n      case NodeKind.FunctionType: {\n        this.visitFunctionTypeNode(<FunctionTypeNode>node);\n        break;\n      }\n      case NodeKind.TypeParameter: {\n        this.visitTypeParameter(<TypeParameterNode>node);\n        break;\n      }\n\n      // expressions\n\n      case NodeKind.False:\n      case NodeKind.Null:\n      case NodeKind.Super:\n      case NodeKind.This:\n      case NodeKind.True:\n      case NodeKind.Constructor:\n      case NodeKind.Identifier: {\n        this.visitIdentifierExpression(<IdentifierExpression>node);\n        break;\n      }\n      case NodeKind.Assertion: {\n        this.visitAssertionExpression(<AssertionExpression>node);\n        break;\n      }\n      case NodeKind.Binary: {\n        this.visitBinaryExpression(<BinaryExpression>node);\n        break;\n      }\n      case NodeKind.Call: {\n        this.visitCallExpression(<CallExpression>node);\n        break;\n      }\n      case NodeKind.Class: {\n        this.visitClassExpression(<ClassExpression>node);\n        break;\n      }\n      case NodeKind.Comma: {\n        this.visitCommaExpression(<CommaExpression>node);\n        break;\n      }\n      case NodeKind.ElementAccess: {\n        this.visitElementAccessExpression(<ElementAccessExpression>node);\n        break;\n      }\n      case NodeKind.Function: {\n        this.visitFunctionExpression(<FunctionExpression>node);\n        break;\n      }\n      case NodeKind.InstanceOf: {\n        this.visitInstanceOfExpression(<InstanceOfExpression>node);\n        break;\n      }\n      case NodeKind.Literal: {\n        this.visitLiteralExpression(<LiteralExpression>node);\n        break;\n      }\n      case NodeKind.New: {\n        this.visitNewExpression(<NewExpression>node);\n        break;\n      }\n      case NodeKind.Parenthesized: {\n        this.visitParenthesizedExpression(<ParenthesizedExpression>node);\n        break;\n      }\n      case NodeKind.PropertyAccess: {\n        this.visitPropertyAccessExpression(<PropertyAccessExpression>node);\n        break;\n      }\n      case NodeKind.Ternary: {\n        this.visitTernaryExpression(<TernaryExpression>node);\n        break;\n      }\n      case NodeKind.UnaryPostfix: {\n        this.visitUnaryPostfixExpression(<UnaryPostfixExpression>node);\n        break;\n      }\n      case NodeKind.UnaryPrefix: {\n        this.visitUnaryPrefixExpression(<UnaryPrefixExpression>node);\n        break;\n      }\n\n      // statements\n\n      case NodeKind.Block: {\n        this.visitBlockStatement(<BlockStatement>node);\n        break;\n      }\n      case NodeKind.Break: {\n        this.visitBreakStatement(<BreakStatement>node);\n        break;\n      }\n      case NodeKind.Continue: {\n        this.visitContinueStatement(<ContinueStatement>node);\n        break;\n      }\n      case NodeKind.Do: {\n        this.visitDoStatement(<DoStatement>node);\n        break;\n      }\n      case NodeKind.Empty: {\n        this.visitEmptyStatement(<EmptyStatement>node);\n        break;\n      }\n      case NodeKind.Export: {\n        this.visitExportStatement(<ExportStatement>node);\n        break;\n      }\n      case NodeKind.ExportDefault: {\n        this.visitExportDefaultStatement(<ExportDefaultStatement>node);\n        break;\n      }\n      case NodeKind.ExportImport: {\n        this.visitExportImportStatement(<ExportImportStatement>node);\n        break;\n      }\n      case NodeKind.Expression: {\n        this.visitExpressionStatement(<ExpressionStatement>node);\n        break;\n      }\n      case NodeKind.For: {\n        this.visitForStatement(<ForStatement>node);\n        break;\n      }\n      case NodeKind.ForOf: {\n        this.visitForOfStatement(<ForOfStatement>node);\n        break;\n      }\n      case NodeKind.If: {\n        this.visitIfStatement(<IfStatement>node);\n        break;\n      }\n      case NodeKind.Import: {\n        this.visitImportStatement(<ImportStatement>node);\n        break;\n      }\n      case NodeKind.Return: {\n        this.visitReturnStatement(<ReturnStatement>node);\n        break;\n      }\n      case NodeKind.Switch: {\n        this.visitSwitchStatement(<SwitchStatement>node);\n        break;\n      }\n      case NodeKind.Throw: {\n        this.visitThrowStatement(<ThrowStatement>node);\n        break;\n      }\n      case NodeKind.Try: {\n        this.visitTryStatement(<TryStatement>node);\n        break;\n      }\n      case NodeKind.Variable: {\n        this.visitVariableStatement(<VariableStatement>node);\n        break;\n      }\n      case NodeKind.While: {\n        this.visitWhileStatement(<WhileStatement>node);\n        break;\n      }\n      case NodeKind.Module: {\n        this.visitModuleDeclaration(<ModuleDeclaration>node);\n        break;\n      }\n\n      // declaration statements\n\n      case NodeKind.ClassDeclaration: {\n        this.visitClassDeclaration(<ClassDeclaration>node);\n        break;\n      }\n      case NodeKind.EnumDeclaration: {\n        this.visitEnumDeclaration(<EnumDeclaration>node);\n        break;\n      }\n      case NodeKind.EnumValueDeclaration: {\n        this.visitEnumValueDeclaration(<EnumValueDeclaration>node);\n        break;\n      }\n      case NodeKind.FieldDeclaration: {\n        this.visitFieldDeclaration(<FieldDeclaration>node);\n        break;\n      }\n      case NodeKind.FunctionDeclaration: {\n        this.visitFunctionDeclaration(<FunctionDeclaration>node);\n        break;\n      }\n      case NodeKind.ImportDeclaration: {\n        this.visitImportDeclaration(<ImportDeclaration>node);\n        break;\n      }\n      case NodeKind.InterfaceDeclaration: {\n        this.visitInterfaceDeclaration(<InterfaceDeclaration>node);\n        break;\n      }\n      case NodeKind.MethodDeclaration: {\n        this.visitMethodDeclaration(<MethodDeclaration>node);\n        break;\n      }\n      case NodeKind.NamespaceDeclaration: {\n        this.visitNamespaceDeclaration(<NamespaceDeclaration>node);\n        break;\n      }\n      case NodeKind.TypeDeclaration: {\n        this.visitTypeDeclaration(<TypeDeclaration>node);\n        break;\n      }\n      case NodeKind.VariableDeclaration: {\n        this.visitVariableDeclaration(<VariableDeclaration>node);\n        break;\n      }\n\n      // other\n\n      case NodeKind.Decorator: {\n        this.serializeDecorator(<DecoratorNode>node);\n        break;\n      }\n      case NodeKind.ExportMember: {\n        this.visitExportMember(<ExportMember>node);\n        break;\n      }\n      case NodeKind.Parameter: {\n        this.serializeParameter(<ParameterNode>node);\n        break;\n      }\n      case NodeKind.SwitchCase: {\n        this.visitSwitchCase(<SwitchCase>node);\n        break;\n      }\n      case NodeKind.IndexSignature: {\n        this.visitIndexSignature(<IndexSignatureNode>node);\n        break;\n      }\n      default: assert(false);\n    }\n  }\n\n  visitSource(source: Source): void {\n    let statements = source.statements;\n    for (let i = 0, k = statements.length; i < k; ++i) {\n      this.visitNodeAndTerminate(statements[i]);\n    }\n  }\n\n  // types\n\n  visitTypeNode(node: TypeNode): void {\n    switch (node.kind) {\n      case NodeKind.NamedType: {\n        this.visitNamedTypeNode(<NamedTypeNode>node);\n        break;\n      }\n      case NodeKind.FunctionType: {\n        this.visitFunctionTypeNode(<FunctionTypeNode>node);\n        break;\n      }\n      default: assert(false);\n    }\n  }\n\n  visitTypeName(node: TypeName): void {\n    this.visitIdentifierExpression(node.identifier);\n    let sb = this.sb;\n    let current = node.next;\n    while (current) {\n      sb.push(\".\");\n      this.visitIdentifierExpression(current.identifier);\n      current = current.next;\n    }\n  }\n\n  visitNamedTypeNode(node: NamedTypeNode): void {\n    this.visitTypeName(node.name);\n    let typeArguments = node.typeArguments;\n    if (typeArguments) {\n      let numTypeArguments = typeArguments.length;\n      let sb = this.sb;\n      if (numTypeArguments) {\n        sb.push(\"<\");\n        this.visitTypeNode(typeArguments[0]);\n        for (let i = 1; i < numTypeArguments; ++i) {\n          sb.push(\", \");\n          this.visitTypeNode(typeArguments[i]);\n        }\n        sb.push(\">\");\n      }\n      if (node.isNullable) sb.push(\" | null\");\n    }\n  }\n\n  visitFunctionTypeNode(node: FunctionTypeNode): void {\n    let isNullable = node.isNullable;\n    let sb = this.sb;\n    sb.push(isNullable ? \"((\" : \"(\");\n    let explicitThisType = node.explicitThisType;\n    if (explicitThisType) {\n      sb.push(\"this: \");\n      this.visitTypeNode(explicitThisType);\n    }\n    let parameters = node.parameters;\n    let numParameters = parameters.length;\n    if (numParameters) {\n      if (explicitThisType) sb.push(\", \");\n      this.serializeParameter(parameters[0]);\n      for (let i = 1; i < numParameters; ++i) {\n        sb.push(\", \");\n        this.serializeParameter(parameters[i]);\n      }\n    }\n    let returnType = node.returnType;\n    if (returnType) {\n      sb.push(\") => \");\n      this.visitTypeNode(returnType);\n    } else {\n      sb.push(\") => void\");\n    }\n    if (isNullable) sb.push(\") | null\");\n  }\n\n  visitTypeParameter(node: TypeParameterNode): void {\n    this.visitIdentifierExpression(node.name);\n    let extendsType = node.extendsType;\n    if (extendsType) {\n      this.sb.push(\" extends \");\n      this.visitTypeNode(extendsType);\n    }\n    let defaultType = node.defaultType;\n    if (defaultType) {\n      this.sb.push(\"=\");\n      this.visitTypeNode(defaultType);\n    }\n  }\n\n  // expressions\n\n  visitIdentifierExpression(node: IdentifierExpression): void {\n    if (node.isQuoted) this.visitStringLiteral(node.text);\n    else this.sb.push(node.text);\n  }\n\n  visitArrayLiteralExpression(node: ArrayLiteralExpression): void {\n    let sb = this.sb;\n    sb.push(\"[\");\n    let elements = node.elementExpressions;\n    let numElements = elements.length;\n    if (numElements) {\n      let element = elements[0];\n      if (element) this.visitNode(element);\n      for (let i = 1; i < numElements; ++i) {\n        element = elements[i];\n        sb.push(\", \");\n        if (element) this.visitNode(element);\n      }\n    }\n    sb.push(\"]\");\n  }\n\n  visitObjectLiteralExpression(node: ObjectLiteralExpression): void {\n    let sb = this.sb;\n    let names = node.names;\n    let values = node.values;\n    let numElements = names.length;\n    assert(numElements == values.length);\n    if (numElements) {\n      sb.push(\"{\\n\");\n      indent(sb, ++this.indentLevel);\n      this.visitNode(names[0]);\n      sb.push(\": \");\n      this.visitNode(values[0]);\n      for (let i = 1; i < numElements; ++i) {\n        sb.push(\",\\n\");\n        indent(sb, this.indentLevel);\n        let name = names[i];\n        let value = values[i];\n        if (name == value) {\n          this.visitNode(name);\n        } else {\n          this.visitNode(name);\n          sb.push(\": \");\n          this.visitNode(value);\n        }\n      }\n      sb.push(\"\\n\");\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    } else {\n      sb.push(\"{}\");\n    }\n  }\n\n  visitAssertionExpression(node: AssertionExpression): void {\n    let sb = this.sb;\n    switch (node.assertionKind) {\n      case AssertionKind.Prefix: {\n        sb.push(\"<\");\n        this.visitTypeNode(assert(node.toType));\n        sb.push(\">\");\n        this.visitNode(node.expression);\n        break;\n      }\n      case AssertionKind.As: {\n        this.visitNode(node.expression);\n        sb.push(\" as \");\n        this.visitTypeNode(assert(node.toType));\n        break;\n      }\n      case AssertionKind.NonNull: {\n        this.visitNode(node.expression);\n        sb.push(\"!\");\n        break;\n      }\n      case AssertionKind.Const: {\n        this.visitNode(node.expression);\n        sb.push(\" as const\");\n        break;\n      }\n      default: assert(false);\n    }\n  }\n\n  visitBinaryExpression(node: BinaryExpression): void {\n    let sb = this.sb;\n    this.visitNode(node.left);\n    sb.push(\" \");\n    sb.push(operatorTokenToString(node.operator));\n    sb.push(\" \");\n    this.visitNode(node.right);\n  }\n\n  visitCallExpression(node: CallExpression): void {\n    this.visitNode(node.expression);\n    this.visitArguments(node.typeArguments, node.args);\n  }\n\n  private visitArguments(typeArguments: TypeNode[] | null, args: Expression[]): void {\n    let sb = this.sb;\n    if (typeArguments) {\n      let numTypeArguments = typeArguments.length;\n      if (numTypeArguments) {\n        sb.push(\"<\");\n        this.visitTypeNode(typeArguments[0]);\n        for (let i = 1; i < numTypeArguments; ++i) {\n          sb.push(\", \");\n          this.visitTypeNode(typeArguments[i]);\n        }\n        sb.push(\">(\");\n      }\n    } else {\n      sb.push(\"(\");\n    }\n    let numArgs = args.length;\n    if (numArgs) {\n      this.visitNode(args[0]);\n      for (let i = 1; i < numArgs; ++i) {\n        sb.push(\", \");\n        this.visitNode(args[i]);\n      }\n    }\n    sb.push(\")\");\n  }\n\n  visitClassExpression(node: ClassExpression): void {\n    let declaration = node.declaration;\n    this.visitClassDeclaration(declaration);\n  }\n\n  visitCommaExpression(node: CommaExpression): void {\n    let expressions = node.expressions;\n    let numExpressions = assert(expressions.length);\n    this.visitNode(expressions[0]);\n    let sb = this.sb;\n    for (let i = 1; i < numExpressions; ++i) {\n      sb.push(\",\");\n      this.visitNode(expressions[i]);\n    }\n  }\n\n  visitElementAccessExpression(node: ElementAccessExpression): void {\n    let sb = this.sb;\n    this.visitNode(node.expression);\n    sb.push(\"[\");\n    this.visitNode(node.elementExpression);\n    sb.push(\"]\");\n  }\n\n  visitFunctionExpression(node: FunctionExpression): void {\n    let declaration = node.declaration;\n    if (!declaration.arrowKind) {\n      if (declaration.name.text.length) {\n        this.sb.push(\"function \");\n      } else {\n        this.sb.push(\"function\");\n      }\n    } else {\n      assert(declaration.name.text.length == 0);\n    }\n    this.visitFunctionCommon(declaration);\n  }\n\n  visitLiteralExpression(node: LiteralExpression): void {\n    switch (node.literalKind) {\n      case LiteralKind.Float: {\n        this.visitFloatLiteralExpression(<FloatLiteralExpression>node);\n        break;\n      }\n      case LiteralKind.Integer: {\n        this.visitIntegerLiteralExpression(<IntegerLiteralExpression>node);\n        break;\n      }\n      case LiteralKind.String: {\n        this.visitStringLiteralExpression(<StringLiteralExpression>node);\n        break;\n      }\n      case LiteralKind.Template: {\n        this.visitTemplateLiteralExpression(<TemplateLiteralExpression>node);\n        break;\n      }\n      case LiteralKind.RegExp: {\n        this.visitRegexpLiteralExpression(<RegexpLiteralExpression>node);\n        break;\n      }\n      case LiteralKind.Array: {\n        this.visitArrayLiteralExpression(<ArrayLiteralExpression>node);\n        break;\n      }\n      case LiteralKind.Object: {\n        this.visitObjectLiteralExpression(<ObjectLiteralExpression>node);\n        break;\n      }\n      default: {\n        assert(false);\n        break;\n      }\n    }\n  }\n\n  visitFloatLiteralExpression(node: FloatLiteralExpression): void {\n    this.sb.push(node.value.toString());\n  }\n\n  visitInstanceOfExpression(node: InstanceOfExpression): void {\n    this.visitNode(node.expression);\n    this.sb.push(\" instanceof \");\n    this.visitTypeNode(node.isType);\n  }\n\n  visitIntegerLiteralExpression(node: IntegerLiteralExpression): void {\n    let range = node.range;\n    let hasExplicitSign = range.source.text.startsWith(\"-\", range.start);\n    this.sb.push(i64_to_string(node.value, !hasExplicitSign));\n  }\n\n  visitStringLiteral(str: string): void {\n    let sb = this.sb;\n    sb.push(\"\\\"\");\n    sb.push(escapeString(str, CharCode.DoubleQuote));\n    sb.push(\"\\\"\");\n  }\n\n  visitStringLiteralExpression(node: StringLiteralExpression): void {\n    this.visitStringLiteral(node.value);\n  }\n\n  visitTemplateLiteralExpression(node: TemplateLiteralExpression): void {\n    let sb = this.sb;\n    let tag = node.tag;\n    let parts = node.parts;\n    let expressions = node.expressions;\n    if (tag) this.visitNode(tag);\n    sb.push(\"`\");\n    sb.push(escapeString(parts[0], CharCode.Backtick));\n    assert(parts.length == expressions.length + 1);\n    for (let i = 0, k = expressions.length; i < k; ++i) {\n      sb.push(\"${\");\n      this.visitNode(expressions[i]);\n      sb.push(\"}\");\n      sb.push(escapeString(parts[i + 1], CharCode.Backtick));\n    }\n    sb.push(\"`\");\n  }\n\n  visitRegexpLiteralExpression(node: RegexpLiteralExpression): void {\n    let sb = this.sb;\n    sb.push(\"/\");\n    sb.push(node.pattern);\n    sb.push(\"/\");\n    sb.push(node.patternFlags);\n  }\n\n  visitNewExpression(node: NewExpression): void {\n    this.sb.push(\"new \");\n    this.visitTypeName(node.typeName);\n    this.visitArguments(node.typeArguments, node.args);\n  }\n\n  visitParenthesizedExpression(node: ParenthesizedExpression): void {\n    let sb = this.sb;\n    sb.push(\"(\");\n    this.visitNode(node.expression);\n    sb.push(\")\");\n  }\n\n  visitPropertyAccessExpression(node: PropertyAccessExpression): void {\n    this.visitNode(node.expression);\n    this.sb.push(\".\");\n    this.visitIdentifierExpression(node.property);\n  }\n\n  visitTernaryExpression(node: TernaryExpression): void {\n    let sb = this.sb;\n    this.visitNode(node.condition);\n    sb.push(\" ? \");\n    this.visitNode(node.ifThen);\n    sb.push(\" : \");\n    this.visitNode(node.ifElse);\n  }\n\n  visitUnaryExpression(node: UnaryExpression): void {\n    switch (node.kind) {\n      case NodeKind.UnaryPostfix: {\n        this.visitUnaryPostfixExpression(<UnaryPostfixExpression>node);\n        break;\n      }\n      case NodeKind.UnaryPrefix: {\n        this.visitUnaryPrefixExpression(<UnaryPrefixExpression>node);\n        break;\n      }\n      default: assert(false);\n    }\n  }\n\n  visitUnaryPostfixExpression(node: UnaryPostfixExpression): void {\n    this.visitNode(node.operand);\n    this.sb.push(operatorTokenToString(node.operator));\n  }\n\n  visitUnaryPrefixExpression(node: UnaryPrefixExpression): void {\n    this.sb.push(operatorTokenToString(node.operator));\n    this.visitNode(node.operand);\n  }\n\n  // statements\n\n  visitNodeAndTerminate(node: Node): void {\n    this.visitNode(node);\n    let sb = this.sb;\n    if (\n      !sb.length ||                     // leading EmptyStatement\n      node.kind == NodeKind.Variable || // potentially assigns a FunctionExpression\n      node.kind == NodeKind.Expression  // potentially assigns a FunctionExpression\n    ) {\n      sb.push(\";\\n\");\n    } else {\n      let last = sb[sb.length - 1];\n      let lastCharPos = last.length - 1;\n      if (lastCharPos >= 0 && (\n        last.charCodeAt(lastCharPos) == CharCode.CloseBrace ||\n        last.charCodeAt(lastCharPos) == CharCode.Semicolon)\n      ) {\n        sb.push(\"\\n\");\n      } else {\n        sb.push(\";\\n\");\n      }\n    }\n  }\n\n  visitBlockStatement(node: BlockStatement): void {\n    let sb = this.sb;\n    let statements = node.statements;\n    let numStatements = statements.length;\n    if (numStatements) {\n      sb.push(\"{\\n\");\n      let indentLevel = ++this.indentLevel;\n      for (let i = 0; i < numStatements; ++i) {\n        indent(sb, indentLevel);\n        this.visitNodeAndTerminate(statements[i]);\n      }\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    } else {\n      sb.push(\"{}\");\n    }\n  }\n\n  visitBreakStatement(node: BreakStatement): void {\n    let label = node.label;\n    if (label) {\n      this.sb.push(\"break \");\n      this.visitIdentifierExpression(label);\n    } else {\n      this.sb.push(\"break\");\n    }\n  }\n\n  visitContinueStatement(node: ContinueStatement): void {\n    let label = node.label;\n    if (label) {\n      this.sb.push(\"continue \");\n      this.visitIdentifierExpression(label);\n    } else {\n      this.sb.push(\"continue\");\n    }\n  }\n\n  visitClassDeclaration(node: ClassDeclaration, isDefault: bool = false): void {\n    let decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    let sb = this.sb;\n    if (isDefault) {\n      sb.push(\"export default \");\n    } else {\n      this.serializeExternalModifiers(node);\n    }\n    if (node.is(CommonFlags.Abstract)) sb.push(\"abstract \");\n    if (node.name.text.length) {\n      sb.push(\"class \");\n      this.visitIdentifierExpression(node.name);\n    } else {\n      sb.push(\"class\");\n    }\n    let typeParameters = node.typeParameters;\n    if (typeParameters != null && typeParameters.length > 0) {\n      sb.push(\"<\");\n      this.visitTypeParameter(typeParameters[0]);\n      for (let i = 1, k = typeParameters.length; i < k; ++i) {\n        sb.push(\", \");\n        this.visitTypeParameter(typeParameters[i]);\n      }\n      sb.push(\">\");\n    }\n    let extendsType = node.extendsType;\n    if (extendsType) {\n      sb.push(\" extends \");\n      this.visitTypeNode(extendsType);\n    }\n    let implementsTypes = node.implementsTypes;\n    if (implementsTypes) {\n      let numImplementsTypes = implementsTypes.length;\n      if (numImplementsTypes) {\n        sb.push(\" implements \");\n        this.visitTypeNode(implementsTypes[0]);\n        for (let i = 1; i < numImplementsTypes; ++i) {\n          sb.push(\", \");\n          this.visitTypeNode(implementsTypes[i]);\n        }\n      }\n    }\n    let indexSignature = node.indexSignature;\n    let members = node.members;\n    let numMembers = members.length;\n    if (indexSignature || numMembers) {\n      sb.push(\" {\\n\");\n      let indentLevel = ++this.indentLevel;\n      if (indexSignature) {\n        indent(sb, indentLevel);\n        this.visitNodeAndTerminate(indexSignature);\n      }\n      for (let i = 0, k = members.length; i < k; ++i) {\n        let member = members[i];\n        if (member.kind != NodeKind.FieldDeclaration || (<FieldDeclaration>member).parameterIndex < 0) {\n          indent(sb, indentLevel);\n          this.visitNodeAndTerminate(member);\n        }\n      }\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    } else {\n      sb.push(\" {}\");\n    }\n  }\n\n  visitDoStatement(node: DoStatement): void {\n    let sb = this.sb;\n    sb.push(\"do \");\n    this.visitNode(node.body);\n    if (node.body.kind == NodeKind.Block) {\n      sb.push(\" while (\");\n    } else {\n      sb.push(\";\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(\"while (\");\n    }\n    this.visitNode(node.condition);\n    sb.push(\")\");\n  }\n\n  visitEmptyStatement(node: EmptyStatement): void {\n    /* nop */\n  }\n\n  visitEnumDeclaration(node: EnumDeclaration, isDefault: bool = false): void {\n    let sb = this.sb;\n    if (isDefault) {\n      sb.push(\"export default \");\n    } else {\n      this.serializeExternalModifiers(node);\n    }\n    if (node.is(CommonFlags.Const)) sb.push(\"const \");\n    sb.push(\"enum \");\n    this.visitIdentifierExpression(node.name);\n    let values = node.values;\n    let numValues = values.length;\n    if (numValues) {\n      sb.push(\" {\\n\");\n      let indentLevel = ++this.indentLevel;\n      indent(sb, indentLevel);\n      this.visitEnumValueDeclaration(node.values[0]);\n      for (let i = 1; i < numValues; ++i) {\n        sb.push(\",\\n\");\n        indent(sb, indentLevel);\n        this.visitEnumValueDeclaration(node.values[i]);\n      }\n      sb.push(\"\\n\");\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    } else {\n      sb.push(\" {}\");\n    }\n  }\n\n  visitEnumValueDeclaration(node: EnumValueDeclaration): void {\n    this.visitIdentifierExpression(node.name);\n    let initializer = node.initializer;\n    if (initializer) {\n      this.sb.push(\" = \");\n      this.visitNode(initializer);\n    }\n  }\n\n  visitExportImportStatement(node: ExportImportStatement): void {\n    let sb = this.sb;\n    sb.push(\"export import \");\n    this.visitIdentifierExpression(node.externalName);\n    sb.push(\" = \");\n    this.visitIdentifierExpression(node.name);\n  }\n\n  visitExportMember(node: ExportMember): void {\n    this.visitIdentifierExpression(node.localName);\n    if (node.exportedName.text != node.localName.text) {\n      this.sb.push(\" as \");\n      this.visitIdentifierExpression(node.exportedName);\n    }\n  }\n\n  visitExportStatement(node: ExportStatement): void {\n    let sb = this.sb;\n    if (node.isDeclare) {\n      sb.push(\"declare \");\n    }\n    let members = node.members;\n    if (members == null) {\n      sb.push(\"export *\");\n    } else if (members.length > 0) {\n      let numMembers = members.length;\n      sb.push(\"export {\\n\");\n      let indentLevel = ++this.indentLevel;\n      indent(sb, indentLevel);\n      this.visitExportMember(members[0]);\n      for (let i = 1; i < numMembers; ++i) {\n        sb.push(\",\\n\");\n        indent(sb, indentLevel);\n        this.visitExportMember(members[i]);\n      }\n      --this.indentLevel;\n      sb.push(\"\\n}\");\n    } else {\n      sb.push(\"export {}\");\n    }\n    let path = node.path;\n    if (path) {\n      sb.push(\" from \");\n      this.visitStringLiteralExpression(path);\n    }\n    sb.push(\";\");\n  }\n\n  visitExportDefaultStatement(node: ExportDefaultStatement): void {\n    let declaration = node.declaration;\n    switch (declaration.kind) {\n      case NodeKind.EnumDeclaration: {\n        this.visitEnumDeclaration(<EnumDeclaration>declaration, true);\n        break;\n      }\n      case NodeKind.FunctionDeclaration: {\n        this.visitFunctionDeclaration(<FunctionDeclaration>declaration, true);\n        break;\n      }\n      case NodeKind.ClassDeclaration: {\n        this.visitClassDeclaration(<ClassDeclaration>declaration, true);\n        break;\n      }\n      case NodeKind.InterfaceDeclaration: {\n        this.visitInterfaceDeclaration(<InterfaceDeclaration>declaration, true);\n        break;\n      }\n      case NodeKind.NamespaceDeclaration: {\n        this.visitNamespaceDeclaration(<NamespaceDeclaration>declaration, true);\n        break;\n      }\n      default: assert(false);\n    }\n  }\n\n  visitExpressionStatement(node: ExpressionStatement): void {\n    this.visitNode(node.expression);\n  }\n\n  visitFieldDeclaration(node: FieldDeclaration): void {\n    let decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    this.serializeAccessModifiers(node);\n    this.visitIdentifierExpression(node.name);\n    let sb = this.sb;\n    if (node.flags & CommonFlags.DefinitelyAssigned) {\n      sb.push(\"!\");\n    }\n    let type = node.type;\n    if (type) {\n      sb.push(\": \");\n      this.visitTypeNode(type);\n    }\n    let initializer = node.initializer;\n    if (initializer) {\n      sb.push(\" = \");\n      this.visitNode(initializer);\n    }\n  }\n\n  visitForStatement(node: ForStatement): void {\n    let sb = this.sb;\n    sb.push(\"for (\");\n    let initializer = node.initializer;\n    if (initializer) {\n      this.visitNode(initializer);\n    }\n    let condition = node.condition;\n    if (condition) {\n      sb.push(\"; \");\n      this.visitNode(condition);\n    } else {\n      sb.push(\";\");\n    }\n    let incrementor = node.incrementor;\n    if (incrementor) {\n      sb.push(\"; \");\n      this.visitNode(incrementor);\n    } else {\n      sb.push(\";\");\n    }\n    sb.push(\") \");\n    this.visitNode(node.body);\n  }\n\n  visitForOfStatement(node: ForOfStatement): void {\n    let sb = this.sb;\n    sb.push(\"for (\");\n    this.visitNode(node.variable);\n    sb.push(\" of \");\n    this.visitNode(node.iterable);\n    sb.push(\") \");\n    this.visitNode(node.body);\n  }\n\n  visitFunctionDeclaration(node: FunctionDeclaration, isDefault: bool = false): void {\n    let sb = this.sb;\n    let decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    if (isDefault) {\n      sb.push(\"export default \");\n    } else {\n      this.serializeExternalModifiers(node);\n      this.serializeAccessModifiers(node);\n    }\n    if (node.name.text.length) {\n      sb.push(\"function \");\n    } else {\n      sb.push(\"function\");\n    }\n    this.visitFunctionCommon(node);\n  }\n\n  visitFunctionCommon(node: FunctionDeclaration): void {\n    let sb = this.sb;\n    this.visitIdentifierExpression(node.name);\n    let signature = node.signature;\n    let typeParameters = node.typeParameters;\n    if (typeParameters) {\n      let numTypeParameters = typeParameters.length;\n      if (numTypeParameters) {\n        sb.push(\"<\");\n        this.visitTypeParameter(typeParameters[0]);\n        for (let i = 1; i < numTypeParameters; ++i) {\n          sb.push(\", \");\n          this.visitTypeParameter(typeParameters[i]);\n        }\n        sb.push(\">\");\n      }\n    }\n    if (node.arrowKind == ArrowKind.Single) {\n      let parameters = signature.parameters;\n      assert(parameters.length == 1);\n      assert(!signature.explicitThisType);\n      this.serializeParameter(parameters[0]);\n    } else {\n      sb.push(\"(\");\n      let parameters = signature.parameters;\n      let numParameters = parameters.length;\n      let explicitThisType = signature.explicitThisType;\n      if (explicitThisType) {\n        sb.push(\"this: \");\n        this.visitTypeNode(explicitThisType);\n      }\n      if (numParameters) {\n        if (explicitThisType) sb.push(\", \");\n        this.serializeParameter(parameters[0]);\n        for (let i = 1; i < numParameters; ++i) {\n          sb.push(\", \");\n          this.serializeParameter(parameters[i]);\n        }\n      }\n    }\n    let body = node.body;\n    let returnType = signature.returnType;\n    if (node.arrowKind) {\n      if (body) {\n        if (node.arrowKind == ArrowKind.Single) {\n          assert(isTypeOmitted(returnType));\n        } else {\n          if (isTypeOmitted(returnType)) {\n            sb.push(\")\");\n          } else {\n            sb.push(\"): \");\n            this.visitTypeNode(returnType);\n          }\n        }\n        sb.push(\" => \");\n        this.visitNode(body);\n      } else {\n        assert(!isTypeOmitted(returnType));\n        sb.push(\" => \");\n        this.visitTypeNode(returnType);\n      }\n    } else {\n      if (\n        !isTypeOmitted(returnType) &&\n        !node.isAny(CommonFlags.Constructor | CommonFlags.Set)\n      ) {\n        sb.push(\"): \");\n        this.visitTypeNode(returnType);\n      } else {\n        sb.push(\")\");\n      }\n      if (body) {\n        sb.push(\" \");\n        this.visitNode(body);\n      }\n    }\n  }\n\n  visitIfStatement(node: IfStatement): void {\n    let sb = this.sb;\n    sb.push(\"if (\");\n    this.visitNode(node.condition);\n    sb.push(\") \");\n    let ifTrue = node.ifTrue;\n    this.visitNode(ifTrue);\n    if (ifTrue.kind != NodeKind.Block) {\n      sb.push(\";\\n\");\n    }\n    let ifFalse = node.ifFalse;\n    if (ifFalse) {\n      if (ifTrue.kind == NodeKind.Block) {\n        sb.push(\" else \");\n      } else {\n        sb.push(\"else \");\n      }\n      this.visitNode(ifFalse);\n    }\n  }\n\n  visitImportDeclaration(node: ImportDeclaration): void {\n    let externalName = node.foreignName;\n    let name = node.name;\n    this.visitIdentifierExpression(externalName);\n    if (externalName.text != name.text) {\n      this.sb.push(\" as \");\n      this.visitIdentifierExpression(name);\n    }\n  }\n\n  visitImportStatement(node: ImportStatement): void {\n    let sb = this.sb;\n    sb.push(\"import \");\n    let declarations = node.declarations;\n    let namespaceName = node.namespaceName;\n    if (declarations) {\n      let numDeclarations = declarations.length;\n      if (numDeclarations) {\n        sb.push(\"{\\n\");\n        let indentLevel = ++this.indentLevel;\n        indent(sb, indentLevel);\n        this.visitImportDeclaration(declarations[0]);\n        for (let i = 1; i < numDeclarations; ++i) {\n          sb.push(\",\\n\");\n          indent(sb, indentLevel);\n          this.visitImportDeclaration(declarations[i]);\n        }\n        --this.indentLevel;\n        sb.push(\"\\n} from \");\n      } else {\n        sb.push(\"{} from \");\n      }\n    } else if (namespaceName) {\n      sb.push(\"* as \");\n      this.visitIdentifierExpression(namespaceName);\n      sb.push(\" from \");\n    }\n    this.visitStringLiteralExpression(node.path);\n  }\n\n  visitIndexSignature(node: IndexSignatureNode): void {\n    let sb = this.sb;\n    sb.push(\"[key: \");\n    this.visitTypeNode(node.keyType);\n    sb.push(\"]: \");\n    this.visitTypeNode(node.valueType);\n  }\n\n  visitInterfaceDeclaration(node: InterfaceDeclaration, isDefault: bool = false): void {\n    let decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    let sb = this.sb;\n    if (isDefault) {\n      sb.push(\"export default \");\n    } else {\n      this.serializeExternalModifiers(node);\n    }\n    sb.push(\"interface \");\n    this.visitIdentifierExpression(node.name);\n    let typeParameters = node.typeParameters;\n    if (typeParameters != null && typeParameters.length > 0) {\n      sb.push(\"<\");\n      this.visitTypeParameter(typeParameters[0]);\n      for (let i = 1, k = typeParameters.length; i < k; ++i) {\n        sb.push(\", \");\n        this.visitTypeParameter(typeParameters[i]);\n      }\n      sb.push(\">\");\n    }\n    let extendsType = node.extendsType;\n    if (extendsType) {\n      sb.push(\" extends \");\n      this.visitTypeNode(extendsType);\n    }\n    // must not have implementsTypes\n    sb.push(\" {\\n\");\n    let indentLevel = ++this.indentLevel;\n    let members = node.members;\n    for (let i = 0, k = members.length; i < k; ++i) {\n      indent(sb, indentLevel);\n      this.visitNodeAndTerminate(members[i]);\n    }\n    --this.indentLevel;\n    sb.push(\"}\");\n  }\n\n  visitMethodDeclaration(node: MethodDeclaration): void {\n    let decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    this.serializeAccessModifiers(node);\n    if (node.is(CommonFlags.Get)) {\n      this.sb.push(\"get \");\n    } else if (node.is(CommonFlags.Set)) {\n      this.sb.push(\"set \");\n    }\n    this.visitFunctionCommon(node);\n  }\n\n  visitNamespaceDeclaration(node: NamespaceDeclaration, isDefault: bool = false): void {\n    let decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    let sb = this.sb;\n    if (isDefault) {\n      sb.push(\"export default \");\n    } else {\n      this.serializeExternalModifiers(node);\n    }\n    sb.push(\"namespace \");\n    this.visitIdentifierExpression(node.name);\n    let members = node.members;\n    let numMembers = members.length;\n    if (numMembers) {\n      sb.push(\" {\\n\");\n      let indentLevel = ++this.indentLevel;\n      for (let i = 0, k = members.length; i < k; ++i) {\n        indent(sb, indentLevel);\n        this.visitNodeAndTerminate(members[i]);\n      }\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    } else {\n      sb.push(\" {}\");\n    }\n  }\n\n  visitReturnStatement(node: ReturnStatement): void {\n    let value = node.value;\n    if (value) {\n      this.sb.push(\"return \");\n      this.visitNode(value);\n    } else {\n      this.sb.push(\"return\");\n    }\n  }\n\n  visitSwitchCase(node: SwitchCase): void {\n    let sb = this.sb;\n    let label = node.label;\n    if (label) {\n      sb.push(\"case \");\n      this.visitNode(label);\n      sb.push(\":\\n\");\n    } else {\n      sb.push(\"default:\\n\");\n    }\n    let statements = node.statements;\n    let numStatements = statements.length;\n    if (numStatements) {\n      let indentLevel = ++this.indentLevel;\n      indent(sb, indentLevel);\n      this.visitNodeAndTerminate(statements[0]);\n      for (let i = 1; i < numStatements; ++i) {\n        indent(sb, indentLevel);\n        this.visitNodeAndTerminate(statements[i]);\n      }\n      --this.indentLevel;\n    }\n  }\n\n  visitSwitchStatement(node: SwitchStatement): void {\n    let sb = this.sb;\n    sb.push(\"switch (\");\n    this.visitNode(node.condition);\n    sb.push(\") {\\n\");\n    let indentLevel = ++this.indentLevel;\n    let cases = node.cases;\n    for (let i = 0, k = cases.length; i < k; ++i) {\n      indent(sb, indentLevel);\n      this.visitSwitchCase(cases[i]);\n      sb.push(\"\\n\");\n    }\n    --this.indentLevel;\n    sb.push(\"}\");\n  }\n\n  visitThrowStatement(node: ThrowStatement): void {\n    this.sb.push(\"throw \");\n    this.visitNode(node.value);\n  }\n\n  visitTryStatement(node: TryStatement): void {\n    let sb = this.sb;\n    sb.push(\"try {\\n\");\n    let indentLevel = ++this.indentLevel;\n    let bodyStatements = node.bodyStatements;\n    for (let i = 0, k = bodyStatements.length; i < k; ++i) {\n      indent(sb, indentLevel);\n      this.visitNodeAndTerminate(bodyStatements[i]);\n    }\n    let catchVariable = node.catchVariable;\n    if (catchVariable) {\n      indent(sb, indentLevel - 1);\n      sb.push(\"} catch (\");\n      this.visitIdentifierExpression(catchVariable);\n      sb.push(\") {\\n\");\n      let catchStatements = node.catchStatements;\n      if (catchStatements) {\n        for (let i = 0, k = catchStatements.length; i < k; ++i) {\n          indent(sb, indentLevel);\n          this.visitNodeAndTerminate(catchStatements[i]);\n        }\n      }\n    }\n    let finallyStatements = node.finallyStatements;\n    if (finallyStatements) {\n      indent(sb, indentLevel - 1);\n      sb.push(\"} finally {\\n\");\n      for (let i = 0, k = finallyStatements.length; i < k; ++i) {\n        indent(sb, indentLevel);\n        this.visitNodeAndTerminate(finallyStatements[i]);\n      }\n    }\n    indent(sb, indentLevel - 1);\n    sb.push(\"}\");\n  }\n\n  visitTypeDeclaration(node: TypeDeclaration): void {\n    let decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    let sb = this.sb;\n    this.serializeExternalModifiers(node);\n    sb.push(\"type \");\n    this.visitIdentifierExpression(node.name);\n    let typeParameters = node.typeParameters;\n    if (typeParameters) {\n      let numTypeParameters = typeParameters.length;\n      if (numTypeParameters) {\n        sb.push(\"<\");\n        for (let i = 0; i < numTypeParameters; ++i) {\n          this.visitTypeParameter(typeParameters[i]);\n        }\n        sb.push(\">\");\n      }\n    }\n    sb.push(\" = \");\n    this.visitTypeNode(node.type);\n  }\n\n  visitModuleDeclaration(node: ModuleDeclaration): void {\n    let sb = this.sb;\n    if (node.flags & CommonFlags.Declare) {\n      sb.push(\"declare \");\n    }\n    sb.push(\"module \\\"\");\n    sb.push(escapeString(node.moduleName, CharCode.DoubleQuote));\n    sb.push(\"\\\"\");\n  }\n\n  visitVariableDeclaration(node: VariableDeclaration): void {\n    this.visitIdentifierExpression(node.name);\n    let type = node.type;\n    let sb = this.sb;\n    if (node.flags & CommonFlags.DefinitelyAssigned) {\n      sb.push(\"!\");\n    }\n    if (type) {\n      sb.push(\": \");\n      this.visitTypeNode(type);\n    }\n    let initializer = node.initializer;\n    if (initializer) {\n      sb.push(\" = \");\n      this.visitNode(initializer);\n    }\n  }\n\n  visitVariableStatement(node: VariableStatement): void {\n    let decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    let sb = this.sb;\n    let declarations = node.declarations;\n    let numDeclarations = assert(declarations.length);\n    let firstDeclaration = declarations[0];\n    this.serializeExternalModifiers(firstDeclaration);\n    sb.push(firstDeclaration.is(CommonFlags.Const) ? \"const \" : firstDeclaration.is(CommonFlags.Let) ? \"let \" : \"var \");\n    this.visitVariableDeclaration(node.declarations[0]);\n    for (let i = 1; i < numDeclarations; ++i) {\n      sb.push(\", \");\n      this.visitVariableDeclaration(node.declarations[i]);\n    }\n  }\n\n  visitWhileStatement(node: WhileStatement): void {\n    let sb = this.sb;\n    sb.push(\"while (\");\n    this.visitNode(node.condition);\n    let body = node.body;\n    if (body.isEmpty) {\n      sb.push(\")\");\n    } else {\n      sb.push(\") \");\n      this.visitNode(body);\n    }\n  }\n\n  // other\n\n  serializeDecorator(node: DecoratorNode): void {\n    let sb = this.sb;\n    sb.push(\"@\");\n    this.visitNode(node.name);\n    let args = node.args;\n    if (args) {\n      sb.push(\"(\");\n      let numArgs = args.length;\n      if (numArgs) {\n        this.visitNode(args[0]);\n        for (let i = 1; i < numArgs; ++i) {\n          sb.push(\", \");\n          this.visitNode(args[i]);\n        }\n      }\n      sb.push(\")\\n\");\n    } else {\n      sb.push(\"\\n\");\n    }\n    indent(sb, this.indentLevel);\n  }\n\n  serializeParameter(node: ParameterNode): void {\n    let sb = this.sb;\n    let kind = node.parameterKind;\n    let implicitFieldDeclaration = node.implicitFieldDeclaration;\n    if (implicitFieldDeclaration) {\n      this.serializeAccessModifiers(implicitFieldDeclaration);\n    }\n    if (kind == ParameterKind.Rest) {\n      sb.push(\"...\");\n    }\n    this.visitIdentifierExpression(node.name);\n    let type = node.type;\n    let initializer = node.initializer;\n    if (type) {\n      if (kind == ParameterKind.Optional && !initializer) sb.push(\"?\");\n      if (!isTypeOmitted(type)) {\n        sb.push(\": \");\n        this.visitTypeNode(type);\n      }\n    }\n    if (initializer) {\n      sb.push(\" = \");\n      this.visitNode(initializer);\n    }\n  }\n\n  serializeExternalModifiers(node: DeclarationStatement): void {\n    let sb = this.sb;\n    if (node.is(CommonFlags.Export)) {\n      sb.push(\"export \");\n    } else if (node.is(CommonFlags.Import)) {\n      sb.push(\"import \");\n    } else if (node.is(CommonFlags.Declare)) {\n      sb.push(\"declare \");\n    }\n  }\n\n  serializeAccessModifiers(node: DeclarationStatement): void {\n    let sb = this.sb;\n    if (node.is(CommonFlags.Declare)) {\n      sb.push(\"declare \");\n    }\n    if (node.is(CommonFlags.Public)) {\n      sb.push(\"public \");\n    } else if (node.is(CommonFlags.Private)) {\n      sb.push(\"private \");\n    } else if (node.is(CommonFlags.Protected)) {\n      sb.push(\"protected \");\n    }\n    if (node.is(CommonFlags.Static)) {\n      sb.push(\"static \");\n    } else if (node.is(CommonFlags.Abstract)) {\n      sb.push(\"abstract \");\n    }\n    if (node.is(CommonFlags.Readonly)) {\n      sb.push(\"readonly \");\n    }\n  }\n\n  finish(): string {\n    let ret = this.sb.join(\"\");\n    this.sb = [];\n    return ret;\n  }\n}\n", "/**\n * @license\n * Copyright 2020 Daniel Wirtz / The AssemblyScript Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\nexport * from \"./index-js\";\nimport * as assemblyscript from \"./index-js\";\nexport default assemblyscript;\n"],
  "mappings": "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,IAAQ,IAAQ,IACxD,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IACxD,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IACxD,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,IAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,MAC1B,EACMH,GAA4B,IAC5BC,GAA4B,OAG5BM,GAA+B,CAEnC,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IACxD,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IACxD,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IACxD,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IACxD,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,IAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACx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",
  "names": ["index_js_exports", "__export", "ASTBuilder", "ArrayLiteralExpression", "ArrowKind", "AssertionExpression", "AssertionKind", "AtomicRMWOp", "BinaryExpression", "BinaryModule", "BinaryOp", "BlockStatement", "BrOnOp", "BreakStatement", "CallExpression", "Class", "ClassDeclaration", "ClassExpression", "ClassPrototype", "CommaExpression", "CommentKind", "CommentNode", "CommonFlags", "CommonNames", "CompiledExpression", "Compiler", "ConditionKind", "ConstantValueKind", "Constraints", "ConstructorExpression", "ContinueStatement", "DEFAULT_STACK_SIZE", "DeclarationStatement", "DeclaredElement", "DecoratorFlags", "DecoratorKind", "DecoratorNode", "DiagnosticCategory", "DiagnosticCode", "DiagnosticEmitter", "DiagnosticMessage", "DoStatement", "Element", "ElementAccessExpression", "ElementKind", "EmptyStatement", "Enum", "EnumDeclaration", "EnumValue", "EnumValueDeclaration", "ExportDefaultStatement", "ExportImportStatement", "ExportMember", "ExportNames", "ExportStatement", "Expression", "ExpressionId", "ExpressionRunnerFlags", "ExpressionStatement", "ExternalKind", "FEATURES_ALL", "FEATURES_DEFAULT", "FEATURE_BULK_MEMORY", "FEATURE_EXCEPTION_HANDLING", "FEATURE_EXTENDED_CONST", "FEATURE_GC", "FEATURE_MEMORY64", "FEATURE_MULTI_VALUE", "FEATURE_MUTABLE_GLOBALS", "FEATURE_NONTRAPPING_F2I", "FEATURE_REFERENCE_TYPES", "FEATURE_RELAXED_SIMD", "FEATURE_SIGN_EXTENSION", "FEATURE_SIMD", "FEATURE_STRINGREF", "FEATURE_TAIL_CALLS", "FEATURE_THREADS", "FalseExpression", "Feature", "FeatureFlags", "FieldDeclaration", "FieldFlags", "File", "FloatLiteralExpression", "Flow", "FlowFlags", "ForOfStatement", "ForStatement", "Function", "FunctionDeclaration", "FunctionExpression", "FunctionPrototype", "FunctionTypeNode", "GETTER_PREFIX", "Global", "HeapTypeRef", "INDEX_SUFFIX", "INNER_DELIMITER", "INSTANCE_DELIMITER", "IdentifierExpression", "IdentifierHandling", "IfStatement", "ImportDeclaration", "ImportNames", "ImportStatement", "IndexSignature", "IndexSignatureNode", "InstanceOfExpression", "IntegerLiteralExpression", "Interface", "InterfaceDeclaration", "InterfacePrototype", "JSBuilder", "LIBRARY_PREFIX", "LIBRARY_SUBST", "LiteralExpression", "LiteralKind", "Local", "LocalFlags", "MemorySegment", "MethodDeclaration", "Module", "ModuleDeclaration", "NamedTypeNode", "Namespace", "NamespaceDeclaration", "NewExpression", "Node", "NodeKind", "NullExpression", "ObjectLiteralExpression", "OmittedExpression", "OperatorKind", "Options", "PARENT_SUBST", "PATH_DELIMITER", "PackedType", "Parameter", "ParameterKind", "ParameterNode", "ParenthesizedExpression", "Parser", "Precedence", "Program", "Property", "PropertyAccessExpression", "PropertyPrototype", "Range", "RefAsOp", "RegexpLiteralExpression", "Relooper", "ReportMode", "Resolver", "ReturnStatement", "Runtime", "RuntimeFeatures", "SETTER_PREFIX", "SIMDExtractOp", "SIMDLoadOp", "SIMDLoadStoreLaneOp", "SIMDReplaceOp", "SIMDShiftOp", "SIMDTernaryOp", "STATIC_DELIMITER", "STUB_DELIMITER", "SideEffects", "Signature", "Source", "SourceKind", "State", "Statement", "StringEncodeOp", "StringEqOp", "StringLiteralExpression", "StringMeasureOp", "StringNewOp", "SuperExpression", "SwitchBuilder", "SwitchCase", "SwitchStatement", "TSDBuilder", "Target", "TemplateLiteralExpression", "TernaryExpression", "ThisExpression", "ThrowStatement", "Token", "Tokenizer", "TrueExpression", "TryStatement", "Type", "TypeBuilderErrorReason", "TypeDeclaration", "TypeDefinition", "TypeFlags", "TypeKind", "TypeName", "TypeNode", "TypeParameterNode", "TypeRef", "TypedElement", "Typeinfo", "TypeinfoFlags", "UnaryExpression", "UnaryOp", "UnaryPostfixExpression", "UnaryPrefixExpression", "UncheckedBehavior", "VariableDeclaration", "VariableLikeDeclarationStatement", "VariableLikeElement", "VariableStatement", "VoidStatement", "WhileStatement", "addGlobalAlias", "allocPtrArray", "buildJS", "buildTSD", "compile", "createType", "defaultFeatures", "diagnosticCategoryToColor", "diagnosticCategoryToString", "diagnosticCodeToString", "ensureType", "expandType", "featureToString", "findDecorator", "formatDiagnosticMessage", "getBinaryLeft", "getBinaryOp", "getBinaryRight", "getBinaryenModuleRef", "getBlockChildAt", "getBlockChildCount", "getBlockName", "getBreakCondition", "getBreakName", "getCallOperandAt", "getCallOperandCount", "getCallTarget", "getConstValueF32", "getConstValueF64", "getConstValueI32", "getConstValueI64High", "getConstValueI64Low", "getConstValueInteger", "getConstValueV128", "getDefaultParameterName", "getDependee", "getDiagnosticCategory", "getDiagnosticCode", "getDiagnosticMessage", "getDiagnosticRange", "getDiagnosticRelatedRange", "getDropValue", "getExpressionId", "getExpressionType", "getFunctionBody", "getFunctionName", "getFunctionParams", "getFunctionResults", "getFunctionVars", "getGlobalGetName", "getGlobalInit", "getGlobalName", "getGlobalType", "getIfCondition", "getIfFalse", "getIfTrue", "getLoadBytes", "getLoadOffset", "getLoadPtr", "getLocalGetIndex", "getLocalSetIndex", "getLocalSetValue", "getLoopBody", "getLoopName", "getMemoryGrowDelta", "getRangeEnd", "getRangeSource", "getRangeStart", "getReturnValue", "getSelectCondition", "getSelectElse", "getSelectThen", "getSideEffects", "getSource", "getSourceNormalizedPath", "getStoreBytes", "getStoreOffset", "getStorePtr", "getStoreValue", "getTagName", "getTagParams", "getTagResults", "getUnaryOp", "getUnaryValue", "initializeProgram", "isConstExpressionNaN", "isConstNaN", "isConstNegZero", "isConstNonZero", "isConstZero", "isDeclaredElement", "isError", "isGlobalMutable", "isIllegalVariableIdentifier", "isInfo", "isLoadSigned", "isLocalTee", "isNullableType", "isTypeOmitted", "isTypedElement", "isWarning", "mangleInternalName", "mangleInternalPath", "mustPreserveSideEffects", "newOptions", "newProgram", "nextDiagnostic", "nextFile", "operatorTokenToString", "optimize", "parse", "readString", "removeGlobalAlias", "runtimeFunctions", "runtimeGlobals", "setBasenameHint", "setBindingsHint", "setBundleVersion", "setDebugInfo", "setExportMemory", "setExportRuntime", "setExportStart", "setExportTable", "setFeature", "setImportMemory", "setImportTable", "setInitialMemory", "setLowMemoryLimit", "setMaximumMemory", "setMemoryBase", "setNoAssert", "setNoUnsafe", "setOptimizeLevelHints", "setPedantic", "setRuntime", "setSharedMemory", "setSourceMap", "setStackSize", "setTableBase", "setTarget", "setUncheckedBehavior", "tokenFromKeyword", "tokenIsAlsoIdentifier", "typesToRefs", "typesToString", "util_exports", "validate", "globalScope", "UnreachableError", "AssertionError", "message", "defaultComparator", "b", "nanA", "nanB", "F64", "U64", "value", "str", "radix", "shift", "y", "ifTrue", "ifFalse", "condition", "x", "a", "isTrueish", "arr", "len", "index", "parts", "search", "replacment", "res", "arraySort", "comparator", "Ctr", "fn", "i", "buffer", "byteOffset", "length", "arg", "expr", "n", "binaryen_exports", "__export", "default", "__reExport", "binaryen_star", "_BinaryenTypeCreate", "_BinaryenTypeArity", "_BinaryenTypeExpand", "_BinaryenTypeGetHeapType", "_BinaryenTypeFromHeapType", "_BinaryenTypeIsNullable", "_BinaryenTypeFuncref", "_BinaryenTypeExternref", "_BinaryenTypeAnyref", "_BinaryenTypeEqref", "_BinaryenTypeI31ref", "_BinaryenTypeStructref", "_BinaryenTypeArrayref", "_BinaryenTypeStringref", "_BinaryenTypeNullref", "_BinaryenTypeNullExternref", "_BinaryenTypeNullFuncref", "_BinaryenHeapTypeFunc", "_BinaryenHeapTypeExt", "_BinaryenHeapTypeAny", "_BinaryenHeapTypeEq", "_BinaryenHeapTypeI31", "_BinaryenHeapTypeStruct", "_BinaryenHeapTypeArray", "_BinaryenHeapTypeString", "_BinaryenHeapTypeNone", "_BinaryenHeapTypeNoext", "_BinaryenHeapTypeNofunc", "_BinaryenHeapTypeIsBasic", "_BinaryenHeapTypeIsSignature", "_BinaryenHeapTypeIsStruct", "_BinaryenHeapTypeIsArray", "_BinaryenHeapTypeIsBottom", "_BinaryenHeapTypeGetBottom", "_BinaryenHeapTypeIsSubType", "_BinaryenStructTypeGetNumFields", "_BinaryenStructTypeGetFieldType", "_BinaryenStructTypeGetFieldPackedType", "_BinaryenStructTypeIsFieldMutable", "_BinaryenArrayTypeGetElementType", "_BinaryenArrayTypeGetElementPackedType", "_BinaryenArrayTypeIsElementMutable", "_BinaryenSignatureTypeGetParams", "_BinaryenSignatureTypeGetResults", "_BinaryenModuleCreate", "_BinaryenModuleDispose", "_BinaryenSizeofLiteral", "_BinaryenLiteralInt32", "_BinaryenLiteralInt64", "_BinaryenLiteralFloat32", "_BinaryenLiteralFloat64", "_BinaryenLiteralVec128", "_BinaryenLiteralFloat32Bits", "_BinaryenLiteralFloat64Bits", "_BinaryenExpressionGetId", "_BinaryenExpressionGetType", "_BinaryenExpressionSetType", "_BinaryenExpressionPrint", "_BinaryenExpressionCopy", "_BinaryenExpressionFinalize", "_BinaryenBlock", "_BinaryenBlockGetName", "_BinaryenBlockSetName", "_BinaryenBlockGetNumChildren", "_BinaryenBlockGetChildAt", "_BinaryenBlockSetChildAt", "_BinaryenBlockAppendChild", "_BinaryenBlockInsertChildAt", "_BinaryenBlockRemoveChildAt", "_BinaryenIf", "_BinaryenIfGetCondition", "_BinaryenIfSetCondition", "_BinaryenIfGetIfTrue", "_BinaryenIfSetIfTrue", "_BinaryenIfGetIfFalse", "_BinaryenIfSetIfFalse", "_BinaryenLoop", "_BinaryenLoopGetName", "_BinaryenLoopSetName", "_BinaryenLoopGetBody", "_BinaryenLoopSetBody", "_BinaryenBreak", "_BinaryenBreakGetName", "_BinaryenBreakSetName", "_BinaryenBreakGetCondition", "_BinaryenBreakSetCondition", "_BinaryenBreakGetValue", "_BinaryenBreakSetValue", "_BinaryenSwitch", "_BinaryenSwitchGetNumNames", "_BinaryenSwitchGetNameAt", "_BinaryenSwitchSetNameAt", "_BinaryenSwitchAppendName", "_BinaryenSwitchInsertNameAt", "_BinaryenSwitchRemoveNameAt", "_BinaryenSwitchGetDefaultName", "_BinaryenSwitchSetDefaultName", "_BinaryenSwitchGetCondition", "_BinaryenSwitchSetCondition", "_BinaryenSwitchGetValue", "_BinaryenSwitchSetValue", "_BinaryenCall", "_BinaryenCallGetTarget", "_BinaryenCallSetTarget", "_BinaryenCallGetNumOperands", "_BinaryenCallGetOperandAt", "_BinaryenCallSetOperandAt", "_BinaryenCallAppendOperand", "_BinaryenCallInsertOperandAt", "_BinaryenCallRemoveOperandAt", "_BinaryenCallIsReturn", "_BinaryenCallSetReturn", "_BinaryenReturnCall", "_BinaryenCallIndirect", "_BinaryenCallIndirectGetTable", "_BinaryenCallIndirectSetTable", "_BinaryenCallIndirectGetTarget", "_BinaryenCallIndirectSetTarget", "_BinaryenCallIndirectGetNumOperands", "_BinaryenCallIndirectGetOperandAt", "_BinaryenCallIndirectSetOperandAt", "_BinaryenCallIndirectAppendOperand", "_BinaryenCallIndirectInsertOperandAt", "_BinaryenCallIndirectRemoveOperandAt", "_BinaryenCallIndirectIsReturn", "_BinaryenCallIndirectSetReturn", "_BinaryenReturnCallIndirect", "_BinaryenLocalGet", "_BinaryenLocalGetGetIndex", "_BinaryenLocalGetSetIndex", "_BinaryenLocalSet", "_BinaryenLocalSetIsTee", "_BinaryenLocalSetGetIndex", "_BinaryenLocalSetSetIndex", "_BinaryenLocalSetGetValue", "_BinaryenLocalSetSetValue", "_BinaryenLocalTee", "_BinaryenGlobalGet", "_BinaryenGlobalGetGetName", "_BinaryenGlobalGetSetName", "_BinaryenGlobalSet", "_BinaryenGlobalSetGetName", "_BinaryenGlobalSetSetName", "_BinaryenGlobalSetGetValue", "_BinaryenGlobalSetSetValue", "_BinaryenMemorySize", "_BinaryenMemoryGrow", "_BinaryenMemoryGrowGetDelta", "_BinaryenMemoryGrowSetDelta", "_BinaryenLoad", "_BinaryenLoadIsAtomic", "_BinaryenLoadSetAtomic", "_BinaryenLoadIsSigned", "_BinaryenLoadSetSigned", "_BinaryenLoadGetOffset", "_BinaryenLoadSetOffset", "_BinaryenLoadGetBytes", "_BinaryenLoadSetBytes", "_BinaryenLoadGetAlign", "_BinaryenLoadSetAlign", "_BinaryenLoadGetPtr", "_BinaryenLoadSetPtr", "_BinaryenAtomicLoad", "_BinaryenStore", "_BinaryenStoreIsAtomic", "_BinaryenStoreSetAtomic", "_BinaryenStoreGetBytes", "_BinaryenStoreSetBytes", "_BinaryenStoreGetOffset", "_BinaryenStoreSetOffset", "_BinaryenStoreGetAlign", "_BinaryenStoreSetAlign", "_BinaryenStoreGetPtr", "_BinaryenStoreSetPtr", "_BinaryenStoreGetValue", "_BinaryenStoreSetValue", "_BinaryenStoreGetValueType", "_BinaryenStoreSetValueType", "_BinaryenAtomicStore", "_BinaryenConst", "_BinaryenConstGetValueI32", "_BinaryenConstSetValueI32", "_BinaryenConstGetValueI64Low", "_BinaryenConstSetValueI64Low", "_BinaryenConstGetValueI64High", "_BinaryenConstSetValueI64High", "_BinaryenConstGetValueF32", "_BinaryenConstSetValueF32", "_BinaryenConstGetValueF64", "_BinaryenConstSetValueF64", "_BinaryenConstGetValueV128", "_BinaryenConstSetValueV128", "_BinaryenUnary", "_BinaryenUnaryGetOp", "_BinaryenUnarySetOp", "_BinaryenUnaryGetValue", "_BinaryenUnarySetValue", "_BinaryenBinary", "_BinaryenBinaryGetOp", "_BinaryenBinarySetOp", "_BinaryenBinaryGetLeft", "_BinaryenBinarySetLeft", "_BinaryenBinaryGetRight", "_BinaryenBinarySetRight", "_BinaryenSelect", "_BinaryenSelectGetIfTrue", "_BinaryenSelectSetIfTrue", "_BinaryenSelectGetIfFalse", "_BinaryenSelectSetIfFalse", "_BinaryenSelectGetCondition", "_BinaryenSelectSetCondition", "_BinaryenDrop", "_BinaryenDropGetValue", "_BinaryenDropSetValue", "_BinaryenReturn", "_BinaryenReturnGetValue", "_BinaryenReturnSetValue", "_BinaryenNop", "_BinaryenUnreachable", "_BinaryenAtomicRMW", "_BinaryenAtomicRMWGetOp", "_BinaryenAtomicRMWSetOp", "_BinaryenAtomicRMWGetBytes", "_BinaryenAtomicRMWSetBytes", "_BinaryenAtomicRMWGetOffset", "_BinaryenAtomicRMWSetOffset", "_BinaryenAtomicRMWGetPtr", "_BinaryenAtomicRMWSetPtr", "_BinaryenAtomicRMWGetValue", "_BinaryenAtomicRMWSetValue", "_BinaryenAtomicCmpxchg", "_BinaryenAtomicCmpxchgGetBytes", "_BinaryenAtomicCmpxchgSetBytes", "_BinaryenAtomicCmpxchgGetOffset", "_BinaryenAtomicCmpxchgSetOffset", "_BinaryenAtomicCmpxchgGetPtr", "_BinaryenAtomicCmpxchgSetPtr", "_BinaryenAtomicCmpxchgGetExpected", "_BinaryenAtomicCmpxchgSetExpected", "_BinaryenAtomicCmpxchgGetReplacement", "_BinaryenAtomicCmpxchgSetReplacement", "_BinaryenAtomicWait", "_BinaryenAtomicWaitGetPtr", "_BinaryenAtomicWaitSetPtr", "_BinaryenAtomicWaitGetExpected", "_BinaryenAtomicWaitSetExpected", "_BinaryenAtomicWaitGetTimeout", "_BinaryenAtomicWaitSetTimeout", "_BinaryenAtomicWaitGetExpectedType", "_BinaryenAtomicWaitSetExpectedType", "_BinaryenAtomicNotify", "_BinaryenAtomicNotifyGetPtr", "_BinaryenAtomicNotifySetPtr", "_BinaryenAtomicNotifyGetNotifyCount", "_BinaryenAtomicNotifySetNotifyCount", "_BinaryenAtomicFence", "_BinaryenAtomicFenceGetOrder", "_BinaryenAtomicFenceSetOrder", "_BinaryenSIMDExtract", "_BinaryenSIMDExtractGetOp", "_BinaryenSIMDExtractSetOp", "_BinaryenSIMDExtractGetVec", "_BinaryenSIMDExtractSetVec", "_BinaryenSIMDExtractGetIndex", "_BinaryenSIMDExtractSetIndex", "_BinaryenSIMDReplace", "_BinaryenSIMDReplaceGetOp", "_BinaryenSIMDReplaceSetOp", "_BinaryenSIMDReplaceGetVec", "_BinaryenSIMDReplaceSetVec", "_BinaryenSIMDReplaceGetIndex", "_BinaryenSIMDReplaceSetIndex", "_BinaryenSIMDReplaceGetValue", "_BinaryenSIMDReplaceSetValue", "_BinaryenSIMDShuffle", "_BinaryenSIMDShuffleGetLeft", "_BinaryenSIMDShuffleSetLeft", "_BinaryenSIMDShuffleGetRight", "_BinaryenSIMDShuffleSetRight", "_BinaryenSIMDShuffleGetMask", "_BinaryenSIMDShuffleSetMask", "_BinaryenSIMDTernary", "_BinaryenSIMDTernaryGetOp", "_BinaryenSIMDTernarySetOp", "_BinaryenSIMDTernaryGetA", "_BinaryenSIMDTernarySetA", "_BinaryenSIMDTernaryGetB", "_BinaryenSIMDTernarySetB", "_BinaryenSIMDTernaryGetC", "_BinaryenSIMDTernarySetC", "_BinaryenSIMDShift", "_BinaryenSIMDShiftGetOp", "_BinaryenSIMDShiftSetOp", "_BinaryenSIMDShiftGetVec", "_BinaryenSIMDShiftSetVec", "_BinaryenSIMDShiftGetShift", "_BinaryenSIMDShiftSetShift", "_BinaryenSIMDLoad", "_BinaryenSIMDLoadGetOp", "_BinaryenSIMDLoadSetOp", "_BinaryenSIMDLoadGetOffset", "_BinaryenSIMDLoadSetOffset", "_BinaryenSIMDLoadGetAlign", "_BinaryenSIMDLoadSetAlign", "_BinaryenSIMDLoadGetPtr", "_BinaryenSIMDLoadSetPtr", "_BinaryenSIMDLoadStoreLane", "_BinaryenSIMDLoadStoreLaneGetOp", "_BinaryenSIMDLoadStoreLaneSetOp", "_BinaryenSIMDLoadStoreLaneGetOffset", "_BinaryenSIMDLoadStoreLaneSetOffset", "_BinaryenSIMDLoadStoreLaneGetAlign", "_BinaryenSIMDLoadStoreLaneSetAlign", "_BinaryenSIMDLoadStoreLaneGetIndex", "_BinaryenSIMDLoadStoreLaneSetIndex", "_BinaryenSIMDLoadStoreLaneGetPtr", "_BinaryenSIMDLoadStoreLaneSetPtr", "_BinaryenSIMDLoadStoreLaneGetVec", "_BinaryenSIMDLoadStoreLaneSetVec", "_BinaryenSIMDLoadStoreLaneIsStore", "_BinaryenMemoryInit", "_BinaryenMemoryInitGetSegment", "_BinaryenMemoryInitSetSegment", "_BinaryenMemoryInitGetDest", "_BinaryenMemoryInitSetDest", "_BinaryenMemoryInitGetOffset", "_BinaryenMemoryInitSetOffset", "_BinaryenMemoryInitGetSize", "_BinaryenMemoryInitSetSize", "_BinaryenDataDrop", "_BinaryenDataDropGetSegment", "_BinaryenDataDropSetSegment", "_BinaryenMemoryCopy", "_BinaryenMemoryCopyGetDest", "_BinaryenMemoryCopySetDest", "_BinaryenMemoryCopyGetSource", "_BinaryenMemoryCopySetSource", "_BinaryenMemoryCopyGetSize", "_BinaryenMemoryCopySetSize", "_BinaryenMemoryFill", "_BinaryenMemoryFillGetDest", "_BinaryenMemoryFillSetDest", "_BinaryenMemoryFillGetValue", "_BinaryenMemoryFillSetValue", "_BinaryenMemoryFillGetSize", "_BinaryenMemoryFillSetSize", "_BinaryenRefNull", "_BinaryenRefIsNull", "_BinaryenRefIsNullGetValue", "_BinaryenRefIsNullSetValue", "_BinaryenRefAs", "_BinaryenRefAsGetOp", "_BinaryenRefAsSetOp", "_BinaryenRefAsGetValue", "_BinaryenRefAsSetValue", "_BinaryenRefFunc", "_BinaryenRefFuncGetFunc", "_BinaryenRefFuncSetFunc", "_BinaryenRefEq", "_BinaryenRefEqGetLeft", "_BinaryenRefEqSetLeft", "_BinaryenRefEqGetRight", "_BinaryenRefEqSetRight", "_BinaryenTableGet", "_BinaryenTableGetGetTable", "_BinaryenTableGetSetTable", "_BinaryenTableGetGetIndex", "_BinaryenTableGetSetIndex", "_BinaryenTableSet", "_BinaryenTableSetGetTable", "_BinaryenTableSetSetTable", "_BinaryenTableSetGetIndex", "_BinaryenTableSetSetIndex", "_BinaryenTableSetGetValue", "_BinaryenTableSetSetValue", "_BinaryenTableSize", "_BinaryenTableSizeGetTable", "_BinaryenTableSizeSetTable", "_BinaryenTableGrow", "_BinaryenTableGrowGetTable", "_BinaryenTableGrowSetTable", "_BinaryenTableGrowGetValue", "_BinaryenTableGrowSetValue", "_BinaryenTableGrowGetDelta", "_BinaryenTableGrowSetDelta", "_BinaryenTry", "_BinaryenTryGetName", "_BinaryenTrySetName", "_BinaryenTryGetBody", "_BinaryenTrySetBody", "_BinaryenTryGetNumCatchTags", "_BinaryenTryGetNumCatchBodies", "_BinaryenTryGetCatchTagAt", "_BinaryenTrySetCatchTagAt", "_BinaryenTryAppendCatchTag", "_BinaryenTryInsertCatchTagAt", "_BinaryenTryRemoveCatchTagAt", "_BinaryenTryGetCatchBodyAt", "_BinaryenTrySetCatchBodyAt", "_BinaryenTryAppendCatchBody", "_BinaryenTryInsertCatchBodyAt", "_BinaryenTryRemoveCatchBodyAt", "_BinaryenTryHasCatchAll", "_BinaryenTryGetDelegateTarget", "_BinaryenTrySetDelegateTarget", "_BinaryenTryIsDelegate", "_BinaryenThrow", "_BinaryenThrowGetTag", "_BinaryenThrowSetTag", "_BinaryenThrowGetNumOperands", "_BinaryenThrowGetOperandAt", "_BinaryenThrowSetOperandAt", "_BinaryenThrowAppendOperand", "_BinaryenThrowInsertOperandAt", "_BinaryenThrowRemoveOperandAt", "_BinaryenRethrow", "_BinaryenRethrowGetTarget", "_BinaryenRethrowSetDepth", "_BinaryenTupleMake", "_BinaryenTupleMakeGetNumOperands", "_BinaryenTupleMakeGetOperandAt", "_BinaryenTupleMakeSetOperandAt", "_BinaryenTupleMakeAppendOperand", "_BinaryenTupleMakeInsertOperandAt", "_BinaryenTupleMakeRemoveOperandAt", "_BinaryenTupleExtract", "_BinaryenTupleExtractGetTuple", "_BinaryenTupleExtractSetTuple", "_BinaryenTupleExtractGetIndex", "_BinaryenTupleExtractSetIndex", "_BinaryenPop", "_BinaryenRefI31", "_BinaryenRefI31GetValue", "_BinaryenRefI31SetValue", "_BinaryenI31Get", "_BinaryenI31GetGetI31", "_BinaryenI31GetSetI31", "_BinaryenI31GetIsSigned", "_BinaryenI31GetSetSigned", "_BinaryenCallRef", "_BinaryenCallRefGetNumOperands", "_BinaryenCallRefGetOperandAt", "_BinaryenCallRefSetOperandAt", "_BinaryenCallRefAppendOperand", "_BinaryenCallRefInsertOperandAt", "_BinaryenCallRefRemoveOperandAt", "_BinaryenCallRefGetTarget", "_BinaryenCallRefSetTarget", "_BinaryenCallRefIsReturn", "_BinaryenCallRefSetReturn", "_BinaryenRefTest", "_BinaryenRefTestGetRef", "_BinaryenRefTestSetRef", "_BinaryenRefTestGetCastType", "_BinaryenRefTestSetCastType", "_BinaryenRefCast", "_BinaryenRefCastGetRef", "_BinaryenRefCastSetRef", "_BinaryenBrOn", "_BinaryenBrOnGetOp", "_BinaryenBrOnSetOp", "_BinaryenBrOnGetName", "_BinaryenBrOnSetName", "_BinaryenBrOnGetRef", "_BinaryenBrOnSetRef", "_BinaryenBrOnGetCastType", "_BinaryenBrOnSetCastType", "_BinaryenStructNew", "_BinaryenStructNewGetNumOperands", "_BinaryenStructNewGetOperandAt", "_BinaryenStructNewSetOperandAt", "_BinaryenStructNewAppendOperand", "_BinaryenStructNewInsertOperandAt", "_BinaryenStructNewRemoveOperandAt", "_BinaryenStructGet", "_BinaryenStructGetGetIndex", "_BinaryenStructGetSetIndex", "_BinaryenStructGetGetRef", "_BinaryenStructGetSetRef", "_BinaryenStructGetIsSigned", "_BinaryenStructGetSetSigned", "_BinaryenStructSet", "_BinaryenStructSetGetIndex", "_BinaryenStructSetSetIndex", "_BinaryenStructSetGetRef", "_BinaryenStructSetSetRef", "_BinaryenStructSetGetValue", "_BinaryenStructSetSetValue", "_BinaryenArrayNew", "_BinaryenArrayNewGetInit", "_BinaryenArrayNewSetInit", "_BinaryenArrayNewGetSize", "_BinaryenArrayNewSetSize", "_BinaryenArrayNewFixed", "_BinaryenArrayNewFixedGetNumValues", "_BinaryenArrayNewFixedGetValueAt", "_BinaryenArrayNewFixedSetValueAt", "_BinaryenArrayNewFixedAppendValue", "_BinaryenArrayNewFixedInsertValueAt", "_BinaryenArrayNewFixedRemoveValueAt", "_BinaryenArrayNewData", "_BinaryenArrayNewDataGetSegment", "_BinaryenArrayNewDataSetSegment", "_BinaryenArrayNewDataGetOffset", "_BinaryenArrayNewDataSetOffset", "_BinaryenArrayNewDataGetSize", "_BinaryenArrayNewDataSetSize", "_BinaryenArrayNewElem", "_BinaryenArrayNewElemGetSegment", "_BinaryenArrayNewElemSetSegment", "_BinaryenArrayNewElemGetOffset", "_BinaryenArrayNewElemSetOffset", "_BinaryenArrayNewElemGetSize", "_BinaryenArrayNewElemSetSize", "_BinaryenArrayGet", "_BinaryenArrayGetGetRef", "_BinaryenArrayGetSetRef", "_BinaryenArrayGetGetIndex", "_BinaryenArrayGetSetIndex", "_BinaryenArrayGetIsSigned", "_BinaryenArrayGetSetSigned", "_BinaryenArraySet", "_BinaryenArraySetGetRef", "_BinaryenArraySetSetRef", "_BinaryenArraySetGetIndex", "_BinaryenArraySetSetIndex", "_BinaryenArraySetGetValue", "_BinaryenArraySetSetValue", "_BinaryenArrayLen", "_BinaryenArrayLenGetRef", "_BinaryenArrayLenSetRef", "_BinaryenArrayFill", "_BinaryenArrayFillGetRef", "_BinaryenArrayFillSetRef", "_BinaryenArrayFillGetIndex", "_BinaryenArrayFillSetIndex", "_BinaryenArrayFillGetValue", "_BinaryenArrayFillSetValue", "_BinaryenArrayFillGetSize", "_BinaryenArrayFillSetSize", "_BinaryenArrayCopy", "_BinaryenArrayCopyGetDestRef", "_BinaryenArrayCopySetDestRef", "_BinaryenArrayCopyGetDestIndex", "_BinaryenArrayCopySetDestIndex", "_BinaryenArrayCopyGetSrcRef", "_BinaryenArrayCopySetSrcRef", "_BinaryenArrayCopyGetSrcIndex", "_BinaryenArrayCopySetSrcIndex", "_BinaryenArrayCopyGetLength", "_BinaryenArrayCopySetLength", "_BinaryenArrayInitData", "_BinaryenArrayInitDataGetSegment", "_BinaryenArrayInitDataSetSegment", "_BinaryenArrayInitDataGetRef", "_BinaryenArrayInitDataSetRef", "_BinaryenArrayInitDataGetIndex", "_BinaryenArrayInitDataSetIndex", "_BinaryenArrayInitDataGetOffset", "_BinaryenArrayInitDataSetOffset", "_BinaryenArrayInitDataGetSize", "_BinaryenArrayInitDataSetSize", "_BinaryenArrayInitElem", "_BinaryenArrayInitElemGetSegment", "_BinaryenArrayInitElemSetSegment", "_BinaryenArrayInitElemGetRef", "_BinaryenArrayInitElemSetRef", "_BinaryenArrayInitElemGetIndex", "_BinaryenArrayInitElemSetIndex", "_BinaryenArrayInitElemGetOffset", "_BinaryenArrayInitElemSetOffset", "_BinaryenArrayInitElemGetSize", "_BinaryenArrayInitElemSetSize", "_BinaryenStringNew", "_BinaryenStringNewGetOp", "_BinaryenStringNewSetOp", "_BinaryenStringNewGetRef", "_BinaryenStringNewSetRef", "_BinaryenStringNewGetStart", "_BinaryenStringNewSetStart", "_BinaryenStringNewGetEnd", "_BinaryenStringNewSetEnd", "_BinaryenStringConst", "_BinaryenStringConstGetString", "_BinaryenStringConstSetString", "_BinaryenStringMeasure", "_BinaryenStringMeasureGetOp", "_BinaryenStringMeasureSetOp", "_BinaryenStringMeasureGetRef", "_BinaryenStringMeasureSetRef", "_BinaryenStringEncode", "_BinaryenStringEncodeGetOp", "_BinaryenStringEncodeSetOp", "_BinaryenStringEncodeGetStr", "_BinaryenStringEncodeSetStr", "_BinaryenStringEncodeGetArray", "_BinaryenStringEncodeSetArray", "_BinaryenStringEncodeGetStart", "_BinaryenStringEncodeSetStart", "_BinaryenStringConcat", "_BinaryenStringConcatGetLeft", "_BinaryenStringConcatSetLeft", "_BinaryenStringConcatGetRight", "_BinaryenStringConcatSetRight", "_BinaryenStringEq", "_BinaryenStringEqGetOp", "_BinaryenStringEqSetOp", "_BinaryenStringEqGetLeft", "_BinaryenStringEqSetLeft", "_BinaryenStringEqGetRight", "_BinaryenStringEqSetRight", "_BinaryenStringWTF16Get", "_BinaryenStringWTF16GetGetRef", "_BinaryenStringWTF16GetSetRef", "_BinaryenStringWTF16GetGetPos", "_BinaryenStringWTF16GetSetPos", "_BinaryenStringSliceWTF", "_BinaryenStringSliceWTFGetRef", "_BinaryenStringSliceWTFSetRef", "_BinaryenStringSliceWTFGetStart", "_BinaryenStringSliceWTFSetStart", "_BinaryenStringSliceWTFGetEnd", "_BinaryenStringSliceWTFSetEnd", "_BinaryenAddFunction", "_BinaryenGetFunction", "_BinaryenRemoveFunction", "_BinaryenGetNumFunctions", "_BinaryenGetFunctionByIndex", "_BinaryenFunctionGetName", "_BinaryenFunctionGetParams", "_BinaryenFunctionGetResults", "_BinaryenFunctionGetNumVars", "_BinaryenFunctionGetVar", "_BinaryenFunctionAddVar", "_BinaryenFunctionGetNumLocals", "_BinaryenFunctionHasLocalName", "_BinaryenFunctionGetLocalName", "_BinaryenFunctionSetLocalName", "_BinaryenFunctionGetBody", "_BinaryenFunctionSetBody", "_BinaryenFunctionGetType", "_BinaryenFunctionSetType", "_BinaryenFunctionOptimize", "_BinaryenFunctionRunPasses", "_BinaryenFunctionSetDebugLocation", "_BinaryenAddFunctionImport", "_BinaryenAddTableImport", "_BinaryenAddMemoryImport", "_BinaryenAddGlobalImport", "_BinaryenAddTagImport", "_BinaryenAddFunctionExport", "_BinaryenAddTableExport", "_BinaryenAddMemoryExport", "_BinaryenAddGlobalExport", "_BinaryenAddTagExport", "_BinaryenGetExport", "_BinaryenRemoveExport", "_BinaryenGetNumExports", "_BinaryenGetExportByIndex", "_BinaryenExportGetKind", "_BinaryenExportGetName", "_BinaryenExportGetValue", "_BinaryenAddGlobal", "_BinaryenGetGlobal", "_BinaryenRemoveGlobal", "_BinaryenGetNumGlobals", "_BinaryenGetGlobalByIndex", "_BinaryenGlobalGetName", "_BinaryenGlobalGetType", "_BinaryenGlobalIsMutable", "_BinaryenGlobalGetInitExpr", "_BinaryenAddTag", "_BinaryenGetTag", "_BinaryenRemoveTag", "_BinaryenTagGetName", "_BinaryenTagGetParams", "_BinaryenTagGetResults", "_BinaryenAddTable", "_BinaryenRemoveTable", "_BinaryenGetNumTables", "_BinaryenGetTable", "_BinaryenGetTableByIndex", "_BinaryenTableGetName", "_BinaryenTableSetName", "_BinaryenTableGetInitial", "_BinaryenTableSetInitial", "_BinaryenTableHasMax", "_BinaryenTableGetMax", "_BinaryenTableSetMax", "_BinaryenTableGetType", "_BinaryenTableSetType", "_BinaryenAddActiveElementSegment", "_BinaryenAddPassiveElementSegment", "_BinaryenRemoveElementSegment", "_BinaryenGetNumElementSegments", "_BinaryenGetElementSegment", "_BinaryenGetElementSegmentByIndex", "_BinaryenSetMemory", "_BinaryenGetNumMemorySegments", "_BinaryenGetMemorySegmentByteOffset", "_BinaryenGetMemorySegmentByteLength", "_BinaryenCopyMemorySegmentData", "_BinaryenAddDataSegment", "_BinaryenSetStart", "_BinaryenGetStart", "_BinaryenModuleParse", "_BinaryenModulePrint", "_BinaryenModulePrintAsmjs", "_BinaryenModuleValidate", "_BinaryenModuleOptimize", "_BinaryenModuleRunPasses", "_BinaryenSizeofAllocateAndWriteResult", "_BinaryenModuleAllocateAndWrite", "_BinaryenModuleAllocateAndWriteText", "_BinaryenModuleAllocateAndWriteStackIR", "_BinaryenModuleRead", "_BinaryenModuleReadWithFeatures", "_BinaryenModuleInterpret", "_BinaryenModuleAddDebugInfoFileName", "_BinaryenModuleGetDebugInfoFileName", "_BinaryenModuleGetFeatures", "_BinaryenModuleSetFeatures", "_BinaryenAddCustomSection", "_BinaryenExpressionGetSideEffects", "_RelooperCreate", "_RelooperAddBlock", "_RelooperAddBranch", "_RelooperAddBlockWithSwitch", "_RelooperAddBranchForSwitch", "_RelooperRenderAndDispose", "_ExpressionRunnerCreate", "_ExpressionRunnerSetLocalValue", "_ExpressionRunnerSetGlobalValue", "_ExpressionRunnerRunAndDispose", "_TypeBuilderCreate", "_TypeBuilderGrow", "_TypeBuilderGetSize", "_TypeBuilderSetSignatureType", "_TypeBuilderSetStructType", "_TypeBuilderSetArrayType", "_TypeBuilderGetTempHeapType", "_TypeBuilderGetTempTupleType", "_TypeBuilderGetTempRefType", "_TypeBuilderSetSubType", "_TypeBuilderSetOpen", "_TypeBuilderCreateRecGroup", "_TypeBuilderBuildAndDispose", "_BinaryenModuleSetTypeName", "_BinaryenModuleSetFieldName", "_BinaryenGetOptimizeLevel", "_BinaryenSetOptimizeLevel", "_BinaryenGetShrinkLevel", "_BinaryenSetShrinkLevel", "_BinaryenGetDebugInfo", "_BinaryenSetDebugInfo", "_BinaryenGetTrapsNeverHappen", "_BinaryenSetTrapsNeverHappen", "_BinaryenGetClosedWorld", "_BinaryenSetClosedWorld", "_BinaryenGetLowMemoryUnused", "_BinaryenSetLowMemoryUnused", "_BinaryenGetZeroFilledMemory", "_BinaryenSetZeroFilledMemory", "_BinaryenGetFastMath", "_BinaryenSetFastMath", "_BinaryenGetGenerateStackIR", "_BinaryenSetGenerateStackIR", "_BinaryenGetOptimizeStackIR", "_BinaryenSetOptimizeStackIR", "_BinaryenGetPassArgument", "_BinaryenSetPassArgument", "_BinaryenClearPassArguments", "_BinaryenHasPassToSkip", "_BinaryenAddPassToSkip", "_BinaryenClearPassesToSkip", "_BinaryenGetAlwaysInlineMaxSize", "_BinaryenSetAlwaysInlineMaxSize", "_BinaryenGetFlexibleInlineMaxSize", "_BinaryenSetFlexibleInlineMaxSize", "_BinaryenGetOneCallerInlineMaxSize", "_BinaryenSetOneCallerInlineMaxSize", "_BinaryenGetAllowInliningFunctionsWithLoops", "_BinaryenSetAllowInliningFunctionsWithLoops", "_malloc", "_free", "__i32_store8", "__i32_store16", "__i32_store", "__f32_store", "__f64_store", "__i32_load8_s", "__i32_load8_u", "__i32_load16_s", "__i32_load16_u", "__i32_load", "__f32_load", "__f64_load", "default", "MathWasmBase64", "f64_pow", "MathWasmBase64", "F64", "F32", "I32", "value", "f64_pow", "Long", "value", "lo", "hi", "left", "right", "rightLo", "rightHi", "result", "alignment", "mask", "minSafeF32", "maxSafeF32", "minSafeF64", "maxSafeF64", "unsigned", "map", "set", "Feature", "featureToString", "feature", "Target", "Runtime", "Typeinfo", "__decorateClass", "TypeinfoFlags", "CommonFlags", "PATH_DELIMITER", "PARENT_SUBST", "GETTER_PREFIX", "SETTER_PREFIX", "INSTANCE_DELIMITER", "STATIC_DELIMITER", "INNER_DELIMITER", "LIBRARY_SUBST", "LIBRARY_PREFIX", "INDEX_SUFFIX", "STUB_DELIMITER", "CommonNames", "DiagnosticCode", "diagnosticCodeToString", "code", "util_exports", "__export", "BitSet", "COLOR_BLUE", "COLOR_CYAN", "COLOR_GRAY", "COLOR_GREEN", "COLOR_MAGENTA", "COLOR_RED", "COLOR_RESET", "COLOR_WHITE", "COLOR_YELLOW", "CharCode", "SURROGATE_HIGH", "SURROGATE_LOW", "accuratePow64", "cloneMap", "colorize", "combineSurrogates", "dirname", "escapeString", "indent", "isAlpha", "isAlphaOrDecimal", "isColorsEnabled", "isDecimal", "isHexBase", "isHexOrDecimal", "isHighSurrogate", "isIdentifier", "isIdentifierPart", "isIdentifierStart", "isLineBreak", "isLowSurrogate", "isOctal", "isPowerOf2", "isSurrogate", "isSurrogateHigh", "isSurrogateLow", "isWhiteSpace", "mergeMaps", "normalizePath", "numCodeUnits", "readF32", "readF64", "readI16", "readI32", "readI64", "readI8", "readV128", "resolvePath", "setColorsEnabled", "v128_ones", "v128_zero", "writeF32", "writeF64", "writeI16", "writeI32", "writeI32AsI64", "writeI64", "writeI64AsI32", "writeI8", "writeV128", "readI8", "buffer", "offset", "writeI8", "value", "readI16", "writeI16", "readI32", "writeI32", "writeI32AsI64", "unsigned", "readI64", "lo", "hi", "writeI64", "writeI64AsI32", "readF32", "writeF32", "readF64", "writeF64", "valueI64", "readV128", "writeV128", "cloneMap", "map", "out", "_keys", "i", "k", "v", "mergeMaps", "map1", "map2", "BitSet", "count", "words", "len", "word", "index", "idx", "res", "p", "mask", "isPowerOf2", "x", "accuratePow64", "y", "CharCode", "isLineBreak", "c", "isWhiteSpace", "SURROGATE_HIGH", "SURROGATE_LOW", "isSurrogate", "isSurrogateHigh", "isSurrogateLow", "isHighSurrogate", "isLowSurrogate", "combineSurrogates", "hi", "lo", "numCodeUnits", "cp", "isAlpha", "c0", "isDecimal", "isOctal", "isHexBase", "isHexOrDecimal", "isAlphaOrDecimal", "isIdentifierStart", "unicodeIdentifierStartMin", "unicodeIdentifierStartMax", "lookupInUnicodeMap", "unicodeIdentifierStart", "isIdentifierPart", "unicodeIdentifierPartMin", "unicodeIdentifierPartMax", "unicodeIdentifierPart", "isIdentifier", "str", "len", "i", "code", "map", "mid", "midVal", "indentX1", "indentX2", "indentX3", "indentX4", "indentCache", "indent", "sb", "level", "indents", "escapeString", "quote", "off", "k", "separator", "normalizePath", "path", "pos", "len", "atEnd", "ipos", "resolvePath", "normalizedPath", "origin", "dirname", "PATH_DELIMITER", "COLOR_GRAY", "COLOR_RED", "COLOR_GREEN", "COLOR_YELLOW", "COLOR_BLUE", "COLOR_MAGENTA", "COLOR_CYAN", "COLOR_WHITE", "COLOR_RESET", "colorsEnabled", "isColorsEnabled", "setColorsEnabled", "isEnabled", "wasEnabled", "colorize", "text", "color", "v128_zero", "v128_ones", "DiagnosticCategory", "Range", "_Range", "start", "end", "a", "b", "range", "other", "diagnosticCategoryToString", "category", "diagnosticCategoryToColor", "COLOR_MAGENTA", "COLOR_CYAN", "COLOR_YELLOW", "COLOR_RED", "DiagnosticMessage", "_DiagnosticMessage", "code", "message", "arg0", "arg1", "arg2", "diagnosticCodeToString", "thisRange", "otherRange", "thisRelatedRange", "otherRelatedRange", "source", "path", "line", "column", "len", "formatDiagnosticMessage", "useColors", "showContext", "wasColorsEnabled", "setColorsEnabled", "sb", "isColorsEnabled", "COLOR_RESET", "relatedRange", "minLine", "formatDiagnosticContext", "relatedSource", "text", "lineNumber", "lineNumberLength", "lineSpace", "isLineBreak", "isWhiteSpace", "cc", "DiagnosticEmitter", "diagnostics", "seen", "seenInSource", "seenMessagesAtPos", "i", "k", "NodeKind", "Node", "_Node", "kind", "range", "name", "TypeName", "typeArguments", "isNullable", "NamedTypeNode", "parameters", "returnType", "explicitThisType", "FunctionTypeNode", "extendsType", "defaultType", "TypeParameterNode", "parameterKind", "type", "initializer", "ParameterNode", "args", "DecoratorNode", "DecoratorKind", "commentKind", "text", "CommentNode", "isQuoted", "IdentifierExpression", "elementExpressions", "ArrayLiteralExpression", "assertionKind", "expression", "toType", "AssertionExpression", "operator", "left", "right", "BinaryExpression", "CallExpression", "declaration", "ClassExpression", "expressions", "CommaExpression", "ConstructorExpression", "elementExpression", "ElementAccessExpression", "FalseExpression", "value", "FloatLiteralExpression", "FunctionExpression", "isType", "InstanceOfExpression", "IntegerLiteralExpression", "typeName", "NewExpression", "NullExpression", "names", "values", "ObjectLiteralExpression", "OmittedExpression", "ParenthesizedExpression", "property", "PropertyAccessExpression", "pattern", "patternFlags", "RegexpLiteralExpression", "condition", "ifThen", "ifElse", "TernaryExpression", "StringLiteralExpression", "SuperExpression", "tag", "parts", "rawParts", "TemplateLiteralExpression", "ThisExpression", "TrueExpression", "operand", "UnaryPostfixExpression", "UnaryPrefixExpression", "expr", "CompiledExpression", "statements", "BlockStatement", "label", "BreakStatement", "decorators", "flags", "typeParameters", "implementsTypes", "members", "ClassDeclaration", "ContinueStatement", "body", "DoStatement", "EmptyStatement", "EnumDeclaration", "EnumValueDeclaration", "path", "isDeclare", "ExportStatement", "ExportDefaultStatement", "externalName", "ExportImportStatement", "localName", "exportedName", "ExportMember", "ExpressionStatement", "ifTrue", "ifFalse", "IfStatement", "declarations", "ImportStatement", "namespaceName", "foreignName", "ImportDeclaration", "InterfaceDeclaration", "FieldDeclaration", "incrementor", "ForStatement", "variable", "iterable", "ForOfStatement", "signature", "arrowKind", "FunctionDeclaration", "keyType", "valueType", "IndexSignatureNode", "MethodDeclaration", "NamespaceDeclaration", "ReturnStatement", "cases", "SwitchStatement", "SwitchCase", "ThrowStatement", "bodyStatements", "catchVariable", "catchStatements", "finallyStatements", "TryStatement", "TypeDeclaration", "ModuleDeclaration", "VariableStatement", "VariableDeclaration", "VoidStatement", "statement", "WhileStatement", "literalKind", "node", "TypeNode", "typeParameterNodes", "namedTypeNode", "typeArgumentNodes", "i", "k", "functionTypeNode", "parameterNodes", "identifier", "next", "ParameterKind", "flag", "fromNode", "nameNode", "nameStr", "propertyAccessNode", "propStr", "decoratorKind", "CommentKind", "Expression", "LiteralKind", "LiteralExpression", "AssertionKind", "numTypeArguments", "Range", "numArguments", "UnaryExpression", "Statement", "SourceKind", "Source", "_Source", "sourceKind", "normalizedPath", "internalPath", "mangleInternalPath", "pos", "PATH_DELIMITER", "source", "LIBRARY_PREFIX", "LIBRARY_SUBST", "lineCache", "off", "end", "l", "r", "m", "s", "DeclarationStatement", "VariableLikeDeclarationStatement", "normalizePath", "resolvePath", "parameterIndex", "ArrowKind", "_FunctionDeclaration", "moduleName", "findDecorator", "decorator", "isTypeOmitted", "Token", "IdentifierHandling", "tokenFromKeyword", "text", "len", "tokenIsAlsoIdentifier", "token", "isIllegalVariableIdentifier", "name", "operatorTokenToString", "Tokenizer", "DiagnosticEmitter", "source", "diagnostics", "text", "end", "pos", "identifierHandling", "token", "maxTokenLength", "c", "chr", "isDecimal", "commentStartPos", "commentKind", "closed", "isHighSurrogate", "combineSurrogates", "isIdentifierStart", "posBefore", "numCodeUnits", "isIdentifierPart", "maybeKeywordToken", "tokenFromKeyword", "tokenIsAlsoIdentifier", "isWhiteSpace", "start", "maxCompoundLength", "nextToken", "tokenBefore", "tokenPosBefore", "isLineBreak", "state", "reusableState", "State", "range", "Range", "quote", "isTaggedTemplate", "result", "escaped", "flags", "isOctal", "value", "sepEnd", "i64_4", "nextValue", "overflowOccurred", "isHexBase", "i64_10", "i64_3", "sepCount", "allowLeadingZeroSep", "remain", "startIfTaggedTemplate", "value32", "invalid", "tokenPos", "TypeRef", "_BinaryenTypeFuncref", "_BinaryenTypeExternref", "_BinaryenTypeAnyref", "_BinaryenTypeEqref", "_BinaryenTypeStructref", "_BinaryenTypeArrayref", "_BinaryenTypeI31ref", "_BinaryenTypeStringref", "_BinaryenTypeNullref", "_BinaryenTypeNullFuncref", "_BinaryenTypeNullExternref", "HeapTypeRef", "isBottom", "ht", "_BinaryenHeapTypeIsBottom", "getBottom", "_BinaryenHeapTypeGetBottom", "isSubtype", "superHt", "_BinaryenHeapTypeIsSubType", "leastUpperBound", "a", "b", "t", "PackedType", "TypeBuilderErrorReason", "toString", "reason", "FeatureFlags", "ExpressionId", "ExternalKind", "UnaryOp", "BinaryOp", "AtomicRMWOp", "SIMDExtractOp", "SIMDReplaceOp", "SIMDShiftOp", "SIMDLoadOp", "SIMDLoadStoreLaneOp", "SIMDTernaryOp", "RefAsOp", "BrOnOp", "StringNewOp", "StringMeasureOp", "StringEncodeOp", "StringEqOp", "ExpressionRunnerFlags", "MemorySegment", "buffer", "offset", "Module", "_Module", "ref", "useShadowStack", "sizeType", "_malloc", "_BinaryenSizeofLiteral", "_BinaryenModuleCreate", "cArr", "allocU8Array", "module", "_BinaryenModuleRead", "_free", "value", "out", "_BinaryenLiteralInt32", "_BinaryenConst", "valueLow", "valueHigh", "_BinaryenLiteralInt64", "_BinaryenLiteralFloat32", "_BinaryenLiteralFloat64", "bytes", "i", "__i32_store8", "_BinaryenLiteralVec128", "type", "_BinaryenRefNull", "left", "right", "_BinaryenRefEq", "_BinaryenStringEq", "op", "isWam64", "_BinaryenUnary", "isWasm64", "_BinaryenBinary", "name", "CommonNames", "is64", "cStr", "_BinaryenMemorySize", "delta", "_BinaryenMemoryGrow", "_BinaryenTableSize", "_BinaryenTableGrow", "index", "_BinaryenLocalGet", "_BinaryenExpressionGetType", "BuiltinNames", "isManaged", "_BinaryenLocalTee", "_BinaryenGlobalGet", "_BinaryenTableGet", "signed", "ptr", "align", "_BinaryenLoad", "_BinaryenStore", "_BinaryenAtomicLoad", "_BinaryenAtomicStore", "_BinaryenAtomicRMW", "expected", "replacement", "_BinaryenAtomicCmpxchg", "timeout", "expectedType", "_BinaryenAtomicWait", "notifyCount", "_BinaryenAtomicNotify", "_BinaryenAtomicFence", "_BinaryenLocalSet", "_BinaryenGlobalSet", "_BinaryenTableSet", "label", "children", "allocPtrArray", "ret", "_BinaryenBlock", "stmts", "length", "single", "getExpressionId", "singleType", "getExpressionType", "condition", "_BinaryenBreak", "expression", "_BinaryenDrop", "result", "getSideEffects", "body", "_BinaryenLoop", "ifTrue", "ifFalse", "_BinaryenIf", "_BinaryenNop", "_BinaryenReturn", "_BinaryenSelect", "names", "defaultName", "numNames", "strs", "_BinaryenSwitch", "target", "operands", "returnType", "isReturn", "_BinaryenReturnCall", "_BinaryenCall", "tableName", "params", "results", "_BinaryenReturnCallIndirect", "_BinaryenCallIndirect", "_BinaryenUnreachable", "dest", "source", "size", "destName", "sourceName", "cStr1", "cStr2", "_BinaryenMemoryCopy", "_BinaryenMemoryFill", "catchTags", "catchBodies", "delegateTarget", "numCatchTags", "cArr1", "cArr2", "_BinaryenTry", "tagName", "_BinaryenThrow", "_BinaryenRethrow", "_BinaryenPop", "_BinaryenTupleMake", "tuple", "_BinaryenTupleExtract", "vec", "idx", "_BinaryenSIMDExtract", "_BinaryenSIMDReplace", "vec1", "vec2", "mask", "_BinaryenSIMDShuffle", "c", "_BinaryenSIMDTernary", "shift", "_BinaryenSIMDShift", "_BinaryenSIMDLoad", "_BinaryenSIMDLoadStoreLane", "expr", "_BinaryenRefIsNull", "_BinaryenRefAs", "isNullableType", "_BinaryenRefFunc", "_BinaryenTypeGetHeapType", "_BinaryenRefI31", "_BinaryenI31Get", "mutable", "initializer", "_BinaryenAddGlobal", "_BinaryenGetGlobal", "_BinaryenRemoveGlobal", "_BinaryenAddTag", "_BinaryenGetTag", "_BinaryenRemoveTag", "varTypes", "_BinaryenAddFunction", "funcRef", "_BinaryenFunctionSetLocalName", "_BinaryenGetFunction", "_BinaryenRemoveFunction", "paramTypes", "tempName", "createType", "func", "_BinaryenSetStart", "internalName", "externalName", "_BinaryenAddFunctionExport", "_BinaryenAddTableExport", "_BinaryenAddMemoryExport", "_BinaryenAddGlobalExport", "_BinaryenAddTagExport", "_BinaryenRemoveExport", "_BinaryenGetExport", "externalModuleName", "externalBaseName", "cStr3", "_BinaryenAddFunctionImport", "_BinaryenAddTableImport", "shared", "_BinaryenAddMemoryImport", "globalType", "_BinaryenAddGlobalImport", "_BinaryenAddTagImport", "initial", "maximum", "segments", "exportName", "cExportName", "cName", "k", "segs", "isPassive", "offsets", "sizes", "segment", "cSegs", "cIsPassive", "cOffsets", "cSizes", "allocU32Array", "_BinaryenSetMemory", "funcs", "tableRef", "_BinaryenGetTable", "_BinaryenTableSetInitial", "_BinaryenTableSetMax", "_BinaryenAddTable", "_BinaryenAddActiveElementSegment", "contents", "_BinaryenAddCustomSection", "_BinaryenGetOptimizeLevel", "level", "_BinaryenSetOptimizeLevel", "_BinaryenGetShrinkLevel", "_BinaryenSetShrinkLevel", "_BinaryenGetDebugInfo", "on", "_BinaryenSetDebugInfo", "_BinaryenGetClosedWorld", "_BinaryenSetClosedWorld", "_BinaryenGetLowMemoryUnused", "_BinaryenSetLowMemoryUnused", "_BinaryenGetZeroFilledMemory", "_BinaryenSetZeroFilledMemory", "_BinaryenGetFastMath", "_BinaryenSetFastMath", "_BinaryenGetGenerateStackIR", "_BinaryenSetGenerateStackIR", "_BinaryenGetOptimizeStackIR", "_BinaryenSetOptimizeStackIR", "key", "_BinaryenGetPassArgument", "readString", "_BinaryenSetPassArgument", "_BinaryenClearPassArguments", "_BinaryenGetAlwaysInlineMaxSize", "_BinaryenSetAlwaysInlineMaxSize", "_BinaryenGetFlexibleInlineMaxSize", "_BinaryenSetFlexibleInlineMaxSize", "_BinaryenGetOneCallerInlineMaxSize", "_BinaryenSetOneCallerInlineMaxSize", "_BinaryenGetAllowInliningFunctionsWithLoops", "enabled", "_BinaryenSetAllowInliningFunctionsWithLoops", "_BinaryenModuleGetFeatures", "featureFlags", "_BinaryenModuleSetFeatures", "passes", "cStrs", "allocString", "_BinaryenFunctionRunPasses", "_BinaryenModuleRunPasses", "optimizeLevel", "shrinkLevel", "debugInfo", "zeroFilledMemory", "stackIR", "_BinaryenModuleValidate", "_BinaryenModuleInterpret", "sourceMapUrl", "_BinaryenSizeofAllocateAndWriteResult", "resPtr", "urlPtr", "_BinaryenModuleAllocateAndWrite", "binaryPtr", "__i32_load", "binaryLen", "srcMapPtr", "binary", "BinaryModule", "readBuffer", "watFormat", "textPtr", "_BinaryenModuleAllocateAndWriteStackIR", "_BinaryenModuleAllocateAndWriteText", "text", "str", "cached", "_values", "_BinaryenModuleDispose", "Relooper", "_BinaryenExpressionGetId", "_BinaryenExpressionCopy", "flags", "maxDepth", "maxLoopIterations", "runner", "_ExpressionRunnerCreate", "precomp", "_ExpressionRunnerRunAndDispose", "getBinaryOp", "getBinaryLeft", "getBinaryRight", "_BinaryenModuleAddDebugInfoFileName", "_BinaryenModuleGetDebugInfoFileName", "fileIndex", "lineNumber", "columnNumber", "_BinaryenFunctionSetDebugLocation", "types", "_BinaryenTypeCreate", "expandType", "arity", "_BinaryenTypeArity", "_BinaryenTypeExpand", "_BinaryenTypeIsNullable", "getConstValueI32", "_BinaryenConstGetValueI32", "getConstValueI64Low", "_BinaryenConstGetValueI64Low", "getConstValueI64High", "_BinaryenConstGetValueI64High", "getConstValueInteger", "lo", "hi", "getConstValueF32", "_BinaryenConstGetValueF32", "getConstValueF64", "_BinaryenConstGetValueF64", "getConstValueV128", "_BinaryenConstGetValueV128", "__i32_load8_u", "isConstZero", "isConstNonZero", "isConstNegZero", "d", "isConstNaN", "isConstExpressionNaN", "id", "getLocalGetIndex", "_BinaryenLocalGetGetIndex", "getLocalSetIndex", "_BinaryenLocalSetGetIndex", "getLocalSetValue", "_BinaryenLocalSetGetValue", "isLocalTee", "_BinaryenLocalSetIsTee", "getGlobalGetName", "_BinaryenGlobalGetGetName", "_BinaryenBinaryGetOp", "_BinaryenBinaryGetLeft", "_BinaryenBinaryGetRight", "getUnaryOp", "_BinaryenUnaryGetOp", "getUnaryValue", "_BinaryenUnaryGetValue", "getLoadBytes", "_BinaryenLoadGetBytes", "getLoadOffset", "_BinaryenLoadGetOffset", "getLoadPtr", "_BinaryenLoadGetPtr", "isLoadSigned", "_BinaryenLoadIsSigned", "getStoreBytes", "_BinaryenStoreGetBytes", "getStoreOffset", "_BinaryenStoreGetOffset", "getStorePtr", "_BinaryenStoreGetPtr", "getStoreValue", "_BinaryenStoreGetValue", "getBlockName", "_BinaryenBlockGetName", "getBlockChildCount", "_BinaryenBlockGetNumChildren", "getBlockChildAt", "_BinaryenBlockGetChildAt", "getIfCondition", "_BinaryenIfGetCondition", "getIfTrue", "_BinaryenIfGetIfTrue", "getIfFalse", "_BinaryenIfGetIfFalse", "getLoopName", "_BinaryenLoopGetName", "getLoopBody", "_BinaryenLoopGetBody", "getBreakName", "_BinaryenBreakGetName", "getBreakCondition", "_BinaryenBreakGetCondition", "getSelectThen", "_BinaryenSelectGetIfTrue", "getSelectElse", "_BinaryenSelectGetIfFalse", "getSelectCondition", "_BinaryenSelectGetCondition", "getDropValue", "_BinaryenDropGetValue", "getReturnValue", "_BinaryenReturnGetValue", "getCallTarget", "_BinaryenCallGetTarget", "getCallOperandCount", "_BinaryenCallGetNumOperands", "getCallOperandAt", "_BinaryenCallGetOperandAt", "getMemoryGrowDelta", "_BinaryenMemoryGrowGetDelta", "getFunctionBody", "_BinaryenFunctionGetBody", "getFunctionName", "_BinaryenFunctionGetName", "getFunctionParams", "_BinaryenFunctionGetParams", "getFunctionResults", "_BinaryenFunctionGetResults", "getFunctionVars", "count", "_BinaryenFunctionGetNumVars", "_BinaryenFunctionGetVar", "getGlobalName", "global", "_BinaryenGlobalGetName", "getGlobalType", "_BinaryenGlobalGetType", "isGlobalMutable", "_BinaryenGlobalIsMutable", "getGlobalInit", "_BinaryenGlobalGetInitExpr", "getTagName", "tag", "_BinaryenTagGetName", "getTagParams", "_BinaryenTagGetParams", "getTagResults", "_BinaryenTagGetResults", "_Relooper", "_RelooperCreate", "code", "_RelooperAddBlock", "from", "to", "_RelooperAddBranch", "_RelooperAddBlockWithSwitch", "indexes", "allocI32Array", "_RelooperAddBranchForSwitch", "entry", "labelHelper", "_RelooperRenderAndDispose", "SwitchBuilder", "valueIndex", "codeIndex", "cases", "localIndex", "labelPostfix", "numCases", "values", "numValues", "labels", "defaultIndex", "defaultLabel", "current", "block", "lastCase", "SideEffects", "_BinaryenExpressionGetSideEffects", "mustPreserveSideEffects", "u8s", "len", "i32s", "val", "__i32_store", "u32s", "ptrs", "stringLengthUTF8", "c1", "isHighSurrogate", "isLowSurrogate", "u", "c2", "combineSurrogates", "arr", "cp", "u1", "u2", "u3", "ch", "SURROGATE_HIGH", "SURROGATE_LOW", "output", "sourceMap", "DEBUG_TYPEBUILDER", "ensureType", "Type", "typeRef", "tryEnsureBasicType", "originalType", "_BinaryenTypeFromHeapType", "builder", "_TypeBuilderCreate", "seen", "prepareType", "_TypeBuilderGetSize", "_TypeBuilderBuildAndDispose", "errorIndex", "errorReason", "_keys", "seenType", "heapType", "fullType", "classInstance", "_BinaryenModuleSetTypeName", "members", "numFieldsInType", "_BinaryenStructTypeGetNumFields", "numFieldsInClass", "member", "property", "_BinaryenModuleSetFieldName", "determinePackedType", "classReference", "base", "baseRef", "_TypeBuilderGrow", "heapTypeRef", "_TypeBuilderGetTempHeapType", "_TypeBuilderGetTempRefType", "fieldTypes", "packedTypes", "fieldMutables", "fieldType", "cArrFT", "cArrPT", "cArrFM", "_TypeBuilderSetStructType", "_TypeBuilderSetSubType", "signatureReference", "tempTypeRef", "resultTypes", "parameterTypes", "paramType", "tempParamType", "_TypeBuilderGetTempTupleType", "tempResultType", "cArrRT", "_TypeBuilderSetSignatureType", "FlowFlags", "LocalFlags", "FieldFlags", "ConditionKind", "Flow", "_Flow", "targetFunction", "inlineFunction", "flow", "flag", "condiFlags", "newBreakContext", "newContinueContext", "branch", "thisFieldFlags", "cloneMap", "condExpr", "trueFlows", "trueFlow", "falseFlows", "falseFlow", "name", "definition", "scopedTypeAlias", "current", "sourceParent", "type", "local", "scopedLocals", "scopedLocal", "mangleInternalName", "declarationNode", "scopedDummy", "Local", "index", "reportNode", "existingLocal", "scopedAlias", "scope", "element", "defaultIfInlined", "localFlags", "flags", "sourceFunction", "parent", "classInstance", "members", "_values", "i", "k", "member", "property", "field", "fieldFlags", "id", "stack", "expectedLabel", "other", "otherFlags", "thisFlags", "newFlags", "thisLocalFlags", "numThisLocalFlags", "otherLocalFlags", "numOtherLocalFlags", "maxLocalFlags", "left", "right", "leftFlags", "rightFlags", "rightLocalFlags", "leftLocalFlags", "numLeftLocalFlags", "numRightLocalFlags", "leftFieldFlags", "newFieldFlags", "rightFieldFlags", "_keys", "key", "numLocalsBefore", "localsByIndex", "needsRecompile", "expr", "getExpressionId", "isLocalTee", "getLocalSetIndex", "getLocalGetIndex", "iff", "getLocalSetValue", "ifFalse", "getIfFalse", "isConstZero", "getIfCondition", "getIfTrue", "getUnaryOp", "getUnaryValue", "getBinaryOp", "getBinaryLeft", "getBinaryRight", "isConstNonZero", "getCallTarget", "BuiltinNames", "getCallOperandCount", "getCallOperandAt", "ifTrue", "operand", "canConversionOverflow", "global", "getGlobalGetName", "getConstValueI32", "Type", "shift", "value", "getExpressionType", "TypeRef", "getConstValueI64Low", "getConstValueF32", "getConstValueF64", "fromType", "signed", "isLoadSigned", "getLoadBytes", "getBlockName", "size", "getBlockChildCount", "last", "getBlockChildAt", "getSelectThen", "getSelectElse", "instancesByName", "instanceName", "instance", "functionInstance", "returnType", "levels", "sb", "toType", "ReportMode", "Resolver", "DiagnosticEmitter", "program", "node", "flow", "ctxElement", "ctxTypes", "reportMode", "resolved", "nameNode", "typeArgumentNodes", "isSimpleType", "simpleName", "type", "element", "shadowType", "Type", "instance", "cloneMap", "typeDefinition", "text", "CommonNames", "typeParameterNodes", "typeArguments", "explicitThisType", "thisType", "parameterNodes", "numParameters", "parameterTypes", "requiredParameters", "hasRest", "i", "parameterNode", "parameterTypeNode", "isTypeOmitted", "parameterType", "returnTypeNode", "returnType", "signature", "Signature", "typeArgumentNode", "typeArgument", "classReference", "overload", "signatureReference", "prev", "next", "typeParameters", "alternativeReportNode", "minParameterCount", "maxParameterCount", "k", "argumentCount", "Range", "oldCtxTypes", "prototype", "ctxFlow", "resolvedTypeArguments", "contextualTypeArguments", "numTypeParameters", "typeParameterNames", "name", "argumentNodes", "argumentsRange", "expr", "numArguments", "argumentExpression", "typeNode", "typeParameterNode", "inferredType", "defaultType", "parent", "defaultTypeContextualTypeArguments", "resolvedDefaultType", "range", "namedTypeNode", "classPrototype", "currentType", "functionTypeNode", "kind", "isTypedElement", "wrappedType", "ctxType", "resolvingExpressions", "outerFlow", "global", "targetNode", "target", "propertyName", "variableLikeElement", "propertyInstance", "getterInstance", "setterInstance", "classInstance", "elementExpression", "indexedGet", "resolvedType", "functionInstance", "wrapper", "classLikeTarget", "findBase", "member", "basePrototype", "baseInstance", "targetExpression", "targetType", "indexSignature", "negate", "intValue", "operatorTokenToString", "operand", "operator", "OperatorKind", "left", "right", "leftType", "rightType", "commonType", "thisLocal", "superLocal", "base", "intType", "fltType", "expressions", "length", "elementType", "numNullLiterals", "expression", "functionPrototype", "BuiltinNames", "targetElement", "thenType", "elseType", "declaration", "body", "functionType", "tempFlow", "Flow", "parameters", "parameter", "instanceKey", "typesToString", "resolvedInstance", "classTypeArguments", "classTypeParameters", "numClassTypeArguments", "classTypeParameterName", "signatureNode", "numFunctionTypeArguments", "signatureParameters", "numSignatureParameters", "parameterDeclaration", "nameInclTypeParameters", "Function", "methodOrPropertyName", "baseClass", "baseMember", "incompatibleOverride", "baseProperty", "baseGetter", "baseSetter", "baseFunction", "reportNode", "overridePrototypes", "parentClassInstance", "overrides", "_values", "unboundOverridePrototype", "unboundOverrideParent", "classInstances", "j", "l", "overrideInstance", "boundPropertyPrototype", "boundPropertyInstance", "boundPrototype", "Interface", "Class", "pendingClasses", "numTypeArguments", "anyPending", "current", "extendsNode", "interfacePrototypes", "interfacePrototype", "implementsNode", "iface", "thisMember", "thisClass", "hasErrors", "members", "unimplemented", "interfaces", "ifaceMembers", "_keys", "memberName", "ifaceMember", "existingMember", "memoryOffset", "implicitlyExtendsObject", "baseMembers", "instanceMemberPrototypes", "boundInstance", "fieldType", "needsLayout", "existingPrototype", "existingProperty", "byteSize", "isPowerOf2", "mask", "ctorPrototype", "ctorInstance", "overloadPrototypes", "overloadKind", "overloadPrototype", "operatorInstance", "overloads", "index", "IndexSignature", "pending", "dependsOnInstance", "_values2", "constructorPrototype", "p", "Property", "getterPrototype", "setterPrototype", "Dependee", "source", "reportNode", "Parser", "DiagnosticEmitter", "diagnostics", "sources", "text", "path", "isEntry", "normalizedPath", "normalizePath", "internalPath", "mangleInternalPath", "dependees", "dependee", "Source", "LIBRARY_PREFIX", "PATH_DELIMITER", "tn", "Tokenizer", "statements", "statement", "namespace", "flags", "startPos", "decorators", "decorator", "exportStart", "exportEnd", "defaultStart", "defaultEnd", "declareStart", "declareEnd", "contextIsAmbient", "first", "state", "abstractStart", "abstractEnd", "next", "i", "k", "Node", "backlog", "dependent", "current", "acceptParenthesized", "suppressErrors", "token", "type", "isInnerParenthesized", "signature", "innerType", "name", "parameters", "parameter", "nextType", "typeIsNull", "nextTypeIsNull", "bracketStart", "bracketRange", "nullable", "thisType", "isSignature", "firstParamNameNoType", "firstParamKind", "paramStart", "kind", "param", "returnType", "expression", "args", "isFor", "declarations", "declaration", "ret", "parentFlags", "parentDecorators", "identifier", "isIllegalVariableIdentifier", "initializer", "range", "Range", "members", "member", "value", "expr", "nextToken", "typeParameters", "seenOptional", "start", "typeParameter", "extendsType", "defaultType", "isConstructor", "seenRest", "reportedRest", "isRest", "isOptional", "startRange", "accessFlags", "signatureStart", "isSetter", "body", "arrowKind", "explicitThis", "bodyExpression", "isInterface", "implementsTypes", "DeclarationStatement", "parent", "accessStart", "accessEnd", "staticStart", "staticEnd", "overrideStart", "overrideEnd", "readonlyStart", "readonlyEnd", "isGetter", "getStart", "getEnd", "setStart", "setEnd", "isGetterOrSetter", "retIndex", "typeParametersStart", "implicitFieldDeclaration", "retMethod", "retField", "keyType", "valueType", "isDeclare", "currentSource", "exportPaths", "asIdentifier", "namespaceName", "skipFrom", "topLevel", "condition", "incrementor", "variable", "iterable", "elseStatement", "switchCases", "switchCase", "label", "stmt", "bodyStatements", "catchVariable", "catchStatements", "finallyStatements", "isCircularTypeAlias", "moduleName", "operand", "typeName", "typeArguments", "arguments_", "again", "inner", "elementExpressions", "names", "values", "toType", "identifierText", "regexpPattern", "end", "precedence", "nextPrecedence", "determinePrecedence", "isType", "ifThen", "ifElse", "commaExprs", "tag", "parts", "rawParts", "exprs", "call", "callee", "potentiallyGeneric", "depth", "Precedence", "functionType", "AL_SIZE", "AL_MASK", "QueuedImport", "localFile", "localIdentifier", "foreignIdentifier", "foreignPath", "foreignPathAlt", "QueuedExport", "QueuedExportStar", "pathLiteral", "OperatorKind", "fromDecorator", "decoratorKind", "arg", "fromBinaryToken", "token", "fromUnaryPrefixToken", "fromUnaryPostfixToken", "Program", "DiagnosticEmitter", "options", "diagnostics", "Module", "Parser", "Resolver", "nativeFile", "File", "Source", "cached", "CommonNames", "prototype", "internalPath", "sources", "i", "source", "ref", "modifiedFunctionName", "getFunctionName", "instancesByName", "element", "currentOffset", "blockOverhead", "payloadSize", "isManaged", "blockSize", "blockMinsize", "blockMaxsize", "name", "flags", "range", "Node", "identifier", "signature", "parent", "decoratorFlags", "Function", "FunctionPrototype", "declaration", "elementsByDeclaration", "Type", "TypeDefinition", "queuedImports", "queuedExports", "queuedExportsStar", "queuedExtends", "queuedImplements", "k", "file", "statements", "j", "l", "statement", "_keys", "starExports", "exportStar", "foreignFile", "madeProgress", "queuedImport", "localName", "exports", "exportNames", "exportName", "queuedExport", "globalElement", "isDeclaredElement", "resolver", "thisPrototype", "extendsNode", "baseElement", "basePrototype", "Range", "instanesMembers", "members", "member", "hasOverride", "instanceMembers", "implementsNodes", "implementsNode", "interfaceElement", "interfacePrototype", "interfacePrototypes", "globalAliases", "BuiltinNames", "alias", "firstChar", "elementsByName", "_values", "thisInstanceMembers", "thisMembers", "seen", "baseInstanceMembers", "thisMember", "baseMember", "baseInterfacePrototypes", "baseInterfacePrototype", "nextPrototype", "thisClass", "baseClass", "thisMethod", "baseMethod", "overrides", "baseMethodInstances", "a", "b", "thisProperty", "baseProperty", "thisIsField", "baseGetter", "thisGetter", "baseGetterInstances", "baseSetter", "thisSetter", "baseSetterInstances", "elements", "kind", "resolved", "typeArguments", "exportsStar", "propertyPrototype", "getterPrototype", "setterPrototype", "staticMembers", "moduleName", "moduleImports", "module", "type", "className", "wrapperClasses", "classElement", "value", "global", "Global", "existing", "merged", "tryMerge", "filesByName", "foreignName", "fileQueuedExports", "queuedExportForeignPath", "otherFile", "decorators", "acceptedFlags", "decorator", "DecoratorKind", "flag", "DecoratorFlags", "feature", "reportNode", "featureToString", "classReference", "signatureReference", "thisType", "parameterTypes", "returnType", "ClassPrototype", "implementsTypes", "numImplementsTypes", "memberDeclarations", "memberDeclaration", "methodDeclaration", "method", "PropertyPrototype", "isStatic", "builtinFunctions", "classPrototype", "args", "numArgs", "firstArg", "text", "overloads", "parentMembers", "property", "isGetter", "GETTER_PREFIX", "SETTER_PREFIX", "Enum", "values", "EnumValue", "queued", "INDEX_SUFFIX", "declarations", "namespaceName", "validDecorators", "InterfacePrototype", "initializer", "typeNode", "original", "Namespace", "copyMembers", "builtinVariables_onAccess", "ElementKind", "fromKind", "Element", "internalName", "program", "current", "isType", "localIdentifierIfImport", "originalDeclaration", "reportedIdentifier", "other", "vis", "declaredElements", "DeclaredElement", "identifierNode", "signatureNode", "typedElements", "isTypedElement", "TypedElement", "startFunction", "Signature", "ns", "memberName", "mangleInternalName", "ConstantValueKind", "VariableLikeElement", "Parameter", "Local", "index", "flow", "_FunctionPrototype", "classInstance", "boundPrototypes", "bound", "instanceKey", "instances", "instance", "_Function", "nameInclTypeParameters", "contextualTypeArguments", "Flow", "localIndex", "local", "scopedLocals", "parameterType", "parameterName", "registerConcreteElement", "localsByIndex", "numTotal", "numFixed", "numAdditional", "types", "parameters", "getDefaultParameterName", "postfix", "requiredParameters", "stub", "STUB_DELIMITER", "defaultFlow", "breakStack", "debugLocations", "expressionRef", "localNameMap", "_PropertyPrototype", "firstDeclaration", "fieldDeclaration", "nativeRange", "getterDeclaration", "MethodDeclaration", "FunctionTypeNode", "setterDeclaration", "ParameterNode", "NamedTypeNode", "TypeName", "IdentifierExpression", "setterParameters", "Property", "diag", "propertyGetter", "propertySetter", "IndexSignature", "isUnchecked", "_isInterface", "arrayBufferViewInstance", "basePtototype", "Class", "usizeType", "id", "typeParameters", "numTypeArguments", "lengthField", "candidates", "aBase", "bBase", "base", "inheritedTypeArguments", "baseName", "baseType", "extenders", "extender", "nextBase", "baseInterfaces", "baseInterface", "iface", "nextIface", "implementers", "interfaces", "target", "unchecked", "uncheckedOverload", "fieldName", "overhead", "buffer", "OBJECT", "baseOffset", "offset", "typeKind", "writeI8", "writeI16", "writeI32", "writeI64", "writeI32AsI64", "writeI64AsI32", "writeF32", "writeF64", "extendedPrototype", "arrayPrototype", "staticArrayPrototype", "abvInstance", "Interface", "older", "newer", "olderIsExport", "newerIsExport", "src", "dest", "srcMembers", "destMembers", "isInstance", "asGlobal", "PATH_DELIMITER", "INNER_DELIMITER", "INSTANCE_DELIMITER", "STATIC_DELIMITER", "cachedDefaultParameterNames", "TypeKind", "TypeFlags", "Type", "_Type", "kind", "flags", "size", "program", "classReference", "signatureReference", "type", "wrapper", "wrapperClasses", "targetType", "nullableType", "other", "selfSignatureReference", "otherSignatureReference", "target", "signednessIsRelevant", "currentClass", "targetClass", "currentFunction", "targetFunction", "thisClass", "base", "baseClass", "left", "right", "contextualType", "leftClass", "rightClass", "lubClass", "Class", "CommonNames", "validWat", "nullablePostfix", "TypeRef", "_BinaryenTypeFromHeapType", "HeapTypeRef", "ensureType", "typesToRefs", "types", "numTypes", "ret", "i", "typesToString", "sb", "Signature", "_Signature", "parameterTypes", "returnType", "thisType", "requiredParameters", "hasRest", "id", "usizeType", "signatureTypes", "nextId", "signature", "uniqueKey", "existing", "numParameterTypes", "typeRefs", "createType", "thisThisType", "otherThisType", "selfParameterTypes", "otherParameterTypes", "numParameters", "selfParameterType", "otherParameterType", "checkCompatibleOverride", "targetThisType", "thisReturnType", "targetReturnType", "thisParameterTypes", "targetParameterTypes", "thisParameterType", "targetParameterType", "k", "indices", "index", "parameters", "optionalStart", "restIndex", "cloneParameterTypes", "BuiltinNames", "BuiltinVariableContext", "compiler", "element", "contextualType", "reportNode", "BuiltinFunctionContext", "prototype", "typeArguments", "operands", "thisOperand", "contextIsExact", "builtinFunctions", "builtinVariables_onCompile", "builtinVariables_onAccess", "checkConstantType_expr", "builtin_isBoolean", "ctx", "module", "type", "checkConstantType", "Type", "reifyConstantType", "builtin_isInteger", "builtin_isSigned", "builtin_isFloat", "builtin_isVector", "builtin_isReference", "builtin_isString", "classReference", "builtin_isArray", "builtin_isArrayLike", "builtin_isFunction", "builtin_isNullable", "builtin_isDefined", "checkTypeAbsent", "checkArgsRequired", "builtin_isConstant", "expr", "mustPreserveSideEffects", "getExpressionType", "builtin_isManaged", "builtin_isVoid", "builtin_lengthof", "signatureReference", "builtin_sizeof", "checkTypeRequired", "byteSize", "contextualUsize", "builtin_alignof", "isPowerOf2", "builtin_offsetof", "checkArgsOptional", "firstOperand", "fieldName", "fieldMember", "property", "builtin_nameof", "resultType", "value", "builtin_idof", "builtin_NaN_compile", "TypeRef", "builtin_NaN_access", "builtin_Infinity_compile", "builtin_Infinity_access", "builtin_clz", "checkTypeOptional", "arg0", "builtin_ctz", "builtin_popcnt", "builtin_rotl", "arg1", "flow", "temp1", "temp2", "builtin_rotr", "builtin_abs", "options", "builtin_max", "left", "op", "typeRef", "builtin_min", "builtin_ceil", "builtin_floor", "builtin_copysign", "builtin_nearest", "builtin_reinterpret", "isWasm64", "builtin_sqrt", "builtin_trunc", "builtin_isNaN", "getExpressionId", "getLocalGetIndex", "temp", "builtin_isFinite", "builtin_heap_base_compile", "builtin_heap_base_access", "builtin_data_end_compile", "builtin_data_end_access", "builtin_stack_pointer_compile", "builtin_stack_pointer_access", "builtin_rtti_base_compile", "builtin_rtti_base_access", "builtin_load", "outType", "numOperands", "immOffset", "immAlign", "evaluateImmediateOffset", "evaluateImmediateAlign", "builtin_store", "inType", "builtin_rem", "builtin_add", "builtin_sub", "builtin_mul", "builtin_div", "builtin_eq", "builtin_ne", "builtin_atomic_load", "checkFeatureEnabled", "builtin_atomic_store", "builtin_atomic_binary", "opName", "builtin_atomic_add", "builtin_atomic_sub", "builtin_atomic_and", "builtin_atomic_or", "builtin_atomic_xor", "builtin_atomic_xchg", "builtin_atomic_cmpxchg", "arg2", "builtin_atomic_wait", "builtin_atomic_notify", "builtin_atomic_fence", "builtin_select", "builtin_unreachable", "builtin_memory_size", "builtin_memory_grow", "builtin_memory_copy", "instance", "usizeType", "builtin_memory_fill", "builtin_memory_data", "offset", "elementType", "valuesOperand", "expressions", "numElements", "exprs", "isStatic", "i", "elementExpression", "precomp", "align", "buf", "size", "getConstValueI32", "builtin_i31_new", "builtin_i31_get", "builtin_changetype", "toType", "fromType", "builtin_assert", "evaled", "getConstValueI64Low", "getConstValueI64High", "getConstValueF32", "getConstValueF64", "abort", "builtin_unchecked", "ignoreUnchecked", "alreadyUnchecked", "builtin_inline_always", "alreadyInline", "builtin_call_indirect", "returnType", "indexArg", "operandExprs", "paramTypeRefs", "createType", "builtin_instantiate", "classInstance", "ctor", "builtin_diagnostic", "category", "builtin_error", "builtin_warning", "builtin_info", "builtin_function_call", "parent", "ftype", "signature", "functionArg", "thisType", "thisArg", "builtin_string_raw", "builtin_conversion", "builtin_i8", "builtin_i16", "builtin_i32", "builtin_i64", "builtin_isize", "builtin_u8", "builtin_u16", "builtin_u32", "builtin_u64", "builtin_usize", "builtin_bool", "builtin_f32", "builtin_f64", "builtin_v128", "builtin_i8x16", "bytes", "vars", "numVars", "writeI8", "vec", "fullVars", "builtin_i16x8", "writeI16", "builtin_i32x4", "writeI32", "builtin_i64x2", "off", "builtin_f32x4", "writeF32", "builtin_f64x2", "writeF64", "builtin_v128_splat", "builtin_v128_extract_lane", "idx", "maxIdx", "builtin_v128_replace_lane", "builtin_v128_shuffle", "laneWidth", "laneCount", "mask", "operand", "argN", "off8", "idx8", "builtin_v128_swizzle", "builtin_v128_load_splat", "builtin_v128_load_ext", "builtin_v128_load_zero", "builtin_v128_load_lane", "builtin_v128_store_lane", "builtin_v128_add", "builtin_v128_sub", "builtin_v128_mul", "builtin_v128_div", "builtin_v128_add_sat", "builtin_v128_sub_sat", "builtin_v128_min", "builtin_v128_max", "builtin_v128_pmin", "builtin_v128_pmax", "builtin_v128_dot", "builtin_v128_avgr", "builtin_v128_eq", "builtin_v128_ne", "builtin_v128_lt", "builtin_v128_le", "builtin_v128_gt", "builtin_v128_ge", "builtin_v128_narrow", "builtin_v128_neg", "builtin_v128_abs", "builtin_v128_sqrt", "builtin_v128_ceil", "builtin_v128_floor", "builtin_v128_trunc", "builtin_v128_nearest", "builtin_v128_convert", "builtin_v128_convert_low", "builtin_v128_trunc_sat", "builtin_v128_trunc_sat_zero", "builtin_v128_extend_low", "builtin_v128_extend_high", "builtin_v128_shl", "builtin_v128_shr", "builtin_v128_bitwise_binary", "builtin_v128_and", "builtin_v128_or", "builtin_v128_xor", "builtin_v128_andnot", "builtin_v128_bitwise_unary", "builtin_v128_not", "builtin_v128_bitselect", "builtin_v128_any_true", "builtin_v128_all_true", "builtin_v128_bitmask", "builtin_v128_popcnt", "builtin_v128_extadd_pairwise", "builtin_v128_demote_zero", "builtin_v128_promote_low", "builtin_v128_q15mulr_sat", "builtin_v128_extmul_low", "builtin_v128_extmul_high", "builtin_v128_relaxed_swizzle", "builtin_v128_relaxed_trunc", "builtin_v128_relaxed_trunc_zero", "builtin_v128_relaxed_madd", "builtin_v128_relaxed_nmadd", "builtin_v128_relaxed_laneselect", "builtin_v128_relaxed_min", "builtin_v128_relaxed_max", "builtin_v128_relaxed_q15mulr", "builtin_v128_relaxed_dot", "builtin_v128_relaxed_dot_add", "builtin_visit_globals", "builtin_visit_members", "builtin_i32_clz", "builtin_i64_clz", "builtin_i32_ctz", "builtin_i64_ctz", "builtin_i32_popcnt", "builtin_i64_popcnt", "builtin_i32_rotl", "builtin_i64_rotl", "builtin_i32_rotr", "builtin_i64_rotr", "builtin_f32_abs", "builtin_f64_abs", "builtin_f32_max", "builtin_f64_max", "builtin_f32_min", "builtin_f64_min", "builtin_f32_ceil", "builtin_f64_ceil", "builtin_f32_floor", "builtin_f64_floor", "builtin_f32_copysign", "builtin_f64_copysign", "builtin_f32_nearest", "builtin_f64_nearest", "builtin_i32_reinterpret_f32", "builtin_i64_reinterpret_f64", "builtin_f32_reinterpret_i32", "builtin_f64_reinterpret_i64", "builtin_f32_sqrt", "builtin_f64_sqrt", "builtin_f32_trunc", "builtin_f64_trunc", "builtin_i32_rem_s", "builtin_i32_rem_u", "builtin_i64_rem_s", "builtin_i64_rem_u", "builtin_i32_add", "builtin_i64_add", "builtin_f32_add", "builtin_f64_add", "builtin_i32_sub", "builtin_i64_sub", "builtin_f32_sub", "builtin_f64_sub", "builtin_i32_mul", "builtin_i64_mul", "builtin_f32_mul", "builtin_f64_mul", "builtin_i32_div_s", "builtin_i32_div_u", "builtin_i64_div_s", "builtin_i64_div_u", "builtin_f32_div", "builtin_f64_div", "builtin_i32_eq", "builtin_i64_eq", "builtin_f32_eq", "builtin_f64_eq", "builtin_i32_ne", "builtin_i64_ne", "builtin_f32_ne", "builtin_f64_ne", "builtin_i32_load8_s", "builtin_i32_load8_u", "builtin_i32_load16_s", "builtin_i32_load16_u", "builtin_i32_load", "builtin_i64_load8_s", "builtin_i64_load8_u", "builtin_i64_load16_s", "builtin_i64_load16_u", "builtin_i64_load32_s", "builtin_i64_load32_u", "builtin_i64_load", "builtin_f32_load", "builtin_f64_load", "builtin_i32_store8", "builtin_i32_store16", "builtin_i32_store", "builtin_i64_store8", "builtin_i64_store16", "builtin_i64_store32", "builtin_i64_store", "builtin_f32_store", "builtin_f64_store", "builtin_i32_atomic_load8_u", "builtin_i32_atomic_load16_u", "builtin_i32_atomic_load", "builtin_i64_atomic_load8_u", "builtin_i64_atomic_load16_u", "builtin_i64_atomic_load32_u", "builtin_i64_atomic_load", "builtin_i32_atomic_store8", "builtin_i32_atomic_store16", "builtin_i32_atomic_store", "builtin_i64_atomic_store8", "builtin_i64_atomic_store16", "builtin_i64_atomic_store32", "builtin_i64_atomic_store", "builtin_i32_atomic_rmw8_add_u", "builtin_i32_atomic_rmw16_add_u", "builtin_i32_atomic_rmw_add", "builtin_i64_atomic_rmw8_add_u", "builtin_i64_atomic_rmw16_add_u", "builtin_i64_atomic_rmw32_add_u", "builtin_i64_atomic_rmw_add", "builtin_i32_atomic_rmw8_sub_u", "builtin_i32_atomic_rmw16_sub_u", "builtin_i32_atomic_rmw_sub", "builtin_i64_atomic_rmw8_sub_u", "builtin_i64_atomic_rmw16_sub_u", "builtin_i64_atomic_rmw32_sub_u", "builtin_i64_atomic_rmw_sub", "builtin_i32_atomic_rmw8_and_u", "builtin_i32_atomic_rmw16_and_u", "builtin_i32_atomic_rmw_and", "builtin_i64_atomic_rmw8_and_u", "builtin_i64_atomic_rmw16_and_u", "builtin_i64_atomic_rmw32_and_u", "builtin_i64_atomic_rmw_and", "builtin_i32_atomic_rmw8_or_u", "builtin_i32_atomic_rmw16_or_u", "builtin_i32_atomic_rmw_or", "builtin_i64_atomic_rmw8_or_u", "builtin_i64_atomic_rmw16_or_u", "builtin_i64_atomic_rmw32_or_u", "builtin_i64_atomic_rmw_or", "builtin_i32_atomic_rmw8_xor_u", "builtin_i32_atomic_rmw16_xor_u", "builtin_i32_atomic_rmw_xor", "builtin_i64_atomic_rmw8_xor_u", "builtin_i64_atomic_rmw16_xor_u", "builtin_i64_atomic_rmw32_xor_u", "builtin_i64_atomic_rmw_xor", "builtin_i32_atomic_rmw8_xchg_u", "builtin_i32_atomic_rmw16_xchg_u", "builtin_i32_atomic_rmw_xchg", "builtin_i64_atomic_rmw8_xchg_u", "builtin_i64_atomic_rmw16_xchg_u", "builtin_i64_atomic_rmw32_xchg_u", "builtin_i64_atomic_rmw_xchg", "builtin_i32_atomic_rmw8_cmpxchg_u", "builtin_i32_atomic_rmw16_cmpxchg_u", "builtin_i32_atomic_rmw_cmpxchg", "builtin_i64_atomic_rmw8_cmpxchg_u", "builtin_i64_atomic_rmw16_cmpxchg_u", "builtin_i64_atomic_rmw32_cmpxchg_u", "builtin_i64_atomic_rmw_cmpxchg", "builtin_memory_atomic_wait32", "builtin_memory_atomic_wait64", "builtin_v128_load", "builtin_v128_load8x8_s", "builtin_v128_load8x8_u", "builtin_v128_load16x4_s", "builtin_v128_load16x4_u", "builtin_v128_load32x2_s", "builtin_v128_load32x2_u", "builtin_v128_load8_splat", "builtin_v128_load16_splat", "builtin_v128_load32_splat", "builtin_v128_load64_splat", "builtin_v128_load32_zero", "builtin_v128_load64_zero", "builtin_v128_load8_lane", "builtin_v128_load16_lane", "builtin_v128_load32_lane", "builtin_v128_load64_lane", "builtin_v128_store8_lane", "builtin_v128_store16_lane", "builtin_v128_store32_lane", "builtin_v128_store64_lane", "builtin_v128_store", "builtin_i8x16_splat", "builtin_i8x16_extract_lane_s", "builtin_i8x16_extract_lane_u", "builtin_i8x16_replace_lane", "builtin_i8x16_add", "builtin_i8x16_sub", "builtin_i8x16_min_s", "builtin_i8x16_min_u", "builtin_i8x16_max_s", "builtin_i8x16_max_u", "builtin_i8x16_avgr_u", "builtin_i8x16_abs", "builtin_i8x16_neg", "builtin_i8x16_add_sat_s", "builtin_i8x16_add_sat_u", "builtin_i8x16_sub_sat_s", "builtin_i8x16_sub_sat_u", "builtin_i8x16_shl", "builtin_i8x16_shr_s", "builtin_i8x16_shr_u", "builtin_i8x16_all_true", "builtin_i8x16_bitmask", "builtin_i8x16_popcnt", "builtin_i8x16_eq", "builtin_i8x16_ne", "builtin_i8x16_lt_s", "builtin_i8x16_lt_u", "builtin_i8x16_le_s", "builtin_i8x16_le_u", "builtin_i8x16_gt_s", "builtin_i8x16_gt_u", "builtin_i8x16_ge_s", "builtin_i8x16_ge_u", "builtin_i8x16_narrow_i16x8_s", "builtin_i8x16_narrow_i16x8_u", "builtin_i8x16_shuffle", "builtin_i8x16_swizzle", "builtin_i16x8_splat", "builtin_i16x8_extract_lane_s", "builtin_i16x8_extract_lane_u", "builtin_i16x8_replace_lane", "builtin_i16x8_add", "builtin_i16x8_sub", "builtin_i16x8_mul", "builtin_i16x8_min_s", "builtin_i16x8_min_u", "builtin_i16x8_max_s", "builtin_i16x8_max_u", "builtin_i16x8_avgr_u", "builtin_i16x8_abs", "builtin_i16x8_neg", "builtin_i16x8_add_sat_s", "builtin_i16x8_add_sat_u", "builtin_i16x8_sub_sat_s", "builtin_i16x8_sub_sat_u", "builtin_i16x8_shl", "builtin_i16x8_shr_s", "builtin_i16x8_shr_u", "builtin_i16x8_all_true", "builtin_i16x8_bitmask", "builtin_i16x8_eq", "builtin_i16x8_ne", "builtin_i16x8_lt_s", "builtin_i16x8_lt_u", "builtin_i16x8_le_s", "builtin_i16x8_le_u", "builtin_i16x8_gt_s", "builtin_i16x8_gt_u", "builtin_i16x8_ge_s", "builtin_i16x8_ge_u", "builtin_i16x8_narrow_i32x4_s", "builtin_i16x8_narrow_i32x4_u", "builtin_i16x8_extend_low_i8x16_s", "builtin_i16x8_extend_low_i8x16_u", "builtin_i16x8_extend_high_i8x16_s", "builtin_i16x8_extend_high_i8x16_u", "builtin_i16x8_extadd_pairwise_i8x16_s", "builtin_i16x8_extadd_pairwise_i8x16_u", "builtin_i16x8_q15mulr_sat_s", "builtin_i16x8_extmul_low_i8x16_s", "builtin_i16x8_extmul_low_i8x16_u", "builtin_i16x8_extmul_high_i8x16_s", "builtin_i16x8_extmul_high_i8x16_u", "builtin_i16x8_shuffle", "builtin_i32x4_splat", "builtin_i32x4_extract_lane", "builtin_i32x4_replace_lane", "builtin_i32x4_add", "builtin_i32x4_sub", "builtin_i32x4_mul", "builtin_i32x4_min_s", "builtin_i32x4_min_u", "builtin_i32x4_max_s", "builtin_i32x4_max_u", "builtin_i32x4_dot_i16x8_s", "builtin_i32x4_abs", "builtin_i32x4_neg", "builtin_i32x4_shl", "builtin_i32x4_shr_s", "builtin_i32x4_shr_u", "builtin_i32x4_all_true", "builtin_i32x4_bitmask", "builtin_i32x4_eq", "builtin_i32x4_ne", "builtin_i32x4_lt_s", "builtin_i32x4_lt_u", "builtin_i32x4_le_s", "builtin_i32x4_le_u", "builtin_i32x4_gt_s", "builtin_i32x4_gt_u", "builtin_i32x4_ge_s", "builtin_i32x4_ge_u", "builtin_i32x4_trunc_sat_f32x4_s", "builtin_i32x4_trunc_sat_f32x4_u", "builtin_i32x4_trunc_sat_f64x2_s_zero", "builtin_i32x4_trunc_sat_f64x2_u_zero", "builtin_i32x4_extend_low_i16x8_s", "builtin_i32x4_extend_low_i16x8_u", "builtin_i32x4_extend_high_i16x8_s", "builtin_i32x4_extend_high_i16x8_u", "builtin_i32x4_extadd_pairwise_i16x8_s", "builtin_i32x4_extadd_pairwise_i16x8_u", "builtin_i32x4_extmul_low_i16x8_s", "builtin_i32x4_extmul_low_i16x8_u", "builtin_i32x4_extmul_high_i16x8_s", "builtin_i32x4_extmul_high_i16x8_u", "builtin_i32x4_shuffle", "builtin_i64x2_splat", "builtin_i64x2_extract_lane", "builtin_i64x2_replace_lane", "builtin_i64x2_add", "builtin_i64x2_sub", "builtin_i64x2_mul", "builtin_i64x2_abs", "builtin_i64x2_neg", "builtin_i64x2_shl", "builtin_i64x2_shr_s", "builtin_i64x2_shr_u", "builtin_i64x2_all_true", "builtin_i64x2_bitmask", "builtin_i64x2_eq", "builtin_i64x2_ne", "builtin_i64x2_lt_s", "builtin_i64x2_le_s", "builtin_i64x2_gt_s", "builtin_i64x2_ge_s", "builtin_i64x2_extend_low_i32x4_s", "builtin_i64x2_extend_low_i32x4_u", "builtin_i64x2_extend_high_i32x4_s", "builtin_i64x2_extend_high_i32x4_u", "builtin_i64x2_extmul_low_i32x4_s", "builtin_i64x2_extmul_low_i32x4_u", "builtin_i64x2_extmul_high_i32x4_s", "builtin_i64x2_extmul_high_i32x4_u", "builtin_i64x2_shuffle", "builtin_f32x4_splat", "builtin_f32x4_extract_lane", "builtin_f32x4_replace_lane", "builtin_f32x4_add", "builtin_f32x4_sub", "builtin_f32x4_mul", "builtin_f32x4_div", "builtin_f32x4_neg", "builtin_f32x4_min", "builtin_f32x4_max", "builtin_f32x4_pmin", "builtin_f32x4_pmax", "builtin_f32x4_abs", "builtin_f32x4_sqrt", "builtin_f32x4_ceil", "builtin_f32x4_floor", "builtin_f32x4_trunc", "builtin_f32x4_nearest", "builtin_f32x4_eq", "builtin_f32x4_ne", "builtin_f32x4_lt", "builtin_f32x4_le", "builtin_f32x4_gt", "builtin_f32x4_ge", "builtin_f32x4_convert_i32x4_s", "builtin_f32x4_convert_i32x4_u", "builtin_f32x4_demote_f64x2_zero", "builtin_f32x4_shuffle", "builtin_f64x2_splat", "builtin_f64x2_extract_lane", "builtin_f64x2_replace_lane", "builtin_f64x2_add", "builtin_f64x2_sub", "builtin_f64x2_mul", "builtin_f64x2_div", "builtin_f64x2_neg", "builtin_f64x2_min", "builtin_f64x2_max", "builtin_f64x2_pmin", "builtin_f64x2_pmax", "builtin_f64x2_abs", "builtin_f64x2_sqrt", "builtin_f64x2_ceil", "builtin_f64x2_floor", "builtin_f64x2_trunc", "builtin_f64x2_nearest", "builtin_f64x2_eq", "builtin_f64x2_ne", "builtin_f64x2_lt", "builtin_f64x2_le", "builtin_f64x2_gt", "builtin_f64x2_ge", "builtin_f64x2_convert_low_i32x4_s", "builtin_f64x2_convert_low_i32x4_u", "builtin_f64x4_promote_low_f32x4", "builtin_f64x2_shuffle", "builtin_i8x16_relaxed_swizzle", "builtin_i32x4_relaxed_trunc_f32x4_s", "builtin_i32x4_relaxed_trunc_f32x4_u", "builtin_i32x4_relaxed_trunc_f64x2_s_zero", "builtin_i32x4_relaxed_trunc_f64x2_u_zero", "builtin_f32x4_relaxed_madd", "builtin_f32x4_relaxed_nmadd", "builtin_f64x2_relaxed_madd", "builtin_f64x2_relaxed_nmadd", "builtin_i8x16_relaxed_laneselect", "builtin_i16x8_relaxed_laneselect", "builtin_i32x4_relaxed_laneselect", "builtin_i64x2_relaxed_laneselect", "builtin_f32x4_relaxed_min", "builtin_f32x4_relaxed_max", "builtin_f64x2_relaxed_min", "builtin_f64x2_relaxed_max", "builtin_i16x8_relaxed_q15mulr_s", "builtin_i16x8_relaxed_dot_i8x16_i7x16_s", "builtin_i32x4_relaxed_dot_i8x16_i7x16_add_s", "compileVisitGlobals", "sizeTypeRef", "visitInstance", "_values", "k", "global", "ensureVisitMembersOf", "program", "sizeTypeSize", "body", "base", "hasVisitImpl", "visitPrototype", "visitSignature", "visitThisType", "needsTempValue", "members", "j", "l", "member", "fieldType", "fieldOffset", "compileVisitMembers", "managedClasses", "names", "cases", "nextId", "_keys", "instanceId", "current", "typeToRuntimeFlags", "flags", "compileRTTI", "count", "data", "abvInstance", "abvPrototype", "arrayPrototype", "setPrototype", "mapPrototype", "staticArrayPrototype", "lastId", "valueType", "segment", "expression", "naturalAlign", "feature", "featureToString", "setCurrentTypeOnError", "numTypeArguments", "expected", "expectedMinimum", "expectedMaximum", "Visitor", "currentExpression", "stack", "length", "expr", "name", "index", "previousExpression", "_BinaryenExpressionGetId", "_BinaryenBlockGetName", "i", "n", "_BinaryenBlockGetNumChildren", "_BinaryenBlockGetChildAt", "_BinaryenIfGetCondition", "_BinaryenIfGetIfTrue", "ifFalse", "_BinaryenIfGetIfFalse", "_BinaryenLoopGetName", "_BinaryenLoopGetBody", "_BinaryenBreakGetName", "condition", "_BinaryenBreakGetCondition", "value", "_BinaryenBreakGetValue", "defaultName", "_BinaryenSwitchGetDefaultName", "numNames", "_BinaryenSwitchGetNumNames", "_BinaryenSwitchGetNameAt", "_BinaryenSwitchGetCondition", "_BinaryenSwitchGetValue", "_BinaryenCallGetTarget", "numOperands", "_BinaryenCallGetNumOperands", "_BinaryenCallGetOperandAt", "_BinaryenCallIndirectGetTarget", "k", "_BinaryenCallIndirectGetNumOperands", "_BinaryenCallIndirectGetOperandAt", "_BinaryenLocalGetGetIndex", "_BinaryenLocalSetGetIndex", "_BinaryenLocalSetGetValue", "_BinaryenGlobalGetGetName", "_BinaryenGlobalSetGetName", "_BinaryenGlobalSetGetValue", "_BinaryenLoadGetPtr", "_BinaryenStoreGetPtr", "_BinaryenStoreGetValue", "_BinaryenUnaryGetValue", "_BinaryenBinaryGetLeft", "_BinaryenBinaryGetRight", "_BinaryenSelectGetIfTrue", "_BinaryenSelectGetIfFalse", "_BinaryenSelectGetCondition", "_BinaryenDropGetValue", "_BinaryenReturnGetValue", "_BinaryenMemoryGrowGetDelta", "_BinaryenAtomicRMWGetPtr", "_BinaryenAtomicRMWGetValue", "_BinaryenAtomicCmpxchgGetPtr", "_BinaryenAtomicCmpxchgGetExpected", "_BinaryenAtomicCmpxchgGetReplacement", "_BinaryenAtomicWaitGetPtr", "_BinaryenAtomicWaitGetExpected", "_BinaryenAtomicWaitGetTimeout", "_BinaryenAtomicNotifyGetPtr", "_BinaryenAtomicNotifyGetNotifyCount", "_BinaryenSIMDExtractGetVec", "_BinaryenSIMDReplaceGetVec", "_BinaryenSIMDReplaceGetValue", "_BinaryenSIMDShuffleGetLeft", "_BinaryenSIMDShuffleGetRight", "_BinaryenSIMDTernaryGetA", "_BinaryenSIMDTernaryGetB", "_BinaryenSIMDTernaryGetC", "_BinaryenSIMDShiftGetVec", "_BinaryenSIMDShiftGetShift", "_BinaryenSIMDLoadGetPtr", "_BinaryenSIMDLoadStoreLaneGetPtr", "_BinaryenSIMDLoadStoreLaneGetVec", "_BinaryenMemoryInitGetDest", "_BinaryenMemoryInitGetOffset", "_BinaryenMemoryInitGetSize", "_BinaryenMemoryCopyGetDest", "_BinaryenMemoryCopyGetSource", "_BinaryenMemoryCopyGetSize", "_BinaryenMemoryFillGetDest", "_BinaryenMemoryFillGetValue", "_BinaryenMemoryFillGetSize", "_BinaryenRefIsNullGetValue", "_BinaryenRefFuncGetFunc", "_BinaryenRefEqGetLeft", "_BinaryenRefEqGetRight", "_BinaryenTryGetBody", "numCatchBodies", "_BinaryenTryGetNumCatchBodies", "_BinaryenTryGetCatchBodyAt", "_BinaryenThrowGetTag", "_BinaryenThrowGetNumOperands", "_BinaryenThrowGetOperandAt", "_BinaryenTupleMakeGetNumOperands", "_BinaryenTupleMakeGetOperandAt", "_BinaryenTupleExtractGetTuple", "_BinaryenRefI31GetValue", "_BinaryenI31GetGetI31", "_BinaryenCallRefGetNumOperands", "_BinaryenCallRefGetOperandAt", "_BinaryenCallRefGetTarget", "_BinaryenRefTestGetRef", "_BinaryenRefCastGetRef", "_BinaryenBrOnGetName", "_BinaryenBrOnGetRef", "_BinaryenStructNewGetNumOperands", "_BinaryenStructNewGetOperandAt", "_BinaryenStructGetGetRef", "_BinaryenStructGetGetIndex", "_BinaryenStructSetGetRef", "_BinaryenStructSetGetIndex", "_BinaryenStructSetGetValue", "_BinaryenArrayNewGetSize", "init", "_BinaryenArrayNewGetInit", "numValues", "_BinaryenArrayNewFixedGetNumValues", "_BinaryenArrayNewFixedGetValueAt", "_BinaryenArrayGetGetRef", "_BinaryenArrayGetGetIndex", "_BinaryenArraySetGetRef", "_BinaryenArraySetGetIndex", "_BinaryenArraySetGetValue", "_BinaryenArrayLenGetRef", "_BinaryenArrayCopyGetDestRef", "_BinaryenArrayCopyGetDestIndex", "_BinaryenArrayCopyGetSrcRef", "_BinaryenArrayCopyGetSrcIndex", "_BinaryenArrayCopyGetLength", "_BinaryenRefAsGetValue", "_BinaryenStringNewGetRef", "start", "_BinaryenStringNewGetStart", "end", "_BinaryenStringNewGetEnd", "_BinaryenStringMeasureGetRef", "_BinaryenStringEncodeGetStr", "_BinaryenStringEncodeGetArray", "_BinaryenStringEncodeGetStart", "_BinaryenStringConcatGetLeft", "_BinaryenStringConcatGetRight", "_BinaryenStringEqGetLeft", "_BinaryenStringEqGetRight", "_BinaryenStringWTF16GetGetRef", "_BinaryenStringWTF16GetGetPos", "_BinaryenStringSliceWTFGetRef", "_BinaryenStringSliceWTFGetStart", "_BinaryenStringSliceWTFGetEnd", "Pass", "module", "currentFunction", "currentGlobal", "moduleRef", "_BinaryenGetNumFunctions", "_BinaryenGetFunctionByIndex", "func", "body", "_BinaryenFunctionGetBody", "_BinaryenGetNumGlobals", "_BinaryenGetGlobalByIndex", "global", "_BinaryenGlobalGetInitExpr", "replacement", "search", "_BinaryenFunctionSetBody", "parent", "replaceChild", "_BinaryenExpressionFinalize", "numChildren", "child", "_BinaryenBlockSetChildAt", "_BinaryenIfSetCondition", "ifTrue", "_BinaryenIfSetIfTrue", "_BinaryenIfSetIfFalse", "_BinaryenLoopSetBody", "_BinaryenBreakSetCondition", "_BinaryenBreakSetValue", "_BinaryenSwitchSetCondition", "_BinaryenSwitchSetValue", "operand", "_BinaryenCallSetOperandAt", "target", "_BinaryenCallIndirectSetTarget", "_BinaryenCallIndirectSetOperandAt", "_BinaryenLocalSetSetValue", "_BinaryenGlobalSetSetValue", "ptr", "_BinaryenLoadSetPtr", "_BinaryenStoreSetPtr", "_BinaryenStoreSetValue", "_BinaryenUnarySetValue", "left", "_BinaryenBinarySetLeft", "right", "_BinaryenBinarySetRight", "_BinaryenSelectSetIfTrue", "_BinaryenSelectSetIfFalse", "_BinaryenSelectSetCondition", "_BinaryenDropSetValue", "_BinaryenReturnSetValue", "delta", "_BinaryenMemoryGrowSetDelta", "_BinaryenAtomicRMWSetPtr", "_BinaryenAtomicRMWSetValue", "_BinaryenAtomicCmpxchgSetPtr", "expected", "_BinaryenAtomicCmpxchgSetExpected", "repl", "_BinaryenAtomicCmpxchgSetReplacement", "_BinaryenAtomicWaitSetPtr", "_BinaryenAtomicWaitSetExpected", "timeout", "_BinaryenAtomicWaitSetTimeout", "_BinaryenAtomicNotifySetPtr", "notifyCount", "_BinaryenAtomicNotifySetNotifyCount", "vec", "_BinaryenSIMDExtractSetVec", "_BinaryenSIMDReplaceSetVec", "_BinaryenSIMDReplaceSetValue", "_BinaryenSIMDShuffleSetLeft", "_BinaryenSIMDShuffleSetRight", "a", "_BinaryenSIMDTernarySetA", "b", "_BinaryenSIMDTernarySetB", "c", "_BinaryenSIMDTernarySetC", "_BinaryenSIMDShiftSetVec", "shift", "_BinaryenSIMDShiftSetShift", "_BinaryenSIMDLoadSetPtr", "_BinaryenSIMDLoadStoreLaneSetPtr", "_BinaryenSIMDLoadStoreLaneSetVec", "dest", "_BinaryenMemoryInitSetDest", "offset", "_BinaryenMemoryInitSetOffset", "size", "_BinaryenMemoryInitSetSize", "_BinaryenMemoryCopySetDest", "source", "_BinaryenMemoryCopySetSource", "_BinaryenMemoryCopySetSize", "_BinaryenMemoryFillSetDest", "_BinaryenMemoryFillSetValue", "_BinaryenMemoryFillSetSize", "_BinaryenRefIsNullSetValue", "_BinaryenRefEqSetLeft", "_BinaryenRefEqSetRight", "_BinaryenTrySetBody", "catchBody", "_BinaryenTrySetCatchBodyAt", "_BinaryenThrowSetOperandAt", "_BinaryenTupleMakeSetOperandAt", "tuple", "_BinaryenTupleExtractSetTuple", "_BinaryenRefI31SetValue", "i31Expr", "_BinaryenI31GetSetI31", "_BinaryenCallRefSetOperandAt", "_BinaryenCallRefSetTarget", "ref", "_BinaryenRefTestSetRef", "_BinaryenRefCastSetRef", "_BinaryenBrOnSetRef", "_BinaryenStructNewSetOperandAt", "_BinaryenStructGetSetRef", "_BinaryenStructSetSetRef", "_BinaryenStructSetSetValue", "_BinaryenArrayNewSetSize", "_BinaryenArrayNewSetInit", "_BinaryenArrayNewFixedSetValueAt", "_BinaryenArrayGetSetRef", "_BinaryenArrayGetSetIndex", "_BinaryenArraySetSetRef", "_BinaryenArraySetSetIndex", "_BinaryenArraySetSetValue", "_BinaryenArrayLenSetRef", "destRef", "_BinaryenArrayCopySetDestRef", "destIndex", "_BinaryenArrayCopySetDestIndex", "srcRef", "_BinaryenArrayCopySetSrcRef", "srcIndex", "_BinaryenArrayCopySetSrcIndex", "_BinaryenArrayCopySetLength", "_BinaryenRefAsSetValue", "_BinaryenStringNewSetRef", "_BinaryenStringNewSetStart", "_BinaryenStringNewSetEnd", "_BinaryenStringMeasureSetRef", "_BinaryenStringEncodeSetStr", "_BinaryenStringEncodeSetArray", "_BinaryenStringEncodeSetStart", "_BinaryenStringConcatSetLeft", "_BinaryenStringConcatSetRight", "_BinaryenStringEqSetLeft", "_BinaryenStringEqSetRight", "_BinaryenStringWTF16GetSetRef", "pos", "_BinaryenStringWTF16GetSetPos", "_BinaryenStringSliceWTFSetRef", "_BinaryenStringSliceWTFSetStart", "_BinaryenStringSliceWTFSetEnd", "RtraceMemory", "Pass", "compiler", "_BinaryenFunctionGetName", "store", "module", "ptr", "_BinaryenStoreGetPtr", "offset", "_BinaryenStoreGetOffset", "bytes", "_BinaryenStoreGetBytes", "_BinaryenStoreSetPtr", "createType", "TypeRef", "matchPattern", "module", "expr", "isFound", "_BinaryenExpressionGetId", "_BinaryenCallGetTarget", "BuiltinNames", "_BinaryenCallGetNumOperands", "_BinaryenCallGetOperandAt", "needsSlot", "value", "isConstZero", "ShadowStackPass", "Pass", "compiler", "TypeRef", "func", "localIndex", "slotMap", "slotIndex", "name", "managedOperandIndices", "type", "tempMap", "_BinaryenFunctionGetNumLocals", "offset", "frameSize", "stmts", "remain", "Source", "operands", "numSlots", "i", "k", "operand", "match", "currentFunction", "numLocals", "temp", "call", "numOperands", "_BinaryenCallSetOperandAt", "callIndirect", "_BinaryenCallIndirectGetNumOperands", "_BinaryenCallIndirectGetOperandAt", "_BinaryenCallIndirectSetOperandAt", "localSet", "_BinaryenLocalSetGetValue", "_BinaryenLocalSetSetValue", "index", "_BinaryenLocalSetGetIndex", "_BinaryenLocalSetIsTee", "funcRef", "_BinaryenFunctionGetName", "params", "_BinaryenFunctionGetParams", "results", "_BinaryenFunctionGetResults", "body", "_BinaryenFunctionGetBody", "numVars", "_BinaryenFunctionGetNumVars", "vars", "_BinaryenFunctionGetVar", "tempMaps", "_keys", "moduleRef", "_BinaryenRemoveFunction", "cArr", "allocPtrArray", "newFuncRef", "_BinaryenAddFunction", "_free", "exportRef", "_BinaryenExportGetKind", "internalNameRef", "_BinaryenExportGetValue", "internalName", "externalNameRef", "_BinaryenExportGetName", "_BinaryenGetFunction", "paramTypes", "expandType", "numParams", "wrapperName", "wrapperNameRef", "forwardedOperands", "tempIndex", "_BinaryenRemoveExport", "_BinaryenAddFunctionExport", "instrumentReturns", "InstrumentReturns", "bodyType", "_BinaryenExpressionGetType", "_BinaryenFunctionSetBody", "exportMap", "exportName", "_BinaryenGetExport", "shadowStack", "ret", "_BinaryenReturnGetValue", "returnType", "_BinaryenReturnSetValue", "ExportsWalker", "program", "includePrivate", "_values", "i", "k", "file", "exports", "_keys", "memberName", "member", "exportsStar", "exportStar", "name", "element", "seen", "propertyInstance", "getterInstance", "setterInstance", "hasCompiledMember", "instances", "instance", "members", "j", "l", "importToModule", "moduleName", "shouldInstrument", "JSBuilder", "_JSBuilder", "ExportsWalker", "program", "esm", "includePrivate", "name", "element", "sb", "type", "isPlainValue", "indent", "members", "_values", "i", "k", "value", "escapeString", "isIdentifier", "moduleId", "code", "signature", "isPlainFunction", "parameterTypes", "parameterNames", "expr", "indentText", "Type", "numReferences", "releases", "needsRetainRelease", "originalName", "decorator", "findDecorator", "args", "codeArg", "literal", "parts", "exports", "moduleImports", "options", "insertPos", "sbLengthBefore", "_keys", "module", "resetPos", "numInstrumented", "_keys2", "j", "l", "elem", "func", "global", "hasAdaptedImports", "mappings", "map", "hasAdaptedExports", "deferredCode", "objectInstance", "rtSizeOffset", "arrayBufferId", "chunkSize", "stringId", "dataStartOffset", "lengthOffset", "arrayBufferViewInstance", "arraySize", "bufferOffset", "byteLengthOffset", "size", "makeCheckedSetter", "makeCheckedGetter", "exportStart", "runtimeFunctions", "runtimeGlobals", "needsMaybeDefault", "importExpr", "importMap", "valueExpr", "clazz", "valueType", "isPlainObject", "prevIndentLevel", "fn", "pointerExpr", "memberName", "member", "property", "isPlainValue", "type", "kind", "Type", "isPlainFunction", "signature", "mode", "parameterTypes", "inverseMode", "i", "k", "isPlainObject", "clazz", "members", "_values", "member", "Source", "indentText", "text", "indentLevel", "sb", "butFirst", "lineStart", "length", "pos", "indent", "liftRequiresExportRuntime", "program", "lowerRequiresExportRuntime", "makeCheckedSetter", "fn", "makeCheckedGetter", "mangleImportName_moduleName", "mangleImportName_elementName", "defaultFeatures", "Options", "Type", "TypeRef", "feature", "on", "UncheckedBehavior", "Constraints", "RuntimeFeatures", "ImportNames", "ExportNames", "runtimeFunctions", "runtimeGlobals", "Compiler", "_Compiler", "DiagnosticEmitter", "program", "module", "options", "featureFlags", "startFunctionInstance", "BuiltinNames", "Signature", "ShadowStackPass", "resolver", "hasShadowStack", "startFunctionBody", "files", "_values", "i", "k", "file", "name", "instance", "lazyFunctions", "functionsToCompile", "functionTable", "overrideStubs", "overrideStubsSeen", "overrideInstances", "_keys", "elem", "compileRTTI", "compileVisitGlobals", "compileVisitMembers", "memoryOffset", "startIsEmpty", "exportStart", "signature", "funcRef", "typesToRefs", "isIdentifier", "Source", "RtraceMemory", "memorySegments", "initialPages", "maximumPages", "Module", "isSharedMemory", "lowMemoryLimit32", "lowMemoryLimit", "CommonNames", "tableBase", "functionTableNames", "initialTableSize", "maximumTableSize", "exports", "elementName", "element", "exportsStar", "prefix", "functionPrototype", "functionInstance", "exportName", "thisType", "lowerRequiresExportRuntime", "liftRequiresExportRuntime", "parameterTypes", "global", "type", "members", "subPrefix", "STATIC_DELIMITER", "memberName", "member", "enumValue", "normalizedPathWithoutExtension", "reportNode", "filesByName", "pathWithIndex", "INDEX_SUFFIX", "startFunction", "startSignature", "previousBody", "previousFlow", "flow", "statements", "locals", "numLocals", "varTypes", "pendingElements", "initExpr", "typeNode", "initializerNode", "resolvedType", "internalName", "builtinVariables_onCompile", "BuiltinVariableContext", "typeRef", "isDeclaredConstant", "isDeclaredInline", "mangleImportName", "initializeInStart", "precomp", "getExpressionId", "fromName", "getGlobalGetName", "isGlobalMutable", "elementsByName", "getExpressionType", "getConstValueI32", "getConstValueI64Low", "getConstValueI64High", "getConstValueF32", "getConstValueF64", "findDecorator", "internalType", "previousParent", "previousValue", "previousValueIsMut", "isInline", "initInStart", "valueNode", "value", "forceStdAlternative", "parameters", "numParameters", "visited", "paramIdentifier", "paramName", "previousType", "bodyNode", "declarationNode", "decoratorNodes", "decorator", "stmts", "propertyName", "propertyParent", "propertyInstance", "range", "fnTypeNode", "firstIndex", "returnType", "thisLocal", "bodyStartIndex", "expr", "parent", "classInstance", "allocStmts", "property", "getterInstance", "valueType", "valueTypeRef", "thisTypeRef", "body", "flowBefore", "setterInstance", "bodyExpr", "linkInstance", "createType", "buffer", "alignment", "isPowerOf2", "segment", "MemorySegment", "stringValue", "ptr", "totalOverhead", "stringInstance", "stringSegment", "segments", "len", "buf", "writeI16", "stringOffset", "staticGcObjectOffsets", "s", "pos", "elementType", "values", "length", "byteSize", "elementTypeRef", "writeI8", "writeI32", "writeI64", "writeF32", "writeF64", "writeV128", "getConstValueV128", "id", "bufferSegment", "arrayInstance", "bufferLength", "readI32", "arrayLength", "bufferAddress", "memorySegment", "index", "rtInstance", "statement", "memberStatements", "declaration", "declarations", "exportStatement", "internalPath", "importStatement", "stmt", "numStatements", "getBlockName", "j", "getBlockChildCount", "getBlockChildAt", "outerFlow", "innerFlow", "existedTypeAlias", "TypeDefinition", "labelNode", "breakLabel", "label", "continueLabel", "numLocalsBefore", "loopLabel", "bodyStmts", "possiblyContinues", "possiblyBreaks", "possiblyFallsThrough", "condExpr", "condExprTrueish", "condKind", "initializer", "condition", "bodyFlow", "possiblyLoops", "incrementor", "ifTrue", "ifFalse", "thenStmts", "thenFlow", "elseFlow", "elseStmts", "valueExpression", "constraints", "inlineReturnLabel", "cases", "numCases", "condType", "tempLocalIndex", "breaks", "breakIndex", "defaultIndex", "case_", "left", "leftExpr", "leftType", "right", "rightExpr", "rightType", "equalityExpr", "currentBlock", "fallThroughFlow", "breakingFlowAlternatives", "isLast", "nextLabel", "count", "message", "newArgs", "numDeclarations", "initializers", "initType", "cloneMap", "dummy", "temp", "isConst", "isStatic", "local", "Local", "scopedLocals", "existing", "existingLocal", "alwaysTerminates", "contextualType", "shift", "mask", "expression", "compiled", "currentType", "wrap", "fromType", "toType", "explicit", "saturating", "op", "inheritedConstraints", "operator", "operatorString", "operatorTokenToString", "operatorKind", "OperatorKind", "leftOverload", "rightOverload", "commonType", "isConstExpressionNaN", "isConstNegZero", "compound", "classReference", "overload", "rightFlow", "leftPrecompExpr", "tempLocal", "possiblyNull", "tempIndex", "target", "targetType", "leftValue", "rightValue", "prototype", "result", "isWasm64", "accuratePow64", "namespace", "operatorInstance", "valueExpr", "first", "firstExpr", "firstType", "second", "secondExpr", "secondType", "thisExpression", "elementExpression", "propertyPrototype", "isUnchecked", "indexedSet", "indexExpression", "tee", "isConstructor", "thisExpr", "ret", "setterIndexType", "getterIndexType", "elementExpr", "tempTarget", "tempElement", "localIndex", "sourceFunction", "baseClassInstance", "sizeTypeRef", "baseCtorInstance", "superCall", "thisArg", "functionArg", "getterPrototype", "typeArguments", "args", "call", "Node", "typeParameterNodes", "typeArgumentNodes", "callee", "ctx", "BuiltinFunctionContext", "builtinFunctions", "numArguments", "hasThis", "hasRest", "minimum", "maximum", "relatedReportNode", "argumentExpressions", "numParams", "elements", "Range", "arrExpr", "ArrayLiteralExpression", "exprs", "inlineStack", "numArgumentsInclThis", "operands", "paramType", "paramExpr", "immediatelyDropped", "Flow", "base", "argumentLocal", "original", "stub", "originalSignature", "originalParameterTypes", "originalParameterDeclarations", "isInstance", "minArguments", "minOperands", "maxArguments", "maxOperands", "numOptional", "forwardedOperands", "operandIndex", "numNames", "names", "ofN", "argumentsLength", "table", "builder", "SwitchBuilder", "mostRecentInheritanceMapping", "overrideInstance", "overrideSignature", "overrideParameterTypes", "overrideNumParameters", "paramExprs", "n", "needsVarargsStub", "calledName", "returnTypeRef", "extenders", "extender", "instanceMembers", "instanceClass", "getConstValueInteger", "operand", "parameterIndex", "theOperands", "numOperands", "parameterNodes", "allOptionalsAreConstant", "resolved", "lastOperand", "getSideEffects", "lastOperandType", "expressions", "numExpressions", "targetExpression", "indexedGet", "isNamed", "isSemanticallyAnonymous", "FunctionPrototype", "contextualTypeArguments", "contextualSignature", "signatureNode", "numPresentParameters", "parameterNode", "isTypeOmitted", "thisTypeNode", "Function", "worked", "offset", "fname", "ftype", "signatureReference", "scopedThis", "superType", "currentParent", "localType", "isNonNull", "globalType", "ensureType", "builtinVariables_onAccess", "isType", "namedType", "expectedType", "actualType", "pending", "sizeType", "allInstances", "instances", "implementers", "implementer", "implicitlyNegate", "floatValue", "intValue", "sign", "tag", "parts", "numParts", "stringType", "lhsLen", "rhsLen", "hasPrefix", "lhs", "rhs", "concatMethod", "exprA", "exprB", "expressionPositions", "joinInstance", "indexedSetInstance", "temps", "tsaArrayInstance", "rawParts", "partExprs", "arraySegment", "rawExprs", "rawHeaderSegment", "contextualClass", "arrayType", "tempThis", "arrayAddress", "arrayTypeRef", "dataStartMember", "dataStartProperty", "source", "bufferSize", "classType", "ctorPrototype", "hasErrors", "classTypeRef", "omittedFields", "memberKey", "deferredProperties", "propertyType", "l", "ctor", "classPrototype", "baseClass", "baseCtor", "relatedNode", "ctorInstance", "ctxType", "parentEnum", "ifThen", "ifElse", "ifThenFlow", "ifThenExpr", "ifThenType", "ifElseFlow", "ifElseExpr", "ifElseType", "getValue", "getLocalSetValue", "setValue", "typeString", "targetFunction", "supported", "explicitThisType", "parameterReportNode", "evaled", "v128_zero", "v128_ones", "toStringInstance", "toStringSignature", "toStringReturnType", "allocInstance", "newInstance", "thisIndex", "thisLocalIndex", "nonParameterFields", "fieldPrototype", "fieldTypeRef", "field", "fieldType", "codeLocation", "abortInstance", "messageArg", "messageExpr", "filenameExpr", "staticAbortCallExpr", "nonNullExpr", "mangleInternalName", "overriddenModuleName", "arg", "TSDBuilder", "_TSDBuilder", "ExportsWalker", "program", "esm", "includePrivate", "name", "element", "sb", "type", "tsType", "indent", "members", "_keys", "i", "k", "memberName", "signature", "parameterTypes", "numParameters", "returnType", "Type", "requiredParameters", "originalName", "deferredTypes", "moduleImports", "moduleName", "isIdentifier", "escapeString", "clazz", "_values", "member", "Source", "mode", "valueType", "seenObjectTypes", "typeName", "isPlain", "property", "base", "newOptions", "Options", "setTarget", "options", "target", "setRuntime", "runtime", "setNoAssert", "noAssert", "setExportMemory", "exportMemory", "setImportMemory", "importMemory", "setInitialMemory", "initialMemory", "setMaximumMemory", "maximumMemory", "setSharedMemory", "sharedMemory", "setImportTable", "importTable", "setExportTable", "exportTable", "setSourceMap", "sourceMap", "setUncheckedBehavior", "uncheckedBehavior", "setMemoryBase", "memoryBase", "setTableBase", "tableBase", "addGlobalAlias", "alias", "name", "globalAliases", "removeGlobalAlias", "setExportStart", "exportStart", "setNoUnsafe", "noUnsafe", "setLowMemoryLimit", "lowMemoryLimit", "setExportRuntime", "exportRuntime", "DEFAULT_STACK_SIZE", "setStackSize", "stackSize", "setBundleVersion", "bundleMajorVersion", "bundleMinorVersion", "bundlePatchVersion", "FEATURE_SIGN_EXTENSION", "FEATURE_MUTABLE_GLOBALS", "FEATURE_NONTRAPPING_F2I", "FEATURE_BULK_MEMORY", "FEATURE_SIMD", "FEATURE_THREADS", "FEATURE_EXCEPTION_HANDLING", "FEATURE_TAIL_CALLS", "FEATURE_REFERENCE_TYPES", "FEATURE_MULTI_VALUE", "FEATURE_GC", "FEATURE_MEMORY64", "FEATURE_RELAXED_SIMD", "FEATURE_EXTENDED_CONST", "FEATURE_STRINGREF", "FEATURES_ALL", "FEATURES_DEFAULT", "defaultFeatures", "setFeature", "feature", "on", "setOptimizeLevelHints", "optimizeLevel", "shrinkLevel", "setBasenameHint", "basename", "setBindingsHint", "bindings", "setPedantic", "pedantic", "setDebugInfo", "debug", "newProgram", "Program", "nextDiagnostic", "program", "getSource", "internalPath", "getDiagnosticCode", "diagnostic", "getDiagnosticCategory", "getDiagnosticMessage", "getDiagnosticRange", "getDiagnosticRelatedRange", "getRangeStart", "range", "getRangeEnd", "getRangeSource", "getSourceNormalizedPath", "source", "isInfo", "message", "isWarning", "isError", "parse", "program", "text", "path", "isEntry", "nextFile", "getDependee", "file", "initializeProgram", "compile", "Compiler", "buildTSD", "esm", "TSDBuilder", "buildJS", "JSBuilder", "getBinaryenModuleRef", "module", "validate", "optimize", "optimizeLevel", "shrinkLevel", "debugInfo", "zeroFilledMemory", "ASTBuilder", "_ASTBuilder", "node", "builder", "source", "statements", "i", "k", "sb", "current", "typeArguments", "numTypeArguments", "isNullable", "explicitThisType", "parameters", "numParameters", "returnType", "extendsType", "defaultType", "elements", "numElements", "element", "names", "values", "indent", "name", "value", "operatorTokenToString", "args", "numArgs", "declaration", "expressions", "numExpressions", "range", "hasExplicitSign", "str", "escapeString", "tag", "parts", "last", "lastCharPos", "numStatements", "indentLevel", "label", "isDefault", "decorators", "typeParameters", "implementsTypes", "numImplementsTypes", "indexSignature", "members", "numMembers", "member", "numValues", "initializer", "path", "type", "condition", "incrementor", "signature", "numTypeParameters", "body", "isTypeOmitted", "ifTrue", "ifFalse", "externalName", "declarations", "namespaceName", "numDeclarations", "cases", "bodyStatements", "catchVariable", "catchStatements", "finallyStatements", "firstDeclaration", "kind", "implicitFieldDeclaration", "ret", "index_default", "index_js_exports"]
}
